continue<\exit>
if typeid in [Header, Trailer]:<\exit>
continue<\exit>
c = TypeIdConfig()<\exit>
c.selected = True<\exit>
c.name = typeid.GetName()<\exit>
c.typeid = typeid<\exit>
self.packet_filter_list.append(c)<\exit>
self.packet_filter_widget.add_list(self.packet_filter_list)<\exit>
def update_capture_options():<\exit>
if self.op_AND_button.props.active:<\exit>
self.packet_capture_options.mode = ns.visualizer.PyViz.PACKET_CAPTURE_FILTER_HEADERS_AND<\exit>
else:<\exit>
self.packet_capture_options.mode = ns.visualizer.PyViz.PACKET_CAPTURE_FILTER_HEADERS_OR<\exit>
self.packet_capture_options.numLastPackets = 100<\exit>
self.packet_capture_options.headers = [c.typeid for c in self.packet_filter_list if c.selected]<\exit>
self.visualizer.simulation.lock.acquire()<\exit>
try:<\exit>
self.visualizer.simulation.sim_helper.SetPacketCaptureOptions(<\exit>
self.node.GetId(), self.packet_capture_options)<\exit>
finally:<\exit>
self.visualizer.simulation.lock.release()<\exit>
def sel_all_cb(bt):<\exit>
for c in self.packet_filter_list:<\exit>
c.selected = True<\exit>
self.packet_filter_widget.refresh()<\exit>
update_capture_options()<\exit>
def sel_none_cb(bt):<\exit>
for c in self.packet_filter_list:<\exit>
c.selected = False<\exit>
self.packet_filter_widget.refresh()<\exit>
update_capture_options()<\exit>
select_all_button.connect("clicked", sel_all_cb)<\exit>
select_none_button.connect("clicked", sel_none_cb)<\exit>
op_buttons_box = gtk.HButtonBox()<\exit>
op_buttons_box.show()<\exit>
packet_filter_vbox.pack_start(op_buttons_box, False, False, 4)<\exit>
self.op_AND_button = gobject.new(gtk.RadioButton, label="AND", visible=True)<\exit>
self.op_OR_button = gobject.new(gtk.RadioButton, label="OR", visible=True, group=self.op_AND_button)<\exit>
op_buttons_box.add(self.op_AND_button)<\exit>
op_buttons_box.add(self.op_OR_button)<\exit>
self.op_OR_button.props.active = True<\exit>
self.op_AND_button.connect("toggled", lambda b: update_capture_options())<\exit>
def cell_edited(l, obj, attribute):<\exit>
update_capture_options()<\exit>
self.packet_filter_widget.connect("cell-edited", cell_edited)<\exit>
update_capture_options()<\exit>
self.visualizer.add_information_window(self)<\exit>
self.win.set_default_size(600, 300)<\exit>
self.win.show()<\exit>
def _response_cb(self, win, response):<\exit>
self.win.destroy()<\exit>
self.visualizer.remove_information_window(self)<\exit>
def update(self):<\exit>
last_packets = self.visualizer.simulation.sim_helper.GetLastPackets(self.node.GetId())<\exit>
self.tx_list.update(self.node, last_packets.lastTransmittedPackets)<\exit>
self.rx_list.update(self.node, last_packets.lastReceivedPackets)<\exit>
self.drop_list.update(self.node, last_packets.lastDroppedPackets)<\exit>
def populate_node_menu(viz, node, menu):<\exit>
menu_item = gtk.MenuItem("Show Last Packets")<\exit>
menu_item.show()<\exit>
def _show_it(dummy_menu_item):<\exit>
ShowLastPackets(viz, node.node_index)<\exit>
menu_item.connect("activate", _show_it)<\exit>
menu.add(menu_item)<\exit>
def register(viz):<\exit>
viz.connect("populate-node-menu", populate_node_menu)<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine();<\exit>
cmd.Parse(argv);<\exit>
print "Create nodes"<\exit>
n0 = ns.network.Node();<\exit>
r = ns.network.Node();<\exit>
n1 = ns.network.Node();<\exit>
net1 = ns.network.NodeContainer();<\exit>
net1.Add(n0);<\exit>
net1.Add(r);<\exit>
net2 = ns.network.NodeContainer();<\exit>
net2.Add(r);<\exit>
net2.Add(n1);<\exit>
all = ns.network.NodeContainer();<\exit>
all.Add(n0);<\exit>
all.Add(r);<\exit>
all.Add(n1);<\exit>
internetv6 = ns.internet.InternetStackHelper();<\exit>
internetv6.Install(all);<\exit>
csma = ns.csma.CsmaHelper();<\exit>
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)));<\exit>
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)));<\exit>
d1 = csma.Install(net1);<\exit>
d2 = csma.Install(net2);<\exit>
print "Addressing"<\exit>
ipv6 = ns.internet.Ipv6AddressHelper();<\exit>
ipv6.NewNetwork(ns.network.Ipv6Address("2001:1::"), ns.network.Ipv6Prefix(64));<\exit>
i1 = ipv6.Assign(d1);<\exit>
i1.SetRouter(1, True);<\exit>
ipv6.NewNetwork(ns.network.Ipv6Address("2001:2::"), ns.network.Ipv6Prefix(64));<\exit>
i2 = ipv6.Assign(d2);<\exit>
i2.SetRouter(0, True);<\exit>
print "Application"<\exit>
packetSize = 1024;<\exit>
maxPacketCount = 5;<\exit>
interPacketInterval = ns.core.Seconds(1.);<\exit>
ping6 = ns.applications.Ping6Helper();<\exit>
ping6.SetLocal(i1.GetAddress(0, 1));<\exit>
ping6.SetRemote(i2.GetAddress(1, 1));<\exit>
ping6.SetAttribute("MaxPackets", ns.core.UintegerValue(maxPacketCount));<\exit>
ping6.SetAttribute("Interval", ns.core.TimeValue(interPacketInterval));<\exit>
ping6.SetAttribute("PacketSize", ns.core.UintegerValue(packetSize));<\exit>
apps = ping6.Install(ns.network.NodeContainer(net1.Get(0)));<\exit>
apps.Start(ns.core.Seconds(2.0));<\exit>
apps.Stop(ns.core.Seconds(20.0));<\exit>
print "Tracing"<\exit>
ascii = ns.network.AsciiTraceHelper()<\exit>
csma.EnableAsciiAll(ascii.CreateFileStream("simple-routing-ping6.tr"))<\exit>
csma.EnablePcapAll("simple-routing-ping6", True)<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
main(sys.argv)<\exit>
import sys, os<\exit>
sys.path.append("../..")<\exit>
from facerec.feature import Fisherfaces, SpatialHistogram, Identity<\exit>
from facerec.distance import EuclideanDistance, ChiSquareDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.visual import subplot<\exit>
from facerec.util import minmax_normalize<\exit>
from facerec.serialization import save_model, load_model<\exit>
import numpy as np<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import matplotlib.cm as cm<\exit>
import logging<\exit>
import matplotlib.pyplot as plt<\exit>
import matplotlib.cm as cm<\exit>
from facerec.lbp import LPQ, ExtendedLBP<\exit>
def read_images(path, sz=None):<\exit>
c = 0<\exit>
X,y = [], []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
try:<\exit>
im = Image.open(os.path.join(subject_path, filename))<\exit>
im = im.convert("L")<\exit>
if (sz is not None):<\exit>
im = im.resize(self.sz, Image.ANTIALIAS)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y]<\exit>
if __name__ == "__main__":<\exit>
out_dir = None<\exit>
if len(sys.argv) < 2:<\exit>
print "USAGE: facerec_demo.py </path/to/images>"<\exit>
sys.exit()<\exit>
[X,y] = read_images(sys.argv[1])<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
feature = Fisherfaces()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
my_model = PredictableModel(feature=feature, classifier=classifier)<\exit>
my_model.compute(X, y)<\exit>
save_model('model.pkl', my_model)<\exit>
model = load_model('model.pkl')<\exit>
E = []<\exit>
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):<\exit>
e = model.feature.eigenvectors[:,i].reshape(X[0].shape)<\exit>
E.append(minmax_normalize(e,0,255, dtype=np.uint8))<\exit>
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet, filename="fisherfaces.png")<\exit>
cv = KFoldCrossValidation(model, k=10)<\exit>
cv.validate(X, y)<\exit>
cv.print_results()<\exit>
import logging<\exit>
import cv2<\exit>
from helper.common import *<\exit>
from helper.video import *<\exit>
import sys<\exit>
sys.path.append("../..")<\exit>
from facerec.model import PredictableModel<\exit>
from facerec.feature import Fisherfaces<\exit>
from facerec.distance import EuclideanDistance<\exit>
from facerec.classifier import NearestNeighbor<\exit>
from facerec.validation import KFoldCrossValidation<\exit>
from facerec.serialization import save_model, load_model<\exit>
from facedet.detector import CascadedDetector<\exit>
class ExtendedPredictableModel(PredictableModel):<\exit>
def __init__(self, feature, classifier, image_size, subject_names):<\exit>
PredictableModel.__init__(self, feature=feature, classifier=classifier)<\exit>
self.image_size = image_size<\exit>
self.subject_names = subject_names<\exit>
def get_model(image_size, subject_names):<\exit>
feature = Fisherfaces()<\exit>
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)<\exit>
return ExtendedPredictableModel(feature=feature, classifier=classifier, image_size=image_size, subject_names=subject_names)<\exit>
def read_subject_names(path):<\exit>
folder_names = []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
folder_names.append(subdirname)<\exit>
return folder_names<\exit>
def read_images(path, image_size=None):<\exit>
c = 0<\exit>
X = []<\exit>
y = []<\exit>
folder_names = []<\exit>
for dirname, dirnames, filenames in os.walk(path):<\exit>
for subdirname in dirnames:<\exit>
folder_names.append(subdirname)<\exit>
subject_path = os.path.join(dirname, subdirname)<\exit>
for filename in os.listdir(subject_path):<\exit>
try:<\exit>
im = cv2.imread(os.path.join(subject_path, filename), cv2.IMREAD_GRAYSCALE)<\exit>
if (image_size is not None):<\exit>
im = cv2.resize(im, image_size)<\exit>
X.append(np.asarray(im, dtype=np.uint8))<\exit>
y.append(c)<\exit>
except IOError, (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Unexpected error:", sys.exc_info()[0]<\exit>
raise<\exit>
c = c+1<\exit>
return [X,y,folder_names]<\exit>
class App(object):<\exit>
def __init__(self, model, camera_id, cascade_filename):<\exit>
self.model = model<\exit>
self.detector = CascadedDetector(cascade_fn=cascade_filename, minNeighbors=5, scaleFactor=1.1)<\exit>
self.cam = create_capture(camera_id)<\exit>
def run(self):<\exit>
while True:<\exit>
ret, frame = self.cam.read()<\exit>
img = cv2.resize(frame, (frame.shape[1]/2, frame.shape[0]/2), interpolation = cv2.INTER_CUBIC)<\exit>
imgout = img.copy()<\exit>
for i,r in enumerate(self.detector.detect(img)):<\exit>
x0,y0,x1,y1 = r<\exit>
face = img[y0:y1, x0:x1]<\exit>
face = cv2.cvtColor(face,cv2.COLOR_BGR2GRAY)<\exit>
face = cv2.resize(face, self.model.image_size, interpolation = cv2.INTER_CUBIC)<\exit>
prediction = self.model.predict(face)[0]<\exit>
cv2.rectangle(imgout, (x0,y0),(x1,y1),(0,255,0),2)<\exit>
draw_str(imgout, (x0-20,y0-20), self.model.subject_names[prediction])<\exit>
cv2.imshow('videofacerec', imgout)<\exit>
ch = cv2.waitKey(10)<\exit>
if ch == 27:<\exit>
break<\exit>
if __name__ == '__main__':<\exit>
from optparse import OptionParser<\exit>
usage = "usage: %prog [options] model_filename"<\exit>
parser = OptionParser(usage=usage)<\exit>
parser.add_option("-r", "--resize", action="store", type="string", dest="size", default="100x100",<\exit>
help="Resizes the given dataset to a given size in format [width]x[height] (default: 100x100).")<\exit>
parser.add_option("-v", "--validate", action="store", dest="numfolds", type="int", default=None,<\exit>
help="Performs a k-fold cross validation on the dataset, if given (default: None).")<\exit>
parser.add_option("-t", "--train", action="store", dest="dataset", type="string", default=None,<\exit>
help="Trains the model on the given dataset.")<\exit>
parser.add_option("-i", "--id", action="store", dest="camera_id", type="int", default=0,<\exit>
help="Sets the Camera Id to be used (default: 0).")<\exit>
parser.add_option("-c", "--cascade", action="store", dest="cascade_filename", default="haarcascade_frontalface_alt2.xml",<\exit>
help="Sets the path to the Haar Cascade used for the face detection part (default: haarcascade_frontalface_alt2.xml).")<\exit>
parser.print_help()<\exit>
print "Press [ESC] to exit the program!"<\exit>
print "Script output:"<\exit>
(options, args) = parser.parse_args()<\exit>
if len(args) == 0:<\exit>
print "[Error] No prediction model was given."<\exit>
sys.exit()<\exit>
model_filename = args[0]<\exit>
if (options.dataset is None) and (not os.path.exists(model_filename)):<\exit>
print "[Error] No prediction model found at '%s'." % model_filename<\exit>
sys.exit()<\exit>
if not os.path.exists(options.cascade_filename):<\exit>
print "[Error] No Cascade File found at '%s'." % options.cascade_filename<\exit>
sys.exit()<\exit>
try:<\exit>
image_size = (int(options.size.split("x")[0]), int(options.size.split("x")[1]))<\exit>
except:<\exit>
print "[Error] Unable to parse the given image size '%s'. Please pass it in the format [width]x[height]!" % options.size<\exit>
sys.exit()<\exit>
if options.dataset:<\exit>
if not os.path.exists(options.dataset):<\exit>
print "[Error] No dataset found at '%s'." % dataset_path<\exit>
sys.exit()<\exit>
print "Loading dataset..."<\exit>
[images, labels, subject_names] = read_images(options.dataset, image_size)<\exit>
list_of_labels = list(xrange(max(labels)+1))<\exit>
subject_dictionary = dict(zip(list_of_labels, subject_names))<\exit>
model = get_model(image_size=image_size, subject_names=subject_dictionary)<\exit>
if options.numfolds:<\exit>
print "Validating model with %s folds..." % options.numfolds<\exit>
handler = logging.StreamHandler(sys.stdout)<\exit>
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<\exit>
handler.setFormatter(formatter)<\exit>
logger = logging.getLogger("facerec")<\exit>
logger.addHandler(handler)<\exit>
logger.setLevel(logging.DEBUG)<\exit>
crossval = KFoldCrossValidation(model, k=options.numfolds)<\exit>
crossval.validate(images, labels)<\exit>
crossval.print_results()<\exit>
print "Computing the model..."<\exit>
model.compute(images, labels)<\exit>
print "Saving the model..."<\exit>
save_model(model_filename, model)<\exit>
else:<\exit>
print "Loading the model..."<\exit>
model = load_model(model_filename)<\exit>
if not isinstance(model, ExtendedPredictableModel):<\exit>
print "[Error] The given model is not of type '%s'." % "ExtendedPredictableModel"<\exit>
sys.exit()<\exit>
print "Starting application..."<\exit>
App(model=model,<\exit>
camera_id=options.camera_id,<\exit>
cascade_filename=options.cascade_filename).run()<\exit>
class Solution:<\exit>
def singleNumberIII(self, A):<\exit>
bits = 0<\exit>
for a in A:<\exit>
bits ^= a<\exit>
rightmost_set_bit = bits&-bits<\exit>
bits1 = 0<\exit>
bits2 = 0<\exit>
for a in A:<\exit>
if a&rightmost_set_bit:<\exit>
bits1 ^= a<\exit>
else:<\exit>
bits2 ^= a<\exit>
return bits1, bits2<\exit>
import threading<\exit>
class SingletonMixin(object):<\exit>
__singleton_lock = threading.Lock()<\exit>
__singleton_instance = None<\exit>
@classmethod<\exit>
def instance(cls):<\exit>
if not cls.__singleton_instance:<\exit>
with cls.__singleton_lock:<\exit>
if not cls.__singleton_instance:<\exit>
cls.__singleton_instance = cls()<\exit>
return cls.__singleton_instance<\exit>
import operator<\exit>
import sys<\exit>
import types<\exit>
__version__ = "1.2.0"<\exit>
PY3 = sys.version_info[0] == 3<\exit>
if PY3:<\exit>
string_types = str,<\exit>
integer_types = int,<\exit>
class_types = type,<\exit>
text_type = str<\exit>
binary_type = bytes<\exit>
MAXSIZE = sys.maxsize<\exit>
else:<\exit>
string_types = basestring,<\exit>
integer_types = (int, long)<\exit>
class_types = (type, types.ClassType)<\exit>
text_type = unicode<\exit>
binary_type = str<\exit>
if sys.platform.startswith("java"):<\exit>
MAXSIZE = int((1 << 31) - 1)<\exit>
else:<\exit>
class X(object):<\exit>
def __len__(self):<\exit>
return 1 << 31<\exit>
try:<\exit>
len(X())<\exit>
except OverflowError:<\exit>
MAXSIZE = int((1 << 31) - 1)<\exit>
else:<\exit>
MAXSIZE = int((1 << 63) - 1)<\exit>
del X<\exit>
def _add_doc(func, doc):<\exit>
func.__doc__ = doc<\exit>
def _import_module(name):<\exit>
__import__(name)<\exit>
return sys.modules[name]<\exit>
class _LazyDescr(object):<\exit>
def __init__(self, name):<\exit>
self.name = name<\exit>
def __get__(self, obj, tp):<\exit>
result = self._resolve()<\exit>
setattr(obj, self.name, result)<\exit>
delattr(tp, self.name)<\exit>
return result<\exit>
class MovedModule(_LazyDescr):<\exit>
def __init__(self, name, old, new=None):<\exit>
super(MovedModule, self).__init__(name)<\exit>
if PY3:<\exit>
if new is None:<\exit>
new = name<\exit>
self.mod = new<\exit>
else:<\exit>
self.mod = old<\exit>
def _resolve(self):<\exit>
return _import_module(self.mod)<\exit>
class MovedAttribute(_LazyDescr):<\exit>
def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):<\exit>
super(MovedAttribute, self).__init__(name)<\exit>
if PY3:<\exit>
if new_mod is None:<\exit>
new_mod = name<\exit>
self.mod = new_mod<\exit>
if new_attr is None:<\exit>
if old_attr is None:<\exit>
new_attr = name<\exit>
else:<\exit>
new_attr = old_attr<\exit>
self.attr = new_attr<\exit>
else:<\exit>
self.mod = old_mod<\exit>
if old_attr is None:<\exit>
old_attr = name<\exit>
self.attr = old_attr<\exit>
def _resolve(self):<\exit>
module = _import_module(self.mod)<\exit>
return getattr(module, self.attr)<\exit>
class _MovedItems(types.ModuleType):<\exit>
_moved_attributes = [<\exit>
MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),<\exit>
MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),<\exit>
MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),<\exit>
MovedAttribute("map", "itertools", "builtins", "imap", "map"),<\exit>
MovedAttribute("reload_module", "__builtin__", "imp", "reload"),<\exit>
MovedAttribute("reduce", "__builtin__", "functools"),<\exit>
MovedAttribute("StringIO", "StringIO", "io"),<\exit>
MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),<\exit>
MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),<\exit>
MovedModule("builtins", "__builtin__"),<\exit>
MovedModule("configparser", "ConfigParser"),<\exit>
MovedModule("copyreg", "copy_reg"),<\exit>
MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),<\exit>
MovedModule("http_cookies", "Cookie", "http.cookies"),<\exit>
MovedModule("html_entities", "htmlentitydefs", "html.entities"),<\exit>
MovedModule("html_parser", "HTMLParser", "html.parser"),<\exit>
MovedModule("http_client", "httplib", "http.client"),<\exit>
MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),<\exit>
MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),<\exit>
MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),<\exit>
MovedModule("cPickle", "cPickle", "pickle"),<\exit>
MovedModule("queue", "Queue"),<\exit>
MovedModule("reprlib", "repr"),<\exit>
MovedModule("socketserver", "SocketServer"),<\exit>
MovedModule("tkinter", "Tkinter"),<\exit>
MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),<\exit>
MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),<\exit>
MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),<\exit>
MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),<\exit>
MovedModule("tkinter_tix", "Tix", "tkinter.tix"),<\exit>
MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),<\exit>
MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),<\exit>
MovedModule("tkinter_colorchooser", "tkColorChooser",<\exit>
"tkinter.colorchooser"),<\exit>
MovedModule("tkinter_commondialog", "tkCommonDialog",<\exit>
"tkinter.commondialog"),<\exit>
MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),<\exit>
MovedModule("tkinter_font", "tkFont", "tkinter.font"),<\exit>
MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),<\exit>
MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",<\exit>
"tkinter.simpledialog"),<\exit>
MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),<\exit>
MovedModule("winreg", "_winreg"),<\exit>
]<\exit>
for attr in _moved_attributes:<\exit>
setattr(_MovedItems, attr.name, attr)<\exit>
del attr<\exit>
moves = sys.modules[__name__ + ".moves"] = _MovedItems("moves")<\exit>
def add_move(move):<\exit>
setattr(_MovedItems, move.name, move)<\exit>
def remove_move(name):<\exit>
try:<\exit>
delattr(_MovedItems, name)<\exit>
except AttributeError:<\exit>
try:<\exit>
del moves.__dict__[name]<\exit>
except KeyError:<\exit>
raise AttributeError("no such move, %r" % (name,))<\exit>
if PY3:<\exit>
_meth_func = "__func__"<\exit>
_meth_self = "__self__"<\exit>
_func_code = "__code__"<\exit>
_func_defaults = "__defaults__"<\exit>
_iterkeys = "keys"<\exit>
_itervalues = "values"<\exit>
_iteritems = "items"<\exit>
else:<\exit>
_meth_func = "im_func"<\exit>
_meth_self = "im_self"<\exit>
_func_code = "func_code"<\exit>
_func_defaults = "func_defaults"<\exit>
_iterkeys = "iterkeys"<\exit>
_itervalues = "itervalues"<\exit>
_iteritems = "iteritems"<\exit>
try:<\exit>
advance_iterator = next<\exit>
except NameError:<\exit>
def advance_iterator(it):<\exit>
return it.next()<\exit>
next = advance_iterator<\exit>
if PY3:<\exit>
def get_unbound_function(unbound):<\exit>
return unbound<\exit>
Iterator = object<\exit>
def callable(obj):<\exit>
return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)<\exit>
else:<\exit>
def get_unbound_function(unbound):<\exit>
return unbound.im_func<\exit>
class Iterator(object):<\exit>
def next(self):<\exit>
return type(self).__next__(self)<\exit>
callable = callable<\exit>
_add_doc(get_unbound_function,<\exit>
)<\exit>
get_method_function = operator.attrgetter(_meth_func)<\exit>
get_method_self = operator.attrgetter(_meth_self)<\exit>
get_function_code = operator.attrgetter(_func_code)<\exit>
get_function_defaults = operator.attrgetter(_func_defaults)<\exit>
def iterkeys(d):<\exit>
return iter(getattr(d, _iterkeys)())<\exit>
def itervalues(d):<\exit>
return iter(getattr(d, _itervalues)())<\exit>
def iteritems(d):<\exit>
return iter(getattr(d, _iteritems)())<\exit>
if PY3:<\exit>
def b(s):<\exit>
return s.encode("latin-1")<\exit>
def u(s):<\exit>
return s<\exit>
if sys.version_info[1] <= 1:<\exit>
def int2byte(i):<\exit>
return bytes((i,))<\exit>
else:<\exit>
int2byte = operator.methodcaller("to_bytes", 1, "big")<\exit>
import io<\exit>
StringIO = io.StringIO<\exit>
BytesIO = io.BytesIO<\exit>
else:<\exit>
def b(s):<\exit>
return s<\exit>
def u(s):<\exit>
return unicode(s, "unicode_escape")<\exit>
int2byte = chr<\exit>
import StringIO<\exit>
StringIO = BytesIO = StringIO.StringIO<\exit>
_add_doc(b, )<\exit>
_add_doc(u, )<\exit>
if PY3:<\exit>
import builtins<\exit>
exec_ = getattr(builtins, "exec")<\exit>
def reraise(tp, value, tb=None):<\exit>
if value.__traceback__ is not tb:<\exit>
raise value.with_traceback(tb)<\exit>
raise value<\exit>
print_ = getattr(builtins, "print")<\exit>
del builtins<\exit>
else:<\exit>
def exec_(code, globs=None, locs=None):<\exit>
if globs is None:<\exit>
frame = sys._getframe(1)<\exit>
globs = frame.f_globals<\exit>
if locs is None:<\exit>
locs = frame.f_locals<\exit>
del frame<\exit>
elif locs is None:<\exit>
locs = globs<\exit>
exec()<\exit>
exec_()<\exit>
def print_(*args, **kwargs):<\exit>
fp = kwargs.pop("file", sys.stdout)<\exit>
if fp is None:<\exit>
return<\exit>
def write(data):<\exit>
if not isinstance(data, basestring):<\exit>
data = str(data)<\exit>
fp.write(data)<\exit>
want_unicode = False<\exit>
sep = kwargs.pop("sep", None)<\exit>
if sep is not None:<\exit>
if isinstance(sep, unicode):<\exit>
want_unicode = True<\exit>
elif not isinstance(sep, str):<\exit>
raise TypeError("sep must be None or a string")<\exit>
end = kwargs.pop("end", None)<\exit>
if end is not None:<\exit>
if isinstance(end, unicode):<\exit>
want_unicode = True<\exit>
elif not isinstance(end, str):<\exit>
raise TypeError("end must be None or a string")<\exit>
if kwargs:<\exit>
raise TypeError("invalid keyword arguments to print()")<\exit>
if not want_unicode:<\exit>
for arg in args:<\exit>
if isinstance(arg, unicode):<\exit>
want_unicode = True<\exit>
break<\exit>
if want_unicode:<\exit>
newline = unicode("\n")<\exit>
space = unicode(" ")<\exit>
else:<\exit>
newline = "\n"<\exit>
space = " "<\exit>
if sep is None:<\exit>
sep = space<\exit>
if end is None:<\exit>
end = newline<\exit>
for i, arg in enumerate(args):<\exit>
if i:<\exit>
write(sep)<\exit>
write(arg)<\exit>
write(end)<\exit>
_add_doc(reraise, )<\exit>
def with_metaclass(meta, base=object):<\exit>
return meta("NewBase", (base,), {})<\exit>
import sys<\exit>
from .mbcharsetprober import MultiByteCharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .chardistribution import SJISDistributionAnalysis<\exit>
from .jpcntx import SJISContextAnalysis<\exit>
from .mbcssm import SJISSMModel<\exit>
from . import constants<\exit>
class SJISProber(MultiByteCharSetProber):<\exit>
def __init__(self):<\exit>
MultiByteCharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(SJISSMModel)<\exit>
self._mDistributionAnalyzer = SJISDistributionAnalysis()<\exit>
self._mContextAnalyzer = SJISContextAnalysis()<\exit>
self.reset()<\exit>
def reset(self):<\exit>
MultiByteCharSetProber.reset(self)<\exit>
self._mContextAnalyzer.reset()<\exit>
def get_charset_name(self):<\exit>
return "SHIFT_JIS"<\exit>
def feed(self, aBuf):<\exit>
aLen = len(aBuf)<\exit>
for i in range(0, aLen):<\exit>
codingState = self._mCodingSM.next_state(aBuf[i])<\exit>
if codingState == constants.eError:<\exit>
if constants._debug:<\exit>
sys.stderr.write(self.get_charset_name()<\exit>
+ ' prober hit error at byte ' + str(i)<\exit>
+ '\n')<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
charLen = self._mCodingSM.get_current_charlen()<\exit>
if i == 0:<\exit>
self._mLastChar[1] = aBuf[0]<\exit>
self._mContextAnalyzer.feed(self._mLastChar[2 - charLen:],<\exit>
charLen)<\exit>
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)<\exit>
else:<\exit>
self._mContextAnalyzer.feed(aBuf[i + 1 - charLen:i + 3<\exit>
- charLen], charLen)<\exit>
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],<\exit>
charLen)<\exit>
self._mLastChar[0] = aBuf[aLen - 1]<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if (self._mContextAnalyzer.got_enough_data() and<\exit>
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
contxtCf = self._mContextAnalyzer.get_confidence()<\exit>
distribCf = self._mDistributionAnalyzer.get_confidence()<\exit>
return max(contxtCf, distribCf)<\exit>
class Solution:<\exit>
def maxSlidingWindow(self, nums, k):<\exit>
if not nums or k == 0:<\exit>
return []<\exit>
q = []<\exit>
ret = []<\exit>
for i in xrange(k):<\exit>
while q and nums[i] >= nums[q[-1]]:<\exit>
q.pop()<\exit>
q.append(i)<\exit>
ret.append(nums[q[0]])<\exit>
for i in xrange(k, len(nums)):<\exit>
while q and nums[i] >= nums[q[-1]]:<\exit>
q.pop()<\exit>
while q and q[0] < i-k+1:<\exit>
q.pop(0)<\exit>
q.append(i)<\exit>
ret.append(nums[q[0]])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
print Solution().maxSlidingWindow([1, 2, 7, 7, 8], 3)<\exit>
from collections import defaultdict<\exit>
class Heap(object):<\exit>
def __init__(self, A):<\exit>
self._A = A<\exit>
self._h = []<\exit>
self._pos = defaultdict(set)<\exit>
def _pos2pos_set(self, ind):<\exit>
return self._pos[self._A[self._h[ind]]]<\exit>
def _swap_heap_node(self, i, j):<\exit>
if self._cmp_by_pos(i, j) == 0:<\exit>
return<\exit>
self._pos2pos_set(i).remove(i)<\exit>
self._pos2pos_set(j).remove(j)<\exit>
self._pos2pos_set(i).add(j)<\exit>
self._pos2pos_set(j).add(i)<\exit>
self._h[i], self._h[j] = self._h[j], self._h[i]<\exit>
def _pi(self, pos):<\exit>
if pos%2 == 0:<\exit>
return max(0, pos/2-1)<\exit>
else:<\exit>
return pos/2<\exit>
def push(self, i):<\exit>
pos = len(self._h)<\exit>
self._h.append(i)<\exit>
self._pos[self._A[i]].add(pos)<\exit>
pi = self._pi(pos)<\exit>
while pi != pos and self._cmp_by_pos(pos, pi) < 0:<\exit>
self._swap_heap_node(pi, pos)<\exit>
pos = pi<\exit>
pi = self._pi(pos)<\exit>
def _val2pos(self, val):<\exit>
return next(iter(self._pos[val]))<\exit>
def _pos2val(self, pos):<\exit>
return self._A[self._h[pos]]<\exit>
def _cmp_by_pos(self, i, j):<\exit>
return self._pos2val(i) - self._pos2val(j)<\exit>
def remove(self, i):<\exit>
try:<\exit>
pos = self._val2pos(self._A[i])<\exit>
self.pop(pos)<\exit>
except StopIteration:<\exit>
pass<\exit>
def _heappush(self, pos):<\exit>
n = len(self._h)<\exit>
if pos >= n:<\exit>
return<\exit>
l = 2*pos+1<\exit>
r = 2*pos+2<\exit>
mini = pos<\exit>
if l < n and self._cmp_by_pos(l, mini) < 0:<\exit>
mini = l<\exit>
if r < n and self._cmp_by_pos(r, mini) < 0:<\exit>
mini = r<\exit>
if pos != mini:<\exit>
self._swap_heap_node(pos, mini)<\exit>
self._heappush(mini)<\exit>
def peek(self):<\exit>
return self._h[0]<\exit>
def pop(self, pos=0):<\exit>
last_pos = len(self._h)-1<\exit>
self._swap_heap_node(pos, last_pos)<\exit>
self._pos2pos_set(last_pos).remove(last_pos)<\exit>
head = self._h.pop()<\exit>
self._heappush(pos)<\exit>
return head<\exit>
def __len__(self):<\exit>
return len(self._h)<\exit>
def __repr__(self):<\exit>
return repr(map(lambda x: self._A[x], self._h))<\exit>
class DualHeap(object):<\exit>
def __init__(self, A):<\exit>
self._A = A<\exit>
self.min_h = Heap(A)<\exit>
self.max_h = Heap(map(lambda x: -x, A))<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, i):<\exit>
if len(self.min_h) > 0 and self._A[i] > self._A[self.min_h.peek()]:<\exit>
self.min_h.push(i)<\exit>
else:<\exit>
self.max_h.push(i)<\exit>
self._rebalance()<\exit>
def remove(self, i):<\exit>
if len(self.min_h) > 0 and self._A[i] >= self._A[self.min_h.peek()]:<\exit>
self.min_h.remove(i)<\exit>
else:<\exit>
self.max_h.remove(i)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self._A[self.min_h.peek()]<\exit>
else:<\exit>
return self._A[self.max_h.peek()]<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap(nums)<\exit>
for i in xrange(k):<\exit>
dh.add(i)<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(i-k)<\exit>
dh.add(i)<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 1, 1, 1], 3) == [1, 1]<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
class PriorityQueue(object):<\exit>
def __init__(self):<\exit>
self.lst = []<\exit>
def bisect(self, t):<\exit>
l = 0<\exit>
h = len(self.lst)<\exit>
while l < h:<\exit>
m = (l+h)/2<\exit>
if self.lst[m] < t:<\exit>
l = m+1<\exit>
else:<\exit>
h = m<\exit>
return l<\exit>
def insert(self, t):<\exit>
pos = self.bisect(t)<\exit>
self.lst.insert(pos, t)<\exit>
def remove(self, t):<\exit>
pos = self.bisect(t)<\exit>
if self.lst[pos] != t:<\exit>
raise ValueError("%s not found in the queue"%str(t))<\exit>
del self.lst[pos]<\exit>
def __getitem__(self, item):<\exit>
return self.lst[item]<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Heap(object):<\exit>
def __init__(self):<\exit>
self.h = []<\exit>
self.existing = defaultdict(int)<\exit>
self.len = 0<\exit>
def push(self, t):<\exit>
heapq.heappush(self.h, t)<\exit>
self.existing[t] += 1<\exit>
self.len += 1<\exit>
def pop(self):<\exit>
while True:<\exit>
a = heapq.heappop(self.h)<\exit>
if self.existing[a] == 0:<\exit>
continue<\exit>
else:<\exit>
self.remove(a)<\exit>
return a<\exit>
def remove(self, t):<\exit>
if self.existing[t] < 1:<\exit>
raise ValueError("%s does not exist in the heap"%str(t))<\exit>
self.existing[t] -= 1<\exit>
self.len -= 1<\exit>
def __len__(self):<\exit>
return self.len<\exit>
def peek(self):<\exit>
a = self.h[0]<\exit>
if self.existing[a] > 0:<\exit>
return a<\exit>
a = self.pop()<\exit>
self.push(a)<\exit>
return a<\exit>
def __repr__(self):<\exit>
return repr(self.existing)<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = Heap()<\exit>
self.max_h = Heap()<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(-self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(-self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, t):<\exit>
if len(self.min_h) > 0 and t > self.min_h.peek():<\exit>
self.min_h.push(t)<\exit>
else:<\exit>
self.max_h.push(-t)<\exit>
self._rebalance()<\exit>
def remove(self, t):<\exit>
if len(self.min_h) > 0 and t >= self.min_h.peek():<\exit>
self.min_h.remove(t)<\exit>
else:<\exit>
self.max_h.remove(-t)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self.min_h.peek()<\exit>
else:<\exit>
return -self.max_h.peek()<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap()<\exit>
for i in xrange(k):<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(nums[i-k])<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
def medianSlidingWindow_TLE(self, nums, k):<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
pq = PriorityQueue()<\exit>
for i in xrange(k):<\exit>
pq.insert(nums[i])<\exit>
ret = []<\exit>
mid = k/2<\exit>
if k%2 == 0:<\exit>
mid -= 1<\exit>
ret.append(pq[mid])<\exit>
for i in xrange(k, len(nums)):<\exit>
pq.remove(nums[i-k])<\exit>
pq.insert(nums[i])<\exit>
ret.append(pq[mid])<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
import heapq<\exit>
from collections import defaultdict<\exit>
class Value(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.deleted = False<\exit>
def __neg__(self):<\exit>
self.val = -self.val<\exit>
return self<\exit>
def __cmp__(self, other):<\exit>
assert isinstance(other, Value)<\exit>
return self.val - other.val<\exit>
def __repr__(self):<\exit>
return repr(self.val)<\exit>
class Heap(object):<\exit>
def __init__(self):<\exit>
self.h = []<\exit>
self.len = 0<\exit>
def push(self, t):<\exit>
heapq.heappush(self.h, t)<\exit>
self.len += 1<\exit>
def pop(self):<\exit>
self._clean_top()<\exit>
self.len -= 1<\exit>
return heapq.heappop(self.h)<\exit>
def remove(self, t):<\exit>
t.deleted = True<\exit>
self.len -= 1<\exit>
def __len__(self):<\exit>
return self.len<\exit>
def _clean_top(self):<\exit>
while self.h and self.h[0].deleted:<\exit>
heapq.heappop(self.h)<\exit>
def peek(self):<\exit>
self._clean_top()<\exit>
return self.h[0]<\exit>
def __repr__(self):<\exit>
return repr(self.h)<\exit>
class DualHeap(object):<\exit>
def __init__(self):<\exit>
self.min_h = Heap()<\exit>
self.max_h = Heap()<\exit>
def _rebalance(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if abs(l-r) <= 1:<\exit>
return<\exit>
if r > l:<\exit>
self.max_h.push(-self.min_h.pop())<\exit>
else:<\exit>
self.min_h.push(-self.max_h.pop())<\exit>
self._rebalance()<\exit>
def add(self, t):<\exit>
if len(self.min_h) > 0 and t > self.min_h.peek():<\exit>
self.min_h.push(t)<\exit>
else:<\exit>
self.max_h.push(-t)<\exit>
self._rebalance()<\exit>
def remove(self, t):<\exit>
if len(self.min_h) > 0 and t >= self.min_h.peek():<\exit>
self.min_h.remove(t)<\exit>
else:<\exit>
self.max_h.remove(t)<\exit>
self._rebalance()<\exit>
def median(self):<\exit>
r = len(self.min_h)<\exit>
l = len(self.max_h)<\exit>
if r > l:<\exit>
return self.min_h.peek().val<\exit>
else:<\exit>
return -self.max_h.peek().val<\exit>
def __repr__(self):<\exit>
return repr(self.max_h)+repr(self.min_h)<\exit>
class Solution:<\exit>
def medianSlidingWindow(self, nums, k):<\exit>
nums = map(lambda x: Value(x), nums)<\exit>
if len(nums) < 1:<\exit>
return []<\exit>
ret = []<\exit>
dh = DualHeap()<\exit>
for i in xrange(k):<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
for i in xrange(k, len(nums)):<\exit>
dh.remove(nums[i-k])<\exit>
dh.add(nums[i])<\exit>
ret.append(dh.median())<\exit>
return ret<\exit>
if __name__ == "__main__":<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 7, 2], 3) == [2, 7, 7]<\exit>
assert Solution().medianSlidingWindow([1, 2, 7, 8, 5], 3) == [2, 7, 7]<\exit>
class Solution:<\exit>
def sortLetters(self, chars):<\exit>
closed = -1<\exit>
for ind, val in enumerate(chars):<\exit>
if ord(val) < ord('a'):<\exit>
continue<\exit>
else:<\exit>
closed += 1<\exit>
chars[ind], chars[closed] = chars[closed], chars[ind]<\exit>
if __name__ == "__main__":<\exit>
chars = list("abAcD")<\exit>
Solution().sortLetters(chars)<\exit>
assert "".join(chars) == "abcAD<\exit>
import random<\exit>
class PartialQuickSort(object):<\exit>
def partial_qsort(self, A, i, j, m):<\exit>
if i >= j: return<\exit>
p = self.pivot(A, i, j)<\exit>
self.partial_qsort(A, i, p, m)<\exit>
if p+1 >= m: return<\exit>
self.partial_qsort(A, p+1, j, m)<\exit>
def pivot(self, A, i, j):<\exit>
p = i<\exit>
closed = p<\exit>
for ptr in xrange(i, j):<\exit>
if A[ptr] < A[p]:<\exit>
closed += 1<\exit>
A[ptr], A[closed] = A[closed], A[ptr]<\exit>
A[closed], A[p] = A[p], A[closed]<\exit>
return closed<\exit>
@staticmethod<\exit>
def test():<\exit>
A = [4, 5, 3, 2, 1, 6, 7]<\exit>
sorter = PartialQuickSort()<\exit>
m = 3<\exit>
sorter.partial_qsort(A, 0, len(A), m)<\exit>
try:<\exit>
assert A[:m] == range(1, m+1)<\exit>
except AssertionError as e:<\exit>
print A[:m]<\exit>
raise e<\exit>
class MergeSort(object):<\exit>
def merge_sort(self, A):<\exit>
n = len(A)<\exit>
l = 1<\exit>
while l <= n:<\exit>
for i in range(0, n, l*2):<\exit>
lo, hi = i, min(n, i+2*l)<\exit>
mid = i + l<\exit>
p, q = lo, mid<\exit>
while p < mid and q < hi:<\exit>
if A[p] < A[q]:<\exit>
p += 1<\exit>
else:<\exit>
tmp = A[q]<\exit>
A[p+1: q+1] = A[p:q]<\exit>
A[p] = tmp<\exit>
p, mid, q = p+1, mid+1, q+1<\exit>
l *= 2<\exit>
return A<\exit>
@staticmethod<\exit>
def test():<\exit>
sorter = MergeSort()<\exit>
assert sorter.merge_sort([4, 3, 2, 1]) == [1, 2, 3, 4]<\exit>
assert sorter.merge_sort([4, 2, 3, 1]) == [1, 2, 3, 4]<\exit>
assert sorter.merge_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]<\exit>
for _ in range(100):<\exit>
tmp = range(100)<\exit>
random.shuffle(tmp)<\exit>
assert sorter.merge_sort(tmp) == range(100)<\exit>
return 'test pass!'<\exit>
class MergeSorter2(object):<\exit>
def merge_sort(self, A):<\exit>
if len(A) <= 1:<\exit>
return<\exit>
mid = len(A)/2<\exit>
L, R = A[:mid], A[mid:]<\exit>
self.merge_sort(L)<\exit>
self.merge_sort(R)<\exit>
i, j, k = 0, 0, 0<\exit>
while i < len(L) and j < len(R):<\exit>
if L[i] < R[j]:<\exit>
A[k] = L[i]<\exit>
i += 1<\exit>
else:<\exit>
A[k] = R[j]<\exit>
j += 1<\exit>
k += 1<\exit>
if i < len(L):<\exit>
A[k:] = L[i:]<\exit>
if j < len(R):<\exit>
A[k:] = R[j:]<\exit>
@staticmethod<\exit>
def test():<\exit>
sorter = MergeSorter2()<\exit>
A = [4, 3, 2, 1]<\exit>
sorter.merge_sort(A)<\exit>
assert A == [1, 2, 3, 4]<\exit>
for _ in range(100):<\exit>
tmp = range(100)<\exit>
random.shuffle(tmp)<\exit>
sorter.merge_sort(tmp)<\exit>
assert tmp == range(100)<\exit>
return 'test pass!'<\exit>
if __name__ == "__main__":<\exit>
PartialQuickSort.test()<\exit>
MergeSort.test()<\exit>
MergeSorter2.test()<\exit>
class Solution:<\exit>
def replaceBlank(self, string, length):<\exit>
i = 0<\exit>
while i < length:<\exit>
if string[i] == " ":<\exit>
string.append("")<\exit>
string.append("")<\exit>
length += 2<\exit>
for j in xrange(length-1, i, -1):<\exit>
string[j] = string[j-2]<\exit>
string[i:i+3] = list("%20")<\exit>
i += 2<\exit>
i += 1<\exit>
return length<\exit>
if __name__ == "__main__":<\exit>
assert Solution().replaceBlank(list("Mr John Smith"), 13) == 17<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = cipher<\exit>
x = 1<\exit>
while True:<\exit>
binary = bin(x)[2:]<\exit>
nine_ary = str(binary).replace("1", "9")<\exit>
dec = int(nine_ary)<\exit>
if dec % N == 0:<\exit>
return dec<\exit>
x += 1<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = int(f.readline().strip())<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class AllNerestSmallerValues(object):<\exit>
def allNearestSmaller(self, A):<\exit>
P = [-1 for _ in A]<\exit>
stk = []<\exit>
for i, v in enumerate(A):<\exit>
while stk and A[stk[-1]] >= v: stk.pop()<\exit>
if stk:<\exit>
P[i] = stk[-1]<\exit>
else:<\exit>
P[i] = -1<\exit>
stk.append(i)<\exit>
return P<\exit>
@staticmethod<\exit>
def test():<\exit>
A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]<\exit>
solution = AllNerestSmallerValues()<\exit>
P = solution.allNearestSmaller(A)<\exit>
expected = [None, 0, 0, 4, 0, 2, 2, 6, 0, 1, 1, 5, 1, 3, 3, 7]<\exit>
for i, v in enumerate(P):<\exit>
if P[i] == -1:<\exit>
assert expected[i] is None<\exit>
else:<\exit>
assert expected[i] == A[P[i]]<\exit>
if __name__ == "__main__":<\exit>
AllNerestSmallerValues.test()<\exit>
import sys<\exit>
import os<\exit>
from posixpath import normpath<\exit>
from urllib import unquote<\exit>
from cgi import FieldStorage<\exit>
from BaseHTTPServer import HTTPServer<\exit>
from SimpleHTTPServer import SimpleHTTPRequestHandler<\exit>
from SocketServer import ForkingMixIn<\exit>
import socket<\exit>
sys.path.append(os.path.join(os.path.dirname(__file__), 'server/src'))<\exit>
from server import serve<\exit>
import annlog<\exit>
import annotation<\exit>
import annotator<\exit>
import auth<\exit>
import common<\exit>
import delete<\exit>
import dispatch<\exit>
import docimport<\exit>
import document<\exit>
import download<\exit>
import filelock<\exit>
import gtbtokenize<\exit>
import jsonwrap<\exit>
import message<\exit>
import normdb<\exit>
import norm<\exit>
import predict<\exit>
import projectconfig<\exit>
import realmessage<\exit>
import sdistance<\exit>
import search<\exit>
import server<\exit>
import session<\exit>
import simstringdb<\exit>
import sosmessage<\exit>
import ssplit<\exit>
import sspostproc<\exit>
import stats<\exit>
import svg<\exit>
import tag<\exit>
import tokenise<\exit>
import undo<\exit>
import verify_annotations<\exit>
_VERBOSE_HANDLER = False<\exit>
_DEFAULT_SERVER_ADDR = ''<\exit>
_DEFAULT_SERVER_PORT = 8001<\exit>
_PERMISSIONS =<\exit>
class PermissionParseError(Exception):<\exit>
def __init__(self, linenum, line, message=None):<\exit>
self.linenum = linenum<\exit>
self.line = line<\exit>
self.message = ' (%s)' % message if message is not None else ''<\exit>
def __str__(self):<\exit>
return 'line %d%s: %s' % (self.linenum, self.message, self.line)<\exit>
class PathPattern(object):<\exit>
def __init__(self, path):<\exit>
self.path = path<\exit>
self.plen = len(path)<\exit>
def match(self, s):<\exit>
return s[:self.plen] == self.path and (self.path[-1] == '/' or<\exit>
s[self.plen:] == '' or<\exit>
s[self.plen] == '/')<\exit>
class ExtensionPattern(object):<\exit>
def __init__(self, ext):<\exit>
self.ext = ext<\exit>
def match(self, s):<\exit>
return os.path.splitext(s)[1] == self.ext<\exit>
class PathPermissions(object):<\exit>
def __init__(self, default_allow=False):<\exit>
self._entries = []<\exit>
self.default_allow = default_allow<\exit>
def allow(self, path):<\exit>
for pattern, allow in self._entries:<\exit>
if pattern.match(path):<\exit>
return allow<\exit>
return self.default_allow<\exit>
def parse(self, lines):<\exit>
for ln, l in enumerate(lines):<\exit>
i = l.find('#')<\exit>
if i != -1:<\exit>
l = l[:i]<\exit>
l = l.strip()<\exit>
if not l:<\exit>
continue<\exit>
i = l.find(':')<\exit>
if i == -1:<\exit>
raise PermissionParseError(ln, lines[ln], 'missing colon')<\exit>
directive = l[:i].strip().lower()<\exit>
pattern = l[i+1:].strip()<\exit>
if directive == 'allow':<\exit>
allow = True<\exit>
elif directive == 'disallow':<\exit>
allow = False<\exit>
else:<\exit>
raise PermissionParseError(ln, lines[ln], 'unrecognized directive')<\exit>
if pattern.startswith('/'):<\exit>
patt = PathPattern(pattern)<\exit>
elif pattern.startswith('*.'):<\exit>
patt = ExtensionPattern(pattern[1:])<\exit>
else:<\exit>
raise PermissionParseError(ln, lines[ln], 'unrecognized pattern')<\exit>
self._entries.append((patt, allow))<\exit>
return self<\exit>
class BratHTTPRequestHandler(SimpleHTTPRequestHandler):<\exit>
permissions = PathPermissions().parse(_PERMISSIONS.split('\n'))<\exit>
def log_request(self, code='-', size='-'):<\exit>
if _VERBOSE_HANDLER:<\exit>
SimpleHTTPRequestHandler.log_request(self, code, size)<\exit>
else:<\exit>
pass<\exit>
def is_brat(self):<\exit>
path = self.path<\exit>
path = path.split('?', 1)[0]<\exit>
path = path.split('#', 1)[0]<\exit>
if path == '/ajax.cgi':<\exit>
return True<\exit>
else:<\exit>
return False<\exit>
def run_brat_direct(self):<\exit>
remote_addr = self.client_address[0]<\exit>
remote_host = self.address_string()<\exit>
cookie_data = ', '.join(filter(None, self.headers.getheaders('cookie')))<\exit>
query_string = ''<\exit>
i = self.path.find('?')<\exit>
if i != -1:<\exit>
query_string = self.path[i+1:]<\exit>
saved = sys.stdin, sys.stdout, sys.stderr<\exit>
sys.stdin, sys.stdout = self.rfile, self.wfile<\exit>
env = {}<\exit>
env['REQUEST_METHOD'] = self.command<\exit>
content_length = self.headers.getheader('content-length')<\exit>
if content_length:<\exit>
env['CONTENT_LENGTH'] = content_length<\exit>
if query_string:<\exit>
env['QUERY_STRING'] = query_string<\exit>
os.environ.update(env)<\exit>
params = FieldStorage()<\exit>
cookie_hdrs, response_data = serve(params, remote_addr, remote_host,<\exit>
cookie_data)<\exit>
sys.stdin, sys.stdout, sys.stderr = saved<\exit>
if cookie_hdrs is not None:<\exit>
response_hdrs = [hdr for hdr in cookie_hdrs]<\exit>
else:<\exit>
response_hdrs = []<\exit>
response_hdrs.extend(response_data[0])<\exit>
self.send_response(200)<\exit>
self.wfile.write('\n'.join('%s: %s' % (k, v) for k, v in response_hdrs))<\exit>
self.wfile.write('\n')<\exit>
self.wfile.write('\n')<\exit>
if isinstance(response_data[1], unicode):<\exit>
self.wfile.write(response_data[1].encode('utf-8'))<\exit>
else:<\exit>
self.wfile.write(response_data[1])<\exit>
return 0<\exit>
def allow_path(self):<\exit>
path = self.path<\exit>
path = path.split('?', 1)[0]<\exit>
path = path.split('#', 1)[0]<\exit>
path = unquote(path)<\exit>
path = normpath(path)<\exit>
parts = path.split('/')<\exit>
parts = filter(None, parts)<\exit>
if '..' in parts:<\exit>
return False<\exit>
path = '/'+'/'.join(parts)<\exit>
return self.permissions.allow(path)<\exit>
def list_directory(self, path):<\exit>
self.send_error(403)<\exit>
def do_POST(self):<\exit>
if self.is_brat():<\exit>
self.run_brat_direct()<\exit>
else:<\exit>
self.send_error(501, "Can only POST to brat")<\exit>
def do_GET(self):<\exit>
if not self.allow_path():<\exit>
self.send_error(403)<\exit>
elif self.is_brat():<\exit>
self.run_brat_direct()<\exit>
else:<\exit>
SimpleHTTPRequestHandler.do_GET(self)<\exit>
def do_HEAD(self):<\exit>
if not self.allow_path():<\exit>
self.send_error(403)<\exit>
else:<\exit>
SimpleHTTPRequestHandler.do_HEAD(self)<\exit>
class BratServer(ForkingMixIn, HTTPServer):<\exit>
def __init__(self, server_address):<\exit>
HTTPServer.__init__(self, server_address, BratHTTPRequestHandler)<\exit>
def main(argv):<\exit>
try:<\exit>
if os.getuid() == 0:<\exit>
print >> sys.stderr,<\exit>
except AttributeError:<\exit>
print >> sys.stderr,<\exit>
if len(argv) > 1:<\exit>
try:<\exit>
port = int(argv[1])<\exit>
except ValueError:<\exit>
print >> sys.stderr, "Failed to parse", argv[1], "as port number."<\exit>
return 1<\exit>
else:<\exit>
port = _DEFAULT_SERVER_PORT<\exit>
try:<\exit>
server = BratServer((_DEFAULT_SERVER_ADDR, port))<\exit>
print >> sys.stderr, "Serving brat at http://%s:%d" % server.server_address<\exit>
server.serve_forever()<\exit>
except KeyboardInterrupt:<\exit>
pass<\exit>
except socket.error, why:<\exit>
print >> sys.stderr, "Error binding to port", port, ":", why[1]<\exit>
except Exception, e:<\exit>
print >> sys.stderr, "Server error", e<\exit>
raise<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main(sys.argv))<\exit>
from .structures import LookupDict<\exit>
_codes = {<\exit>
100: ('continue',),<\exit>
101: ('switching_protocols',),<\exit>
102: ('processing',),<\exit>
103: ('checkpoint',),<\exit>
122: ('uri_too_long', 'request_uri_too_long'),<\exit>
200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', '閴'),<\exit>
201: ('created',),<\exit>
202: ('accepted',),<\exit>
203: ('non_authoritative_info', 'non_authoritative_information'),<\exit>
204: ('no_content',),<\exit>
205: ('reset_content', 'reset'),<\exit>
206: ('partial_content', 'partial'),<\exit>
207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),<\exit>
208: ('im_used',),<\exit>
300: ('multiple_choices',),<\exit>
301: ('moved_permanently', 'moved', '\\o-'),<\exit>
302: ('found',),<\exit>
303: ('see_other', 'other'),<\exit>
304: ('not_modified',),<\exit>
305: ('use_proxy',),<\exit>
306: ('switch_proxy',),<\exit>
307: ('temporary_redirect', 'temporary_moved', 'temporary'),<\exit>
308: ('resume_incomplete', 'resume'),<\exit>
400: ('bad_request', 'bad'),<\exit>
401: ('unauthorized',),<\exit>
402: ('payment_required', 'payment'),<\exit>
403: ('forbidden',),<\exit>
404: ('not_found', '-o-'),<\exit>
405: ('method_not_allowed', 'not_allowed'),<\exit>
406: ('not_acceptable',),<\exit>
407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),<\exit>
408: ('request_timeout', 'timeout'),<\exit>
409: ('conflict',),<\exit>
410: ('gone',),<\exit>
411: ('length_required',),<\exit>
412: ('precondition_failed', 'precondition'),<\exit>
413: ('request_entity_too_large',),<\exit>
414: ('request_uri_too_large',),<\exit>
415: ('unsupported_media_type', 'unsupported_media', 'media_type'),<\exit>
416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),<\exit>
417: ('expectation_failed',),<\exit>
418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),<\exit>
422: ('unprocessable_entity', 'unprocessable'),<\exit>
423: ('locked',),<\exit>
424: ('failed_dependency', 'dependency'),<\exit>
425: ('unordered_collection', 'unordered'),<\exit>
426: ('upgrade_required', 'upgrade'),<\exit>
428: ('precondition_required', 'precondition'),<\exit>
429: ('too_many_requests', 'too_many'),<\exit>
431: ('header_fields_too_large', 'fields_too_large'),<\exit>
444: ('no_response', 'none'),<\exit>
449: ('retry_with', 'retry'),<\exit>
450: ('blocked_by_windows_parental_controls', 'parental_controls'),<\exit>
499: ('client_closed_request',),<\exit>
500: ('internal_server_error', 'server_error', '/o\\', '閴'),<\exit>
501: ('not_implemented',),<\exit>
502: ('bad_gateway',),<\exit>
503: ('service_unavailable', 'unavailable'),<\exit>
504: ('gateway_timeout',),<\exit>
505: ('http_version_not_supported', 'http_version'),<\exit>
506: ('variant_also_negotiates',),<\exit>
507: ('insufficient_storage',),<\exit>
509: ('bandwidth_limit_exceeded', 'bandwidth'),<\exit>
510: ('not_extended',),<\exit>
}<\exit>
codes = LookupDict(name='status_codes')<\exit>
for (code, titles) in list(_codes.items()):<\exit>
for title in titles:<\exit>
setattr(codes, title, code)<\exit>
if not title.startswith('\\'):<\exit>
setattr(codes, title.upper(), code)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
f = [0 for _ in A]<\exit>
f[N - 1] = A[N - 1]<\exit>
for i in xrange(N - 2, -1, -1):<\exit>
f[i] = max(A[i], f[i + 1])<\exit>
profit = 0<\exit>
for i in xrange(N - 1):<\exit>
profit += max(0, f[i + 1] - A[i])<\exit>
return profit<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
r, c = cipher<\exit>
r, c = r - 1, c - 1<\exit>
return r / 2 * 10 + r % 2 + c * 2<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
def longest(word_set, cache, word):<\exit>
if word not in cache:<\exit>
ret = 1<\exit>
for i in xrange(len(word)):<\exit>
w = word[:i] + word[i+1:]<\exit>
if w and w in word_set:<\exit>
cnt = longest(word_set, cache, w)<\exit>
ret = max(ret, 1 + cnt)<\exit>
cache[word] = ret<\exit>
return cache[word]<\exit>
def longestChain(words):<\exit>
cache = {}<\exit>
word_set = set(words)<\exit>
gmax = 0<\exit>
for word in words:<\exit>
gmax = max(gmax, longest(word_set, cache, word))<\exit>
return gmax<\exit>
if __name__ == "__main__":<\exit>
words = ["a", "b", "ba", "bca", "bda", "bdca"]<\exit>
assert longestChain(words) == 4<\exit>
class CaseInsensitiveDict(dict):<\exit>
@property<\exit>
def lower_keys(self):<\exit>
if not hasattr(self, '_lower_keys') or not self._lower_keys:<\exit>
self._lower_keys = dict((k.lower(), k) for k in list(self.keys()))<\exit>
return self._lower_keys<\exit>
def _clear_lower_keys(self):<\exit>
if hasattr(self, '_lower_keys'):<\exit>
self._lower_keys.clear()<\exit>
def __setitem__(self, key, value):<\exit>
dict.__setitem__(self, key, value)<\exit>
self._clear_lower_keys()<\exit>
def __delitem__(self, key):<\exit>
dict.__delitem__(self, self.lower_keys.get(key.lower(), key))<\exit>
self._lower_keys.clear()<\exit>
def __contains__(self, key):<\exit>
return key.lower() in self.lower_keys<\exit>
def __getitem__(self, key):<\exit>
if key in self:<\exit>
return dict.__getitem__(self, self.lower_keys[key.lower()])<\exit>
def get(self, key, default=None):<\exit>
if key in self:<\exit>
return self[key]<\exit>
else:<\exit>
return default<\exit>
class LookupDict(dict):<\exit>
def __init__(self, name=None):<\exit>
self.name = name<\exit>
super(LookupDict, self).__init__()<\exit>
def __repr__(self):<\exit>
return '<lookup \'%s\'>' % (self.name)<\exit>
def __getitem__(self, key):<\exit>
return self.__dict__.get(key, None)<\exit>
def get(self, key, default=None):<\exit>
return self.__dict__.get(key, default)<\exit>
from bisect import bisect_left, bisect_right<\exit>
class Solution:<\exit>
def subarraySumII(self, A, start, end):<\exit>
n = len(A)<\exit>
cnt = 0<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+A[i-1]<\exit>
f.sort()<\exit>
for i in xrange(n+1):<\exit>
lo = bisect_left(f, f[i]-end, 0, i)<\exit>
hi = bisect_right(f, f[i]-start, 0, i)<\exit>
cnt += hi-lo<\exit>
return cnt<\exit>
def subarraySumII_TLE(self, A, start, end):<\exit>
n = len(A)<\exit>
cnt = 0<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+A[i-1]<\exit>
for i in xrange(0, n+1):<\exit>
for j in xrange(i+1, n+1):<\exit>
s = f[j]-f[i]<\exit>
if start <= s <= end:<\exit>
cnt += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().subarraySumII([1, 2, 3, 4], 1, 3) == 4<\exit>
from collections import defaultdict<\exit>
class Solution:<\exit>
def subarraySum(self, nums):<\exit>
n = len(nums)<\exit>
f = [0 for _ in xrange(n+1)]<\exit>
for i in xrange(1, n+1):<\exit>
f[i] = f[i-1]+nums[i-1]<\exit>
d = defaultdict(list)<\exit>
for i in xrange(1, n+1):<\exit>
d[f[i]].append(i)<\exit>
for k, v in d.items():<\exit>
if k == 0:<\exit>
return [0, v[0]-1]<\exit>
if len(v) > 1:<\exit>
return [v[0], v[1]-1]<\exit>
return [-1, -1]<\exit>
if __name__ == "__main__":<\exit>
print Solution().subarraySum([-5, 10, 5, -3, 1, 1, 1, -2, 3, -4])<\exit>
class Solution:<\exit>
def submatrixSum(self, matrix):<\exit>
m = len(matrix)<\exit>
n = len(matrix[0])<\exit>
to_top = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]<\exit>
for i in xrange(1, m+1):<\exit>
for j in xrange(1, n+1):<\exit>
to_top[i][j] = to_top[i-1][j] + matrix[i-1][j-1]<\exit>
for up in xrange(m):<\exit>
for down in xrange(up, m):<\exit>
h = {}<\exit>
s = 0<\exit>
h[s] = -1<\exit>
for j in xrange(n):<\exit>
s += to_top[down+1][j+1] - to_top[up][j+1]<\exit>
if s in h:<\exit>
return [[up, h[s]+1], [down, j]]<\exit>
h[s] = j<\exit>
return [[-1, -1], [-1, -1]]<\exit>
if __name__ == "__main__":<\exit>
assert Solution().submatrixSum([<\exit>
[1, 5, 7],<\exit>
[3, 7, -8],<\exit>
[4, -8, 9],<\exit>
]) == [[1, 1], [2, 2]]<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
S, p, q = cipher<\exit>
n = len(p)<\exit>
S = int(S)<\exit>
global_max = 0<\exit>
for i in xrange(n):<\exit>
global_max = max(global_max, self.get_longest(S, p, q, i, 0), self.get_longest(S, p, q, 0, i))<\exit>
return global_max<\exit>
def get_longest(self, S, p, q, i, j):<\exit>
start_i = i<\exit>
start_j = j<\exit>
local_max = 0<\exit>
n = len(p)<\exit>
cur_diff = 0<\exit>
while i < n and j < n:<\exit>
if p[i] != q[j]:<\exit>
cur_diff += 1<\exit>
if cur_diff > S:<\exit>
while p[start_i] == q[start_j]:<\exit>
start_i += 1<\exit>
start_j += 1<\exit>
start_i += 1<\exit>
start_j += 1<\exit>
cur_diff -= 1<\exit>
local_max = max(local_max, i - start_i + 1)<\exit>
i += 1<\exit>
j += 1<\exit>
return local_max<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import gobject<\exit>
import rsvg<\exit>
import goocanvas<\exit>
import os.path<\exit>
class SvgItem(goocanvas.ItemSimple):<\exit>
__gproperties__ = {<\exit>
'x': (float,<\exit>
'X',<\exit>
'The x coordinate of a SVG image',<\exit>
-10e6,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'y': (float,<\exit>
'Y',<\exit>
'The y coordinate of a SVG image',<\exit>
-10e6,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'width': (float,<\exit>
'Width',<\exit>
'The width of the SVG Image',<\exit>
0,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
'height': (float,<\exit>
'Height',<\exit>
'The width of the SVG Image',<\exit>
0,<\exit>
10e6,<\exit>
0,<\exit>
gobject.PARAM_READWRITE),<\exit>
}<\exit>
def __init__(self, x, y, rsvg_handle, **kwargs):<\exit>
super(SvgItem, self).__init__(**kwargs)<\exit>
assert isinstance(rsvg_handle, rsvg.Handle)<\exit>
self.x = x<\exit>
self.y = y<\exit>
self.sx = 1.0<\exit>
self.sy = 1.0<\exit>
self.handle = rsvg_handle<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
self.custom_width = None<\exit>
self.custom_height = None<\exit>
def do_set_property(self, pspec, value):<\exit>
if pspec.name == 'x':<\exit>
self.x = value<\exit>
self.changed(True)<\exit>
elif pspec.name == 'y':<\exit>
self.y = value<\exit>
self.changed(True)<\exit>
elif pspec.name == 'width':<\exit>
self.custom_width = value<\exit>
self._size_changed()<\exit>
self.changed(True)<\exit>
elif pspec.name == 'height':<\exit>
self.custom_height = value<\exit>
self._size_changed()<\exit>
self.changed(True)<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
def _size_changed(self):<\exit>
if self.custom_width is None and self.custom_height is None:<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
self.sx = 1.0<\exit>
self.sy = 1.0<\exit>
elif self.custom_width is not None and self.custom_height is None:<\exit>
self.width = self.custom_width<\exit>
self.sx = self.custom_width / self.handle.props.width<\exit>
self.sy = self.sx<\exit>
self.height = self.handle.props.height*self.sy<\exit>
elif self.custom_width is None and self.custom_height is not None:<\exit>
self.height = self.custom_height<\exit>
self.sy = self.custom_height / self.handle.props.height<\exit>
self.sx  = self.sy<\exit>
self.width = self.handle.props.width*self.sx<\exit>
else:<\exit>
self.width = self.custom_width<\exit>
self.height = self.custom_height<\exit>
self.sx = self.custom_width / self.handle.props.width<\exit>
self.sy = self.custom_height / self.handle.props.height<\exit>
def do_get_property(self, pspec):<\exit>
if pspec.name == 'x':<\exit>
return self.x<\exit>
elif pspec.name == 'y':<\exit>
return self.y<\exit>
elif pspec.name == 'width':<\exit>
self.width = self.handle.props.width<\exit>
self.height = self.handle.props.height<\exit>
return self.width<\exit>
elif pspec.name == 'height':<\exit>
return self.height<\exit>
else:<\exit>
raise AttributeError, 'unknown property %s' % pspec.name<\exit>
def do_simple_paint(self, cr, bounds):<\exit>
cr.translate(self.x, self.y)<\exit>
cr.scale(self.sx, self.sy)<\exit>
self.handle.render_cairo(cr)<\exit>
def do_simple_update(self, cr):<\exit>
self.bounds_x1 = float(self.x)<\exit>
self.bounds_y1 = float(self.y)<\exit>
self.bounds_x2 = float(self.x + self.width)<\exit>
self.bounds_y2 = float(self.y + self.height)<\exit>
def do_simple_is_item_at(self, x, y, cr, is_pointer_event):<\exit>
if ((x < self.x) or (x > self.x + self.width)) or ((y < self.y) or (y > self.y + self.height)):<\exit>
return False<\exit>
else:<\exit>
return True<\exit>
_rsvg_cache = dict()<\exit>
def rsvg_handle_factory(base_file_name):<\exit>
try:<\exit>
return _rsvg_cache[base_file_name]<\exit>
except KeyError:<\exit>
full_path = os.path.join(os.path.dirname(__file__), 'resource', base_file_name)<\exit>
rsvg_handle = rsvg.Handle(full_path)<\exit>
_rsvg_cache[base_file_name] = rsvg_handle<\exit>
return rsvg_handle<\exit>
from facerec_py.facerec.classifier import SVM<\exit>
from facerec_py.facerec.validation import KFoldCrossValidation<\exit>
from facerec_py.facerec.model import PredictableModel<\exit>
from svmutil import *<\exit>
from itertools import product<\exit>
import numpy as np<\exit>
import logging<\exit>
def range_f(begin, end, step):<\exit>
seq = []<\exit>
while True:<\exit>
if step == 0: break<\exit>
if step > 0 and begin > end: break<\exit>
if step < 0 and begin < end: break<\exit>
seq.append(begin)<\exit>
begin = begin + step<\exit>
return seq<\exit>
def grid(grid_parameters):<\exit>
grid = []<\exit>
for parameter in grid_parameters:<\exit>
begin, end, step = parameter<\exit>
grid.append(range_f(begin, end, step))<\exit>
return product(*grid)<\exit>
def grid_search(model, X, y, C_range=(-5,  15, 2), gamma_range=(3, -15, -2), k=5, num_cores=1):<\exit>
if not isinstance(model, PredictableModel):<\exit>
raise TypeError("GridSearch expects a PredictableModel. If you want to perform optimization on raw data use facerec.feature.Identity to pass unpreprocessed data!")<\exit>
if not isinstance(model.classifier, SVM):<\exit>
raise TypeError("GridSearch expects a SVM as classifier. Please use a facerec.classifier.SVM!")<\exit>
logger = logging.getLogger("facerec.svm.gridsearch")<\exit>
logger.info("Performing a Grid Search.")<\exit>
best_parameter = svm_parameter("-q")<\exit>
best_parameter.kernel_type = model.classifier.param.kernel_type<\exit>
best_parameter.nu = model.classifier.param.nu<\exit>
best_parameter.coef0 = model.classifier.param.coef0<\exit>
if (gamma_range is None) or (model.classifier.param.kernel_type == LINEAR):<\exit>
gamma_range = (0, 0, 1)<\exit>
best_accuracy = np.finfo('float').min<\exit>
g = grid([C_range, gamma_range])<\exit>
results = []<\exit>
for p in g:<\exit>
C, gamma = p<\exit>
C, gamma = 2**C, 2**gamma<\exit>
model.classifier.param.C, model.classifier.param.gamma = C, gamma<\exit>
cv = KFoldCrossValidation(model=model,k=k)<\exit>
cv.validate(X,y)<\exit>
results.append([C, gamma, cv.accuracy])<\exit>
if cv.accuracy > best_accuracy:<\exit>
logger.info("best_accuracy=%s" % (cv.accuracy))<\exit>
best_accuracy = cv.accuracy<\exit>
best_parameter.C, best_parameter.gamma = C, gamma<\exit>
logger.info("%d-CV Result = %.2f." % (k, cv.accuracy))<\exit>
return best_parameter, results<\exit>
from django import template<\exit>
import markdown2<\exit>
register = template.Library()<\exit>
@register.simple_tag(takes_context=True)<\exit>
def some_tags(context):<\exit>
pass<\exit>
@register.filter<\exit>
def markdownify(text):<\exit>
return markdown2.markdown(text, extras=["fenced-code-blocks"], safe_mode=None)<\exit>
import sys<\exit>
import ns.core<\exit>
import ns.csma<\exit>
import ns.internet<\exit>
import ns.network<\exit>
import ns.tap_bridge<\exit>
def main(argv):<\exit>
ns.core.GlobalValue.Bind("SimulatorImplementationType", ns.core.StringValue("ns3::RealtimeSimulatorImpl"))<\exit>
ns.core.GlobalValue.Bind("ChecksumEnabled", ns.core.BooleanValue("true"))<\exit>
nodes = ns.network.NodeContainer()<\exit>
nodes.Create (2)<\exit>
csma = ns.csma.CsmaHelper()<\exit>
devices = csma.Install(nodes)<\exit>
tapBridge = ns.tap_bridge.TapBridgeHelper()<\exit>
tapBridge.SetAttribute ("Mode", ns.core.StringValue ("UseLocal"))<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-left"))<\exit>
tapBridge.Install (nodes.Get (0), devices.Get (0))<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-right"))<\exit>
tapBridge.Install (nodes.Get (1), devices.Get (1))<\exit>
ns.core.Simulator.Stop (ns.core.Seconds (600))<\exit>
ns.core.Simulator.Run(signal_check_frequency = -1)<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import ns.core<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.tap_bridge<\exit>
import ns.wifi<\exit>
def main(argv):<\exit>
ns.core.GlobalValue.Bind("SimulatorImplementationType", ns.core.StringValue("ns3::RealtimeSimulatorImpl"))<\exit>
ns.core.GlobalValue.Bind("ChecksumEnabled", ns.core.BooleanValue("true"))<\exit>
nodes = ns.network.NodeContainer()<\exit>
nodes.Create (2);<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
wifi.SetStandard (ns.wifi.WIFI_PHY_STANDARD_80211a);<\exit>
wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager", "DataMode", ns.core.StringValue ("OfdmRate54Mbps"));<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiMac.SetType ("ns3::AdhocWifiMac");<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
devices = wifi.Install(wifiPhy, wifiMac, nodes)<\exit>
mobility = ns.mobility.MobilityHelper()<\exit>
positionAlloc = ns.mobility.ListPositionAllocator()<\exit>
positionAlloc.Add(ns.core.Vector(0.0, 0.0, 0.0))<\exit>
positionAlloc.Add(ns.core.Vector(5.0, 0.0, 0.0))<\exit>
mobility.SetPositionAllocator(positionAlloc)<\exit>
mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel")<\exit>
mobility.Install(nodes)<\exit>
tapBridge = ns.tap_bridge.TapBridgeHelper()<\exit>
tapBridge.SetAttribute ("Mode", ns.core.StringValue ("UseLocal"));<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-left"));<\exit>
tapBridge.Install (nodes.Get (0), devices.Get (0));<\exit>
tapBridge.SetAttribute ("DeviceName", ns.core.StringValue ("tap-right"));<\exit>
tapBridge.Install (nodes.Get (1), devices.Get (1));<\exit>
ns.core.Simulator.Stop (ns.core.Seconds (600));<\exit>
ns.core.Simulator.Run(signal_check_frequency = -1)<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
tasks = cipher<\exit>
tasks.sort(key=lambda t: t[0])<\exit>
overshot = -1<\exit>
timer = 0<\exit>
for task in tasks:<\exit>
timer += task[1]<\exit>
overshot = max(overshot, timer - task[0])<\exit>
return overshot<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
cipher = []<\exit>
for t in xrange(testcases):<\exit>
cipher.append(map(lambda x: int(x), f.readline().strip().split(' ')))<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = map(int, f.readline().strip().split(' '))<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import os<\exit>
import sys<\exit>
import time<\exit>
import optparse<\exit>
import subprocess<\exit>
import threading<\exit>
import Queue<\exit>
import signal<\exit>
import xml.dom.minidom<\exit>
import shutil<\exit>
import re<\exit>
from utils import get_list_from_file<\exit>
interesting_config_items = [<\exit>
"NS3_ENABLED_MODULES",<\exit>
"NS3_MODULE_PATH",<\exit>
"NSC_ENABLED",<\exit>
"ENABLE_REAL_TIME",<\exit>
"ENABLE_THREADING",<\exit>
"ENABLE_EXAMPLES",<\exit>
"ENABLE_TESTS",<\exit>
"EXAMPLE_DIRECTORIES",<\exit>
"ENABLE_PYTHON_BINDINGS",<\exit>
"ENABLE_CLICK",<\exit>
"ENABLE_OPENFLOW",<\exit>
]<\exit>
NSC_ENABLED = False<\exit>
ENABLE_REAL_TIME = False<\exit>
ENABLE_THREADING = False<\exit>
ENABLE_EXAMPLES = True<\exit>
ENABLE_TESTS = True<\exit>
ENABLE_CLICK = False<\exit>
ENABLE_OPENFLOW = False<\exit>
EXAMPLE_DIRECTORIES = []<\exit>
core_kinds = ["bvt", "core", "system", "unit"]<\exit>
core_valgrind_skip_tests = [<\exit>
"ns3-tcp-cwnd",<\exit>
"nsc-tcp-loss",<\exit>
"ns3-tcp-interoperability",<\exit>
"routing-click",<\exit>
]<\exit>
core_nsc_missing_skip_tests = [<\exit>
"ns3-tcp-cwnd",<\exit>
"nsc-tcp-loss",<\exit>
"ns3-tcp-interoperability",<\exit>
]<\exit>
def parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests):<\exit>
if os.path.exists(examples_to_run_path):<\exit>
cpp_examples = get_list_from_file(examples_to_run_path, "cpp_examples")<\exit>
for example_name, do_run, do_valgrind_run in cpp_examples:<\exit>
example_path = os.path.join(cpp_executable_dir, example_name)<\exit>
if os.path.exists(example_path):<\exit>
example_tests.append((example_path, do_run, do_valgrind_run))<\exit>
python_examples = get_list_from_file(examples_to_run_path, "python_examples")<\exit>
for example_name, do_run in python_examples:<\exit>
example_path = os.path.join(python_script_dir, example_name)<\exit>
if os.path.exists(example_path):<\exit>
python_tests.append((example_path, do_run))<\exit>
TMP_OUTPUT_DIR = "testpy-output"<\exit>
def read_test(test):<\exit>
result = test.find('Result').text<\exit>
name = test.find('Name').text<\exit>
if not test.find('Time') is None:<\exit>
time_real = test.find('Time').get('real')<\exit>
else:<\exit>
time_real = ''<\exit>
return (result, name, time_real)<\exit>
def node_to_text (test, f):<\exit>
(result, name, time_real) = read_test(test)<\exit>
output = "%s: Test Suite \"%s\" (%s)\n" % (result, name, time_real)<\exit>
f.write(output)<\exit>
for details in test.findall('FailureDetails'):<\exit>
f.write("    Details:\n")<\exit>
f.write("      Message:   %s\n" % details.find('Message').text)<\exit>
f.write("      Condition: %s\n" % details.find('Condition').text)<\exit>
f.write("      Actual:    %s\n" % details.find('Actual').text)<\exit>
f.write("      Limit:     %s\n" % details.find('Limit').text)<\exit>
f.write("      File:      %s\n" % details.find('File').text)<\exit>
f.write("      Line:      %s\n" % details.find('Line').text)<\exit>
for child in test.findall('Test'):<\exit>
node_to_text(child, f)<\exit>
def translate_to_text(results_file, text_file):<\exit>
f = open(text_file, 'w')<\exit>
import xml.etree.ElementTree as ET<\exit>
et = ET.parse (results_file)<\exit>
for test in et.findall('Test'):<\exit>
node_to_text (test, f)<\exit>
for example in et.findall('Example'):<\exit>
result = example.find('Result').text<\exit>
name = example.find('Name').text<\exit>
if not example.find('Time') is None:<\exit>
time_real = example.find('Time').get('real')<\exit>
else:<\exit>
time_real = ''<\exit>
output = "%s: Example \"%s\" (%s)\n" % (result, name, time_real)<\exit>
f.write(output)<\exit>
f.close()<\exit>
def translate_to_html(results_file, html_file):<\exit>
f = open(html_file, 'w')<\exit>
f.write("<html>\n")<\exit>
f.write("<body>\n")<\exit>
f.write("<center><h1>ns-3 Test Results</h1></center>\n")<\exit>
import xml.etree.ElementTree as ET<\exit>
et = ET.parse(results_file)<\exit>
f.write("<h2>Test Suites</h2>\n")<\exit>
for suite in et.findall('Test'):<\exit>
(result, name, time) = read_test (suite)<\exit>
if result == "PASS":<\exit>
f.write("<h3 style=\"color:green\">%s: %s (%s)</h3>\n" % (result, name, time))<\exit>
elif result == "SKIP":<\exit>
f.write("<h3 style=\"color:<\exit>
else:<\exit>
f.write("<h3 style=\"color:red\">%s: %s (%s)</h3>\n" % (result, name, time))<\exit>
f.write("<table border=\"1\">\n")<\exit>
f.write("<th> Result </th>\n")<\exit>
if result in ["CRASH", "SKIP", "VALGR"]:<\exit>
f.write("<tr>\n")<\exit>
if result == "SKIP":<\exit>
f.write("<td style=\"color:<\exit>
else:<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
continue<\exit>
f.write("<th>Test Case Name</th>\n")<\exit>
f.write("<th> Time </th>\n")<\exit>
if result == "FAIL":<\exit>
f.write("<th>Failure Details</th>\n")<\exit>
for case in suite.findall('Test'):<\exit>
(result, name, time) = read_test(case)<\exit>
if result == "FAIL":<\exit>
first_row = True<\exit>
for details in case.findall('FailureDetails'):<\exit>
f.write("<tr>\n")<\exit>
if first_row:<\exit>
first_row = False<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
else:<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td></td>\n")<\exit>
f.write("<td>")<\exit>
f.write("<b>Message: </b>%s, " % details.find('Message').text)<\exit>
f.write("<b>Condition: </b>%s, " % details.find('Condition').text)<\exit>
f.write("<b>Actual: </b>%s, " % details.find('Actual').text)<\exit>
f.write("<b>Limit: </b>%s, " % details.find('Limit').text)<\exit>
f.write("<b>File: </b>%s, " % details.find('File').text)<\exit>
f.write("<b>Line: </b>%s" % details.find('Line').text)<\exit>
f.write("</td>\n")<\exit>
f.write("</td>\n")<\exit>
else:<\exit>
f.write("<tr>\n")<\exit>
f.write("<td style=\"color:green\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
f.write("<td></td>\n")<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
f.write("<h2>Examples</h2>\n")<\exit>
f.write("<table border=\"1\">\n")<\exit>
f.write("<th> Result </th>\n")<\exit>
f.write("<th>Example Name</th>\n")<\exit>
f.write("<th>Elapsed Time</th>\n")<\exit>
for example in et.findall("Example"):<\exit>
f.write("<tr>\n")<\exit>
(result, name, time) = read_test(example)<\exit>
if result == "PASS":<\exit>
f.write("<td style=\"color:green\">%s</td>\n" % result)<\exit>
elif result == "SKIP":<\exit>
f.write("<td style=\"color:<\exit>
else:<\exit>
f.write("<td style=\"color:red\">%s</td>\n" % result)<\exit>
f.write("<td>%s</td>\n" % name)<\exit>
f.write("<td>%s</td>\n" % time)<\exit>
f.write("</tr>\n")<\exit>
f.write("</table>\n")<\exit>
f.write("</body>\n")<\exit>
f.write("</html>\n")<\exit>
f.close()<\exit>
thread_exit = False<\exit>
def sigint_hook(signal, frame):<\exit>
global thread_exit<\exit>
thread_exit = True<\exit>
return 0<\exit>
def read_waf_config():<\exit>
for line in open(".lock-wafbuild", "rt"):<\exit>
if line.startswith("out_dir ="):<\exit>
key, val = line.split('=')<\exit>
out_dir = eval(val.strip())<\exit>
global NS3_BUILDDIR<\exit>
NS3_BUILDDIR = out_dir<\exit>
for line in open("%s/c4che/_cache.py" % out_dir).readlines():<\exit>
for item in interesting_config_items:<\exit>
if line.startswith(item):<\exit>
exec(line, globals())<\exit>
if options.verbose:<\exit>
for item in interesting_config_items:<\exit>
print "%s ==" % item, eval(item)<\exit>
def make_paths():<\exit>
have_DYLD_LIBRARY_PATH = False<\exit>
have_LD_LIBRARY_PATH = False<\exit>
have_PATH = False<\exit>
have_PYTHONPATH = False<\exit>
keys = os.environ.keys()<\exit>
for key in keys:<\exit>
if key == "DYLD_LIBRARY_PATH":<\exit>
have_DYLD_LIBRARY_PATH = True<\exit>
if key == "LD_LIBRARY_PATH":<\exit>
have_LD_LIBRARY_PATH = True<\exit>
if key == "PATH":<\exit>
have_PATH = True<\exit>
if key == "PYTHONPATH":<\exit>
have_PYTHONPATH = True<\exit>
pypath = os.environ["PYTHONPATH"] = os.path.join (NS3_BUILDDIR, "bindings", "python")<\exit>
if not have_PYTHONPATH:<\exit>
os.environ["PYTHONPATH"] = pypath<\exit>
else:<\exit>
os.environ["PYTHONPATH"] += ":" + pypath<\exit>
if options.verbose:<\exit>
print "os.environ[\"PYTHONPATH\"] == %s" % os.environ["PYTHONPATH"]<\exit>
if sys.platform == "darwin":<\exit>
if not have_DYLD_LIBRARY_PATH:<\exit>
os.environ["DYLD_LIBRARY_PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["DYLD_LIBRARY_PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"DYLD_LIBRARY_PATH\"] == %s" % os.environ["DYLD_LIBRARY_PATH"]<\exit>
elif sys.platform == "win32":<\exit>
if not have_PATH:<\exit>
os.environ["PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["PATH"] += ';' + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"PATH\"] == %s" % os.environ["PATH"]<\exit>
elif sys.platform == "cygwin":<\exit>
if not have_PATH:<\exit>
os.environ["PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"PATH\"] == %s" % os.environ["PATH"]<\exit>
else:<\exit>
if not have_LD_LIBRARY_PATH:<\exit>
os.environ["LD_LIBRARY_PATH"] = ""<\exit>
for path in NS3_MODULE_PATH:<\exit>
os.environ["LD_LIBRARY_PATH"] += ":" + path<\exit>
if options.verbose:<\exit>
print "os.environ[\"LD_LIBRARY_PATH\"] == %s" % os.environ["LD_LIBRARY_PATH"]<\exit>
VALGRIND_SUPPRESSIONS_FILE = "testpy.supp"<\exit>
def run_job_synchronously(shell_command, directory, valgrind, is_python, build_path=""):<\exit>
(base, build) = os.path.split (NS3_BUILDDIR)<\exit>
suppressions_path = os.path.join (base, VALGRIND_SUPPRESSIONS_FILE)<\exit>
if is_python:<\exit>
path_cmd = "python " + os.path.join (base, shell_command)<\exit>
else:<\exit>
if len(build_path):<\exit>
path_cmd = os.path.join (build_path, shell_command)<\exit>
else:<\exit>
path_cmd = os.path.join (NS3_BUILDDIR, shell_command)<\exit>
if valgrind:<\exit>
cmd = "valgrind --suppressions=%s --leak-check=full --show-reachable=yes --error-exitcode=2 %s" % (suppressions_path,<\exit>
path_cmd)<\exit>
else:<\exit>
cmd = path_cmd<\exit>
if options.verbose:<\exit>
print "Synchronously execute %s" % cmd<\exit>
start_time = time.time()<\exit>
proc = subprocess.Popen(cmd, shell = True, cwd = directory, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<\exit>
stdout_results, stderr_results = proc.communicate()<\exit>
elapsed_time = time.time() - start_time<\exit>
retval = proc.returncode<\exit>
if valgrind and retval == 0 and "== LEAK SUMMARY:" in stderr_results:<\exit>
retval = 2<\exit>
if options.verbose:<\exit>
print "Return code = ", retval<\exit>
print "stderr = ", stderr_results<\exit>
return (retval, stdout_results, stderr_results, elapsed_time)<\exit>
class Job:<\exit>
def __init__(self):<\exit>
self.is_break = False<\exit>
self.is_skip = False<\exit>
self.is_example = False<\exit>
self.is_pyexample = False<\exit>
self.shell_command = ""<\exit>
self.display_name = ""<\exit>
self.basedir = ""<\exit>
self.tempdir = ""<\exit>
self.cwd = ""<\exit>
self.tmp_file_name = ""<\exit>
self.returncode = False<\exit>
self.elapsed_time = 0<\exit>
self.build_path = ""<\exit>
def set_is_break(self, is_break):<\exit>
self.is_break = is_break<\exit>
def set_is_skip(self, is_skip):<\exit>
self.is_skip = is_skip<\exit>
def set_is_example(self, is_example):<\exit>
self.is_example = is_example<\exit>
def set_is_pyexample(self, is_pyexample):<\exit>
self.is_pyexample = is_pyexample<\exit>
def set_shell_command(self, shell_command):<\exit>
self.shell_command = shell_command<\exit>
def set_build_path(self, build_path):<\exit>
self.build_path = build_path<\exit>
def set_display_name(self, display_name):<\exit>
self.display_name = display_name<\exit>
def set_basedir(self, basedir):<\exit>
self.basedir = basedir<\exit>
def set_tempdir(self, tempdir):<\exit>
self.tempdir = tempdir<\exit>
def set_cwd(self, cwd):<\exit>
self.cwd = cwd<\exit>
def set_tmp_file_name(self, tmp_file_name):<\exit>
self.tmp_file_name = tmp_file_name<\exit>
def set_returncode(self, returncode):<\exit>
self.returncode = returncode<\exit>
def set_elapsed_time(self, elapsed_time):<\exit>
self.elapsed_time = elapsed_time<\exit>
class worker_thread(threading.Thread):<\exit>
def __init__(self, input_queue, output_queue):<\exit>
threading.Thread.__init__(self)<\exit>
self.input_queue = input_queue<\exit>
self.output_queue = output_queue<\exit>
def run(self):<\exit>
while True:<\exit>
job = self.input_queue.get()<\exit>
if job.is_break:<\exit>
return<\exit>
if thread_exit == True:<\exit>
job.set_is_break(True)<\exit>
self.output_queue.put(job)<\exit>
continue<\exit>
if job.is_skip:<\exit>
if options.verbose:<\exit>
print "Skip %s" % job.shell_command<\exit>
self.output_queue.put(job)<\exit>
continue<\exit>
else:<\exit>
if options.verbose:<\exit>
print "Launch %s" % job.shell_command<\exit>
if job.is_example or job.is_pyexample:<\exit>
(job.returncode, standard_out, standard_err, et) = run_job_synchronously(job.shell_command,<\exit>
job.cwd, options.valgrind, job.is_pyexample, job.build_path)<\exit>
else:<\exit>
if options.update_data:<\exit>
update_data = '--update-data'<\exit>
else:<\exit>
update_data = ''<\exit>
(job.returncode, standard_out, standard_err, et) = run_job_synchronously(job.shell_command +<\exit>
" --xml --tempdir=%s --out=%s %s" % (job.tempdir, job.tmp_file_name, update_data),<\exit>
job.cwd, options.valgrind, False)<\exit>
job.set_elapsed_time(et)<\exit>
if options.verbose:<\exit>
print "returncode = %d" % job.returncode<\exit>
print "---------- begin standard out ----------"<\exit>
print standard_out<\exit>
print "---------- begin standard err ----------"<\exit>
print standard_err<\exit>
print "---------- end standard err ----------"<\exit>
self.output_queue.put(job)<\exit>
def run_tests():<\exit>
if not options.nowaf:<\exit>
if options.kinds or options.list or (len(options.constrain) and options.constrain in core_kinds):<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf --target=test-runner"<\exit>
else:<\exit>
waf_cmd = "./waf --target=test-runner"<\exit>
elif len(options.example):<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf --target=%s" % os.path.basename(options.example)<\exit>
else:<\exit>
waf_cmd = "./waf --target=%s" % os.path.basename(options.example)<\exit>
else:<\exit>
if sys.platform == "win32":<\exit>
waf_cmd = "waf"<\exit>
else:<\exit>
waf_cmd = "./waf"<\exit>
if options.verbose:<\exit>
print "Building: %s" % waf_cmd<\exit>
proc = subprocess.Popen(waf_cmd, shell = True)<\exit>
proc.communicate()<\exit>
if proc.returncode:<\exit>
print >> sys.stderr, "Waf died. Not running tests"<\exit>
return proc.returncode<\exit>
read_waf_config()<\exit>
make_paths()<\exit>
build_status_file = os.path.join (NS3_BUILDDIR, 'build-status.py')<\exit>
if os.path.exists(build_status_file):<\exit>
ns3_runnable_programs = get_list_from_file(build_status_file, "ns3_runnable_programs")<\exit>
ns3_runnable_scripts = get_list_from_file(build_status_file, "ns3_runnable_scripts")<\exit>
else:<\exit>
print >> sys.stderr, 'The build status file was not found.  You must do waf build before running test.py.'<\exit>
sys.exit(2)<\exit>
example_tests = []<\exit>
python_tests = []<\exit>
for directory in EXAMPLE_DIRECTORIES:<\exit>
example_directory   = os.path.join("examples", directory)<\exit>
examples_to_run_path = os.path.join(example_directory, "examples-to-run.py")<\exit>
cpp_executable_dir   = os.path.join(NS3_BUILDDIR, example_directory)<\exit>
python_script_dir    = os.path.join(example_directory)<\exit>
parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests)<\exit>
for module in NS3_ENABLED_MODULES:<\exit>
module = module[len("ns3-"):]<\exit>
module_directory     = os.path.join("src", module)<\exit>
example_directory    = os.path.join(module_directory, "examples")<\exit>
examples_to_run_path = os.path.join(module_directory, "test", "examples-to-run.py")<\exit>
cpp_executable_dir   = os.path.join(NS3_BUILDDIR, example_directory)<\exit>
python_script_dir    = os.path.join(example_directory)<\exit>
parse_examples_to_run_file(<\exit>
examples_to_run_path,<\exit>
cpp_executable_dir,<\exit>
python_script_dir,<\exit>
example_tests,<\exit>
python_tests)<\exit>
os.environ["NS_LOG"] = ""<\exit>
if options.kinds:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-type-list")<\exit>
(rc, standard_out, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
print standard_out<\exit>
if options.list:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, standard_out, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
print standard_out<\exit>
if options.kinds or options.list:<\exit>
return<\exit>
date_and_time = time.strftime("%Y-%m-%d-%H-%M-%S-CUT", time.gmtime())<\exit>
if not os.path.exists(TMP_OUTPUT_DIR):<\exit>
os.makedirs(TMP_OUTPUT_DIR)<\exit>
testpy_output_dir = os.path.join(TMP_OUTPUT_DIR, date_and_time);<\exit>
if not os.path.exists(testpy_output_dir):<\exit>
os.makedirs(testpy_output_dir)<\exit>
xml_results_file = os.path.join(testpy_output_dir, "results.xml")<\exit>
f = open(xml_results_file, 'w')<\exit>
f.write('<?xml version="1.0"?>\n')<\exit>
f.write('<Results>\n')<\exit>
f.close()<\exit>
if len(options.suite):<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
if options.suite in suites:<\exit>
suites = options.suite + "\n"<\exit>
else:<\exit>
print >> sys.stderr, 'The test suite was not run because an unknown test suite name was requested.'<\exit>
sys.exit(2)<\exit>
elif len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain):<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list --test-type=%s" % options.constrain)<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
else:<\exit>
path_cmd = os.path.join("utils", "test-runner --print-test-name-list")<\exit>
(rc, suites, standard_err, et) = run_job_synchronously(path_cmd, os.getcwd(), False, False)<\exit>
else:<\exit>
suites = ""<\exit>
suite_list = suites.split('\n')<\exit>
input_queue = Queue.Queue(0)<\exit>
output_queue = Queue.Queue(0)<\exit>
jobs = 0<\exit>
threads=[]<\exit>
processors = 1<\exit>
if sys.platform != "win32":<\exit>
if 'SC_NPROCESSORS_ONLN'in os.sysconf_names:<\exit>
processors = os.sysconf('SC_NPROCESSORS_ONLN')<\exit>
else:<\exit>
proc = subprocess.Popen("sysctl -n hw.ncpu", shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<\exit>
stdout_results, stderr_results = proc.communicate()<\exit>
if len(stderr_results) == 0:<\exit>
processors = int(stdout_results)<\exit>
for i in range(processors):<\exit>
thread = worker_thread(input_queue, output_queue)<\exit>
threads.append(thread)<\exit>
thread.start()<\exit>
total_tests = 0<\exit>
skipped_tests = 0<\exit>
for test in suite_list:<\exit>
test = test.strip()<\exit>
if len(test):<\exit>
job = Job()<\exit>
job.set_is_example(False)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name(os.path.join(testpy_output_dir, "%s.xml" % test))<\exit>
job.set_cwd(os.getcwd())<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
if (options.multiple):<\exit>
multiple = ""<\exit>
else:<\exit>
multiple = " --stop-on-failure"<\exit>
path_cmd = os.path.join("utils", "test-runner --test-name=%s%s" % (test, multiple))<\exit>
job.set_shell_command(path_cmd)<\exit>
if options.valgrind and test in core_valgrind_skip_tests:<\exit>
job.set_is_skip(True)<\exit>
if not NSC_ENABLED and test in core_nsc_missing_skip_tests:<\exit>
job.set_is_skip(True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
if len(options.suite) == 0 and len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain) == 0 or options.constrain == "example":<\exit>
if ENABLE_EXAMPLES:<\exit>
for test, do_run, do_valgrind_run in example_tests:<\exit>
if os.path.basename(test) in ns3_runnable_programs:<\exit>
if eval(do_run):<\exit>
job = Job()<\exit>
job.set_is_example(True)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(test)<\exit>
job.set_build_path("")<\exit>
if options.valgrind and not eval(do_valgrind_run):<\exit>
job.set_is_skip (True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
elif len(options.example):<\exit>
example_name = os.path.basename(options.example)<\exit>
if example_name not in ns3_runnable_programs:<\exit>
print "Example %s is not runnable." % example_name<\exit>
else:<\exit>
job = Job()<\exit>
job.set_is_example(True)<\exit>
job.set_is_pyexample(False)<\exit>
job.set_display_name(options.example)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(options.example)<\exit>
job.set_build_path(options.buildpath)<\exit>
if options.verbose:<\exit>
print "Queue %s" % options.example<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
if len(options.suite) == 0 and len(options.example) == 0 and len(options.pyexample) == 0:<\exit>
if len(options.constrain) == 0 or options.constrain == "pyexample":<\exit>
if ENABLE_EXAMPLES:<\exit>
for test, do_run in python_tests:<\exit>
if os.path.basename(test) in ns3_runnable_scripts:<\exit>
if eval(do_run):<\exit>
job = Job()<\exit>
job.set_is_example(False)<\exit>
job.set_is_pyexample(True)<\exit>
job.set_display_name(test)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(test)<\exit>
job.set_build_path("")<\exit>
if options.valgrind:<\exit>
job.set_is_skip (True)<\exit>
if not ENABLE_PYTHON_BINDINGS:<\exit>
job.set_is_skip (True)<\exit>
if options.verbose:<\exit>
print "Queue %s" % test<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
elif len(options.pyexample):<\exit>
example_name = os.path.basename(options.pyexample)<\exit>
if example_name not in ns3_runnable_scripts:<\exit>
print "Example %s is not runnable." % example_name<\exit>
else:<\exit>
job = Job()<\exit>
job.set_is_pyexample(True)<\exit>
job.set_display_name(options.pyexample)<\exit>
job.set_tmp_file_name("")<\exit>
job.set_cwd(testpy_output_dir)<\exit>
job.set_basedir(os.getcwd())<\exit>
job.set_tempdir(testpy_output_dir)<\exit>
job.set_shell_command(options.pyexample)<\exit>
job.set_build_path("")<\exit>
if options.verbose:<\exit>
print "Queue %s" % options.pyexample<\exit>
input_queue.put(job)<\exit>
jobs = jobs + 1<\exit>
total_tests = total_tests + 1<\exit>
for i in range(processors):<\exit>
job = Job()<\exit>
job.set_is_break(True)<\exit>
input_queue.put(job)<\exit>
passed_tests = 0<\exit>
failed_tests = 0<\exit>
crashed_tests = 0<\exit>
valgrind_errors = 0<\exit>
for i in range(jobs):<\exit>
job = output_queue.get()<\exit>
if job.is_break:<\exit>
continue<\exit>
if job.is_example or job.is_pyexample:<\exit>
kind = "Example"<\exit>
else:<\exit>
kind = "TestSuite"<\exit>
if job.is_skip:<\exit>
status = "SKIP"<\exit>
skipped_tests = skipped_tests + 1<\exit>
else:<\exit>
if job.returncode == 0:<\exit>
status = "PASS"<\exit>
passed_tests = passed_tests + 1<\exit>
elif job.returncode == 1:<\exit>
failed_tests = failed_tests + 1<\exit>
status = "FAIL"<\exit>
elif job.returncode == 2:<\exit>
valgrind_errors = valgrind_errors + 1<\exit>
status = "VALGR"<\exit>
else:<\exit>
crashed_tests = crashed_tests + 1<\exit>
status = "CRASH"<\exit>
print "%s: %s %s" % (status, kind, job.display_name)<\exit>
if job.is_example or job.is_pyexample:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write('<Example>\n')<\exit>
example_name = "  <Name>%s</Name>\n" % job.display_name<\exit>
f.write(example_name)<\exit>
if status == "PASS":<\exit>
f.write('  <Result>PASS</Result>\n')<\exit>
elif status == "FAIL":<\exit>
f.write('  <Result>FAIL</Result>\n')<\exit>
elif status == "VALGR":<\exit>
f.write('  <Result>VALGR</Result>\n')<\exit>
elif status == "SKIP":<\exit>
f.write('  <Result>SKIP</Result>\n')<\exit>
else:<\exit>
f.write('  <Result>CRASH</Result>\n')<\exit>
f.write('  <Time real="%.3f"/>\n' % job.elapsed_time)<\exit>
f.write('</Example>\n')<\exit>
f.close()<\exit>
else:<\exit>
if job.is_skip:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>SKIP</Result>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
else:<\exit>
if job.returncode == 0 or job.returncode == 1 or job.returncode == 2:<\exit>
f_to = open(xml_results_file, 'a')<\exit>
f_from = open(job.tmp_file_name)<\exit>
f_to.write(f_from.read())<\exit>
f_to.close()<\exit>
f_from.close()<\exit>
else:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>CRASH</Suite>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
if job.returncode == 2:<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write("<Test>\n")<\exit>
f.write("  <Name>%s</Name>\n" % job.display_name)<\exit>
f.write('  <Result>VALGR</Result>\n')<\exit>
f.write("</Test>\n")<\exit>
f.close()<\exit>
for thread in threads:<\exit>
thread.join()<\exit>
f = open(xml_results_file, 'a')<\exit>
f.write('</Results>\n')<\exit>
f.close()<\exit>
print "%d of %d tests passed (%d passed, %d skipped, %d failed, %d crashed, %d valgrind errors)" % (passed_tests,<\exit>
total_tests, passed_tests, skipped_tests, failed_tests, crashed_tests, valgrind_errors)<\exit>
if len(options.html):<\exit>
translate_to_html(xml_results_file, options.html)<\exit>
if len(options.text):<\exit>
translate_to_text(xml_results_file, options.text)<\exit>
if len(options.xml):<\exit>
shutil.copyfile(xml_results_file, options.xml)<\exit>
if not ENABLE_TESTS or not ENABLE_EXAMPLES:<\exit>
print<\exit>
if not ENABLE_TESTS:<\exit>
print '***  Note: ns-3 tests are currently disabled. Enable them by adding'<\exit>
print '***  "--enable-tests" to ./waf configure or modifying your .ns3rc file.'<\exit>
print<\exit>
if not ENABLE_EXAMPLES:<\exit>
print '***  Note: ns-3 examples are currently disabled. Enable them by adding'<\exit>
print '***  "--enable-examples" to ./waf configure or modifying your .ns3rc file.'<\exit>
print<\exit>
if not options.retain:<\exit>
shutil.rmtree(testpy_output_dir)<\exit>
if passed_tests + skipped_tests == total_tests:<\exit>
return 0<\exit>
else:<\exit>
return 1<\exit>
def main(argv):<\exit>
parser = optparse.OptionParser()<\exit>
parser.add_option("-b", "--buildpath", action="store", type="string", dest="buildpath", default="",<\exit>
metavar="BUILDPATH",<\exit>
help="specify the path where ns-3 was built (defaults to the build directory for the current variant)")<\exit>
parser.add_option("-c", "--constrain", action="store", type="string", dest="constrain", default="",<\exit>
metavar="KIND",<\exit>
help="constrain the test-runner by kind of test")<\exit>
parser.add_option("-e", "--example", action="store", type="string", dest="example", default="",<\exit>
metavar="EXAMPLE",<\exit>
help="specify a single example to run (with relative path)")<\exit>
parser.add_option("-u", "--update-data", action="store_true", dest="update_data", default=False,<\exit>
help="If examples use reference data files, get them to re-generate them")<\exit>
parser.add_option("-g", "--grind", action="store_true", dest="valgrind", default=False,<\exit>
help="run the test suites and examples using valgrind")<\exit>
parser.add_option("-k", "--kinds", action="store_true", dest="kinds", default=False,<\exit>
help="print the kinds of tests available")<\exit>
parser.add_option("-l", "--list", action="store_true", dest="list", default=False,<\exit>
help="print the list of known tests")<\exit>
parser.add_option("-m", "--multiple", action="store_true", dest="multiple", default=False,<\exit>
help="report multiple failures from test suites and test cases")<\exit>
parser.add_option("-n", "--nowaf", action="store_true", dest="nowaf", default=False,<\exit>
help="do not run waf before starting testing")<\exit>
parser.add_option("-p", "--pyexample", action="store", type="string", dest="pyexample", default="",<\exit>
metavar="PYEXAMPLE",<\exit>
help="specify a single python example to run (with relative path)")<\exit>
parser.add_option("-r", "--retain", action="store_true", dest="retain", default=False,<\exit>
help="retain all temporary files (which are normally deleted)")<\exit>
parser.add_option("-s", "--suite", action="store", type="string", dest="suite", default="",<\exit>
metavar="TEST-SUITE",<\exit>
help="specify a single test suite to run")<\exit>
parser.add_option("-t", "--text", action="store", type="string", dest="text", default="",<\exit>
metavar="TEXT-FILE",<\exit>
help="write detailed test results into TEXT-FILE.txt")<\exit>
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,<\exit>
help="print progress and informational messages")<\exit>
parser.add_option("-w", "--web", "--html", action="store", type="string", dest="html", default="",<\exit>
metavar="HTML-FILE",<\exit>
help="write detailed test results into HTML-FILE.html")<\exit>
parser.add_option("-x", "--xml", action="store", type="string", dest="xml", default="",<\exit>
metavar="XML-FILE",<\exit>
help="write detailed test results into XML-FILE.xml")<\exit>
global options<\exit>
options = parser.parse_args()[0]<\exit>
signal.signal(signal.SIGINT, sigint_hook)<\exit>
return run_tests()<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
def _add_tests(generator):<\exit>
def class_decorator(cls):<\exit>
for f, args in generator():<\exit>
test = lambda self, args=args, f=f: f(self, *args)<\exit>
test.__name__ = "test_%s_%s" % (f.__name__, args[0])<\exit>
setattr(cls, test.__name__, test)<\exit>
return cls<\exit>
return class_decorator<\exit>
import copy<\exit>
import functools<\exit>
import unittest<\exit>
from unittest import TestCase<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.element import (<\exit>
CharsetMetaAttributeValue,<\exit>
Comment,<\exit>
ContentMetaAttributeValue,<\exit>
Doctype,<\exit>
SoupStrainer,<\exit>
)<\exit>
from bs4.builder import HTMLParserTreeBuilder<\exit>
default_builder = HTMLParserTreeBuilder<\exit>
class SoupTest(unittest.TestCase):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return default_builder()<\exit>
def soup(self, markup, **kwargs):<\exit>
builder = kwargs.pop('builder', self.default_builder)<\exit>
return BeautifulSoup(markup, builder=builder, **kwargs)<\exit>
def document_for(self, markup):<\exit>
return self.default_builder.test_fragment_to_document(markup)<\exit>
def assertSoupEquals(self, to_parse, compare_parsed_to=None):<\exit>
builder = self.default_builder<\exit>
obj = BeautifulSoup(to_parse, builder=builder)<\exit>
if compare_parsed_to is None:<\exit>
compare_parsed_to = to_parse<\exit>
self.assertEqual(obj.decode(), self.document_for(compare_parsed_to))<\exit>
class HTMLTreeBuilderSmokeTest(object):<\exit>
def assertDoctypeHandled(self, doctype_fragment):<\exit>
doctype_str, soup = self._document_with_doctype(doctype_fragment)<\exit>
doctype = soup.contents[0]<\exit>
self.assertEqual(doctype.__class__, Doctype)<\exit>
self.assertEqual(doctype, doctype_fragment)<\exit>
self.assertEqual(str(soup)[:len(doctype_str)], doctype_str)<\exit>
self.assertEqual(soup.p.contents[0], 'foo')<\exit>
def _document_with_doctype(self, doctype_fragment):<\exit>
doctype = '<!DOCTYPE %s>' % doctype_fragment<\exit>
markup = doctype + '\n<p>foo</p>'<\exit>
soup = self.soup(markup)<\exit>
return doctype, soup<\exit>
def test_normal_doctypes(self):<\exit>
self.assertDoctypeHandled("html")<\exit>
self.assertDoctypeHandled(<\exit>
'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"')<\exit>
def test_public_doctype_with_url(self):<\exit>
doctype = 'html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"'<\exit>
self.assertDoctypeHandled(doctype)<\exit>
def test_system_doctype(self):<\exit>
self.assertDoctypeHandled('foo SYSTEM "http://www.example.com/"')<\exit>
def test_namespaced_system_doctype(self):<\exit>
self.assertDoctypeHandled('xsl:stylesheet SYSTEM "htmlent.dtd"')<\exit>
def test_namespaced_public_doctype(self):<\exit>
self.assertDoctypeHandled('xsl:stylesheet PUBLIC "htmlent.dtd"')<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8").replace(b"\n", b""),<\exit>
markup.replace(b"\n", b""))<\exit>
def test_deepcopy(self):<\exit>
copy.deepcopy(self.default_builder)<\exit>
def test_p_tag_is_never_empty_element(self):<\exit>
soup = self.soup("<p/>")<\exit>
self.assertFalse(soup.p.is_empty_element)<\exit>
self.assertEqual(str(soup.p), "<p></p>")<\exit>
def test_unclosed_tags_get_closed(self):<\exit>
self.assertSoupEquals("<p>", "<p></p>")<\exit>
self.assertSoupEquals("<b>", "<b></b>")<\exit>
self.assertSoupEquals("<br>", "<br/>")<\exit>
def test_br_is_always_empty_element_tag(self):<\exit>
soup = self.soup("<br></br>")<\exit>
self.assertTrue(soup.br.is_empty_element)<\exit>
self.assertEqual(str(soup.br), "<br/>")<\exit>
def test_nested_formatting_elements(self):<\exit>
self.assertSoupEquals("<em><em></em></em>")<\exit>
def test_comment(self):<\exit>
markup = "<p>foo<!--foobar-->baz</p>"<\exit>
self.assertSoupEquals(markup)<\exit>
soup = self.soup(markup)<\exit>
comment = soup.find(text="foobar")<\exit>
self.assertEqual(comment.__class__, Comment)<\exit>
def test_preserved_whitespace_in_pre_and_textarea(self):<\exit>
self.assertSoupEquals("<pre>   </pre>")<\exit>
self.assertSoupEquals("<textarea> woo  </textarea>")<\exit>
def test_nested_inline_elements(self):<\exit>
b_tag = "<b>Inside a B tag</b>"<\exit>
self.assertSoupEquals(b_tag)<\exit>
nested_b_tag = "<p>A <i>nested <b>tag</b></i></p>"<\exit>
self.assertSoupEquals(nested_b_tag)<\exit>
double_nested_b_tag = "<p>A <a>doubly <i>nested <b>tag</b></i></a></p>"<\exit>
self.assertSoupEquals(nested_b_tag)<\exit>
def test_nested_block_level_elements(self):<\exit>
soup = self.soup('<blockquote><p><b>Foo</b></p></blockquote>')<\exit>
blockquote = soup.blockquote<\exit>
self.assertEqual(blockquote.p.b.string, 'Foo')<\exit>
self.assertEqual(blockquote.b.string, 'Foo')<\exit>
def test_correctly_nested_tables(self):<\exit>
markup = ('<table id="1">'<\exit>
'<tr>'<\exit>
"<td>Here's another table:"<\exit>
'<table id="2">'<\exit>
'<tr><td>foo</td></tr>'<\exit>
'</table></td>')<\exit>
self.assertSoupEquals(<\exit>
markup,<\exit>
'<table id="1"><tr><td>Here\'s another table:'<\exit>
'<table id="2"><tr><td>foo</td></tr></table>'<\exit>
'</td></tr></table>')<\exit>
self.assertSoupEquals(<\exit>
"<table><thead><tr><td>Foo</td></tr></thead>"<\exit>
"<tbody><tr><td>Bar</td></tr></tbody>"<\exit>
"<tfoot><tr><td>Baz</td></tr></tfoot></table>")<\exit>
def test_deeply_nested_multivalued_attribute(self):<\exit>
markup = '<table><div><div class="css"></div></div></table>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(["css"], soup.div.div['class'])<\exit>
def test_angle_brackets_in_attribute_values_are_escaped(self):<\exit>
self.assertSoupEquals('<a b="<a>"></a>', '<a b="&lt;a&gt;"></a>')<\exit>
def test_entities_in_attributes_converted_to_unicode(self):<\exit>
expect = u'<p id="pi\N{LATIN SMALL LETTER N WITH TILDE}ata"></p>'<\exit>
self.assertSoupEquals('<p id="pi&<\exit>
self.assertSoupEquals('<p id="pi&<\exit>
self.assertSoupEquals('<p id="pi&ntilde;ata"></p>', expect)<\exit>
def test_entities_in_text_converted_to_unicode(self):<\exit>
expect = u'<p>pi\N{LATIN SMALL LETTER N WITH TILDE}ata</p>'<\exit>
self.assertSoupEquals("<p>pi&<\exit>
self.assertSoupEquals("<p>pi&<\exit>
self.assertSoupEquals("<p>pi&ntilde;ata</p>", expect)<\exit>
def test_quot_entity_converted_to_quotation_mark(self):<\exit>
self.assertSoupEquals("<p>I said &quot;good day!&quot;</p>",<\exit>
'<p>I said "good day!"</p>')<\exit>
def test_out_of_range_entity(self):<\exit>
expect = u"\N{REPLACEMENT CHARACTER}"<\exit>
self.assertSoupEquals("&<\exit>
self.assertSoupEquals("&<\exit>
self.assertSoupEquals("&<\exit>
def test_basic_namespaces(self):<\exit>
markup = b'<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mathml="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg"><head></head><body><mathml:msqrt>4</mathml:msqrt><b svg:fill="red"></b></body></html>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(markup, soup.encode())<\exit>
html = soup.html<\exit>
self.assertEqual('http://www.w3.org/1999/xhtml', soup.html['xmlns'])<\exit>
self.assertEqual(<\exit>
'http://www.w3.org/1998/Math/MathML', soup.html['xmlns:mathml'])<\exit>
self.assertEqual(<\exit>
'http://www.w3.org/2000/svg', soup.html['xmlns:svg'])<\exit>
def test_multivalued_attribute_value_becomes_list(self):<\exit>
markup = b'<a class="foo bar">'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(['foo', 'bar'], soup.a['class'])<\exit>
def test_soupstrainer(self):<\exit>
strainer = SoupStrainer("b")<\exit>
soup = self.soup("A <b>bold</b> <meta/> <i>statement</i>",<\exit>
parse_only=strainer)<\exit>
self.assertEqual(soup.decode(), "<b>bold</b>")<\exit>
def test_single_quote_attribute_values_become_double_quotes(self):<\exit>
self.assertSoupEquals("<foo attr='bar'></foo>",<\exit>
'<foo attr="bar"></foo>')<\exit>
def test_attribute_values_with_nested_quotes_are_left_alone(self):<\exit>
text =<\exit>
self.assertSoupEquals(text)<\exit>
def test_attribute_values_with_double_nested_quotes_get_quoted(self):<\exit>
text =<\exit>
soup = self.soup(text)<\exit>
soup.foo['attr'] = 'Brawls happen at "Bob\'s Bar"'<\exit>
self.assertSoupEquals(<\exit>
soup.foo.decode(),<\exit>
)<\exit>
def test_ampersand_in_attribute_value_gets_escaped(self):<\exit>
self.assertSoupEquals('<this is="really messed up & stuff"></this>',<\exit>
'<this is="really messed up &amp; stuff"></this>')<\exit>
self.assertSoupEquals(<\exit>
'<a href="http://example.org?a=1&b=2;3">foo</a>',<\exit>
'<a href="http://example.org?a=1&amp;b=2;3">foo</a>')<\exit>
def test_escaped_ampersand_in_attribute_value_is_left_alone(self):<\exit>
self.assertSoupEquals('<a href="http://example.org?a=1&amp;b=2;3"></a>')<\exit>
def test_entities_in_strings_converted_during_parsing(self):<\exit>
text = "<p>&lt;&lt;sacr&eacute;&<\exit>
expected = u"<p>&lt;&lt;sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</p>"<\exit>
self.assertSoupEquals(text, expected)<\exit>
def test_smart_quotes_converted_on_the_way_in(self):<\exit>
quote = b"<p>\x91Foo\x92</p>"<\exit>
soup = self.soup(quote)<\exit>
self.assertEqual(<\exit>
soup.p.string,<\exit>
u"\N{LEFT SINGLE QUOTATION MARK}Foo\N{RIGHT SINGLE QUOTATION MARK}")<\exit>
def test_non_breaking_spaces_converted_on_the_way_in(self):<\exit>
soup = self.soup("<a>&nbsp;&nbsp;</a>")<\exit>
self.assertEqual(soup.a.string, u"\N{NO-BREAK SPACE}" * 2)<\exit>
def test_entities_converted_on_the_way_out(self):<\exit>
text = "<p>&lt;&lt;sacr&eacute;&<\exit>
expected = u"<p>&lt;&lt;sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</p>".encode("utf-8")<\exit>
soup = self.soup(text)<\exit>
self.assertEqual(soup.p.encode("utf-8"), expected)<\exit>
def test_real_iso_latin_document(self):<\exit>
unicode_html = u'<html><head><meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type"/></head><body><p>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</p></body></html>'<\exit>
iso_latin_html = unicode_html.encode("iso-8859-1")<\exit>
soup = self.soup(iso_latin_html)<\exit>
result = soup.encode("utf-8")<\exit>
expected = unicode_html.replace("ISO-Latin-1", "utf-8")<\exit>
expected = expected.encode("utf-8")<\exit>
self.assertEqual(result, expected)<\exit>
def test_real_shift_jis_document(self):<\exit>
shift_jis_html = (<\exit>
b'<html><head></head><body><pre>'<\exit>
b'\x82\xb1\x82\xea\x82\xcdShift-JIS\x82\xc5\x83R\x81[\x83f'<\exit>
b'\x83B\x83\x93\x83O\x82\xb3\x82\xea\x82\xbd\x93\xfa\x96{\x8c'<\exit>
b'\xea\x82\xcc\x83t\x83@\x83C\x83\x8b\x82\xc5\x82\xb7\x81B'<\exit>
b'</pre></body></html>')<\exit>
unicode_html = shift_jis_html.decode("shift-jis")<\exit>
soup = self.soup(unicode_html)<\exit>
self.assertEqual(soup.encode("utf-8"), unicode_html.encode("utf-8"))<\exit>
self.assertEqual(soup.encode("euc_jp"), unicode_html.encode("euc_jp"))<\exit>
def test_real_hebrew_document(self):<\exit>
hebrew_document = b'<html><head><title>Hebrew (ISO 8859-8) in Visual Directionality</title></head><body><h1>Hebrew (ISO 8859-8) in Visual Directionality</h1>\xed\xe5\xec\xf9</body></html>'<\exit>
soup = self.soup(<\exit>
hebrew_document, from_encoding="iso8859-8")<\exit>
self.assertEqual(soup.original_encoding, 'iso8859-8')<\exit>
self.assertEqual(<\exit>
soup.encode('utf-8'),<\exit>
hebrew_document.decode("iso8859-8").encode("utf-8"))<\exit>
def test_meta_tag_reflects_current_encoding(self):<\exit>
meta_tag = ('<meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/>')<\exit>
shift_jis_html = (<\exit>
'<html><head>\n%s\n'<\exit>
'<meta http-equiv="Content-language" content="ja"/>'<\exit>
'</head><body>Shift-JIS markup goes here.') % meta_tag<\exit>
soup = self.soup(shift_jis_html)<\exit>
parsed_meta = soup.find('meta', {'http-equiv': 'Content-type'})<\exit>
content = parsed_meta['content']<\exit>
self.assertEqual('text/html; charset=x-sjis', content)<\exit>
self.assertTrue(isinstance(content, ContentMetaAttributeValue))<\exit>
self.assertEqual('text/html; charset=utf8', content.encode("utf8"))<\exit>
def test_html5_style_meta_tag_reflects_current_encoding(self):<\exit>
meta_tag = ('<meta id="encoding" charset="x-sjis" />')<\exit>
shift_jis_html = (<\exit>
'<html><head>\n%s\n'<\exit>
'<meta http-equiv="Content-language" content="ja"/>'<\exit>
'</head><body>Shift-JIS markup goes here.') % meta_tag<\exit>
soup = self.soup(shift_jis_html)<\exit>
parsed_meta = soup.find('meta', id="encoding")<\exit>
charset = parsed_meta['charset']<\exit>
self.assertEqual('x-sjis', charset)<\exit>
self.assertTrue(isinstance(charset, CharsetMetaAttributeValue))<\exit>
self.assertEqual('utf8', charset.encode("utf8"))<\exit>
def test_tag_with_no_attributes_can_have_attributes_added(self):<\exit>
data = self.soup("<a>text</a>")<\exit>
data.a['foo'] = 'bar'<\exit>
self.assertEqual('<a foo="bar">text</a>', data.a.decode())<\exit>
class XMLTreeBuilderSmokeTest(object):<\exit>
def test_docstring_generated(self):<\exit>
soup = self.soup("<root/>")<\exit>
self.assertEqual(<\exit>
soup.encode(), b'<?xml version="1.0" encoding="utf-8"?>\n<root/>')<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8"), markup)<\exit>
def test_popping_namespaced_tag(self):<\exit>
markup = '<rss xmlns:dc="foo"><dc:creator>b</dc:creator><dc:date>2012-07-02T20:33:42Z</dc:date><dc:rights>c</dc:rights><image>d</image></rss>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
unicode(soup.rss), markup)<\exit>
def test_docstring_includes_correct_encoding(self):<\exit>
soup = self.soup("<root/>")<\exit>
self.assertEqual(<\exit>
soup.encode("latin1"),<\exit>
b'<?xml version="1.0" encoding="latin1"?>\n<root/>')<\exit>
def test_large_xml_document(self):<\exit>
markup = (b'<?xml version="1.0" encoding="utf-8"?>\n<root>'<\exit>
+ b'0' * (2**12)<\exit>
+ b'</root>')<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(soup.encode("utf-8"), markup)<\exit>
def test_tags_are_empty_element_if_and_only_if_they_are_empty(self):<\exit>
self.assertSoupEquals("<p>", "<p/>")<\exit>
self.assertSoupEquals("<p>foo</p>")<\exit>
def test_namespaces_are_preserved(self):<\exit>
markup = '<root xmlns:a="http://example.com/" xmlns:b="http://example.net/"><a:foo>This tag is in the a namespace</a:foo><b:foo>This tag is in the b namespace</b:foo></root>'<\exit>
soup = self.soup(markup)<\exit>
root = soup.root<\exit>
self.assertEqual("http://example.com/", root['xmlns:a'])<\exit>
self.assertEqual("http://example.net/", root['xmlns:b'])<\exit>
def test_closing_namespaced_tag(self):<\exit>
markup = '<p xmlns:dc="http://purl.org/dc/elements/1.1/"><dc:date>20010504</dc:date></p>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(unicode(soup.p), markup)<\exit>
def test_namespaced_attributes(self):<\exit>
markup = '<foo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><bar xsi:schemaLocation="http://www.example.com"/></foo>'<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(unicode(soup.foo), markup)<\exit>
class HTML5TreeBuilderSmokeTest(HTMLTreeBuilderSmokeTest):<\exit>
def test_real_xhtml_document(self):<\exit>
pass<\exit>
def test_html_tags_have_namespace(self):<\exit>
markup = "<a>"<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual("http://www.w3.org/1999/xhtml", soup.a.namespace)<\exit>
def test_svg_tags_have_namespace(self):<\exit>
markup = '<svg><circle/></svg>'<\exit>
soup = self.soup(markup)<\exit>
namespace = "http://www.w3.org/2000/svg"<\exit>
self.assertEqual(namespace, soup.svg.namespace)<\exit>
self.assertEqual(namespace, soup.circle.namespace)<\exit>
def test_mathml_tags_have_namespace(self):<\exit>
markup = '<math><msqrt>5</msqrt></math>'<\exit>
soup = self.soup(markup)<\exit>
namespace = 'http://www.w3.org/1998/Math/MathML'<\exit>
self.assertEqual(namespace, soup.math.namespace)<\exit>
self.assertEqual(namespace, soup.msqrt.namespace)<\exit>
def skipIf(condition, reason):<\exit>
def nothing(test, *args, **kwargs):<\exit>
return None<\exit>
def decorator(test_item):<\exit>
if condition:<\exit>
return nothing<\exit>
else:<\exit>
return test_item<\exit>
return decorator<\exit>
from django.test import TestCase<\exit>
from BaseHTTPServer import HTTPServer, test as simple_http_server_test<\exit>
from CGIHTTPServer import CGIHTTPRequestHandler<\exit>
from CGIHTTPServer import _url_collapse_path_split<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
class BRATCGIHTTPRequestHandler(CGIHTTPRequestHandler):<\exit>
def is_cgi(self):<\exit>
if urlparse(self.path).path.endswith('.cgi'):<\exit>
self.cgi_info = _url_collapse_path_split(self.path)<\exit>
return True<\exit>
else:<\exit>
return CGIHTTPRequestHandler.is_cgi(self)<\exit>
def main(args):<\exit>
try:<\exit>
try:<\exit>
port = int(args[1])<\exit>
except ValueError:<\exit>
raise TypeError<\exit>
except TypeError:<\exit>
print >> stderr, '%s is not a valid port number' % args[1]<\exit>
return -1<\exit>
except IndexError:<\exit>
port = 8000<\exit>
print >> stderr, 'WARNING: This server is for testing purposes only!'<\exit>
print >> stderr, ('    You can also use it for trying out brat before '<\exit>
'deploying on a "real" web server such as Apache.')<\exit>
print >> stderr, ('    Using this web server to run brat on an open '<\exit>
'network is a security risk!')<\exit>
print >> stderr<\exit>
print >> stderr, 'You can access the test server on:'<\exit>
print >> stderr<\exit>
print >> stderr, '    http://localhost:%s/' % port<\exit>
print >> stderr<\exit>
simple_http_server_test(BRATCGIHTTPRequestHandler, HTTPServer)<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
import unittest<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.builder import (<\exit>
builder_registry as registry,<\exit>
HTMLParserTreeBuilder,<\exit>
TreeBuilderRegistry,<\exit>
)<\exit>
try:<\exit>
from bs4.builder import HTML5TreeBuilder<\exit>
HTML5LIB_PRESENT = True<\exit>
except ImportError:<\exit>
HTML5LIB_PRESENT = False<\exit>
try:<\exit>
from bs4.builder import (<\exit>
LXMLTreeBuilderForXML,<\exit>
LXMLTreeBuilder,<\exit>
)<\exit>
LXML_PRESENT = True<\exit>
except ImportError:<\exit>
LXML_PRESENT = False<\exit>
class BuiltInRegistryTest(unittest.TestCase):<\exit>
def test_combination(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('fast', 'html'),<\exit>
LXMLTreeBuilder)<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('permissive', 'xml'),<\exit>
LXMLTreeBuilderForXML)<\exit>
self.assertEqual(registry.lookup('strict', 'html'),<\exit>
HTMLParserTreeBuilder)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html5lib', 'html'),<\exit>
HTML5TreeBuilder)<\exit>
def test_lookup_by_markup_type(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('html'), LXMLTreeBuilder)<\exit>
self.assertEqual(registry.lookup('xml'), LXMLTreeBuilderForXML)<\exit>
else:<\exit>
self.assertEqual(registry.lookup('xml'), None)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html'), HTML5TreeBuilder)<\exit>
else:<\exit>
self.assertEqual(registry.lookup('html'), HTMLParserTreeBuilder)<\exit>
def test_named_library(self):<\exit>
if LXML_PRESENT:<\exit>
self.assertEqual(registry.lookup('lxml', 'xml'),<\exit>
LXMLTreeBuilderForXML)<\exit>
self.assertEqual(registry.lookup('lxml', 'html'),<\exit>
LXMLTreeBuilder)<\exit>
if HTML5LIB_PRESENT:<\exit>
self.assertEqual(registry.lookup('html5lib'),<\exit>
HTML5TreeBuilder)<\exit>
self.assertEqual(registry.lookup('html.parser'),<\exit>
HTMLParserTreeBuilder)<\exit>
def test_beautifulsoup_constructor_does_lookup(self):<\exit>
BeautifulSoup("", features="html")<\exit>
BeautifulSoup("", features=["html", "fast"])<\exit>
self.assertRaises(ValueError, BeautifulSoup,<\exit>
"", features="no-such-feature")<\exit>
class RegistryTest(unittest.TestCase):<\exit>
def setUp(self):<\exit>
self.registry = TreeBuilderRegistry()<\exit>
def builder_for_features(self, *feature_list):<\exit>
cls = type('Builder_' + '_'.join(feature_list),<\exit>
(object,), {'features' : feature_list})<\exit>
self.registry.register(cls)<\exit>
return cls<\exit>
def test_register_with_no_features(self):<\exit>
builder = self.builder_for_features()<\exit>
self.assertEqual(self.registry.lookup('foo'), None)<\exit>
self.assertEqual(self.registry.lookup(), builder)<\exit>
def test_register_with_features_makes_lookup_succeed(self):<\exit>
builder = self.builder_for_features('foo', 'bar')<\exit>
self.assertEqual(self.registry.lookup('foo'), builder)<\exit>
self.assertEqual(self.registry.lookup('bar'), builder)<\exit>
def test_lookup_fails_when_no_builder_implements_feature(self):<\exit>
builder = self.builder_for_features('foo', 'bar')<\exit>
self.assertEqual(self.registry.lookup('baz'), None)<\exit>
def test_lookup_gets_most_recent_registration_when_no_feature_specified(self):<\exit>
builder1 = self.builder_for_features('foo')<\exit>
builder2 = self.builder_for_features('bar')<\exit>
self.assertEqual(self.registry.lookup(), builder2)<\exit>
def test_lookup_fails_when_no_tree_builders_registered(self):<\exit>
self.assertEqual(self.registry.lookup(), None)<\exit>
def test_lookup_gets_most_recent_builder_supporting_all_features(self):<\exit>
has_one = self.builder_for_features('foo')<\exit>
has_the_other = self.builder_for_features('bar')<\exit>
has_both_early = self.builder_for_features('foo', 'bar', 'baz')<\exit>
has_both_late = self.builder_for_features('foo', 'bar', 'quux')<\exit>
lacks_one = self.builder_for_features('bar')<\exit>
has_the_other = self.builder_for_features('foo')<\exit>
self.assertEqual(self.registry.lookup('foo', 'bar'),<\exit>
has_both_late)<\exit>
self.assertEqual(self.registry.lookup('foo', 'bar', 'baz'),<\exit>
has_both_early)<\exit>
def test_lookup_fails_when_cannot_reconcile_requested_features(self):<\exit>
builder1 = self.builder_for_features('foo', 'bar')<\exit>
builder2 = self.builder_for_features('foo', 'baz')<\exit>
self.assertEqual(self.registry.lookup('bar', 'baz'), None)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.os.child_process import *<\exit>
class TestChildProcess(TestCase):<\exit>
def test_simple_exec(self):<\exit>
self.assertEquals(basic_child_process(),<\exit>
u'Hello from the child!\n')<\exit>
def test_poll_status(self):<\exit>
self.assertEquals(poll_status(), 'Exit status 0')<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.class_hierarchy import *<\exit>
class TestProperty(TestCase):<\exit>
def test_property_setter(self):<\exit>
r = VoltageResistance(ohms=10)<\exit>
r.voltage = 10<\exit>
self.assertEquals(r.current, 1)<\exit>
class TestDescriptor(TestCase):<\exit>
def test_grade_descriptor(self):<\exit>
class Exam(object):<\exit>
math_grade = GradeDescriptor()<\exit>
writing_grade = GradeDescriptor()<\exit>
science_grade = GradeDescriptor()<\exit>
exam1 = Exam()<\exit>
exam2 = Exam()<\exit>
with self.assertRaises(ValueError):<\exit>
exam1.science_grade = 101<\exit>
exam1.science_grade = 99<\exit>
exam2.science_grade = 100<\exit>
self.assertEquals(exam1.science_grade, 99)<\exit>
self.assertEquals(exam2.science_grade, 100)<\exit>
from unittest import TestCase<\exit>
import pickle<\exit>
from util.commons_util.fundamentals.pickle.copyreg_demo import *<\exit>
class TestSerialization(TestCase):<\exit>
def test_copyreg(self):<\exit>
state = State()<\exit>
state.points += 1000<\exit>
serialized = pickle.dumps(state)<\exit>
state_after = pickle.loads(serialized)<\exit>
self.assertEquals(state_after.__dict__,<\exit>
{'points': 1000, 'lives': 4, 'level': 0})<\exit>
import random<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.data_structs import *<\exit>
class TestDataStructs(TestCase):<\exit>
def test_argsort(self):<\exit>
A = [3, 2, 1]<\exit>
ret = Sorter.argsort(A)<\exit>
self.assertEqual(ret, [2, 1, 0])<\exit>
def test_excel_column(self):<\exit>
col = ExcelColumn()<\exit>
self.assertEqual(list(col.columns(800))[-1], 'adt')<\exit>
class TestDisplayer(TestCase):<\exit>
def test_display(self):<\exit>
dis = Displayer()<\exit>
class A(object):<\exit>
def __init__(self):<\exit>
self.a = "abc"<\exit>
self.b = 1.0<\exit>
class B(object):<\exit>
def __init__(self):<\exit>
self.a = A()<\exit>
self.b = 1.0<\exit>
b = B()<\exit>
self.assertEqual(str(dis.dump(b)), '{"a": {"a": "abc", "b": 1.0}, "b": 1.0}')<\exit>
b_str =<\exit>
self.assertEqual(dis.display(b), b_str)<\exit>
class TestSearcher(TestCase):<\exit>
def test_binary_search(self):<\exit>
rand_lst = [int(1000*random.random()) for _ in xrange(100)]<\exit>
target = rand_lst[0]<\exit>
rand_lst.sort()<\exit>
def predicate(idx):<\exit>
if rand_lst[idx]==target:<\exit>
return 0<\exit>
elif rand_lst[idx]<target:<\exit>
return -1<\exit>
else:<\exit>
return 1<\exit>
idx = Searcher.binary_search(0, 100, predicate)<\exit>
self.assertEqual(target, rand_lst[idx])<\exit>
class TestWrapper(TestCase):<\exit>
def test_unpack(self):<\exit>
x = [random.randint(0, 100) for _ in xrange(100)]<\exit>
y = [random.randint(0, 100) for _ in xrange(100)]<\exit>
lst = zip(x, y)<\exit>
a, b = Wrapper.unpack(lst)<\exit>
self.assertEqual(a, tuple(x))<\exit>
self.assertEqual(b, tuple(y))<\exit>
"Test harness for doctests."<\exit>
__metaclass__ = type<\exit>
__all__ = [<\exit>
'additional_tests',<\exit>
]<\exit>
import atexit<\exit>
import doctest<\exit>
import os<\exit>
import unittest<\exit>
DOCTEST_FLAGS = (<\exit>
doctest.ELLIPSIS |<\exit>
doctest.NORMALIZE_WHITESPACE |<\exit>
doctest.REPORT_NDIFF)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.generators import *<\exit>
class TestGenerator(TestCase):<\exit>
def test_coroutine(self):<\exit>
itr = first_coroutine()<\exit>
itr.next()<\exit>
self.assertEquals(itr.send(1), "Received: 1")<\exit>
self.assertEquals(itr.send(2), "Received: 2")<\exit>
def test_yieldmin(self):<\exit>
itr = minimize()<\exit>
next(itr)<\exit>
self.assertEquals(itr.send(10), 10)<\exit>
self.assertEquals(itr.send(4), 4)<\exit>
self.assertEquals(itr.send(22), 4)<\exit>
self.assertEquals(itr.send(-1), -1)<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import HTML5TreeBuilder<\exit>
HTML5LIB_PRESENT = True<\exit>
except ImportError, e:<\exit>
HTML5LIB_PRESENT = False<\exit>
from bs4.element import SoupStrainer<\exit>
from bs4.testing import (<\exit>
HTML5TreeBuilderSmokeTest,<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
@skipIf(<\exit>
not HTML5LIB_PRESENT,<\exit>
"html5lib seems not to be present, not testing its tree builder.")<\exit>
class HTML5LibBuilderSmokeTest(SoupTest, HTML5TreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return HTML5TreeBuilder()<\exit>
def test_soupstrainer(self):<\exit>
strainer = SoupStrainer("b")<\exit>
markup = "<p>A <b>bold</b> statement.</p>"<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(markup))<\exit>
self.assertTrue(<\exit>
"the html5lib tree builder doesn't support parse_only" in<\exit>
str(w[0].message))<\exit>
def test_correctly_nested_tables(self):<\exit>
markup = ('<table id="1">'<\exit>
'<tr>'<\exit>
"<td>Here's another table:"<\exit>
'<table id="2">'<\exit>
'<tr><td>foo</td></tr>'<\exit>
'</table></td>')<\exit>
self.assertSoupEquals(<\exit>
markup,<\exit>
'<table id="1"><tbody><tr><td>Here\'s another table:'<\exit>
'<table id="2"><tbody><tr><td>foo</td></tr></tbody></table>'<\exit>
'</td></tr></tbody></table>')<\exit>
self.assertSoupEquals(<\exit>
"<table><thead><tr><td>Foo</td></tr></thead>"<\exit>
"<tbody><tr><td>Bar</td></tr></tbody>"<\exit>
"<tfoot><tr><td>Baz</td></tr></tfoot></table>")<\exit>
from bs4.testing import SoupTest, HTMLTreeBuilderSmokeTest<\exit>
from bs4.builder import HTMLParserTreeBuilder<\exit>
class HTMLParserTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return HTMLParserTreeBuilder()<\exit>
def test_namespaced_system_doctype(self):<\exit>
pass<\exit>
def test_namespaced_public_doctype(self):<\exit>
pass<\exit>
import re<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import LXMLTreeBuilder, LXMLTreeBuilderForXML<\exit>
LXML_PRESENT = True<\exit>
except ImportError, e:<\exit>
LXML_PRESENT = False<\exit>
from bs4 import (<\exit>
BeautifulSoup,<\exit>
BeautifulStoneSoup,<\exit>
)<\exit>
from bs4.element import Comment, Doctype, SoupStrainer<\exit>
from bs4.testing import skipIf<\exit>
from bs4.tests import test_htmlparser<\exit>
from bs4.testing import (<\exit>
HTMLTreeBuilderSmokeTest,<\exit>
XMLTreeBuilderSmokeTest,<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml seems not to be present, not testing its tree builder.")<\exit>
class LXMLTreeBuilderSmokeTest(SoupTest, HTMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return LXMLTreeBuilder()<\exit>
def test_out_of_range_entity(self):<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
self.assertSoupEquals(<\exit>
"<p>foo&<\exit>
def test_beautifulstonesoup_is_xml_parser(self):<\exit>
with warnings.catch_warnings(record=False) as w:<\exit>
soup = BeautifulStoneSoup("<b />")<\exit>
self.assertEqual(u"<b/>", unicode(soup.b))<\exit>
def test_real_xhtml_document(self):<\exit>
markup = b<\exit>
soup = self.soup(markup)<\exit>
self.assertEqual(<\exit>
soup.encode("utf-8").replace(b"\n", b''),<\exit>
markup.replace(b'\n', b'').replace(<\exit>
b'<?xml version="1.0" encoding="utf-8"?>', b''))<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml seems not to be present, not testing its XML tree builder.")<\exit>
class LXMLXMLTreeBuilderSmokeTest(SoupTest, XMLTreeBuilderSmokeTest):<\exit>
@property<\exit>
def default_builder(self):<\exit>
return LXMLTreeBuilderForXML()<\exit>
import sys<\exit>
import os<\exit>
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)),'..'))<\exit>
from qfc.core import filter_files, get_weight<\exit>
def _equals(marks_list1, marks_list2):<\exit>
l1 = sorted(marks_list1)<\exit>
l2 = sorted(marks_list2)<\exit>
if len(l1) != len(l2):<\exit>
return False<\exit>
for i,_ in enumerate(l1):<\exit>
if l1[i] != l2[i]:<\exit>
return False<\exit>
return True<\exit>
def test_filter_files():<\exit>
files = [<\exit>
'/',<\exit>
'/a/',<\exit>
'/b/',<\exit>
'/a/b',<\exit>
'/a/b/c',<\exit>
'/b/a/',<\exit>
'/b/a/c',<\exit>
'd',<\exit>
'da'<\exit>
]<\exit>
assert(_equals(filter_files(files,''), ['/','d','da']))<\exit>
assert(_equals(filter_files(files,'/'), ['/']))<\exit>
assert(_equals(filter_files(files,'a'), ['/a/', '/b/a/', 'da']))<\exit>
def test_weight():<\exit>
assert(get_weight('a','') == 1001)<\exit>
assert(get_weight('a/','') == 1000)<\exit>
assert(get_weight('a/b/','') == 2000)<\exit>
assert(get_weight('a/b/c','') == 3001)<\exit>
assert(get_weight('a','a')  == 1001)<\exit>
assert(get_weight('ab','a')  == 1021)<\exit>
assert(get_weight('bab','a')  == 1111)<\exit>
assert(get_weight('a_b','a')  == 1011)<\exit>
assert(get_weight('root/a_b','a')  == 2011)<\exit>
assert(get_weight('root/a_b_c_d_e_f_g_h_i_j_k','k')  == 2091)<\exit>
assert(get_weight('a/b/c/d/e/f/g/h/i/j/k','k')  == 10001)<\exit>
assert(get_weight('a/B/','b') == 2000)<\exit>
from unittest import TestCase<\exit>
from util.commons_util.fundamentals.serialization import *<\exit>
class TestSerialization(TestCase):<\exit>
def test_todict(self):<\exit>
class BinaryTree(ToDictMixin):<\exit>
def __init__(self, value, left=None, right=None):<\exit>
self.value = value<\exit>
self.left = left<\exit>
self.right = right<\exit>
tree = BinaryTree(10,<\exit>
left=BinaryTree(7, right=BinaryTree(9)),<\exit>
right=BinaryTree(13, left=BinaryTree(11)))<\exit>
self.assertEquals(tree.to_dict(), {'right': {'right': None, 'value': 13, 'left': {'right': None, 'value': 11, 'left': None}}, 'value': 10, 'left': {'right': {'right': None, 'value': 9, 'left': None}, 'value': 7, 'left': None}})<\exit>
import logging<\exit>
import unittest<\exit>
import sys<\exit>
from bs4 import (<\exit>
BeautifulSoup,<\exit>
BeautifulStoneSoup,<\exit>
)<\exit>
from bs4.element import (<\exit>
CharsetMetaAttributeValue,<\exit>
ContentMetaAttributeValue,<\exit>
SoupStrainer,<\exit>
NamespacedAttribute,<\exit>
)<\exit>
import bs4.dammit<\exit>
from bs4.dammit import EntitySubstitution, UnicodeDammit<\exit>
from bs4.testing import (<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
import warnings<\exit>
try:<\exit>
from bs4.builder import LXMLTreeBuilder, LXMLTreeBuilderForXML<\exit>
LXML_PRESENT = True<\exit>
except ImportError, e:<\exit>
LXML_PRESENT = False<\exit>
PYTHON_2_PRE_2_7 = (sys.version_info < (2,7))<\exit>
PYTHON_3_PRE_3_2 = (sys.version_info[0] == 3 and sys.version_info < (3,2))<\exit>
class TestDeprecatedConstructorArguments(SoupTest):<\exit>
def test_parseOnlyThese_renamed_to_parse_only(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = self.soup("<a><b></b></a>", parseOnlyThese=SoupStrainer("b"))<\exit>
msg = str(w[0].message)<\exit>
self.assertTrue("parseOnlyThese" in msg)<\exit>
self.assertTrue("parse_only" in msg)<\exit>
self.assertEqual(b"<b></b>", soup.encode())<\exit>
def test_fromEncoding_renamed_to_from_encoding(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
utf8 = b"\xc3\xa9"<\exit>
soup = self.soup(utf8, fromEncoding="utf8")<\exit>
msg = str(w[0].message)<\exit>
self.assertTrue("fromEncoding" in msg)<\exit>
self.assertTrue("from_encoding" in msg)<\exit>
self.assertEqual("utf8", soup.original_encoding)<\exit>
def test_unrecognized_keyword_argument(self):<\exit>
self.assertRaises(<\exit>
TypeError, self.soup, "<a>", no_such_argument=True)<\exit>
@skipIf(<\exit>
not LXML_PRESENT,<\exit>
"lxml not present, not testing BeautifulStoneSoup.")<\exit>
def test_beautifulstonesoup(self):<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
soup = BeautifulStoneSoup("<markup>")<\exit>
self.assertTrue(isinstance(soup, BeautifulSoup))<\exit>
self.assertTrue("BeautifulStoneSoup class is deprecated")<\exit>
class TestSelectiveParsing(SoupTest):<\exit>
def test_parse_with_soupstrainer(self):<\exit>
markup = "No<b>Yes</b><a>No<b>Yes <c>Yes</c></b>"<\exit>
strainer = SoupStrainer("b")<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(soup.encode(), b"<b>Yes</b><b>Yes <c>Yes</c></b>")<\exit>
class TestEntitySubstitution(unittest.TestCase):<\exit>
def setUp(self):<\exit>
self.sub = EntitySubstitution<\exit>
def test_simple_html_substitution(self):<\exit>
s = u"foo\u2200\N{SNOWMAN}\u00f5bar"<\exit>
self.assertEqual(self.sub.substitute_html(s),<\exit>
u"foo&forall;\N{SNOWMAN}&otilde;bar")<\exit>
def test_smart_quote_substitution(self):<\exit>
quotes = b"\x91\x92foo\x93\x94"<\exit>
dammit = UnicodeDammit(quotes)<\exit>
self.assertEqual(self.sub.substitute_html(dammit.markup),<\exit>
"&lsquo;&rsquo;foo&ldquo;&rdquo;")<\exit>
def test_xml_converstion_includes_no_quotes_if_make_quoted_attribute_is_false(self):<\exit>
s = 'Welcome to "my bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(s, False), s)<\exit>
def test_xml_attribute_quoting_normally_uses_double_quotes(self):<\exit>
self.assertEqual(self.sub.substitute_xml("Welcome", True),<\exit>
'"Welcome"')<\exit>
self.assertEqual(self.sub.substitute_xml("Bob's Bar", True),<\exit>
'"Bob\'s Bar"')<\exit>
def test_xml_attribute_quoting_uses_single_quotes_when_value_contains_double_quotes(self):<\exit>
s = 'Welcome to "my bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(s, True),<\exit>
"'Welcome to \"my bar\"'")<\exit>
def test_xml_attribute_quoting_escapes_single_quotes_when_value_contains_both_single_and_double_quotes(self):<\exit>
s = 'Welcome to "Bob\'s Bar"'<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml(s, True),<\exit>
'"Welcome to &quot;Bob\'s Bar&quot;"')<\exit>
def test_xml_quotes_arent_escaped_when_value_is_not_being_quoted(self):<\exit>
quoted = 'Welcome to "Bob\'s Bar"'<\exit>
self.assertEqual(self.sub.substitute_xml(quoted), quoted)<\exit>
def test_xml_quoting_handles_angle_brackets(self):<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml("foo<bar>"),<\exit>
"foo&lt;bar&gt;")<\exit>
def test_xml_quoting_handles_ampersands(self):<\exit>
self.assertEqual(self.sub.substitute_xml("AT&T"), "AT&amp;T")<\exit>
def test_xml_quoting_ignores_ampersands_when_they_are_part_of_an_entity(self):<\exit>
self.assertEqual(<\exit>
self.sub.substitute_xml("&Aacute;T&T"),<\exit>
"&Aacute;T&amp;T")<\exit>
def test_quotes_not_html_substituted(self):<\exit>
text = 'Bob\'s "bar"'<\exit>
self.assertEqual(self.sub.substitute_html(text), text)<\exit>
class TestEncodingConversion(SoupTest):<\exit>
def setUp(self):<\exit>
super(TestEncodingConversion, self).setUp()<\exit>
self.unicode_data = u'<html><head><meta charset="utf-8"/></head><body><foo>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</foo></body></html>'<\exit>
self.utf8_data = self.unicode_data.encode("utf-8")<\exit>
self.assertEqual(<\exit>
self.utf8_data,<\exit>
b'<html><head><meta charset="utf-8"/></head><body><foo>Sacr\xc3\xa9 bleu!</foo></body></html>')<\exit>
def test_ascii_in_unicode_out(self):<\exit>
ascii = b"<foo>a</foo>"<\exit>
soup_from_ascii = self.soup(ascii)<\exit>
unicode_output = soup_from_ascii.decode()<\exit>
self.assertTrue(isinstance(unicode_output, unicode))<\exit>
self.assertEqual(unicode_output, self.document_for(ascii.decode()))<\exit>
self.assertEqual(soup_from_ascii.original_encoding.lower(), "ascii")<\exit>
def test_unicode_in_unicode_out(self):<\exit>
soup_from_unicode = self.soup(self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.decode(), self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.foo.string, u'Sacr\xe9 bleu!')<\exit>
self.assertEqual(soup_from_unicode.original_encoding, None)<\exit>
def test_utf8_in_unicode_out(self):<\exit>
soup_from_utf8 = self.soup(self.utf8_data)<\exit>
self.assertEqual(soup_from_utf8.decode(), self.unicode_data)<\exit>
self.assertEqual(soup_from_utf8.foo.string, u'Sacr\xe9 bleu!')<\exit>
def test_utf8_out(self):<\exit>
soup_from_unicode = self.soup(self.unicode_data)<\exit>
self.assertEqual(soup_from_unicode.encode('utf-8'), self.utf8_data)<\exit>
@skipIf(<\exit>
PYTHON_2_PRE_2_7 or PYTHON_3_PRE_3_2,<\exit>
"Bad HTMLParser detected; skipping test of non-ASCII characters in attribute name.")<\exit>
def test_attribute_name_containing_unicode_characters(self):<\exit>
markup = u'<div><a \N{SNOWMAN}="snowman"></a></div>'<\exit>
self.assertEqual(self.soup(markup).div.encode("utf8"), markup.encode("utf8"))<\exit>
class TestUnicodeDammit(unittest.TestCase):<\exit>
def test_smart_quotes_to_unicode(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup)<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, u"<foo>\u2018\u2019\u201c\u201d</foo>")<\exit>
def test_smart_quotes_to_xml_entities(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="xml")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, "<foo>&<\exit>
def test_smart_quotes_to_html_entities(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="html")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, "<foo>&lsquo;&rsquo;&ldquo;&rdquo;</foo>")<\exit>
def test_smart_quotes_to_ascii(self):<\exit>
markup = b"<foo>\x91\x92\x93\x94</foo>"<\exit>
dammit = UnicodeDammit(markup, smart_quotes_to="ascii")<\exit>
self.assertEqual(<\exit>
dammit.unicode_markup, )<\exit>
def test_detect_utf8(self):<\exit>
utf8 = b"\xc3\xa9"<\exit>
dammit = UnicodeDammit(utf8)<\exit>
self.assertEqual(dammit.unicode_markup, u'\xe9')<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_convert_hebrew(self):<\exit>
hebrew = b"\xed\xe5\xec\xf9"<\exit>
dammit = UnicodeDammit(hebrew, ["iso-8859-8"])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'iso-8859-8')<\exit>
self.assertEqual(dammit.unicode_markup, u'\u05dd\u05d5\u05dc\u05e9')<\exit>
def test_dont_see_smart_quotes_where_there_are_none(self):<\exit>
utf_8 = b"\343\202\261\343\203\274\343\202\277\343\202\244 Watch"<\exit>
dammit = UnicodeDammit(utf_8)<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
self.assertEqual(dammit.unicode_markup.encode("utf-8"), utf_8)<\exit>
def test_ignore_inappropriate_codecs(self):<\exit>
utf8_data = u"R鐩瞜sm鏋歳g姘搒".encode("utf-8")<\exit>
dammit = UnicodeDammit(utf8_data, ["iso-8859-8"])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_ignore_invalid_codecs(self):<\exit>
utf8_data = u"R鐩瞜sm鏋歳g姘搒".encode("utf-8")<\exit>
for bad_encoding in ['.utf8', '...', 'utF---16.!']:<\exit>
dammit = UnicodeDammit(utf8_data, [bad_encoding])<\exit>
self.assertEqual(dammit.original_encoding.lower(), 'utf-8')<\exit>
def test_detect_html5_style_meta_tag(self):<\exit>
for data in (<\exit>
b'<html><meta charset="euc-jp" /></html>',<\exit>
b"<html><meta charset='euc-jp' /></html>",<\exit>
b"<html><meta charset=euc-jp /></html>",<\exit>
b"<html><meta charset=euc-jp/></html>"):<\exit>
dammit = UnicodeDammit(data, is_html=True)<\exit>
self.assertEqual(<\exit>
"euc-jp", dammit.original_encoding)<\exit>
def test_last_ditch_entity_replacement(self):<\exit>
doc = b<\exit>
chardet = bs4.dammit.chardet_dammit<\exit>
logging.disable(logging.WARNING)<\exit>
try:<\exit>
def noop(str):<\exit>
return None<\exit>
bs4.dammit.chardet_dammit = noop<\exit>
dammit = UnicodeDammit(doc)<\exit>
self.assertEqual(True, dammit.contains_replacement_characters)<\exit>
self.assertTrue(u"\ufffd" in dammit.unicode_markup)<\exit>
soup = BeautifulSoup(doc, "html.parser")<\exit>
self.assertTrue(soup.contains_replacement_characters)<\exit>
finally:<\exit>
logging.disable(logging.NOTSET)<\exit>
bs4.dammit.chardet_dammit = chardet<\exit>
def test_sniffed_xml_encoding(self):<\exit>
data = b'\xff\xfe<\x00a\x00>\x00\xe1\x00\xe9\x00<\x00/\x00a\x00>\x00'<\exit>
dammit = UnicodeDammit(data)<\exit>
self.assertEqual(u"<a>璋╄寘</a>", dammit.unicode_markup)<\exit>
self.assertEqual("utf-16le", dammit.original_encoding)<\exit>
def test_detwingle(self):<\exit>
utf8 = (u"\N{SNOWMAN}" * 3).encode("utf8")<\exit>
windows_1252 = (<\exit>
u"\N{LEFT DOUBLE QUOTATION MARK}Hi, I like Windows!"<\exit>
u"\N{RIGHT DOUBLE QUOTATION MARK}").encode("windows_1252")<\exit>
doc = utf8 + windows_1252 + utf8<\exit>
self.assertRaises(UnicodeDecodeError, doc.decode, "utf8")<\exit>
fixed = UnicodeDammit.detwingle(doc)<\exit>
self.assertEqual(<\exit>
u"閳藉啠妲傞埥鍐ｆ窏i, I like Windows!閳ユ績妲傞埥鍐ｆ", fixed.decode("utf8"))<\exit>
def test_detwingle_ignores_multibyte_characters(self):<\exit>
for tricky_unicode_char in (<\exit>
u"\N{LATIN SMALL LIGATURE OE}",<\exit>
u"\N{LATIN SUBSCRIPT SMALL LETTER X}",<\exit>
u"\xf0\x90\x90\x93",<\exit>
):<\exit>
input = tricky_unicode_char.encode("utf8")<\exit>
self.assertTrue(input.endswith(b'\x93'))<\exit>
output = UnicodeDammit.detwingle(input)<\exit>
self.assertEqual(output, input)<\exit>
class TestNamedspacedAttribute(SoupTest):<\exit>
def test_name_may_be_none(self):<\exit>
a = NamespacedAttribute("xmlns", None)<\exit>
self.assertEqual(a, "xmlns")<\exit>
def test_attribute_is_equivalent_to_colon_separated_string(self):<\exit>
a = NamespacedAttribute("a", "b")<\exit>
self.assertEqual("a:b", a)<\exit>
def test_attributes_are_equivalent_if_prefix_and_name_identical(self):<\exit>
a = NamespacedAttribute("a", "b", "c")<\exit>
b = NamespacedAttribute("a", "b", "c")<\exit>
self.assertEqual(a, b)<\exit>
c = NamespacedAttribute("a", "b", None)<\exit>
self.assertEqual(a, c)<\exit>
d = NamespacedAttribute("a", "z", "c")<\exit>
self.assertNotEqual(a, d)<\exit>
e = NamespacedAttribute("z", "b", "c")<\exit>
self.assertNotEqual(a, e)<\exit>
class TestAttributeValueWithCharsetSubstitution(unittest.TestCase):<\exit>
def test_content_meta_attribute_value(self):<\exit>
value = CharsetMetaAttributeValue("euc-jp")<\exit>
self.assertEqual("euc-jp", value)<\exit>
self.assertEqual("euc-jp", value.original_value)<\exit>
self.assertEqual("utf8", value.encode("utf8"))<\exit>
def test_content_meta_attribute_value(self):<\exit>
value = ContentMetaAttributeValue("text/html; charset=euc-jp")<\exit>
self.assertEqual("text/html; charset=euc-jp", value)<\exit>
self.assertEqual("text/html; charset=euc-jp", value.original_value)<\exit>
self.assertEqual("text/html; charset=utf8", value.encode("utf8"))<\exit>
import copy<\exit>
import pickle<\exit>
import re<\exit>
import warnings<\exit>
from bs4 import BeautifulSoup<\exit>
from bs4.builder import (<\exit>
builder_registry,<\exit>
HTMLParserTreeBuilder,<\exit>
)<\exit>
from bs4.element import (<\exit>
CData,<\exit>
Doctype,<\exit>
NavigableString,<\exit>
SoupStrainer,<\exit>
Tag,<\exit>
)<\exit>
from bs4.testing import (<\exit>
SoupTest,<\exit>
skipIf,<\exit>
)<\exit>
XML_BUILDER_PRESENT = (builder_registry.lookup("xml") is not None)<\exit>
LXML_PRESENT = (builder_registry.lookup("lxml") is not None)<\exit>
class TreeTest(SoupTest):<\exit>
def assertSelects(self, tags, should_match):<\exit>
self.assertEqual([tag.string for tag in tags], should_match)<\exit>
def assertSelectsIDs(self, tags, should_match):<\exit>
self.assertEqual([tag['id'] for tag in tags], should_match)<\exit>
class TestFind(TreeTest):<\exit>
def test_find_tag(self):<\exit>
soup = self.soup("<a>1</a><b>2</b><a>3</a><b>4</b>")<\exit>
self.assertEqual(soup.find("b").string, "2")<\exit>
def test_unicode_text_find(self):<\exit>
soup = self.soup(u'<h1>R鐩瞜sm鏋歳g姘搒</h1>')<\exit>
self.assertEqual(soup.find(text=u'R鐩瞜sm鏋歳g姘搒'), u'R鐩瞜sm鏋歳g姘搒')<\exit>
class TestFindAll(TreeTest):<\exit>
def test_find_all_text_nodes(self):<\exit>
soup = self.soup("<html>Foo<b>bar</b>\xbb</html>")<\exit>
self.assertEqual(soup.find_all(text="bar"), [u"bar"])<\exit>
self.assertEqual(<\exit>
soup.find_all(text=["Foo", "bar"]), [u"Foo", u"bar"])<\exit>
self.assertEqual(soup.find_all(text=re.compile('.*')),<\exit>
[u"Foo", u"bar", u'\xbb'])<\exit>
self.assertEqual(soup.find_all(text=True),<\exit>
[u"Foo", u"bar", u'\xbb'])<\exit>
def test_find_all_limit(self):<\exit>
soup = self.soup("<a>1</a><a>2</a><a>3</a><a>4</a><a>5</a>")<\exit>
self.assertSelects(soup.find_all('a', limit=3), ["1", "2", "3"])<\exit>
self.assertSelects(soup.find_all('a', limit=1), ["1"])<\exit>
self.assertSelects(<\exit>
soup.find_all('a', limit=10), ["1", "2", "3", "4", "5"])<\exit>
self.assertSelects(<\exit>
soup.find_all('a', limit=0), ["1", "2", "3", "4", "5"])<\exit>
def test_calling_a_tag_is_calling_findall(self):<\exit>
soup = self.soup("<a>1</a><b>2<a id='foo'>3</a></b>")<\exit>
self.assertSelects(soup('a', limit=1), ["1"])<\exit>
self.assertSelects(soup.b(id="foo"), ["3"])<\exit>
def test_find_all_with_self_referential_data_structure_does_not_cause_infinite_recursion(self):<\exit>
soup = self.soup("<a></a>")<\exit>
l = []<\exit>
l.append(l)<\exit>
self.assertEqual([], soup.find_all(l))<\exit>
class TestFindAllBasicNamespaces(TreeTest):<\exit>
def test_find_by_namespaced_name(self):<\exit>
soup = self.soup('<mathml:msqrt>4</mathml:msqrt><a svg:fill="red">')<\exit>
self.assertEqual("4", soup.find("mathml:msqrt").string)<\exit>
self.assertEqual("a", soup.find(attrs= { "svg:fill" : "red" }).name)<\exit>
class TestFindAllByName(TreeTest):<\exit>
def setUp(self):<\exit>
super(TreeTest, self).setUp()<\exit>
self.tree =  self.soup()<\exit>
def test_find_all_by_tag_name(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a'), ['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_name_and_text(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text='First tag.'), ['First tag.'])<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text=True), ['First tag.', 'Nested tag.'])<\exit>
self.assertSelects(<\exit>
self.tree.find_all('a', text=re.compile("tag")),<\exit>
['First tag.', 'Nested tag.'])<\exit>
def test_find_all_on_non_root_element(self):<\exit>
self.assertSelects(self.tree.c.find_all('a'), ['Nested tag.'])<\exit>
def test_calling_element_invokes_find_all(self):<\exit>
self.assertSelects(self.tree('a'), ['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_strainer(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(SoupStrainer('a')),<\exit>
['First tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_names(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(['a', 'b']),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_dict(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all({'a' : True, 'b' : True}),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_by_tag_re(self):<\exit>
self.assertSelects(<\exit>
self.tree.find_all(re.compile('^[ab]$')),<\exit>
['First tag.', 'Second tag.', 'Nested tag.'])<\exit>
def test_find_all_with_tags_matching_method(self):<\exit>
def id_matches_name(tag):<\exit>
return tag.name == tag.get('id')<\exit>
tree = self.soup()<\exit>
self.assertSelects(<\exit>
tree.find_all(id_matches_name), ["Match 1.", "Match 2."])<\exit>
class TestFindAllByAttribute(TreeTest):<\exit>
def test_find_all_by_attribute_name(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id='first'),<\exit>
["Matching a.", "Matching b."])<\exit>
def test_find_all_by_utf8_attribute_value(self):<\exit>
peace = u"璇愯疁璇囩爾".encode("utf8")<\exit>
data = u'<a title="璇愯疁璇囩爾"></a>'.encode("utf8")<\exit>
soup = self.soup(data)<\exit>
self.assertEqual([soup.a], soup.find_all(title=peace))<\exit>
self.assertEqual([soup.a], soup.find_all(title=peace.decode("utf8")))<\exit>
self.assertEqual([soup.a], soup.find_all(title=[peace, "something else"]))<\exit>
def test_find_all_by_attribute_dict(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(name='name1'),<\exit>
["A tag called 'name1'."])<\exit>
self.assertSelects(tree.find_all(attrs={'name' : 'name1'}),<\exit>
["Name match."])<\exit>
self.assertSelects(tree.find_all(attrs={'class' : 'class2'}),<\exit>
["Class match."])<\exit>
def test_find_all_by_class(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all('a', class_='1'), ['Class 1.'])<\exit>
self.assertSelects(tree.find_all('c', class_='3'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('c', class_='4'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('a', '1'), ['Class 1.'])<\exit>
self.assertSelects(tree.find_all(attrs='1'), ['Class 1.', 'Class 1.'])<\exit>
self.assertSelects(tree.find_all('c', '3'), ['Class 3 and 4.'])<\exit>
self.assertSelects(tree.find_all('c', '4'), ['Class 3 and 4.'])<\exit>
def test_find_by_class_when_multiple_classes_present(self):<\exit>
tree = self.soup("<gar class='foo bar'>Found it</gar>")<\exit>
f = tree.find_all("gar", class_=re.compile("o"))<\exit>
self.assertSelects(f, ["Found it"])<\exit>
f = tree.find_all("gar", class_=re.compile("a"))<\exit>
self.assertSelects(f, ["Found it"])<\exit>
f = tree.find_all("gar", class_=re.compile("o b"))<\exit>
self.assertSelects(f, [])<\exit>
def test_find_all_with_non_dictionary_for_attrs_finds_by_class(self):<\exit>
soup = self.soup("<a class='bar'>Found it</a>")<\exit>
self.assertSelects(soup.find_all("a", re.compile("ba")), ["Found it"])<\exit>
def big_attribute_value(value):<\exit>
return len(value) > 3<\exit>
self.assertSelects(soup.find_all("a", big_attribute_value), [])<\exit>
def small_attribute_value(value):<\exit>
return len(value) <= 3<\exit>
self.assertSelects(<\exit>
soup.find_all("a", small_attribute_value), ["Found it"])<\exit>
def test_find_all_with_string_for_attrs_finds_multiple_classes(self):<\exit>
soup = self.soup('<a class="foo bar"></a><a class="foo"></a>')<\exit>
a, a2 = soup.find_all("a")<\exit>
self.assertEqual([a, a2], soup.find_all("a", "foo"))<\exit>
self.assertEqual([a], soup.find_all("a", "bar"))<\exit>
self.assertEqual([a], soup.find_all("a", class_="foo bar"))<\exit>
self.assertEqual([a], soup.find_all("a", "foo bar"))<\exit>
self.assertEqual([], soup.find_all("a", "bar foo"))<\exit>
def test_find_all_by_attribute_soupstrainer(self):<\exit>
tree = self.soup()<\exit>
strainer = SoupStrainer(attrs={'id' : 'first'})<\exit>
self.assertSelects(tree.find_all(strainer), ['Match.'])<\exit>
def test_find_all_with_missing_atribute(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all('a', id=None), ["No ID present."])<\exit>
def test_find_all_with_defined_attribute(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(<\exit>
tree.find_all(id=True), ["ID present.", "ID is empty."])<\exit>
def test_find_all_with_numeric_attribute(self):<\exit>
tree = self.soup()<\exit>
expected = ["Unquoted attribute.", "Quoted attribute."]<\exit>
self.assertSelects(tree.find_all(id=1), expected)<\exit>
self.assertSelects(tree.find_all(id="1"), expected)<\exit>
def test_find_all_with_list_attribute_values(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id=["1", "3", "4"]),<\exit>
["1", "3"])<\exit>
def test_find_all_with_regular_expression_attribute_value(self):<\exit>
tree = self.soup()<\exit>
self.assertSelects(tree.find_all(id=re.compile("^a+$")),<\exit>
["One a.", "Two as."])<\exit>
def test_find_by_name_and_containing_string(self):<\exit>
soup = self.soup("<b>foo</b><b>bar</b><a>foo</a>")<\exit>
a = soup.a<\exit>
self.assertEqual([a], soup.find_all("a", text="foo"))<\exit>
self.assertEqual([], soup.find_all("a", text="bar"))<\exit>
self.assertEqual([], soup.find_all("a", text="bar"))<\exit>
def test_find_by_name_and_containing_string_when_string_is_buried(self):<\exit>
soup = self.soup("<a>foo</a><a><b><c>foo</c></b></a>")<\exit>
self.assertEqual(soup.find_all("a"), soup.find_all("a", text="foo"))<\exit>
def test_find_by_attribute_and_containing_string(self):<\exit>
soup = self.soup('<b id="1">foo</b><a id="2">foo</a>')<\exit>
a = soup.a<\exit>
self.assertEqual([a], soup.find_all(id=2, text="foo"))<\exit>
self.assertEqual([], soup.find_all(id=1, text="bar"))<\exit>
class TestIndex(TreeTest):<\exit>
def test_index(self):<\exit>
tree = self.soup()<\exit>
div = tree.div<\exit>
for i, element in enumerate(div.contents):<\exit>
self.assertEqual(i, div.index(element))<\exit>
self.assertRaises(ValueError, tree.index, 1)<\exit>
class TestParentOperations(TreeTest):<\exit>
def setUp(self):<\exit>
super(TestParentOperations, self).setUp()<\exit>
self.tree = self.soup()<\exit>
self.start = self.tree.b<\exit>
def test_parent(self):<\exit>
self.assertEqual(self.start.parent['id'], 'bottom')<\exit>
self.assertEqual(self.start.parent.parent['id'], 'middle')<\exit>
self.assertEqual(self.start.parent.parent.parent['id'], 'top')<\exit>
def test_parent_of_top_tag_is_soup_object(self):<\exit>
top_tag = self.tree.contents[0]<\exit>
self.assertEqual(top_tag.parent, self.tree)<\exit>
def test_soup_object_has_no_parent(self):<\exit>
self.assertEqual(None, self.tree.parent)<\exit>
def test_find_parents(self):<\exit>
self.assertSelectsIDs(<\exit>
self.start.find_parents('ul'), ['bottom', 'middle', 'top'])<\exit>
self.assertSelectsIDs(<\exit>
self.start.find_parents('ul', id="middle"), ['middle'])<\exit>
def test_find_parent(self):<\exit>
self.assertEqual(self.start.find_parent('ul')['id'], 'bottom')<\exit>
def test_parent_of_text_element(self):<\exit>
text = self.tree.find(text="Start here")<\exit>
self.assertEqual(text.parent.name, 'b')<\exit>
def test_text_element_find_parent(self):<\exit>
text = self.tree.find(text="Start here")<\exit>
self.assertEqual(text.find_parent('ul')['id'], 'bottom')<\exit>
def test_parent_generator(self):<\exit>
parents = [parent['id'] for parent in self.start.parents<\exit>
if parent is not None and 'id' in parent.attrs]<\exit>
self.assertEqual(parents, ['bottom', 'middle', 'top'])<\exit>
class ProximityTest(TreeTest):<\exit>
def setUp(self):<\exit>
super(TreeTest, self).setUp()<\exit>
self.tree = self.soup(<\exit>
'<html id="start"><head></head><body><b id="1">One</b><b id="2">Two</b><b id="3">Three</b></body></html>')<\exit>
class TestNextOperations(ProximityTest):<\exit>
def setUp(self):<\exit>
super(TestNextOperations, self).setUp()<\exit>
self.start = self.tree.b<\exit>
def test_next(self):<\exit>
self.assertEqual(self.start.next_element, "One")<\exit>
self.assertEqual(self.start.next_element.next_element['id'], "2")<\exit>
def test_next_of_last_item_is_none(self):<\exit>
last = self.tree.find(text="Three")<\exit>
self.assertEqual(last.next_element, None)<\exit>
def test_next_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.next_element, None)<\exit>
def test_find_all_next(self):<\exit>
self.assertSelects(self.start.find_all_next('b'), ["Two", "Three"])<\exit>
self.start.find_all_next(id=3)<\exit>
self.assertSelects(self.start.find_all_next(id=3), ["Three"])<\exit>
def test_find_next(self):<\exit>
self.assertEqual(self.start.find_next('b')['id'], '2')<\exit>
self.assertEqual(self.start.find_next(text="Three"), "Three")<\exit>
def test_find_next_for_text_element(self):<\exit>
text = self.tree.find(text="One")<\exit>
self.assertEqual(text.find_next("b").string, "Two")<\exit>
self.assertSelects(text.find_all_next("b"), ["Two", "Three"])<\exit>
def test_next_generator(self):<\exit>
start = self.tree.find(text="Two")<\exit>
successors = [node for node in start.next_elements]<\exit>
tag, contents = successors<\exit>
self.assertEqual(tag['id'], '3')<\exit>
self.assertEqual(contents, "Three")<\exit>
class TestPreviousOperations(ProximityTest):<\exit>
def setUp(self):<\exit>
super(TestPreviousOperations, self).setUp()<\exit>
self.end = self.tree.find(text="Three")<\exit>
def test_previous(self):<\exit>
self.assertEqual(self.end.previous_element['id'], "3")<\exit>
self.assertEqual(self.end.previous_element.previous_element, "Two")<\exit>
def test_previous_of_first_item_is_none(self):<\exit>
first = self.tree.find('html')<\exit>
self.assertEqual(first.previous_element, None)<\exit>
def test_previous_of_root_is_none(self):<\exit>
pass<\exit>
def test_find_all_previous(self):<\exit>
self.assertSelects(<\exit>
self.end.find_all_previous('b'), ["Three", "Two", "One"])<\exit>
self.assertSelects(self.end.find_all_previous(id=1), ["One"])<\exit>
def test_find_previous(self):<\exit>
self.assertEqual(self.end.find_previous('b')['id'], '3')<\exit>
self.assertEqual(self.end.find_previous(text="One"), "One")<\exit>
def test_find_previous_for_text_element(self):<\exit>
text = self.tree.find(text="Three")<\exit>
self.assertEqual(text.find_previous("b").string, "Three")<\exit>
self.assertSelects(<\exit>
text.find_all_previous("b"), ["Three", "Two", "One"])<\exit>
def test_previous_generator(self):<\exit>
start = self.tree.find(text="One")<\exit>
predecessors = [node for node in start.previous_elements]<\exit>
b, body, head, html = predecessors<\exit>
self.assertEqual(b['id'], '1')<\exit>
self.assertEqual(body.name, "body")<\exit>
self.assertEqual(head.name, "head")<\exit>
self.assertEqual(html.name, "html")<\exit>
class SiblingTest(TreeTest):<\exit>
def setUp(self):<\exit>
super(SiblingTest, self).setUp()<\exit>
markup =<\exit>
markup = re.compile("\n\s*").sub("", markup)<\exit>
self.tree = self.soup(markup)<\exit>
class TestNextSibling(SiblingTest):<\exit>
def setUp(self):<\exit>
super(TestNextSibling, self).setUp()<\exit>
self.start = self.tree.find(id="1")<\exit>
def test_next_sibling_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.next_sibling, None)<\exit>
def test_next_sibling(self):<\exit>
self.assertEqual(self.start.next_sibling['id'], '2')<\exit>
self.assertEqual(self.start.next_sibling.next_sibling['id'], '3')<\exit>
self.assertEqual(self.start.next_element['id'], '1.1')<\exit>
def test_next_sibling_may_not_exist(self):<\exit>
self.assertEqual(self.tree.html.next_sibling, None)<\exit>
nested_span = self.tree.find(id="1.1")<\exit>
self.assertEqual(nested_span.next_sibling, None)<\exit>
last_span = self.tree.find(id="4")<\exit>
self.assertEqual(last_span.next_sibling, None)<\exit>
def test_find_next_sibling(self):<\exit>
self.assertEqual(self.start.find_next_sibling('span')['id'], '2')<\exit>
def test_next_siblings(self):<\exit>
self.assertSelectsIDs(self.start.find_next_siblings("span"),<\exit>
['2', '3', '4'])<\exit>
self.assertSelectsIDs(self.start.find_next_siblings(id='3'), ['3'])<\exit>
def test_next_sibling_for_text_element(self):<\exit>
soup = self.soup("Foo<b>bar</b>baz")<\exit>
start = soup.find(text="Foo")<\exit>
self.assertEqual(start.next_sibling.name, 'b')<\exit>
self.assertEqual(start.next_sibling.next_sibling, 'baz')<\exit>
self.assertSelects(start.find_next_siblings('b'), ['bar'])<\exit>
self.assertEqual(start.find_next_sibling(text="baz"), "baz")<\exit>
self.assertEqual(start.find_next_sibling(text="nonesuch"), None)<\exit>
class TestPreviousSibling(SiblingTest):<\exit>
def setUp(self):<\exit>
super(TestPreviousSibling, self).setUp()<\exit>
self.end = self.tree.find(id="4")<\exit>
def test_previous_sibling_of_root_is_none(self):<\exit>
self.assertEqual(self.tree.previous_sibling, None)<\exit>
def test_previous_sibling(self):<\exit>
self.assertEqual(self.end.previous_sibling['id'], '3')<\exit>
self.assertEqual(self.end.previous_sibling.previous_sibling['id'], '2')<\exit>
self.assertEqual(self.end.previous_element['id'], '3.1')<\exit>
def test_previous_sibling_may_not_exist(self):<\exit>
self.assertEqual(self.tree.html.previous_sibling, None)<\exit>
nested_span = self.tree.find(id="1.1")<\exit>
self.assertEqual(nested_span.previous_sibling, None)<\exit>
first_span = self.tree.find(id="1")<\exit>
self.assertEqual(first_span.previous_sibling, None)<\exit>
def test_find_previous_sibling(self):<\exit>
self.assertEqual(self.end.find_previous_sibling('span')['id'], '3')<\exit>
def test_previous_siblings(self):<\exit>
self.assertSelectsIDs(self.end.find_previous_siblings("span"),<\exit>
['3', '2', '1'])<\exit>
self.assertSelectsIDs(self.end.find_previous_siblings(id='1'), ['1'])<\exit>
def test_previous_sibling_for_text_element(self):<\exit>
soup = self.soup("Foo<b>bar</b>baz")<\exit>
start = soup.find(text="baz")<\exit>
self.assertEqual(start.previous_sibling.name, 'b')<\exit>
self.assertEqual(start.previous_sibling.previous_sibling, 'Foo')<\exit>
self.assertSelects(start.find_previous_siblings('b'), ['bar'])<\exit>
self.assertEqual(start.find_previous_sibling(text="Foo"), "Foo")<\exit>
self.assertEqual(start.find_previous_sibling(text="nonesuch"), None)<\exit>
class TestTagCreation(SoupTest):<\exit>
def test_new_tag(self):<\exit>
soup = self.soup("")<\exit>
new_tag = soup.new_tag("foo", bar="baz")<\exit>
self.assertTrue(isinstance(new_tag, Tag))<\exit>
self.assertEqual("foo", new_tag.name)<\exit>
self.assertEqual(dict(bar="baz"), new_tag.attrs)<\exit>
self.assertEqual(None, new_tag.parent)<\exit>
def test_tag_inherits_self_closing_rules_from_builder(self):<\exit>
if XML_BUILDER_PRESENT:<\exit>
xml_soup = BeautifulSoup("", "xml")<\exit>
xml_br = xml_soup.new_tag("br")<\exit>
xml_p = xml_soup.new_tag("p")<\exit>
self.assertEqual(b"<br/>", xml_br.encode())<\exit>
self.assertEqual(b"<p/>", xml_p.encode())<\exit>
html_soup = BeautifulSoup("", "html")<\exit>
html_br = html_soup.new_tag("br")<\exit>
html_p = html_soup.new_tag("p")<\exit>
self.assertEqual(b"<br/>", html_br.encode())<\exit>
self.assertEqual(b"<p></p>", html_p.encode())<\exit>
def test_new_string_creates_navigablestring(self):<\exit>
soup = self.soup("")<\exit>
s = soup.new_string("foo")<\exit>
self.assertEqual("foo", s)<\exit>
self.assertTrue(isinstance(s, NavigableString))<\exit>
class TestTreeModification(SoupTest):<\exit>
def test_attribute_modification(self):<\exit>
soup = self.soup('<a id="1"></a>')<\exit>
soup.a['id'] = 2<\exit>
self.assertEqual(soup.decode(), self.document_for('<a id="2"></a>'))<\exit>
del(soup.a['id'])<\exit>
self.assertEqual(soup.decode(), self.document_for('<a></a>'))<\exit>
soup.a['id2'] = 'foo'<\exit>
self.assertEqual(soup.decode(), self.document_for('<a id2="foo"></a>'))<\exit>
def test_new_tag_creation(self):<\exit>
builder = builder_registry.lookup('html')()<\exit>
soup = self.soup("<body></body>", builder=builder)<\exit>
a = Tag(soup, builder, 'a')<\exit>
ol = Tag(soup, builder, 'ol')<\exit>
a['href'] = 'http://foo.com/'<\exit>
soup.body.insert(0, a)<\exit>
soup.body.insert(1, ol)<\exit>
self.assertEqual(<\exit>
soup.body.encode(),<\exit>
b'<body><a href="http://foo.com/"></a><ol></ol></body>')<\exit>
def test_append_to_contents_moves_tag(self):<\exit>
doc =<\exit>
soup = self.soup(doc)<\exit>
second_para = soup.find(id='2')<\exit>
bold = soup.b<\exit>
soup.find(id='2').append(soup.b)<\exit>
self.assertEqual(bold.parent, second_para)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
'<p id="1">Don\'t leave me .</p>\n'<\exit>
'<p id="2">Don\'t leave!<b>here</b></p>'))<\exit>
def test_replace_with_returns_thing_that_was_replaced(self):<\exit>
text = "<a></a><b><c></c></b>"<\exit>
soup = self.soup(text)<\exit>
a = soup.a<\exit>
new_a = a.replace_with(soup.c)<\exit>
self.assertEqual(a, new_a)<\exit>
def test_unwrap_returns_thing_that_was_replaced(self):<\exit>
text = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(text)<\exit>
a = soup.a<\exit>
new_a = a.unwrap()<\exit>
self.assertEqual(a, new_a)<\exit>
def test_replace_tag_with_itself(self):<\exit>
text = "<a><b></b><c>Foo<d></d></c></a><a><e></e></a>"<\exit>
soup = self.soup(text)<\exit>
c = soup.c<\exit>
soup.c.replace_with(c)<\exit>
self.assertEqual(soup.decode(), self.document_for(text))<\exit>
def test_replace_tag_with_its_parent_raises_exception(self):<\exit>
text = "<a><b></b></a>"<\exit>
soup = self.soup(text)<\exit>
self.assertRaises(ValueError, soup.b.replace_with, soup.a)<\exit>
def test_insert_tag_into_itself_raises_exception(self):<\exit>
text = "<a><b></b></a>"<\exit>
soup = self.soup(text)<\exit>
self.assertRaises(ValueError, soup.a.insert, 0, soup.a)<\exit>
def test_replace_with_maintains_next_element_throughout(self):<\exit>
soup = self.soup('<p><a>one</a><b>three</b></p>')<\exit>
a = soup.a<\exit>
b = a.contents[0]<\exit>
a.insert(1, "two")<\exit>
left, right = a.contents<\exit>
left.replaceWith('')<\exit>
right.replaceWith('')<\exit>
self.assertEqual("three", soup.b.string)<\exit>
def test_replace_final_node(self):<\exit>
soup = self.soup("<b>Argh!</b>")<\exit>
soup.find(text="Argh!").replace_with("Hooray!")<\exit>
new_text = soup.find(text="Hooray!")<\exit>
b = soup.b<\exit>
self.assertEqual(new_text.previous_element, b)<\exit>
self.assertEqual(new_text.parent, b)<\exit>
self.assertEqual(new_text.previous_element.next_element, new_text)<\exit>
self.assertEqual(new_text.next_element, None)<\exit>
def test_consecutive_text_nodes(self):<\exit>
soup = self.soup("<a><b>Argh!</b><c></c></a>")<\exit>
soup.b.insert(1, "Hooray!")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a><b>Argh!Hooray!</b><c></c></a>"))<\exit>
new_text = soup.find(text="Hooray!")<\exit>
self.assertEqual(new_text.previous_element, "Argh!")<\exit>
self.assertEqual(new_text.previous_element.next_element, new_text)<\exit>
self.assertEqual(new_text.previous_sibling, "Argh!")<\exit>
self.assertEqual(new_text.previous_sibling.next_sibling, new_text)<\exit>
self.assertEqual(new_text.next_sibling, None)<\exit>
self.assertEqual(new_text.next_element, soup.c)<\exit>
def test_insert_string(self):<\exit>
soup = self.soup("<a></a>")<\exit>
soup.a.insert(0, "bar")<\exit>
soup.a.insert(0, "foo")<\exit>
self.assertEqual(["foo", "bar"], soup.a.contents)<\exit>
self.assertEqual(soup.a.contents[0].next_element, "bar")<\exit>
def test_insert_tag(self):<\exit>
builder = self.default_builder<\exit>
soup = self.soup(<\exit>
"<a><b>Find</b><c>lady!</c><d></d></a>", builder=builder)<\exit>
magic_tag = Tag(soup, builder, 'magictag')<\exit>
magic_tag.insert(0, "the")<\exit>
soup.a.insert(1, magic_tag)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a><b>Find</b><magictag>the</magictag><c>lady!</c><d></d></a>"))<\exit>
b_tag = soup.b<\exit>
self.assertEqual(b_tag.next_sibling, magic_tag)<\exit>
self.assertEqual(magic_tag.previous_sibling, b_tag)<\exit>
find = b_tag.find(text="Find")<\exit>
self.assertEqual(find.next_element, magic_tag)<\exit>
self.assertEqual(magic_tag.previous_element, find)<\exit>
c_tag = soup.c<\exit>
self.assertEqual(magic_tag.next_sibling, c_tag)<\exit>
self.assertEqual(c_tag.previous_sibling, magic_tag)<\exit>
the = magic_tag.find(text="the")<\exit>
self.assertEqual(the.parent, magic_tag)<\exit>
self.assertEqual(the.next_element, c_tag)<\exit>
self.assertEqual(c_tag.previous_element, the)<\exit>
def test_append_child_thats_already_at_the_end(self):<\exit>
data = "<a><b></b></a>"<\exit>
soup = self.soup(data)<\exit>
soup.a.append(soup.b)<\exit>
self.assertEqual(data, soup.decode())<\exit>
def test_move_tag_to_beginning_of_parent(self):<\exit>
data = "<a><b></b><c></c><d></d></a>"<\exit>
soup = self.soup(data)<\exit>
soup.a.insert(0, soup.d)<\exit>
self.assertEqual("<a><d></d><b></b><c></c></a>", soup.decode())<\exit>
def test_insert_works_on_empty_element_tag(self):<\exit>
soup = self.soup("<br/>")<\exit>
soup.br.insert(1, "Contents")<\exit>
self.assertEqual(str(soup.br), "<br>Contents</br>")<\exit>
def test_insert_before(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
soup.b.insert_before("BAZ")<\exit>
soup.a.insert_before("QUUX")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<a>foo</a>BAZ<b>bar</b>"))<\exit>
soup.a.insert_before(soup.b)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<b>bar</b><a>foo</a>BAZ"))<\exit>
def test_insert_after(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
soup.b.insert_after("BAZ")<\exit>
soup.a.insert_after("QUUX")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<a>foo</a>QUUX<b>bar</b>BAZ"))<\exit>
soup.b.insert_after(soup.a)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("QUUX<b>bar</b><a>foo</a>BAZ"))<\exit>
def test_insert_after_raises_exception_if_after_has_no_meaning(self):<\exit>
soup = self.soup("")<\exit>
tag = soup.new_tag("a")<\exit>
string = soup.new_string("")<\exit>
self.assertRaises(ValueError, string.insert_after, tag)<\exit>
self.assertRaises(NotImplementedError, soup.insert_after, tag)<\exit>
self.assertRaises(ValueError, tag.insert_after, tag)<\exit>
def test_insert_before_raises_notimplementederror_if_before_has_no_meaning(self):<\exit>
soup = self.soup("")<\exit>
tag = soup.new_tag("a")<\exit>
string = soup.new_string("")<\exit>
self.assertRaises(ValueError, string.insert_before, tag)<\exit>
self.assertRaises(NotImplementedError, soup.insert_before, tag)<\exit>
self.assertRaises(ValueError, tag.insert_before, tag)<\exit>
def test_replace_with(self):<\exit>
soup = self.soup(<\exit>
"<p>There's <b>no</b> business like <b>show</b> business</p>")<\exit>
no, show = soup.find_all('b')<\exit>
show.replace_with(no)<\exit>
self.assertEqual(<\exit>
soup.decode(),<\exit>
self.document_for(<\exit>
"<p>There's  business like <b>no</b> business</p>"))<\exit>
self.assertEqual(show.parent, None)<\exit>
self.assertEqual(no.parent, soup.p)<\exit>
self.assertEqual(no.next_element, "no")<\exit>
self.assertEqual(no.next_sibling, " business")<\exit>
def test_replace_first_child(self):<\exit>
data = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(data)<\exit>
soup.b.replace_with(soup.c)<\exit>
self.assertEqual("<a><c></c></a>", soup.decode())<\exit>
def test_replace_last_child(self):<\exit>
data = "<a><b></b><c></c></a>"<\exit>
soup = self.soup(data)<\exit>
soup.c.replace_with(soup.b)<\exit>
self.assertEqual("<a><b></b></a>", soup.decode())<\exit>
def test_nested_tag_replace_with(self):<\exit>
soup = self.soup(<\exit>
)<\exit>
remove_tag = soup.b<\exit>
move_tag = soup.f<\exit>
remove_tag.replace_with(move_tag)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<a>We<f>refuse</f></a><e>to<g>service</g></e>"))<\exit>
self.assertEqual(remove_tag.parent, None)<\exit>
self.assertEqual(remove_tag.find(text="right").next_element, None)<\exit>
self.assertEqual(remove_tag.previous_element, None)<\exit>
self.assertEqual(remove_tag.next_sibling, None)<\exit>
self.assertEqual(remove_tag.previous_sibling, None)<\exit>
self.assertEqual(move_tag.parent, soup.a)<\exit>
self.assertEqual(move_tag.previous_element, "We")<\exit>
self.assertEqual(move_tag.next_element.next_element, soup.e)<\exit>
self.assertEqual(move_tag.next_sibling, None)<\exit>
to_text = soup.find(text="to")<\exit>
g_tag = soup.g<\exit>
self.assertEqual(to_text.next_element, g_tag)<\exit>
self.assertEqual(to_text.next_sibling, g_tag)<\exit>
self.assertEqual(g_tag.previous_element, to_text)<\exit>
self.assertEqual(g_tag.previous_sibling, to_text)<\exit>
def test_unwrap(self):<\exit>
tree = self.soup()<\exit>
tree.em.unwrap()<\exit>
self.assertEqual(tree.em, None)<\exit>
self.assertEqual(tree.p.text, "Unneeded formatting is unneeded")<\exit>
def test_wrap(self):<\exit>
soup = self.soup("I wish I was bold.")<\exit>
value = soup.string.wrap(soup.new_tag("b"))<\exit>
self.assertEqual(value.decode(), "<b>I wish I was bold.</b>")<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<b>I wish I was bold.</b>"))<\exit>
def test_wrap_extracts_tag_from_elsewhere(self):<\exit>
soup = self.soup("<b></b>I wish I was bold.")<\exit>
soup.b.next_sibling.wrap(soup.b)<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for("<b>I wish I was bold.</b>"))<\exit>
def test_wrap_puts_new_contents_at_the_end(self):<\exit>
soup = self.soup("<b>I like being bold.</b>I wish I was bold.")<\exit>
soup.b.next_sibling.wrap(soup.b)<\exit>
self.assertEqual(2, len(soup.b.contents))<\exit>
self.assertEqual(<\exit>
soup.decode(), self.document_for(<\exit>
"<b>I like being bold.I wish I was bold.</b>"))<\exit>
def test_extract(self):<\exit>
soup = self.soup(<\exit>
'<html><body>Some content. <div id="nav">Nav crap</div> More content.</body></html>')<\exit>
self.assertEqual(len(soup.body.contents), 3)<\exit>
extracted = soup.find(id="nav").extract()<\exit>
self.assertEqual(<\exit>
soup.decode(), "<html><body>Some content.  More content.</body></html>")<\exit>
self.assertEqual(extracted.decode(), '<div id="nav">Nav crap</div>')<\exit>
self.assertEqual(len(soup.body.contents), 2)<\exit>
self.assertEqual(extracted.parent, None)<\exit>
self.assertEqual(extracted.previous_element, None)<\exit>
self.assertEqual(extracted.next_element.next_element, None)<\exit>
content_1 = soup.find(text="Some content. ")<\exit>
content_2 = soup.find(text=" More content.")<\exit>
self.assertEqual(content_1.next_element, content_2)<\exit>
self.assertEqual(content_1.next_sibling, content_2)<\exit>
self.assertEqual(content_2.previous_element, content_1)<\exit>
self.assertEqual(content_2.previous_sibling, content_1)<\exit>
def test_extract_distinguishes_between_identical_strings(self):<\exit>
soup = self.soup("<a>foo</a><b>bar</b>")<\exit>
foo_1 = soup.a.string<\exit>
bar_1 = soup.b.string<\exit>
foo_2 = soup.new_string("foo")<\exit>
bar_2 = soup.new_string("bar")<\exit>
soup.a.append(foo_2)<\exit>
soup.b.append(bar_2)<\exit>
foo_1.extract()<\exit>
bar_2.extract()<\exit>
self.assertEqual(foo_2, soup.a.string)<\exit>
self.assertEqual(bar_2, soup.b.string)<\exit>
def test_clear(self):<\exit>
soup = self.soup("<p><a>String <em>Italicized</em></a> and another</p>")<\exit>
a = soup.a<\exit>
soup.p.clear()<\exit>
self.assertEqual(len(soup.p.contents), 0)<\exit>
self.assertTrue(hasattr(a, "contents"))<\exit>
em = a.em<\exit>
a.clear(decompose=True)<\exit>
self.assertFalse(hasattr(em, "contents"))<\exit>
def test_string_set(self):<\exit>
soup = self.soup("<a></a> <b><c></c></b>")<\exit>
soup.a.string = "foo"<\exit>
self.assertEqual(soup.a.contents, ["foo"])<\exit>
soup.b.string = "bar"<\exit>
self.assertEqual(soup.b.contents, ["bar"])<\exit>
def test_string_set_does_not_affect_original_string(self):<\exit>
soup = self.soup("<a><b>foo</b><c>bar</c>")<\exit>
soup.b.string = soup.c.string<\exit>
self.assertEqual(soup.a.encode(), b"<a><b>bar</b><c>bar</c></a>")<\exit>
def test_set_string_preserves_class_of_string(self):<\exit>
soup = self.soup("<a></a>")<\exit>
cdata = CData("foo")<\exit>
soup.a.string = cdata<\exit>
self.assertTrue(isinstance(soup.a.string, CData))<\exit>
class TestElementObjects(SoupTest):<\exit>
def test_len(self):<\exit>
soup = self.soup("<top>1<b>2</b>3</top>")<\exit>
self.assertEqual(len(soup.contents), 1)<\exit>
self.assertEqual(len(soup), 1)<\exit>
self.assertEqual(len(soup.top), 3)<\exit>
self.assertEqual(len(soup.top.contents), 3)<\exit>
def test_member_access_invokes_find(self):<\exit>
soup = self.soup('<b><i></i></b>')<\exit>
self.assertEqual(soup.b, soup.find('b'))<\exit>
self.assertEqual(soup.b.i, soup.find('b').find('i'))<\exit>
self.assertEqual(soup.a, None)<\exit>
def test_deprecated_member_access(self):<\exit>
soup = self.soup('<b><i></i></b>')<\exit>
with warnings.catch_warnings(record=True) as w:<\exit>
tag = soup.bTag<\exit>
self.assertEqual(soup.b, tag)<\exit>
self.assertEqual(<\exit>
'.bTag is deprecated, use .find("b") instead.',<\exit>
str(w[0].message))<\exit>
def test_has_attr(self):<\exit>
soup = self.soup("<foo attr='bar'>")<\exit>
self.assertTrue(soup.foo.has_attr('attr'))<\exit>
self.assertFalse(soup.foo.has_attr('attr2'))<\exit>
def test_attributes_come_out_in_alphabetical_order(self):<\exit>
markup = '<b a="1" z="5" m="3" f="2" y="4"></b>'<\exit>
self.assertSoupEquals(markup, '<b a="1" f="2" m="3" y="4" z="5"></b>')<\exit>
def test_string(self):<\exit>
soup = self.soup("<b>foo</b>")<\exit>
self.assertEqual(soup.b.string, 'foo')<\exit>
def test_empty_tag_has_no_string(self):<\exit>
soup = self.soup("<b></b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
def test_tag_with_multiple_children_has_no_string(self):<\exit>
soup = self.soup("<a>foo<b></b><b></b></b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
soup = self.soup("<a>foo<b></b>bar</b>")<\exit>
self.assertEqual(soup.b.string, None)<\exit>
soup = self.soup("<a>foo</b>")<\exit>
soup.a.insert(1, "bar")<\exit>
self.assertEqual(soup.a.string, None)<\exit>
def test_tag_with_recursive_string_has_string(self):<\exit>
soup = self.soup("<a><b>foo</b></a>")<\exit>
self.assertEqual(soup.a.string, "foo")<\exit>
self.assertEqual(soup.string, "foo")<\exit>
def test_lack_of_string(self):<\exit>
soup = self.soup("<b>f<i>e</i>o</b>")<\exit>
self.assertFalse(soup.b.string)<\exit>
soup = self.soup("<b></b>")<\exit>
self.assertFalse(soup.b.string)<\exit>
def test_all_text(self):<\exit>
soup = self.soup("<a>a<b>r</b>   <r> t </r></a>")<\exit>
self.assertEqual(soup.a.text, "ar  t ")<\exit>
self.assertEqual(soup.a.get_text(strip=True), "art")<\exit>
self.assertEqual(soup.a.get_text(","), "a,r, , t ")<\exit>
self.assertEqual(soup.a.get_text(",", strip=True), "a,r,t")<\exit>
class TestCDAtaListAttributes(SoupTest):<\exit>
def test_single_value_becomes_list(self):<\exit>
soup = self.soup("<a class='foo'>")<\exit>
self.assertEqual(["foo"],soup.a['class'])<\exit>
def test_multiple_values_becomes_list(self):<\exit>
soup = self.soup("<a class='foo bar'>")<\exit>
self.assertEqual(["foo", "bar"], soup.a['class'])<\exit>
def test_multiple_values_separated_by_weird_whitespace(self):<\exit>
soup = self.soup("<a class='foo\tbar\nbaz'>")<\exit>
self.assertEqual(["foo", "bar", "baz"],soup.a['class'])<\exit>
def test_attributes_joined_into_string_on_output(self):<\exit>
soup = self.soup("<a class='foo\tbar'>")<\exit>
self.assertEqual(b'<a class="foo bar"></a>', soup.a.encode())<\exit>
def test_accept_charset(self):<\exit>
soup = self.soup('<form accept-charset="ISO-8859-1 UTF-8">')<\exit>
self.assertEqual(['ISO-8859-1', 'UTF-8'], soup.form['accept-charset'])<\exit>
def test_cdata_attribute_applying_only_to_one_tag(self):<\exit>
data = '<a accept-charset="ISO-8859-1 UTF-8"></a>'<\exit>
soup = self.soup(data)<\exit>
self.assertEqual('ISO-8859-1 UTF-8', soup.a['accept-charset'])<\exit>
class TestPersistence(SoupTest):<\exit>
"Testing features like pickle and deepcopy."<\exit>
def setUp(self):<\exit>
super(TestPersistence, self).setUp()<\exit>
self.page =<\exit>
self.tree = self.soup(self.page)<\exit>
def test_pickle_and_unpickle_identity(self):<\exit>
dumped = pickle.dumps(self.tree, 2)<\exit>
loaded = pickle.loads(dumped)<\exit>
self.assertEqual(loaded.__class__, BeautifulSoup)<\exit>
self.assertEqual(loaded.decode(), self.tree.decode())<\exit>
def test_deepcopy_identity(self):<\exit>
copied = copy.deepcopy(self.tree)<\exit>
self.assertEqual(copied.decode(), self.tree.decode())<\exit>
def test_unicode_pickle(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
dumped = pickle.dumps(soup, pickle.HIGHEST_PROTOCOL)<\exit>
loaded = pickle.loads(dumped)<\exit>
self.assertEqual(loaded.decode(), soup.decode())<\exit>
class TestSubstitutions(SoupTest):<\exit>
def test_default_formatter_is_minimal(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="minimal")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(<\exit>
u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_html(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="html")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for("<b>&lt;&lt;Sacr&eacute; bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_minimal(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter="minimal")<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(<\exit>
u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"))<\exit>
def test_formatter_null(self):<\exit>
markup = u"<b>&lt;&lt;Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!&gt;&gt;</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter=None)<\exit>
self.assertEqual(decoded,<\exit>
self.document_for(u"<b><<Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!>></b>"))<\exit>
def test_formatter_custom(self):<\exit>
markup = u"<b>&lt;foo&gt;</b><b>bar</b>"<\exit>
soup = self.soup(markup)<\exit>
decoded = soup.decode(formatter = lambda x: x.upper())<\exit>
self.assertEqual(<\exit>
decoded,<\exit>
self.document_for(u"<b><FOO></b><b>BAR</b>"))<\exit>
def test_formatter_is_run_on_attribute_values(self):<\exit>
markup = u'<a href="http://a.com?a=b&c=鑼">e</a>'<\exit>
soup = self.soup(markup)<\exit>
a = soup.a<\exit>
expect_minimal = u'<a href="http://a.com?a=b&amp;c=鑼">e</a>'<\exit>
self.assertEqual(expect_minimal, a.decode())<\exit>
self.assertEqual(expect_minimal, a.decode(formatter="minimal"))<\exit>
expect_html = u'<a href="http://a.com?a=b&amp;c=&eacute;">e</a>'<\exit>
self.assertEqual(expect_html, a.decode(formatter="html"))<\exit>
self.assertEqual(markup, a.decode(formatter=None))<\exit>
expect_upper = u'<a href="HTTP://A.COM?A=B&C=鑴">E</a>'<\exit>
self.assertEqual(expect_upper, a.decode(formatter=lambda x: x.upper()))<\exit>
def test_prettify_accepts_formatter(self):<\exit>
soup = BeautifulSoup("<html><body>foo</body></html>")<\exit>
pretty = soup.prettify(formatter = lambda x: x.upper())<\exit>
self.assertTrue("FOO" in pretty)<\exit>
def test_prettify_outputs_unicode_by_default(self):<\exit>
soup = self.soup("<a></a>")<\exit>
self.assertEqual(unicode, type(soup.prettify()))<\exit>
def test_prettify_can_encode_data(self):<\exit>
soup = self.soup("<a></a>")<\exit>
self.assertEqual(bytes, type(soup.prettify("utf-8")))<\exit>
def test_html_entity_substitution_off_by_default(self):<\exit>
markup = u"<b>Sacr\N{LATIN SMALL LETTER E WITH ACUTE} bleu!</b>"<\exit>
soup = self.soup(markup)<\exit>
encoded = soup.b.encode("utf-8")<\exit>
self.assertEqual(encoded, markup.encode('utf-8'))<\exit>
def test_encoding_substitution(self):<\exit>
meta_tag = ('<meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/>')<\exit>
soup = self.soup(meta_tag)<\exit>
self.assertEqual(soup.meta['content'], 'text/html; charset=x-sjis')<\exit>
utf_8 = soup.encode("utf-8")<\exit>
self.assertTrue(b"charset=utf-8" in utf_8)<\exit>
euc_jp = soup.encode("euc_jp")<\exit>
self.assertTrue(b"charset=euc_jp" in euc_jp)<\exit>
shift_jis = soup.encode("shift-jis")<\exit>
self.assertTrue(b"charset=shift-jis" in shift_jis)<\exit>
utf_16_u = soup.encode("utf-16").decode("utf-16")<\exit>
self.assertTrue("charset=utf-16" in utf_16_u)<\exit>
def test_encoding_substitution_doesnt_happen_if_tag_is_strained(self):<\exit>
markup = ('<head><meta content="text/html; charset=x-sjis" '<\exit>
'http-equiv="Content-type"/></head><pre>foo</pre>')<\exit>
strainer = SoupStrainer('pre')<\exit>
soup = self.soup(markup, parse_only=strainer)<\exit>
self.assertEqual(soup.contents[0].name, 'pre')<\exit>
class TestEncoding(SoupTest):<\exit>
def test_unicode_string_can_be_encoded(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(soup.b.string.encode("utf-8"),<\exit>
u"\N{SNOWMAN}".encode("utf-8"))<\exit>
def test_tag_containing_unicode_string_can_be_encoded(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
soup.b.encode("utf-8"), html.encode("utf-8"))<\exit>
def test_encoding_substitutes_unrecognized_characters_by_default(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(soup.b.encode("ascii"), b"<b>&<\exit>
def test_encoding_can_be_made_strict(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertRaises(<\exit>
UnicodeEncodeError, soup.encode, "ascii", errors="strict")<\exit>
def test_decode_contents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(u"\N{SNOWMAN}", soup.b.decode_contents())<\exit>
def test_encode_contents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
u"\N{SNOWMAN}".encode("utf8"), soup.b.encode_contents(<\exit>
encoding="utf8"))<\exit>
def test_deprecated_renderContents(self):<\exit>
html = u"<b>\N{SNOWMAN}</b>"<\exit>
soup = self.soup(html)<\exit>
self.assertEqual(<\exit>
u"\N{SNOWMAN}".encode("utf8"), soup.b.renderContents())<\exit>
class TestNavigableStringSubclasses(SoupTest):<\exit>
def test_cdata(self):<\exit>
soup = self.soup("")<\exit>
cdata = CData("foo")<\exit>
soup.insert(1, cdata)<\exit>
self.assertEqual(str(soup), "<![CDATA[foo]]>")<\exit>
self.assertEqual(soup.find(text="foo"), "foo")<\exit>
self.assertEqual(soup.contents[0], "foo")<\exit>
def test_cdata_is_never_formatted(self):<\exit>
self.count = 0<\exit>
def increment(*args):<\exit>
self.count += 1<\exit>
return "BITTER FAILURE"<\exit>
soup = self.soup("")<\exit>
cdata = CData("<><><>")<\exit>
soup.insert(1, cdata)<\exit>
self.assertEqual(<\exit>
b"<![CDATA[<><><>]]>", soup.encode(formatter=increment))<\exit>
self.assertEqual(1, self.count)<\exit>
def test_doctype_ends_in_newline(self):<\exit>
doctype = Doctype("foo")<\exit>
soup = self.soup("")<\exit>
soup.insert(1, doctype)<\exit>
self.assertEqual(soup.encode(), b"<!DOCTYPE foo>\n")<\exit>
class TestSoupSelector(TreeTest):<\exit>
HTML =<\exit>
def setUp(self):<\exit>
self.soup = BeautifulSoup(self.HTML)<\exit>
def assertSelects(self, selector, expected_ids):<\exit>
el_ids = [el['id'] for el in self.soup.select(selector)]<\exit>
el_ids.sort()<\exit>
expected_ids.sort()<\exit>
self.assertEqual(expected_ids, el_ids,<\exit>
"Selector %s, expected [%s], got [%s]" % (<\exit>
selector, ', '.join(expected_ids), ', '.join(el_ids)<\exit>
)<\exit>
)<\exit>
assertSelect = assertSelects<\exit>
def assertSelectMultiple(self, *tests):<\exit>
for selector, expected_ids in tests:<\exit>
self.assertSelect(selector, expected_ids)<\exit>
def test_one_tag_one(self):<\exit>
els = self.soup.select('title')<\exit>
self.assertEqual(len(els), 1)<\exit>
self.assertEqual(els[0].name, 'title')<\exit>
self.assertEqual(els[0].contents, [u'The title'])<\exit>
def test_one_tag_many(self):<\exit>
els = self.soup.select('div')<\exit>
self.assertEqual(len(els), 3)<\exit>
for div in els:<\exit>
self.assertEqual(div.name, 'div')<\exit>
def test_tag_in_tag_one(self):<\exit>
els = self.soup.select('div div')<\exit>
self.assertSelects('div div', ['inner'])<\exit>
def test_tag_in_tag_many(self):<\exit>
for selector in ('html div', 'html body div', 'body div'):<\exit>
self.assertSelects(selector, ['main', 'inner', 'footer'])<\exit>
def test_tag_no_match(self):<\exit>
self.assertEqual(len(self.soup.select('del')), 0)<\exit>
def test_invalid_tag(self):<\exit>
self.assertEqual(len(self.soup.select('tag%t')), 0)<\exit>
def test_header_tags(self):<\exit>
self.assertSelectMultiple(<\exit>
('h1', ['header1']),<\exit>
('h2', ['header2', 'header3']),<\exit>
)<\exit>
def test_class_one(self):<\exit>
for selector in ('.onep', 'p.onep', 'html p.onep'):<\exit>
els = self.soup.select(selector)<\exit>
self.assertEqual(len(els), 1)<\exit>
self.assertEqual(els[0].name, 'p')<\exit>
self.assertEqual(els[0]['class'], ['onep'])<\exit>
def test_class_mismatched_tag(self):<\exit>
els = self.soup.select('div.onep')<\exit>
self.assertEqual(len(els), 0)<\exit>
def test_one_id(self):<\exit>
for selector in ('div<\exit>
self.assertSelects(selector, ['inner'])<\exit>
def test_bad_id(self):<\exit>
els = self.soup.select('#doesnotexist')<\exit>
self.assertEqual(len(els), 0)<\exit>
def test_items_in_id(self):<\exit>
els = self.soup.select('div<\exit>
self.assertEqual(len(els), 3)<\exit>
for el in els:<\exit>
self.assertEqual(el.name, 'p')<\exit>
self.assertEqual(els[1]['class'], ['onep'])<\exit>
self.assertFalse(els[0].has_key('class'))<\exit>
def test_a_bunch_of_emptys(self):<\exit>
for selector in ('div<\exit>
self.assertEqual(len(self.soup.select(selector)), 0)<\exit>
def test_multi_class_support(self):<\exit>
for selector in ('.class1', 'p.class1', '.class2', 'p.class2',<\exit>
'.class3', 'p.class3', 'html p.class2', 'div<\exit>
self.assertSelects(selector, ['pmulti'])<\exit>
def test_multi_class_selection(self):<\exit>
for selector in ('.class1.class3', '.class3.class2',<\exit>
'.class1.class2.class3'):<\exit>
self.assertSelects(selector, ['pmulti'])<\exit>
def test_child_selector(self):<\exit>
self.assertSelects('.s1 > a', ['s1a1', 's1a2'])<\exit>
self.assertSelects('.s1 > a span', ['s1a2s1'])<\exit>
def test_attribute_equals(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[class="onep"]', ['p1']),<\exit>
('p[id="p1"]', ['p1']),<\exit>
('[class="onep"]', ['p1']),<\exit>
('[id="p1"]', ['p1']),<\exit>
('link[rel="stylesheet"]', ['l1']),<\exit>
('link[type="text/css"]', ['l1']),<\exit>
('link[href="blah.css"]', ['l1']),<\exit>
('link[href="no-blah.css"]', []),<\exit>
('[rel="stylesheet"]', ['l1']),<\exit>
('[type="text/css"]', ['l1']),<\exit>
('[href="blah.css"]', ['l1']),<\exit>
('[href="no-blah.css"]', []),<\exit>
('p[href="no-blah.css"]', []),<\exit>
('[href="no-blah.css"]', []),<\exit>
)<\exit>
def test_attribute_tilde(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[class~="class1"]', ['pmulti']),<\exit>
('p[class~="class2"]', ['pmulti']),<\exit>
('p[class~="class3"]', ['pmulti']),<\exit>
('[class~="class1"]', ['pmulti']),<\exit>
('[class~="class2"]', ['pmulti']),<\exit>
('[class~="class3"]', ['pmulti']),<\exit>
('a[rel~="friend"]', ['bob']),<\exit>
('a[rel~="met"]', ['bob']),<\exit>
('[rel~="friend"]', ['bob']),<\exit>
('[rel~="met"]', ['bob']),<\exit>
)<\exit>
def test_attribute_startswith(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel^="style"]', ['l1']),<\exit>
('link[rel^="style"]', ['l1']),<\exit>
('notlink[rel^="notstyle"]', []),<\exit>
('[rel^="notstyle"]', []),<\exit>
('link[rel^="notstyle"]', []),<\exit>
('link[href^="bla"]', ['l1']),<\exit>
('a[href^="http://"]', ['bob', 'me']),<\exit>
('[href^="http://"]', ['bob', 'me']),<\exit>
('[id^="p"]', ['pmulti', 'p1']),<\exit>
('[id^="m"]', ['me', 'main']),<\exit>
('div[id^="m"]', ['main']),<\exit>
('a[id^="m"]', ['me']),<\exit>
)<\exit>
def test_attribute_endswith(self):<\exit>
self.assertSelectMultiple(<\exit>
('[href$=".css"]', ['l1']),<\exit>
('link[href$=".css"]', ['l1']),<\exit>
('link[id$="1"]', ['l1']),<\exit>
('[id$="1"]', ['l1', 'p1', 'header1', 's1a1', 's2a1', 's1a2s1']),<\exit>
('div[id$="1"]', []),<\exit>
('[id$="noending"]', []),<\exit>
)<\exit>
def test_attribute_contains(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel*="style"]', ['l1']),<\exit>
('link[rel*="style"]', ['l1']),<\exit>
('notlink[rel*="notstyle"]', []),<\exit>
('[rel*="notstyle"]', []),<\exit>
('link[rel*="notstyle"]', []),<\exit>
('link[href*="bla"]', ['l1']),<\exit>
('a[href*="http://"]', ['bob', 'me']),<\exit>
('[href*="http://"]', ['bob', 'me']),<\exit>
('[id*="p"]', ['pmulti', 'p1']),<\exit>
('div[id*="m"]', ['main']),<\exit>
('a[id*="m"]', ['me']),<\exit>
('[href*=".css"]', ['l1']),<\exit>
('link[href*=".css"]', ['l1']),<\exit>
('link[id*="1"]', ['l1']),<\exit>
('[id*="1"]', ['l1', 'p1', 'header1', 's1a1', 's1a2', 's2a1', 's1a2s1']),<\exit>
('div[id*="1"]', []),<\exit>
('[id*="noending"]', []),<\exit>
('[href*="."]', ['bob', 'me', 'l1']),<\exit>
('a[href*="."]', ['bob', 'me']),<\exit>
('link[href*="."]', ['l1']),<\exit>
('div[id*="n"]', ['main', 'inner']),<\exit>
('div[id*="nn"]', ['inner']),<\exit>
)<\exit>
def test_attribute_exact_or_hypen(self):<\exit>
self.assertSelectMultiple(<\exit>
('p[lang|="en"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),<\exit>
('[lang|="en"]', ['lang-en', 'lang-en-gb', 'lang-en-us']),<\exit>
('p[lang|="fr"]', ['lang-fr']),<\exit>
('p[lang|="gb"]', []),<\exit>
)<\exit>
def test_attribute_exists(self):<\exit>
self.assertSelectMultiple(<\exit>
('[rel]', ['l1', 'bob', 'me']),<\exit>
('link[rel]', ['l1']),<\exit>
('a[rel]', ['bob', 'me']),<\exit>
('[lang]', ['lang-en', 'lang-en-gb', 'lang-en-us', 'lang-fr']),<\exit>
('p[class]', ['p1', 'pmulti']),<\exit>
('[blah]', []),<\exit>
('p[blah]', []),<\exit>
)<\exit>
def test_select_on_element(self):<\exit>
inner = self.soup.find("div", id="main")<\exit>
selected = inner.select("div")<\exit>
self.assertSelectsIDs(selected, ['inner'])<\exit>
from unittest import TestCase<\exit>
import multiprocessing as mp<\exit>
import random<\exit>
import string<\exit>
class TestCounter(TestCase):<\exit>
def test_increment(self):<\exit>
pass<\exit>
def test_value(self):<\exit>
pass<\exit>
def cube(x):<\exit>
return x**3<\exit>
class TestMp(TestCase):<\exit>
def rand_string(self, length, output):<\exit>
rand_str = ''.join(random.choice(<\exit>
string.ascii_lowercase<\exit>
+ string.ascii_uppercase<\exit>
+ string.digits) for _ in range(length))<\exit>
output.put(rand_str)<\exit>
def test_generate_random_str(self):<\exit>
output = mp.Queue()<\exit>
processes = [mp.Process(target=self.rand_string, args=(5, output)) for x in range(4)]<\exit>
for p in processes:<\exit>
p.start()<\exit>
for p in processes:<\exit>
p.join()<\exit>
results = [output.get() for p in processes]<\exit>
self.assertEqual(len(results), 4)<\exit>
self.assertTrue(all(map(lambda x: len(x)==5, results)))<\exit>
def test_pool(self):<\exit>
expected = [1, 8, 27, 64, 125, 216]<\exit>
pool = mp.Pool(processes=4)<\exit>
results = [pool.apply(cube, args=(x,)) for x in range(1, 7)]<\exit>
self.assertEqual(results, expected)<\exit>
pool = mp.Pool(processes=4)<\exit>
results = pool.map(cube, range(1, 7))<\exit>
self.assertEqual(results, expected)<\exit>
pool = mp.Pool(processes=4)<\exit>
results = [pool.apply_async(cube, args=(x,)) for x in range(1, 7)]<\exit>
output = [p.get() for p in results]<\exit>
self.assertEqual(output, expected)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
total, n, lst = cipher<\exit>
f = [[0 for _ in xrange(n)] for _ in xrange(total + 1)]<\exit>
for i in xrange(n):<\exit>
if lst[i] < total + 1:<\exit>
f[lst[i]][i] = 1<\exit>
for k in xrange(1, total + 1):<\exit>
for i in reversed(xrange(n)):<\exit>
if k - lst[i] >= 0:<\exit>
f[k][i] += f[k - lst[i]][i]<\exit>
if i + 1 < n:<\exit>
f[k][i] += f[k][i + 1]<\exit>
return f[total][0]<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
solution = Solution()<\exit>
N, M = map(int, f.readline().strip().split(' '))<\exit>
lst = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, M, lst<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
matrix, pattern = cipher<\exit>
R1, C1 = len(matrix), len(matrix[0])<\exit>
R2, C2 = len(pattern), len(pattern[0])<\exit>
dp = [[0 for _ in xrange(C1 + 1)] for _ in xrange(R1 + 1)]<\exit>
for i in xrange(1, R1 + 1):<\exit>
for j in xrange(1, C1 + 1):<\exit>
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]<\exit>
pattern_sum = sum([sum(pattern[i]) for i in xrange(R2)])<\exit>
for i in xrange(R1 - R2 + 1):<\exit>
for j in xrange(C1 - C2 + 1):<\exit>
bottom = i + R2<\exit>
left = j + C2<\exit>
candidate_sum = dp[bottom][left] - dp[bottom][j] - dp[i][left] + dp[i][j]<\exit>
if candidate_sum == pattern_sum:<\exit>
matched = True<\exit>
for a in xrange(R2):<\exit>
for b in xrange(C2):<\exit>
if matrix[i + a][j + b] != pattern[a][b]:<\exit>
matched = False<\exit>
break<\exit>
if not matched:<\exit>
break<\exit>
if matched:<\exit>
return "YES"<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
matrix = []<\exit>
pattern = []<\exit>
R, C = map(int, f.readline().strip().split(' '))<\exit>
for i in xrange(R):<\exit>
matrix.append(map(int, list(f.readline().strip())))<\exit>
R, C = map(int, f.readline().strip().split(' '))<\exit>
for i in xrange(R):<\exit>
pattern.append(map(int, list(f.readline().strip())))<\exit>
cipher = matrix, pattern<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
start_ptr = 0<\exit>
end_ptr = len(cipher) - 1<\exit>
cnt = 0<\exit>
while start_ptr < end_ptr:<\exit>
ord1 = ord(cipher[start_ptr]) - ord('a')<\exit>
ord2 = ord(cipher[end_ptr]) - ord('a')<\exit>
cnt += abs(ord1 - ord2)<\exit>
start_ptr += 1<\exit>
end_ptr -= 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip()<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import sys<\exit>
class Solution:<\exit>
def smallestDifference(self, A, B):<\exit>
A.sort()<\exit>
B.sort()<\exit>
ret = sys.maxint<\exit>
for a in A:<\exit>
idx = self.bin_search(a, B)<\exit>
ret = min(ret, abs(a-B[idx]))<\exit>
if idx+1<len(B):<\exit>
ret = min(ret, abs(a-B[idx+1]))<\exit>
return ret<\exit>
def bin_search(self, t, A):<\exit>
l = 0<\exit>
u = len(A)<\exit>
while l<u:<\exit>
m = (l+u)/2<\exit>
if A[m]==t:<\exit>
return m<\exit>
elif A[m]>t:<\exit>
u = m<\exit>
else:<\exit>
l = m+1<\exit>
return l-1<\exit>
if __name__=="__main__":<\exit>
print Solution().smallestDifference([3, 4, 6, 7], [2, 3, 8, 9])<\exit>
import signal<\exit>
def signal_handler(signum, frame):<\exit>
raise Exception("Timed out!")<\exit>
signal.signal(signal.SIGALRM, signal_handler)<\exit>
signal.alarm(10)<\exit>
try:<\exit>
while True:<\exit>
pass<\exit>
except Exception, msg:<\exit>
print "Timed out!"<\exit>
signal.alarm(0)<\exit>
import datetime<\exit>
class Timer(object):<\exit>
def __init__(self):<\exit>
self.s = None<\exit>
self.e = None<\exit>
def start(self):<\exit>
self.s = datetime.datetime.now()<\exit>
return self.s<\exit>
def end(self):<\exit>
self.e = datetime.datetime.now()<\exit>
return self.e - self.s<\exit>
class DirectedGraphNode:<\exit>
def __init__(self, x):<\exit>
self.label = x<\exit>
self.neighbors = []<\exit>
class Solution:<\exit>
def topSort_error(self, graph):<\exit>
node2neighbors = {}<\exit>
for node in graph:<\exit>
node2neighbors[node] = set(node.neighbors)<\exit>
def cmp(a, b):<\exit>
if a in node2neighbors[b]:<\exit>
return 1<\exit>
if b in node2neighbors[a]:<\exit>
return -1<\exit>
return 0<\exit>
graph.sort(cmp=cmp)<\exit>
return graph<\exit>
def topSort_normal(self, graph):<\exit>
pi = {}<\exit>
for node in graph:<\exit>
pi[node] = set()<\exit>
for node in graph:<\exit>
for nbr in node.neighbors:<\exit>
pi[nbr].add(node)<\exit>
ret = []<\exit>
while graph:<\exit>
i = 0<\exit>
while i<len(graph):<\exit>
if len(pi[graph[i]])!=0:<\exit>
i += 1<\exit>
else:<\exit>
ret.append(graph[i])<\exit>
for nbr in graph[i].neighbors:<\exit>
if graph[i] in pi[nbr]:<\exit>
pi[nbr].remove(graph[i])<\exit>
graph.pop(i)<\exit>
return ret<\exit>
def topSort(self, graph):<\exit>
unvisited = set(graph)<\exit>
ret = []<\exit>
while unvisited:<\exit>
cur = unvisited.copy().pop()<\exit>
self.dfs(cur, unvisited, ret)<\exit>
return ret<\exit>
def dfs(self, cur, unvisited, ret):<\exit>
for nbr in cur.neighbors:<\exit>
if nbr in unvisited:<\exit>
self.dfs(nbr, unvisited, ret)<\exit>
ret.push(0, cur)<\exit>
unvisited.remove(cur)<\exit>
from __future__ import generators<\exit>
__version__ = '$Revision: 0.9 $'<\exit>
__date__ = '$Date: 2007/03/27 04:15:26 $'<\exit>
__credits__ =<\exit>
try:<\exit>
set<\exit>
except NameError:<\exit>
from sets import Set as set<\exit>
from rad_util import is_rotated<\exit>
class CycleError(Exception):<\exit>
pass<\exit>
def topsort(pairlist):<\exit>
num_parents = {}<\exit>
children = {}<\exit>
for parent, child in pairlist:<\exit>
if not num_parents.has_key( parent ):<\exit>
num_parents[parent] = 0<\exit>
if not num_parents.has_key( child ):<\exit>
num_parents[child] = 0<\exit>
num_parents[child] += 1<\exit>
children.setdefault(parent, []).append(child)<\exit>
answer = [x for x in num_parents.keys() if num_parents[x] == 0]<\exit>
for parent in answer:<\exit>
del num_parents[parent]<\exit>
if children.has_key( parent ):<\exit>
for child in children[parent]:<\exit>
num_parents[child] -= 1<\exit>
if num_parents[child] == 0:<\exit>
answer.append( child )<\exit>
del children[parent]<\exit>
if num_parents:<\exit>
raise CycleError(answer, num_parents, children)<\exit>
return answer<\exit>
def topsort_levels(pairlist):<\exit>
num_parents = {}<\exit>
children = {}<\exit>
for parent, child in pairlist:<\exit>
if not num_parents.has_key( parent ):<\exit>
num_parents[parent] = 0<\exit>
if not num_parents.has_key( child ):<\exit>
num_parents[child] = 0<\exit>
num_parents[child] += 1<\exit>
children.setdefault(parent, []).append(child)<\exit>
return topsort_levels_core(num_parents, children)<\exit>
def topsort_levels_core(num_parents, children):<\exit>
while 1:<\exit>
level_parents = [x for x in num_parents.keys() if num_parents[x] == 0]<\exit>
if not level_parents:<\exit>
break<\exit>
yield level_parents<\exit>
for level_parent in level_parents:<\exit>
del num_parents[level_parent]<\exit>
if children.has_key(level_parent):<\exit>
for level_parent_child in children[level_parent]:<\exit>
num_parents[level_parent_child] -= 1<\exit>
del children[level_parent]<\exit>
if num_parents:<\exit>
raise CycleError(num_parents, children)<\exit>
else:<\exit>
raise StopIteration<\exit>
def find_cycles(parent_children):<\exit>
cycles = []<\exit>
visited_nodes = set()<\exit>
for parent in parent_children:<\exit>
if parent in visited_nodes:<\exit>
continue<\exit>
paths = [[parent]]<\exit>
while paths:<\exit>
path = paths.pop()<\exit>
parent = path[-1]<\exit>
try:<\exit>
children = parent_children[parent]<\exit>
except KeyError:<\exit>
continue<\exit>
for child in children:<\exit>
if child in path:<\exit>
cycle = path[path.index(child):]<\exit>
is_dup = False<\exit>
for other_cycle in cycles:<\exit>
if is_rotated(other_cycle, cycle):<\exit>
is_dup = True<\exit>
break<\exit>
if not is_dup:<\exit>
cycles.append(cycle)<\exit>
yield cycle<\exit>
else:<\exit>
paths.append(path + [child])<\exit>
visited_nodes.add(child)<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
import doctest<\exit>
doctest.testmod(sys.modules['__main__'])<\exit>
import heapq<\exit>
class Cell:<\exit>
def __init__(self, i, j, h):<\exit>
self.i = i<\exit>
self.j = j<\exit>
self.h = h<\exit>
def __cmp__(self, other):<\exit>
return self.h - other.h<\exit>
class Solution(object):<\exit>
def __init__(self):<\exit>
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]<\exit>
def trapRainWater(self, mat):<\exit>
if not mat: return 0<\exit>
m, n = len(mat), len(mat[0])<\exit>
visited = [[False for _ in xrange(n)] for _ in xrange(m)]<\exit>
h = []<\exit>
for i in xrange(m):<\exit>
visited[i][0] = True<\exit>
heapq.heappush(h, Cell(i, 0, mat[i][0]))<\exit>
visited[i][n-1] = True<\exit>
heapq.heappush(h, Cell(i, n-1, mat[i][n-1]))<\exit>
for j in xrange(1, n-1):<\exit>
visited[0][j] = True<\exit>
heapq.heappush(h, Cell(0, j, mat[0][j]))<\exit>
visited[m-1][j] = True<\exit>
heapq.heappush(h, Cell(m-1, j, mat[m-1][j]))<\exit>
trapped = 0<\exit>
while h:<\exit>
cur = heapq.heappop(h)<\exit>
for dir in self.dirs:<\exit>
I, J = cur.i+dir[0], cur.j+dir[1]<\exit>
if 0 <= I < m and 0 <= J < n and not visited[I][J]:<\exit>
nxt = Cell(I, J, mat[I][J])<\exit>
if nxt.h < cur.h:<\exit>
trapped += cur.h - nxt.h<\exit>
nxt.h = cur.h<\exit>
visited[I][J] = True<\exit>
heapq.heappush(h, nxt)<\exit>
return trapped<\exit>
if __name__ == "__main__":<\exit>
assert Solution().trapRainWater([<\exit>
[12, 13, 0, 12],<\exit>
[13, 4, 13, 12],<\exit>
[13, 8, 10, 12],<\exit>
[12, 13, 12, 12],<\exit>
[13, 13, 13, 13]]<\exit>
) == 14<\exit>
assert Solution().trapRainWater([[9, 1, 10, 10], [9, 1, 2, 8], [2, 6, 5, 0], [6, 0, 9, 0]]) == 0<\exit>
class TreeNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Traverser(object):<\exit>
def morris_inorder(self, root):<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
def morris_preorder(self, root):<\exit>
cur = root<\exit>
while cur:<\exit>
if not cur.left:<\exit>
self.consume(cur)<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
self.consume(cur)<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
cur = cur.right<\exit>
def morris_postorder(self, root):<\exit>
dummy = TreeNode(0)<\exit>
dummy.left = root<\exit>
cur = dummy<\exit>
while cur:<\exit>
if not cur.left:<\exit>
cur = cur.right<\exit>
else:<\exit>
pre = cur.left<\exit>
while pre.right and pre.right != cur:<\exit>
pre = pre.right<\exit>
if not pre.right:<\exit>
pre.right = cur<\exit>
cur = cur.left<\exit>
else:<\exit>
pre.right = None<\exit>
self.consume_path(cur.left, pre)<\exit>
cur = cur.right<\exit>
def _reverse(self, fr, to):<\exit>
if fr == to: return<\exit>
cur = fr<\exit>
nxt = cur.right<\exit>
while cur and nxt and cur != to:<\exit>
nxt.right, cur, nxt = cur, nxt, nxt.right<\exit>
def consume_path(self, fr, to):<\exit>
self._reverse(fr, to)<\exit>
cur = to<\exit>
self.consume(cur)<\exit>
while cur != fr:<\exit>
cur = cur.right<\exit>
self.consume(cur)<\exit>
self._reverse(to, fr)<\exit>
def consume(self, node):<\exit>
print node.val<\exit>
if __name__ == "__main__":<\exit>
root = TreeNode(6)<\exit>
root.left = TreeNode(2)<\exit>
root.left.left = TreeNode(1)<\exit>
root.left.right = TreeNode(4)<\exit>
root.left.right.left = TreeNode(3)<\exit>
root.left.right.right = TreeNode(5)<\exit>
root.right = TreeNode(7)<\exit>
root.right.right = TreeNode(9)<\exit>
root.right.right.left = TreeNode(8)<\exit>
traverser = Traverser()<\exit>
print traverser.morris_inorder.__name__<\exit>
traverser.morris_inorder(root)<\exit>
print traverser.morris_preorder.__name__<\exit>
traverser.morris_preorder(root)<\exit>
print traverser.morris_postorder.__name__<\exit>
traverser.morris_postorder(root)<\exit>
class Solution:<\exit>
def triangleCount(self, S):<\exit>
S.sort()<\exit>
cnt = 0<\exit>
for h in xrange(len(S)-1, 1, -1):<\exit>
s = 0<\exit>
e = h-1<\exit>
while s<e:<\exit>
if S[s]+S[e]>S[h]:<\exit>
cnt += e-s<\exit>
e -= 1<\exit>
else:<\exit>
s += 1<\exit>
return cnt<\exit>
if __name__ == "__main__":<\exit>
assert Solution().triangleCount([3, 4, 6, 7]) == 3<\exit>
from httplib import HTTPConnection, HTTPSConnection<\exit>
from httplib import FORBIDDEN, MOVED_PERMANENTLY, NOT_FOUND, OK, TEMPORARY_REDIRECT<\exit>
from sys import stderr<\exit>
from urlparse import urlparse<\exit>
CONNECTION_BY_SCHEME = {<\exit>
'http': HTTPConnection,<\exit>
'https': HTTPSConnection,<\exit>
}<\exit>
def _request_wrap(conn, method, url, body=None,<\exit>
headers=None):<\exit>
depth = 0<\exit>
curr_conn = conn<\exit>
curr_url = url<\exit>
while depth < 100:<\exit>
curr_conn.request(method, curr_url, body,<\exit>
headers=headers if headers is not None else {})<\exit>
res = curr_conn.getresponse()<\exit>
if res.status not in (MOVED_PERMANENTLY, TEMPORARY_REDIRECT, ):<\exit>
return res<\exit>
res.read()<\exit>
res_headers = dict(res.getheaders())<\exit>
url_soup = urlparse(res_headers['location'])<\exit>
try:<\exit>
curr_conn = CONNECTION_BY_SCHEME[url_soup.scheme](url_soup.netloc)<\exit>
except KeyError:<\exit>
assert False, 'redirected to unknown scheme, dying'<\exit>
curr_url = url_soup.path<\exit>
depth += 1<\exit>
assert False, 'redirects and moves lead us astray, dying'<\exit>
def main(args):<\exit>
if len(args) != 2:<\exit>
print >> stderr, 'Usage: %s url_to_brat_installation' % (args[0], )<\exit>
return -1<\exit>
brat_url = args[1]<\exit>
url_soup = urlparse(brat_url)<\exit>
if url_soup.scheme:<\exit>
try:<\exit>
Connection = CONNECTION_BY_SCHEME[url_soup.scheme.split(':')[0]]<\exit>
except KeyError:<\exit>
print >> stderr, ('ERROR: Unknown url scheme %s, try http or '<\exit>
'https') % url_soup.scheme<\exit>
return -1<\exit>
else:<\exit>
path_soup = url_soup.path.split('/')<\exit>
assumed_netloc = path_soup[0]<\exit>
assumed_path = '/' + '/'.join(path_soup[1:])<\exit>
print >> stderr, ('WARNING: No url scheme given, assuming scheme: '<\exit>
'"http", netloc: "%s" and path: "%s"'<\exit>
) % (assumed_netloc, assumed_path, )<\exit>
url_soup = url_soup._replace(scheme='http', netloc=assumed_netloc,<\exit>
path=assumed_path)<\exit>
Connection = HTTPConnection<\exit>
conn = Connection(url_soup.netloc)<\exit>
res = _request_wrap(conn, 'HEAD', url_soup.path)<\exit>
if res.status != OK:<\exit>
print >> stderr, ('Unable to load "%s", please check the url.'<\exit>
) % (brat_url, )<\exit>
print >> stderr, ('Does the url you provdide point to your brat '<\exit>
'installation?')<\exit>
return -1<\exit>
res.read()<\exit>
ajax_cgi_path = url_soup.path + '/ajax.cgi'<\exit>
ajax_cgi_url = url_soup._replace(path=ajax_cgi_path).geturl()<\exit>
res = _request_wrap(conn, 'HEAD', ajax_cgi_path)<\exit>
if res.status == FORBIDDEN:<\exit>
print >> stderr, ('Received forbidden (403) when trying to access '<\exit>
'"%s"') % (ajax_cgi_url, )<\exit>
print ('Have you perhaps forgotten to enable execution of CGI in '<\exit>
' your web server configuration?')<\exit>
return -1<\exit>
elif res.status != OK:<\exit>
print >> stderr, ('Unable to load "%s", please check your url. Does '<\exit>
'it point to your brat installation?') % (ajax_cgi_url, )<\exit>
return -1<\exit>
res_headers = dict(res.getheaders())<\exit>
try:<\exit>
content_type = res_headers['content-type']<\exit>
except KeyError:<\exit>
content_type = None<\exit>
if content_type != 'application/json':<\exit>
print >> stderr, ('Didn\'t receive json data when accessing "%s"%s.'<\exit>
) % (ajax_cgi_url,<\exit>
', instead we received %s' % content_type<\exit>
if content_type is not None else '')<\exit>
print >> stderr, ('Have you perhaps forgotten to add a handler for '<\exit>
'CGI in your web server configuration?')<\exit>
return -1<\exit>
print 'Congratulations! Your brat server appears to be ready to run.'<\exit>
print ('However, there is the possibility that there are further errors, '<\exit>
'but at least the server should be capable of communicating '<\exit>
'these errors to the client.')<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
from sys import argv<\exit>
exit(main(argv))<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, K, A, B = cipher<\exit>
A.sort()<\exit>
B.sort(reverse=True)<\exit>
for i in xrange(N):<\exit>
if not A[i] + B[i] >= K:<\exit>
return "NO"<\exit>
return "YES"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N, K = map(int, f.readline().strip().split(" "))<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
B = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, K, A, B<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a = map(set, cipher)<\exit>
ret = a[0].intersection(a[1])<\exit>
if len(ret) > 0:<\exit>
return "YES"<\exit>
else:<\exit>
return "NO"<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = []<\exit>
cipher.append(f.readline().strip())<\exit>
cipher.append(f.readline().strip())<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve_TLE(self, cipher):<\exit>
a = cipher[0]<\exit>
counter = 0<\exit>
for i in xrange(len(a)):<\exit>
if a[i] == "0":<\exit>
continue<\exit>
for j in xrange(i, len(a)):<\exit>
strength = a[i:j + 1]<\exit>
strength = int(strength)<\exit>
if strength & (strength - 1) == 0:<\exit>
counter += 1<\exit>
return counter<\exit>
def solve(self, cipher):<\exit>
def strength(self, a, i, j):<\exit>
if a[i] == 0:<\exit>
return 0<\exit>
value = 0<\exit>
for k in xrange(i, j + 1):<\exit>
value = value * 10 + a[k]<\exit>
return value<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
import nltk.data<\exit>
import os<\exit>
from nltk.tokenize.punkt import PunktWordTokenizer<\exit>
from nltk.stem.porter import *<\exit>
import math<\exit>
sent_detector = nltk.data.load('tokenizers/punkt/english.pickle')<\exit>
stemmer = PorterStemmer()<\exit>
text_auto = []<\exit>
text_nonauto = []<\exit>
print 'Processing datat in'<\exit>
directory = os.path.dirname(os.path.realpath(__file__)) + '/raw_data/cleaned'<\exit>
print 'dir:'+directory<\exit>
for root, dirs, files in os.walk(directory):<\exit>
for file in files:<\exit>
if file.endswith(".txt") and (not ('(1)' in file)) and (not ('-2' in file)):<\exit>
f=open(os.path.join(root,file), 'r')<\exit>
text_nonauto.append((file,f.read()))<\exit>
f.close()<\exit>
elif file.endswith(".txt"):<\exit>
f=open(os.path.join(root,file), 'r')<\exit>
text_auto.append((file,f.read()))<\exit>
f.close()<\exit>
if not os.path.exists('Sents_split/non_auto/'):<\exit>
os.makedirs('Sents_split/non_auto/')<\exit>
if not os.path.exists('Sents_split/auto/'):<\exit>
os.makedirs('Sents_split/auto/')<\exit>
for ind, (video, text) in enumerate(text_nonauto):<\exit>
xml_nonauto = '[non-automatic.xml]\n<transcripts>\n'<\exit>
video = video[:(video.find('[English]'))]<\exit>
url = text[:text.strip().find('\n')]<\exit>
text = text[text.strip().find('\n'):]<\exit>
sents = sent_detector.tokenize(text.strip())<\exit>
cleaned = '<transcript'+' id=\"'+ str(ind+1)+ '\" title=\"'+video+'\" url=\"'+ url + '\" mode=\"non-automatic\">\n'<\exit>
for s in sents:<\exit>
s = s.replace('\n',' ') +'\n'<\exit>
s = s.replace('.',' ')<\exit>
s = s.lower()<\exit>
cleaned += s<\exit>
temp = PunktWordTokenizer().tokenize(s)<\exit>
cleaned += '</transcript>\n'<\exit>
xml_nonauto+= cleaned+'</transcripts>'<\exit>
f = open('Sents_split/non_auto/'+str(ind+1)+'.txt','w')<\exit>
f.write(xml_nonauto)<\exit>
f.close()<\exit>
for ind, (video, text) in enumerate(text_auto):<\exit>
xml_auto = '[automatic.xml]\n<transcripts>\n'<\exit>
video = video[:(video.find('[English]'))]<\exit>
url = text[:text.strip().find('\n')]<\exit>
text = text[text.strip().find('\n'):]<\exit>
sents = sent_detector.tokenize(text.strip())<\exit>
cleaned = '<transcript'+' id=\"'+ str(ind+1) + '\" title=\"'+video+'\" url=\"'+ url + '\" mode=\"automatic\">\n'<\exit>
for s in sents:<\exit>
s = s.replace('\n',' ') +'\n'<\exit>
s = s.replace('.',' ')<\exit>
s = s.lower()<\exit>
cleaned += s<\exit>
cleaned += '</transcript>\n'<\exit>
xml_auto+= cleaned+'</transcripts>'<\exit>
f = open('Sents_split/auto/'+str(ind+1)+'.txt','w')<\exit>
f.write(xml_auto)<\exit>
f.close()<\exit>
from datetime import datetime<\exit>
import pytz<\exit>
class TimeParser():<\exit>
dt_formats = [<\exit>
'%Y-%m-%d %H:%M:%S %Z',<\exit>
'%Y-%m-%d %H:%M:%S',<\exit>
]<\exit>
def parse(self, dt_str, dt_format):<\exit>
return datetime.strptime(dt_str, dt_format)<\exit>
def localtime(utc_dt, tz_str):<\exit>
tz = pytz.timezone(tz_str)<\exit>
local_dt = tz.normalize(utc_dt.astimezone(tz))<\exit>
return local_dt<\exit>
def utctime(dt, tz_str):<\exit>
tz = pytz.timezone(tz_str)<\exit>
local_dt = tz.localize(dt)<\exit>
utc_dt = pytz.utc.normalize(local_dt.astimezone(pytz.utc))<\exit>
return utc_dt<\exit>
from . import ansi<\exit>
import os<\exit>
import math<\exit>
def _get_terminal_columns():<\exit>
_, columns = os.popen('stty size', 'r').read().split()<\exit>
return int(columns)<\exit>
def erase():<\exit>
ansi.move_cursor_line_beggining()<\exit>
ansi.erase_from_cursor_to_end()<\exit>
def refresh(state):<\exit>
erase()<\exit>
lines, num_rows = _construct_output(state)<\exit>
for line in lines:<\exit>
print(line)<\exit>
ansi.move_cursor_previous_lines(num_rows)<\exit>
ansi.move_cursor_horizental(len(lines[0])+1)<\exit>
ansi.flush()<\exit>
def _construct_output(state):<\exit>
columns = _get_terminal_columns()<\exit>
def number_of_rows(line):<\exit>
return int(math.ceil(float(len(line))/columns))<\exit>
displayed_lines = []<\exit>
num_rows = 0<\exit>
prompt_line = 'Path: ' + state.input<\exit>
displayed_lines.append(prompt_line)<\exit>
num_rows += number_of_rows(prompt_line)<\exit>
matches = state.get_matches()<\exit>
if matches:<\exit>
selected_command_index = matches.index(state.get_selected_match())<\exit>
matches_to_display = matches[max(0, selected_command_index - 10 + 1):max(10, selected_command_index + 1)]<\exit>
for index, m in enumerate(matches_to_display):<\exit>
fm = ' ' + m<\exit>
num_rows += number_of_rows(fm)<\exit>
for w in state.input.split(' '):<\exit>
if w:<\exit>
fm = fm.replace(w, ansi.bold_text(w))<\exit>
if m == state.get_selected_match():<\exit>
fm = ansi.select_text(fm)<\exit>
displayed_lines.append(fm)<\exit>
else:<\exit>
not_found_line = 'Nothing found'<\exit>
displayed_lines.append(not_found_line)<\exit>
num_rows += number_of_rows(not_found_line)<\exit>
return displayed_lines, num_rows<\exit>
class TreeNode(object):<\exit>
def __init__(self, val):<\exit>
self.val = val<\exit>
self.left, self.right = None, None<\exit>
class Solution(object):<\exit>
def generateTrees(self, n):<\exit>
return self.dfs(1, n+1)<\exit>
def dfs(self, s, e):<\exit>
ret = []<\exit>
if s >= e:<\exit>
return [None]<\exit>
for i in xrange(s, e):<\exit>
ls = self.dfs(s, i)<\exit>
rs = self.dfs(i+1, e)<\exit>
for l in ls:<\exit>
for r in rs:<\exit>
root = TreeNode(i)<\exit>
root.left = l<\exit>
root.right = r<\exit>
ret.append(root)<\exit>
return ret<\exit>
class Solution:<\exit>
def __init__(self):<\exit>
self.cache = {}<\exit>
def numTrees(self, n):<\exit>
return self.dfs(n)<\exit>
def dfs(self, n):<\exit>
if n not in self.cache:<\exit>
if n in (0, 1, 2):<\exit>
self.cache[n] = max(1, n)<\exit>
else:<\exit>
s = 0<\exit>
for i in xrange(1, n+1):<\exit>
l = self.dfs(i-1)<\exit>
r = self.dfs(n-i)<\exit>
s += l*r<\exit>
self.cache[n] = s<\exit>
return self.cache[n]<\exit>
if __name__ == "__main__":<\exit>
print Solution().numTrees(3)<\exit>
from . import constants<\exit>
import sys<\exit>
from .latin1prober import Latin1Prober<\exit>
from .mbcsgroupprober import MBCSGroupProber<\exit>
from .sbcsgroupprober import SBCSGroupProber<\exit>
from .escprober import EscCharSetProber<\exit>
import re<\exit>
MINIMUM_THRESHOLD = 0.20<\exit>
ePureAscii = 0<\exit>
eEscAscii = 1<\exit>
eHighbyte = 2<\exit>
class UniversalDetector:<\exit>
def __init__(self):<\exit>
self._highBitDetector = re.compile(b'[\x80-\xFF]')<\exit>
self._escDetector = re.compile(b'(\033|~{)')<\exit>
self._mEscCharSetProber = None<\exit>
self._mCharSetProbers = []<\exit>
self.reset()<\exit>
def reset(self):<\exit>
self.result = {'encoding': None, 'confidence': 0.0}<\exit>
self.done = False<\exit>
self._mStart = True<\exit>
self._mGotData = False<\exit>
self._mInputState = ePureAscii<\exit>
self._mLastChar = b''<\exit>
if self._mEscCharSetProber:<\exit>
self._mEscCharSetProber.reset()<\exit>
for prober in self._mCharSetProbers:<\exit>
prober.reset()<\exit>
def feed(self, aBuf):<\exit>
if self.done:<\exit>
return<\exit>
aLen = len(aBuf)<\exit>
if not aLen:<\exit>
return<\exit>
if not self._mGotData:<\exit>
if aBuf[:3] == '\xEF\xBB\xBF':<\exit>
self.result = {'encoding': "UTF-8", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\xFF\xFE\x00\x00':<\exit>
self.result = {'encoding': "UTF-32LE", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\x00\x00\xFE\xFF':<\exit>
self.result = {'encoding': "UTF-32BE", 'confidence': 1.0}<\exit>
elif aBuf[:4] == '\xFE\xFF\x00\x00':<\exit>
self.result = {<\exit>
'encoding': "X-ISO-10646-UCS-4-3412",<\exit>
'confidence': 1.0<\exit>
}<\exit>
elif aBuf[:4] == '\x00\x00\xFF\xFE':<\exit>
self.result = {<\exit>
'encoding': "X-ISO-10646-UCS-4-2143",<\exit>
'confidence': 1.0<\exit>
}<\exit>
elif aBuf[:2] == '\xFF\xFE':<\exit>
self.result = {'encoding': "UTF-16LE", 'confidence': 1.0}<\exit>
elif aBuf[:2] == '\xFE\xFF':<\exit>
self.result = {'encoding': "UTF-16BE", 'confidence': 1.0}<\exit>
self._mGotData = True<\exit>
if self.result['encoding'] and (self.result['confidence'] > 0.0):<\exit>
self.done = True<\exit>
return<\exit>
if self._mInputState == ePureAscii:<\exit>
if self._highBitDetector.search(aBuf):<\exit>
self._mInputState = eHighbyte<\exit>
elif ((self._mInputState == ePureAscii) and<\exit>
self._escDetector.search(self._mLastChar + aBuf)):<\exit>
self._mInputState = eEscAscii<\exit>
self._mLastChar = aBuf[-1:]<\exit>
if self._mInputState == eEscAscii:<\exit>
if not self._mEscCharSetProber:<\exit>
self._mEscCharSetProber = EscCharSetProber()<\exit>
if self._mEscCharSetProber.feed(aBuf) == constants.eFoundIt:<\exit>
self.result = {<\exit>
'encoding': self._mEscCharSetProber.get_charset_name(),<\exit>
'confidence': self._mEscCharSetProber.get_confidence()<\exit>
}<\exit>
self.done = True<\exit>
elif self._mInputState == eHighbyte:<\exit>
if not self._mCharSetProbers:<\exit>
self._mCharSetProbers = [MBCSGroupProber(), SBCSGroupProber(),<\exit>
Latin1Prober()]<\exit>
for prober in self._mCharSetProbers:<\exit>
if prober.feed(aBuf) == constants.eFoundIt:<\exit>
self.result = {'encoding': prober.get_charset_name(),<\exit>
'confidence': prober.get_confidence()}<\exit>
self.done = True<\exit>
break<\exit>
def close(self):<\exit>
if self.done:<\exit>
return<\exit>
if not self._mGotData:<\exit>
if constants._debug:<\exit>
sys.stderr.write('no data received!\n')<\exit>
return<\exit>
self.done = True<\exit>
if self._mInputState == ePureAscii:<\exit>
self.result = {'encoding': 'ascii', 'confidence': 1.0}<\exit>
return self.result<\exit>
if self._mInputState == eHighbyte:<\exit>
proberConfidence = None<\exit>
maxProberConfidence = 0.0<\exit>
maxProber = None<\exit>
for prober in self._mCharSetProbers:<\exit>
if not prober:<\exit>
continue<\exit>
proberConfidence = prober.get_confidence()<\exit>
if proberConfidence > maxProberConfidence:<\exit>
maxProberConfidence = proberConfidence<\exit>
maxProber = prober<\exit>
if maxProber and (maxProberConfidence > MINIMUM_THRESHOLD):<\exit>
self.result = {'encoding': maxProber.get_charset_name(),<\exit>
'confidence': maxProber.get_confidence()}<\exit>
return self.result<\exit>
if constants._debug:<\exit>
sys.stderr.write('no probers hit minimum threshhold\n')<\exit>
for prober in self._mCharSetProbers[0].mProbers:<\exit>
if not prober:<\exit>
continue<\exit>
sys.stderr.write('%s confidence = %s\n' %<\exit>
(prober.get_charset_name(),<\exit>
prober.get_confidence()))<\exit>
from __future__ import with_statement<\exit>
import sys<\exit>
import re<\exit>
try:<\exit>
import argparse<\exit>
except ImportError:<\exit>
from os.path import basename<\exit>
from sys import path as sys_path<\exit>
sys_path.append(join_path(basename(__file__), '../server/lib'))<\exit>
import argparse<\exit>
DEBUG=True<\exit>
class ArgumentError(Exception):<\exit>
def __init__(self, s):<\exit>
self.errstr = s<\exit>
def __str__(self):<\exit>
return 'Argument error: %s' % (self.errstr)<\exit>
class SyntaxError(Exception):<\exit>
def __init__(self, line, errstr=None, line_num=None):<\exit>
self.line = line<\exit>
self.errstr = errstr<\exit>
self.line_num = str(line_num) if line_num is not None else "(undefined)"<\exit>
def __str__(self):<\exit>
return 'Syntax error on line %s ("%s")%s' % (self.line_num, self.line, ": "+self.errstr if self.errstr is not None else "")<\exit>
class ProcessingError(Exception):<\exit>
pass<\exit>
class Annotation(object):<\exit>
COMMENT_TYPE = "<COMMENT>"<\exit>
_typere = re.compile(r'^([a-zA-Z][a-zA-Z0-9_-]*)\b')<\exit>
@staticmethod<\exit>
def _parse_type(s):<\exit>
if not s or s[0].isspace():<\exit>
raise SyntaxError(s, "ID missing")<\exit>
if s[0].isalnum() or s[0] == '*':<\exit>
fields = s.split("\t")<\exit>
if len(fields) < 2:<\exit>
raise SyntaxError(s, "No TAB in annotation")<\exit>
m = Annotation._typere.search(fields[1])<\exit>
if not m:<\exit>
raise SyntaxError(s, "Failed to parse type in \"%s\"" % fields[1])<\exit>
return m.group(1)<\exit>
elif s[0] == '#':<\exit>
return Annotation.COMMENT_TYPE<\exit>
else:<\exit>
raise SyntaxError(s, "Unrecognized ID")<\exit>
def __init__(self, s):<\exit>
self.ann_string = s<\exit>
self.type = Annotation._parse_type(s)<\exit>
def __str__(self):<\exit>
return self.ann_string<\exit>
def argparser():<\exit>
ap=argparse.ArgumentParser(description="Split merged BioNLP ST annotations into separate files.")<\exit>
ap.add_argument("-a1", "--a1types", default="Protein", metavar="TYPE[,TYPE...]", help="Annotation types to place into .a1 file")<\exit>
ap.add_argument("-a2", "--a2types", default="[OTHER]", metavar="TYPE[,TYPE...]", help="Annotation types to place into .a2 file")<\exit>
ap.add_argument("-d", "--directory", default=None, metavar="DIR", help="Output directory")<\exit>
ap.add_argument("-s", "--skipempty", default=False, action="store_true", help="Skip output for empty split files")<\exit>
ap.add_argument("-i", "--idrewrite", default=False, action="store_true", help="Rewrite IDs following BioNLP ST conventions")<\exit>
ap.add_argument("files", nargs='+', help="Files in merged BioNLP ST-flavored standoff")<\exit>
return ap<\exit>
def parse_annotations(annlines, fn="(unknown)"):<\exit>
annotations = []<\exit>
for ln, l in enumerate(annlines):<\exit>
if not l.strip():<\exit>
print >> sys.stderr, "Warning: ignoring empty line %d in %s" % (ln, fn)<\exit>
continue<\exit>
try:<\exit>
annotations.append(Annotation(l))<\exit>
except SyntaxError, e:<\exit>
raise SyntaxError(l, e.errstr, ln)<\exit>
return annotations<\exit>
DEFAULT_TYPE = "<DEFAULT>"<\exit>
def split_annotations(annotations, typemap):<\exit>
d = {}<\exit>
for a in annotations:<\exit>
if a.type in typemap:<\exit>
t = a.type<\exit>
elif DEFAULT_TYPE in typemap:<\exit>
t = DEFAULT_TYPE<\exit>
else:<\exit>
raise ArgumentError("Don't know where to place annotation of type '%s'" % a.type)<\exit>
s = typemap[t]<\exit>
if s not in d:<\exit>
d[s] = []<\exit>
d[s].append(a)<\exit>
return d<\exit>
def type_mapping(arg):<\exit>
m = {}<\exit>
for suff, typestr in (("a1", arg.a1types),<\exit>
("a2", arg.a2types)):<\exit>
for ts in typestr.split(","):<\exit>
t = ts if ts != "[OTHER]" else DEFAULT_TYPE<\exit>
if t in m:<\exit>
raise ArgumentError("Split for '%s' ambiguous (%s or %s); check arguments." % (ts, m[t], suff))<\exit>
m[t] = suff<\exit>
return m<\exit>
def output_file_name(fn, directory, suff):<\exit>
import os.path<\exit>
dir, base = os.path.split(fn)<\exit>
root, ext = os.path.splitext(base)<\exit>
if not directory:<\exit>
directory = dir<\exit>
return os.path.join(directory, root+"."+suff)<\exit>
def annotation_lines(annotations):<\exit>
return [str(a) for a in annotations]<\exit>
def write_annotation_lines(fn, lines):<\exit>
with open(fn, 'wt') as f:<\exit>
for l in lines:<\exit>
f.write(l)<\exit>
def read_annotation_lines(fn):<\exit>
with open(fn) as f:<\exit>
return f.readlines()<\exit>
def verify_split(origlines, splitlines):<\exit>
orig = origlines[:]<\exit>
split = []<\exit>
for k in splitlines:<\exit>
split.extend(splitlines[k])<\exit>
orig.sort()<\exit>
split.sort()<\exit>
orig_only = []<\exit>
split_only = []<\exit>
oi, si = 0, 0<\exit>
while oi < len(orig) and si < len(split):<\exit>
if orig[oi] == split[si]:<\exit>
oi += 1<\exit>
si += 1<\exit>
elif orig[oi] < split[si]:<\exit>
orig_only.append(orig[oi])<\exit>
oi += 1<\exit>
else:<\exit>
assert split[si] < orig[si]<\exit>
split_only.append(split[si])<\exit>
si += 1<\exit>
while oi < len(orig):<\exit>
orig_only.append(orig[oi])<\exit>
oi += 1<\exit>
while si < len(split):<\exit>
split_only.append(split[si])<\exit>
si += 1<\exit>
difference_found = False<\exit>
for l in split_only:<\exit>
print >> sys.stderr, "Split error: split contains extra line '%s'" % l<\exit>
difference_found = True<\exit>
for l in orig_only:<\exit>
if l.strip() == "":<\exit>
continue<\exit>
print >> sys.stderr, "Split error: split is missing line '%s'" % l<\exit>
difference_found = True<\exit>
if difference_found:<\exit>
raise ProcessingError<\exit>
def process_file(fn, typemap, directory, mandatory):<\exit>
annlines = read_annotation_lines(fn)<\exit>
annotations = parse_annotations(annlines)<\exit>
splitann = split_annotations(annotations, typemap)<\exit>
for t in mandatory:<\exit>
splitann[t] = splitann.get(t, [])<\exit>
splitlines = {}<\exit>
for suff in splitann:<\exit>
splitlines[suff] = annotation_lines(splitann[suff])<\exit>
if DEBUG:<\exit>
verify_split(annlines, splitlines)<\exit>
for suff in splitann:<\exit>
ofn = output_file_name(fn, directory, suff)<\exit>
write_annotation_lines(ofn, splitlines[suff])<\exit>
def main(argv=None):<\exit>
if argv is None:<\exit>
argv = sys.argv<\exit>
arg = argparser().parse_args(argv[1:])<\exit>
try:<\exit>
typemap = type_mapping(arg)<\exit>
except ArgumentError, e:<\exit>
print >> sys.stderr, e<\exit>
return 2<\exit>
if arg.skipempty:<\exit>
mandatory_outputs = []<\exit>
else:<\exit>
mandatory_outputs = ["a1", "a2"]<\exit>
for fn in arg.files:<\exit>
try:<\exit>
process_file(fn, typemap, arg.directory, mandatory_outputs)<\exit>
except IOError, e:<\exit>
print >> sys.stderr, "Error: failed %s, skip processing (%s)" % (fn, e)<\exit>
except SyntaxError, e:<\exit>
print >> sys.stderr, "Error: failed %s, skip processing (%s)" % (fn, e)<\exit>
except:<\exit>
print >> sys.stderr, "Fatal: unexpected error processing %s" % fn<\exit>
raise<\exit>
return 0<\exit>
if __name__ == "__main__":<\exit>
sys.exit(main())<\exit>
class Solution:<\exit>
def updateBits(self, n, m, i, j):<\exit>
mask = ((1<<32)-1)-((1<<j+1)-1)+((1<<i)-1)<\exit>
ret = (n&mask)+(m<<i)<\exit>
return self.twos_comp(ret, 32)<\exit>
@staticmethod<\exit>
def twos_comp(val, bits):<\exit>
if val > 0 and val&(1<<(bits-1)) != 0:<\exit>
val -= 1<<bits<\exit>
return val<\exit>
if __name__ == "__main__":<\exit>
assert Solution().updateBits(-2147483648, 2147483647, 0, 30) == -1<\exit>
assert Solution().updateBits(1, -1, 0, 31) == -1<\exit>
n = int("10000000000", 2)<\exit>
m = int("10101", 2)<\exit>
assert bin(Solution().updateBits(n, m, 2, 6)) == "0b10001010100"<\exit>
from django.conf.urls import include, url<\exit>
from django.contrib import admin<\exit>
from django.views.generic import TemplateView<\exit>
from rake_app import views as rake_views<\exit>
urlpatterns = [<\exit>
url(r'^admin/', include(admin.site.urls)),<\exit>
url(r'^$', rake_views.MainView.as_view()),<\exit>
url(r'^about/$', TemplateView.as_view(template_name="about.html"))<\exit>
]<\exit>
from . import constants<\exit>
from .charsetprober import CharSetProber<\exit>
from .codingstatemachine import CodingStateMachine<\exit>
from .mbcssm import UTF8SMModel<\exit>
ONE_CHAR_PROB = 0.5<\exit>
class UTF8Prober(CharSetProber):<\exit>
def __init__(self):<\exit>
CharSetProber.__init__(self)<\exit>
self._mCodingSM = CodingStateMachine(UTF8SMModel)<\exit>
self.reset()<\exit>
def reset(self):<\exit>
CharSetProber.reset(self)<\exit>
self._mCodingSM.reset()<\exit>
self._mNumOfMBChar = 0<\exit>
def get_charset_name(self):<\exit>
return "utf-8"<\exit>
def feed(self, aBuf):<\exit>
for c in aBuf:<\exit>
codingState = self._mCodingSM.next_state(c)<\exit>
if codingState == constants.eError:<\exit>
self._mState = constants.eNotMe<\exit>
break<\exit>
elif codingState == constants.eItsMe:<\exit>
self._mState = constants.eFoundIt<\exit>
break<\exit>
elif codingState == constants.eStart:<\exit>
if self._mCodingSM.get_current_charlen() >= 2:<\exit>
self._mNumOfMBChar += 1<\exit>
if self.get_state() == constants.eDetecting:<\exit>
if self.get_confidence() > constants.SHORTCUT_THRESHOLD:<\exit>
self._mState = constants.eFoundIt<\exit>
return self.get_state()<\exit>
def get_confidence(self):<\exit>
unlike = 0.99<\exit>
if self._mNumOfMBChar < 6:<\exit>
for i in range(0, self._mNumOfMBChar):<\exit>
unlike = unlike * ONE_CHAR_PROB<\exit>
return 1.0 - unlike<\exit>
else:<\exit>
return unlike<\exit>
import os<\exit>
from PIL import Image<\exit>
import numpy as np<\exit>
import random<\exit>
def read_image(filename):<\exit>
imarr = np.array([])<\exit>
try:<\exit>
im = Image.open(os.path.join(filename))<\exit>
im = im.convert("L")<\exit>
imarr = np.array(im, dtype=np.uint8)<\exit>
except IOError as (errno, strerror):<\exit>
print "I/O error({0}): {1}".format(errno, strerror)<\exit>
except:<\exit>
print "Cannot open image."<\exit>
return imarr<\exit>
def asRowMatrix(X):<\exit>
if len(X) == 0:<\exit>
return np.array([])<\exit>
total = 1<\exit>
for i in range(0, np.ndim(X[0])):<\exit>
total = total * X[0].shape[i]<\exit>
mat = np.empty([0, total], dtype=X[0].dtype)<\exit>
for row in X:<\exit>
mat = np.append(mat, row.reshape(1, -1), axis=0)<\exit>
return np.asmatrix(mat)<\exit>
def asColumnMatrix(X):<\exit>
if len(X) == 0:<\exit>
return np.array([])<\exit>
total = 1<\exit>
for i in range(0, np.ndim(X[0])):<\exit>
total = total * X[0].shape[i]<\exit>
mat = np.empty([total, 0], dtype=X[0].dtype)<\exit>
for col in X:<\exit>
mat = np.append(mat, col.reshape(-1, 1), axis=1)<\exit>
return np.asmatrix(mat)<\exit>
def minmax_normalize(X, low, high, minX=None, maxX=None, dtype=np.float):<\exit>
if minX is None:<\exit>
minX = np.min(X)<\exit>
if maxX is None:<\exit>
maxX = np.max(X)<\exit>
minX = float(minX)<\exit>
maxX = float(maxX)<\exit>
X = X - minX<\exit>
X = X / (maxX - minX)<\exit>
X = X * (high - low)<\exit>
X = X + low<\exit>
return np.asarray(X, dtype=dtype)<\exit>
def shuffle(X, y):<\exit>
idx = np.argsort([random.random() for i in xrange(y.shape[0])])<\exit>
return X[:, idx], y[idx]<\exit>
def shuffle_array(X, y):<\exit>
idx = np.argsort([random.random() for i in xrange(len(y))])<\exit>
X = [X[i] for i in idx]<\exit>
y = [y[i] for i in idx]<\exit>
return X, y<\exit>
def to_col_vec(row_vec):<\exit>
return row_vec[:, np.newaxis]<\exit>
def to_row_vec(col_vec):<\exit>
return col_vec.reshape(1, -1)<\exit>
import os<\exit>
import sys<\exit>
def get_list_from_file(file_path, list_name):<\exit>
list = []<\exit>
if os.path.exists(file_path):<\exit>
file_in = open(file_path, "r")<\exit>
list_string = ""<\exit>
parsing_multiline_list = False<\exit>
for line in file_in:<\exit>
if list_name in line or parsing_multiline_list:<\exit>
list_string += line<\exit>
if ']' not in list_string:<\exit>
parsing_multiline_list = True<\exit>
else:<\exit>
list = eval(list_string.split('=', 1)[1].strip())<\exit>
break<\exit>
file_in.close()<\exit>
return list<\exit>
def get_bool_from_file(file_path, bool_name, value_if_missing):<\exit>
if os.path.exists(file_path):<\exit>
file_in = open(file_path, "r")<\exit>
bool_found = False<\exit>
for line in file_in:<\exit>
if bool_name in line:<\exit>
bool = eval(line.split('=', 1)[1].strip())<\exit>
bool_found = True<\exit>
break<\exit>
file_in.close()<\exit>
if bool_found:<\exit>
return bool<\exit>
else:<\exit>
return value_if_missing<\exit>
def read_config_file():<\exit>
modules_enabled  = ['all_modules']<\exit>
examples_enabled = False<\exit>
tests_enabled    = False<\exit>
config_file_exists = False<\exit>
dot_ns3rc_name = '.ns3rc'<\exit>
dot_ns3rc_path = dot_ns3rc_name<\exit>
if not os.path.exists(dot_ns3rc_path):<\exit>
dot_ns3rc_path = os.path.expanduser('~/') + dot_ns3rc_name<\exit>
if not os.path.exists(dot_ns3rc_path):<\exit>
return (config_file_exists, modules_enabled, examples_enabled, tests_enabled)<\exit>
config_file_exists = True<\exit>
modules_enabled = get_list_from_file(dot_ns3rc_path, 'modules_enabled')<\exit>
if not modules_enabled:<\exit>
modules_enabled = ['all_modules']<\exit>
value_if_missing = False<\exit>
examples_enabled = get_bool_from_file(dot_ns3rc_path, 'examples_enabled', value_if_missing)<\exit>
value_if_missing = False<\exit>
tests_enabled = get_bool_from_file(dot_ns3rc_path, 'tests_enabled', value_if_missing)<\exit>
return (config_file_exists, modules_enabled, examples_enabled, tests_enabled)<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N = int(cipher[0])<\exit>
height = 1<\exit>
for cycle in xrange(N):<\exit>
if cycle & 1 == 0:<\exit>
height *= 2<\exit>
else:<\exit>
height += 1<\exit>
return height<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = sys.stdin<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
cipher = f.readline().strip().split(' ')<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
from __future__ import absolute_import<\exit>
import math as math<\exit>
import random as random<\exit>
import logging<\exit>
import cv2<\exit>
import numpy as np<\exit>
from facerec_py.facerec.model import PredictableModel, AbstractPredictableModel<\exit>
from util.commons_util.fundamentals.generators import frange<\exit>
class TFPN(object):<\exit>
def __init__(self, TP=0, FP=0, TN=0, FN=0):<\exit>
self.rates = np.array([TP, FP, TN, FN], dtype=np.double)<\exit>
@property<\exit>
def TP(self):<\exit>
return self.rates[0]<\exit>
@TP.setter<\exit>
def TP(self, value):<\exit>
self.rates[0] = value<\exit>
@property<\exit>
def FP(self):<\exit>
return self.rates[1]<\exit>
@FP.setter<\exit>
def FP(self, value):<\exit>
self.rates[1] = value<\exit>
@property<\exit>
def TN(self):<\exit>
return self.rates[2]<\exit>
@TN.setter<\exit>
def TN(self, value):<\exit>
self.rates[2] = value<\exit>
@property<\exit>
def FN(self):<\exit>
return self.rates[3]<\exit>
@FN.setter<\exit>
def FN(self, value):<\exit>
self.rates[3] = value<\exit>
def __add__(self, other):<\exit>
return self.rates + other.rates<\exit>
def __iadd__(self, other):<\exit>
self.rates += other.rates<\exit>
return self<\exit>
def shuffle(X, y):<\exit>
idx = np.argsort([random.random() for _ in xrange(len(y))])<\exit>
X = [X[i] for i in idx]<\exit>
y = y[idx]<\exit>
return X, y<\exit>
def slice_2d(X, rows, cols):<\exit>
return [X[i][j] for j in cols for i in rows]<\exit>
def precision(true_positives, false_positives):<\exit>
return accuracy(true_positives, 0, false_positives, 0)<\exit>
def accuracy(true_positives, true_negatives, false_positives, false_negatives, description=None):<\exit>
true_positives = float(true_positives)<\exit>
true_negatives = float(true_negatives)<\exit>
false_positives = float(false_positives)<\exit>
false_negatives = float(false_negatives)<\exit>
if (true_positives + true_negatives + false_positives + false_negatives) < 1e-15:<\exit>
return 0.0<\exit>
return (true_positives + true_negatives) / (true_positives + false_positives + true_negatives + false_negatives)<\exit>
class ValidationResult(object):<\exit>
def __init__(self, true_positives, true_negatives, false_positives, false_negatives, description):<\exit>
self.true_positives = true_positives<\exit>
self.true_negatives = true_negatives<\exit>
self.false_positives = false_positives<\exit>
self.false_negatives = false_negatives<\exit>
self.description = description<\exit>
def __div(self, x, y):<\exit>
if y < 1e-15:<\exit>
return 0.0<\exit>
return x/y<\exit>
@property<\exit>
def TPR(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_negatives)<\exit>
@property<\exit>
def FPR(self):<\exit>
return self.__div(self.false_positives, self.false_positives+self.true_negatives)<\exit>
@property<\exit>
def recall(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_negatives)<\exit>
@property<\exit>
def precision(self):<\exit>
return self.__div(self.true_positives, self.true_positives+self.false_positives)<\exit>
@property<\exit>
def total(self):<\exit>
return self.true_negatives+self.true_positives+self.false_negatives+self.false_positives<\exit>
@property<\exit>
def accuracy(self):<\exit>
return self.__div(self.true_positives+self.true_negatives, self.total)<\exit>
@property<\exit>
def F1(self):<\exit>
return self.__div(2*self.precision*self.recall, self.precision+self.recall)<\exit>
def __repr__(self):<\exit>
return "ValidationResult (Description=%s, Precision=%.2f%%, Recall=%.2f%%, TPR=%.2f%%, FPR=%.2f%%, TP=%d, TN=%d, FP=%d, FN=%d)" % (<\exit>
self.description, self.precision*100, self.recall*100, self.TPR*100, self.FPR*100, self.true_positives, self.true_negatives, self.false_positives, self.false_negatives)<\exit>
class ValidationStrategy(object):<\exit>
def __init__(self, model):<\exit>
if not isinstance(model, AbstractPredictableModel):<\exit>
raise TypeError("Validation can only validate the type PredictableModel.")<\exit>
self.model = model<\exit>
self.validation_results = []<\exit>
def add(self, validation_result):<\exit>
self.validation_results.append(validation_result)<\exit>
def validate(self, X, y, description):<\exit>
raise NotImplementedError("Every Validation module must implement the validate method!")<\exit>
def print_results(self):<\exit>
print self.model<\exit>
for validation_result in self.validation_results:<\exit>
print validation_result<\exit>
def __repr__(self):<\exit>
return "Validation Strategy (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class KFoldCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model, k=10, threshold_up=1, froze_shuffle=False, debug=True):<\exit>
super(KFoldCrossValidation, self).__init__(model=model)<\exit>
self.threshold_up = threshold_up<\exit>
self.k = k<\exit>
self.logger = logging.getLogger("facerec.validation.KFoldCrossValidation")<\exit>
self._debug = debug<\exit>
self.froze_shuffle = froze_shuffle<\exit>
def validate(self, X, y, description="ExperimentName"):<\exit>
if not self.froze_shuffle:<\exit>
X, y = shuffle(X, y)<\exit>
c = len(np.unique(y))<\exit>
foldIndices = []<\exit>
n = np.iinfo(np.int).max<\exit>
for i in range(0, c):<\exit>
idx = np.where(y == i)[0]<\exit>
n = min(n, idx.shape[0])<\exit>
foldIndices.append(idx.tolist());<\exit>
if n < self.k:<\exit>
self.k = n<\exit>
foldSize = int(math.floor(n / self.k))<\exit>
if self.threshold_up==0:<\exit>
threshold_r = [0]<\exit>
else:<\exit>
threshold_r = frange(0, self.threshold_up, 0.001)<\exit>
rates = {}<\exit>
for threshold in threshold_r:<\exit>
rates[threshold] = TFPN()<\exit>
for i in range(0, self.k):<\exit>
self.logger.info("Processing fold %d/%d." % (i + 1, self.k))<\exit>
l = int(i * foldSize)<\exit>
h = int((i + 1) * foldSize)<\exit>
testIdx = slice_2d(foldIndices, rows=range(0, c), cols=range(l, h))<\exit>
trainIdx = slice_2d(foldIndices, rows=range(0, c), cols=range(0, l))<\exit>
trainIdx.extend(slice_2d(foldIndices, rows=range(0, c), cols=range(h, n)))<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
ytrain = y[trainIdx]<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
predictions = {}<\exit>
for j in testIdx:<\exit>
predictions[j] = self.model.predict(X[j])<\exit>
if self.threshold_up == 0:<\exit>
rates[threshold] += self.simple_evaluate(testIdx, predictions, X, y)<\exit>
else:<\exit>
for threshold in threshold_r:<\exit>
rates[threshold] += self.binary_evaluate(testIdx, predictions, X, y, threshold)<\exit>
for threshold in threshold_r:<\exit>
r = rates[threshold]<\exit>
self.add(ValidationResult(r.TP, r.TN, r.FP, r.FN, threshold))<\exit>
def simple_evaluate(self, testIdX, predictions, X, y):<\exit>
r = TFPN()<\exit>
for j in testIdX:<\exit>
prediction, info = predictions[j]<\exit>
if prediction==y[j]:<\exit>
r.TP += 1<\exit>
else:<\exit>
r.FP += 1<\exit>
if self._debug:<\exit>
self.display_prediction_error(X[j], y[j], prediction)<\exit>
return r<\exit>
def display_prediction_error(self, data, actual, predicted):<\exit>
error_msg = "%d!=%d" % (actual, predicted)<\exit>
self.logger.debug("prediction error, actual!=predicted: " + error_msg)<\exit>
cv2.imshow(error_msg, data)<\exit>
cv2.waitKey(1)<\exit>
def binary_evaluate(self, testIdX, predictions, X, y, threshold):<\exit>
r = TFPN()<\exit>
for lbl in np.unique(y):<\exit>
for j in testIdX:<\exit>
_, info = predictions[j]<\exit>
labels = info['labels']<\exit>
idx = labels==lbl<\exit>
sims = info['similarities']<\exit>
sims = sims[idx]<\exit>
sims = sims[:1]<\exit>
score = np.sum(sims)/float(sims.size)<\exit>
if score>threshold:<\exit>
if lbl==y[j]:<\exit>
r.TP += 1<\exit>
else:<\exit>
r.FP += 1<\exit>
else:<\exit>
if lbl==y[j]:<\exit>
r.FN += 1<\exit>
else:<\exit>
r.TN += 1<\exit>
return r<\exit>
def __repr__(self):<\exit>
return "k-Fold Cross Validation (model=%s, k=%s, results=%s)" % (self.model, self.k, self.validation_results)<\exit>
class LeaveOneOutCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model, k=0):<\exit>
super(LeaveOneOutCrossValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.LeaveOneOutCrossValidation")<\exit>
self.k = k<\exit>
def validate(self, X, y, description="ExperimentName"):<\exit>
X, y = shuffle(X, y)<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
if self.k==0:<\exit>
self.k = y.shape[0]<\exit>
for i in range(0, self.k):<\exit>
self.logger.info("Processing fold %d/%d." % (i + 1, self.k))<\exit>
trainIdx = []<\exit>
trainIdx.extend(range(0, i))<\exit>
trainIdx.extend(range(i + 1, self.k))<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
ytrain = y[trainIdx]<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
prediction = self.model.predict(X[i])[0]<\exit>
if prediction == y[i]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Leave-One-Out Cross Validation (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class LeaveOneClassOutCrossValidation(ValidationStrategy):<\exit>
def __init__(self, model):<\exit>
super(LeaveOneClassOutCrossValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.LeaveOneClassOutCrossValidation")<\exit>
def validate(self, X, y, g, description="ExperimentName"):<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
for i in range(0, len(np.unique(y))):<\exit>
self.logger.info("Validating Class %s." % i)<\exit>
trainIdx = np.where(y != i)[0]<\exit>
testIdx = np.where(y == i)[0]<\exit>
Xtrain = [X[t] for t in trainIdx]<\exit>
gtrain = g[trainIdx]<\exit>
self.model.compute(Xtrain, gtrain)<\exit>
for j in testIdx:<\exit>
prediction = self.model.predict(X[j])[0]<\exit>
if prediction == g[j]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Leave-One-Class-Out Cross Validation (model=%s, results=%s)"%(self.model, self.validation_results)<\exit>
class SimpleValidation(ValidationStrategy):<\exit>
def __init__(self, model):<\exit>
super(SimpleValidation, self).__init__(model=model)<\exit>
self.logger = logging.getLogger("facerec.validation.SimpleValidation")<\exit>
def validate(self, Xtrain, ytrain, Xtest, ytest, description="ExperimentName"):<\exit>
self.logger.info("Simple Validation.")<\exit>
self.model.compute(Xtrain, ytrain)<\exit>
self.logger.debug("Model computed.")<\exit>
true_positives, false_positives, true_negatives, false_negatives = (0, 0, 0, 0)<\exit>
count = 0<\exit>
for i in ytest:<\exit>
self.logger.debug("Predicting %s/%s." % (count, len(ytest)))<\exit>
prediction = self.model.predict(Xtest[i])[0]<\exit>
if prediction == ytest[i]:<\exit>
true_positives += 1<\exit>
else:<\exit>
false_positives += 1<\exit>
count += 1<\exit>
self.add(ValidationResult(true_positives, true_negatives, false_positives, false_negatives, description))<\exit>
def __repr__(self):<\exit>
return "Simple Validation (model=%s)" % self.model<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
N, A = cipher<\exit>
l = N + 1<\exit>
E = 0<\exit>
for cur in A:<\exit>
k = 0<\exit>
for a in A:<\exit>
if a >= cur:<\exit>
k += 1<\exit>
E += float(l) / (k + 1)<\exit>
return "%.2f" % E<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("0.in", "r")<\exit>
solution = Solution()<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
N = int(f.readline().strip())<\exit>
A = map(int, f.readline().strip().split(' '))<\exit>
cipher = N, A<\exit>
s = "%s\n" % (solution.solve(cipher))<\exit>
print s,<\exit>
import numpy as np<\exit>
import cv2<\exit>
from time import clock<\exit>
from numpy import pi, sin, cos<\exit>
import common<\exit>
class VideoSynthBase(object):<\exit>
def __init__(self, size=None, noise=0.0, bg = None, **params):<\exit>
self.bg = None<\exit>
self.frame_size = (640, 480)<\exit>
if bg is not None:<\exit>
self.bg = cv2.imread(bg, 1)<\exit>
h, w = self.bg.shape[:2]<\exit>
self.frame_size = (w, h)<\exit>
if size is not None:<\exit>
w, h = map(int, size.split('x'))<\exit>
self.frame_size = (w, h)<\exit>
self.bg = cv2.resize(self.bg, self.frame_size)<\exit>
self.noise = float(noise)<\exit>
def render(self, dst):<\exit>
pass<\exit>
def read(self, dst=None):<\exit>
w, h = self.frame_size<\exit>
if self.bg is None:<\exit>
buf = np.zeros((h, w, 3), np.uint8)<\exit>
else:<\exit>
buf = self.bg.copy()<\exit>
self.render(buf)<\exit>
if self.noise > 0.0:<\exit>
noise = np.zeros((h, w, 3), np.int8)<\exit>
cv2.randn(noise, np.zeros(3), np.ones(3)*255*self.noise)<\exit>
buf = cv2.add(buf, noise, dtype=cv2.CV_8UC3)<\exit>
return True, buf<\exit>
class Chess(VideoSynthBase):<\exit>
def __init__(self, **kw):<\exit>
super(Chess, self).__init__(**kw)<\exit>
w, h = self.frame_size<\exit>
self.grid_size = sx, sy = 10, 7<\exit>
white_quads = []<\exit>
black_quads = []<\exit>
for i, j in np.ndindex(sy, sx):<\exit>
q = [[j, i, 0], [j+1, i, 0], [j+1, i+1, 0], [j, i+1, 0]]<\exit>
[white_quads, black_quads][(i + j) % 2].append(q)<\exit>
self.white_quads = np.float32(white_quads)<\exit>
self.black_quads = np.float32(black_quads)<\exit>
fx = 0.9<\exit>
self.K = np.float64([[fx*w, 0, 0.5*(w-1)],<\exit>
[0, fx*w, 0.5*(h-1)],<\exit>
[0.0,0.0,      1.0]])<\exit>
self.dist_coef = np.float64([-0.2, 0.1, 0, 0])<\exit>
self.t = 0<\exit>
def draw_quads(self, img, quads, color = (0, 255, 0)):<\exit>
img_quads = cv2.projectPoints(quads.reshape(-1, 3), self.rvec, self.tvec, self.K, self.dist_coef) [0]<\exit>
img_quads.shape = quads.shape[:2] + (2,)<\exit>
for q in img_quads:<\exit>
cv2.fillConvexPoly(img, np.int32(q*4), color, cv2.CV_AA, shift=2)<\exit>
def render(self, dst):<\exit>
t = self.t<\exit>
self.t += 1.0/30.0<\exit>
sx, sy = self.grid_size<\exit>
center = np.array([0.5*sx, 0.5*sy, 0.0])<\exit>
phi = pi/3 + sin(t*3)*pi/8<\exit>
c, s = cos(phi), sin(phi)<\exit>
ofs = np.array([sin(1.2*t), cos(1.8*t), 0]) * sx * 0.2<\exit>
eye_pos = center + np.array([cos(t)*c, sin(t)*c, s]) * 15.0 + ofs<\exit>
target_pos = center + ofs<\exit>
R, self.tvec = common.lookat(eye_pos, target_pos)<\exit>
self.rvec = common.mtx2rvec(R)<\exit>
self.draw_quads(dst, self.white_quads, (245, 245, 245))<\exit>
self.draw_quads(dst, self.black_quads, (10, 10, 10))<\exit>
classes = dict(chess=Chess)<\exit>
def create_capture(source):<\exit>
try: source = int(source)<\exit>
except ValueError: pass<\exit>
else:<\exit>
return cv2.VideoCapture(source)<\exit>
source = str(source).strip()<\exit>
if source.startswith('synth'):<\exit>
ss = filter(None, source.split(':'))<\exit>
params = dict( s.split('=') for s in ss[1:] )<\exit>
try: Class = classes[params['class']]<\exit>
except: Class = VideoSynthBase<\exit>
return Class(**params)<\exit>
return cv2.VideoCapture(source)<\exit>
presets = dict(<\exit>
empty = 'synth:',<\exit>
lena = 'synth:bg=../cpp/lena.jpg:noise=0.1',<\exit>
chess = 'synth:class=chess:bg=../cpp/lena.jpg:noise=0.1:size=640x480'<\exit>
)<\exit>
if __name__ == '__main__':<\exit>
import sys<\exit>
import getopt<\exit>
print 'USAGE: video.py [--shotdir <dir>] [source0] [source1] ...'<\exit>
print "source: '<int>' or '<filename>' or 'synth:<params>'"<\exit>
print<\exit>
args, sources = getopt.getopt(sys.argv[1:], '', 'shotdir=')<\exit>
args = dict(args)<\exit>
shotdir = args.get('--shotdir', '.')<\exit>
if len(sources) == 0:<\exit>
sources = [ presets['chess'] ]<\exit>
print 'Press SPACE to save current frame'<\exit>
caps = map(create_capture, sources)<\exit>
shot_idx = 0<\exit>
while True:<\exit>
imgs = []<\exit>
for i, cap in enumerate(caps):<\exit>
ret, img = cap.read()<\exit>
imgs.append(img)<\exit>
cv2.imshow('capture %d' % i, img)<\exit>
ch = cv2.waitKey(1)<\exit>
if ch == 27:<\exit>
break<\exit>
if ch == ord(' '):<\exit>
for i, img in enumerate(imgs):<\exit>
fn = '%s/shot_%d_%03d.bmp' % (shotdir, i, shot_idx)<\exit>
cv2.imwrite(fn, img)<\exit>
print fn, 'saved'<\exit>
shot_idx += 1<\exit>
import json<\exit>
from django.http import HttpResponse<\exit>
from django.shortcuts import render<\exit>
from django.template.response import SimpleTemplateResponse<\exit>
from django.utils.decorators import method_decorator<\exit>
from django.views.decorators.csrf import csrf_exempt<\exit>
from django.views.generic import TemplateView, View<\exit>
from rake import rake<\exit>
class MainView(View):<\exit>
template_name = "tagging.html"<\exit>
@method_decorator(csrf_exempt)<\exit>
def dispatch(self, *args, **kwargs):<\exit>
return super(MainView, self).dispatch(*args, **kwargs)<\exit>
def get(self, request, *args, **kwargs):<\exit>
return SimpleTemplateResponse(MainView.template_name)<\exit>
def post(self, request):<\exit>
dic = json.loads(request.body)<\exit>
ret = rake.Rake().run(dic["text"])<\exit>
ret = filter(lambda x: len(x.split(" ")) > 1, map(lambda x: x[0], ret))<\exit>
ret = {"keywords": list(ret)}<\exit>
return HttpResponse(json.dumps(ret))<\exit>
from facerec_py.facerec.normalization import minmax<\exit>
import os as os<\exit>
import numpy as np<\exit>
import matplotlib.pyplot as plt<\exit>
import matplotlib.cm as cm<\exit>
try:<\exit>
from PIL import Image<\exit>
except ImportError:<\exit>
import Image<\exit>
import math as math<\exit>
def create_font(fontname='Tahoma', fontsize=10):<\exit>
return { 'fontname': fontname, 'fontsize':fontsize }<\exit>
def plot_gray(X,  sz=None, filename=None):<\exit>
if not sz is None:<\exit>
X = X.reshape(sz)<\exit>
X = minmax(I, 0, 255)<\exit>
fig = plt.figure()<\exit>
implot = plt.imshow(np.asarray(Ig), cmap=cm.gray)<\exit>
if filename is None:<\exit>
plt.show()<\exit>
else:<\exit>
fig.savefig(filename, format="png", transparent=False)<\exit>
def plot_eigenvectors(eigenvectors, num_components, sz, filename=None, start_component=0, rows = None, cols = None, title="Subplot", color=True):<\exit>
if (rows is None) or (cols is None):<\exit>
rows = cols = int(math.ceil(np.sqrt(num_components)))<\exit>
num_components = np.min(num_components, eigenvectors.shape[1])<\exit>
fig = plt.figure()<\exit>
for i in range(start_component, num_components):<\exit>
vi = eigenvectors[0:,i].copy()<\exit>
vi = minmax(np.asarray(vi), 0, 255, dtype=np.uint8)<\exit>
vi = vi.reshape(sz)<\exit>
ax0 = fig.add_subplot(rows,cols,(i-start_component)+1)<\exit>
plt.setp(ax0.get_xticklabels(), visible=False)<\exit>
plt.setp(ax0.get_yticklabels(), visible=False)<\exit>
plt.title("%s<\exit>
if color:<\exit>
implot = plt.imshow(np.asarray(vi))<\exit>
else:<\exit>
implot = plt.imshow(np.asarray(vi), cmap=cm.grey)<\exit>
if filename is None:<\exit>
fig.show()<\exit>
else:<\exit>
fig.savefig(filename, format="png", transparent=False)<\exit>
def subplot(title, images, rows, cols, sptitle="subplot", sptitles=[], colormap=cm.gray, ticks_visible=True, filename=None):<\exit>
fig = plt.figure()<\exit>
fig.text(.5, .95, title, horizontalalignment='center')<\exit>
for i in xrange(len(images)):<\exit>
ax0 = fig.add_subplot(rows,cols,(i+1))<\exit>
plt.setp(ax0.get_xticklabels(), visible=False)<\exit>
plt.setp(ax0.get_yticklabels(), visible=False)<\exit>
if len(sptitles) == len(images):<\exit>
plt.title("%s<\exit>
else:<\exit>
plt.title("%s<\exit>
plt.imshow(np.asarray(images[i]), cmap=colormap)<\exit>
if filename is None:<\exit>
plt.show()<\exit>
else:<\exit>
fig.savefig(filename)<\exit>
from expr.feature import *<\exit>
class WeightedHS(SpatialHistogram):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(3), sz=(8, 8), X=None, y=None):<\exit>
super(WeightedHS, self).__init__(lbp_operator, sz)<\exit>
self.weights = {}<\exit>
self.Hs = {}<\exit>
self.L = self.calculate_L(X)<\exit>
self.X = X<\exit>
self.y = y<\exit>
def init_cache(self):<\exit>
self.weights = {}<\exit>
self.Hs = {}<\exit>
def compute(self, X, y):<\exit>
raise NotImplementedError("Not and won't be implemented.")<\exit>
def hist_intersect(self, p, q):<\exit>
p = np.asarray(p).flatten()<\exit>
q = np.asarray(q).flatten()<\exit>
sim = np.sum(np.minimum(p, q))<\exit>
return sim<\exit>
def get_weight(self, row, col):<\exit>
args = (row, col)<\exit>
if args not in self.weights:<\exit>
self.weights[args] = self._get_weight(row, col)<\exit>
return self.weights[args]<\exit>
def _get_weight(self, row, col):<\exit>
C = len(np.unique(self.y))<\exit>
m_I = 0<\exit>
for i in np.unique(self.y):<\exit>
N_i = self.get_N(i)<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
for k in xrange(len(Hs_i)):<\exit>
for j in xrange(k):<\exit>
m_I += self.hist_intersect(Hs_i[j], Hs_i[k])<\exit>
m_I *= 2.0/(N_i*(N_i-1))<\exit>
m_I *= 1.0/C<\exit>
S2_I = 0<\exit>
for i in np.unique(self.y):<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
for k in xrange(len(Hs_i)):<\exit>
for j in xrange(k):<\exit>
S2_I += (self.hist_intersect(Hs_i[j], Hs_i[k])-m_I)**2<\exit>
m_E = 0<\exit>
for i in np.unique(self.y):<\exit>
for j in np.unique(self.y[self.y != i]):<\exit>
N_i = self.get_N(i)<\exit>
N_j = self.get_N(j)<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
Hs_j = self.get_Hs(j, row, col)<\exit>
for h_i in Hs_i:<\exit>
for h_j in Hs_j:<\exit>
m_E += self.hist_intersect(h_i, h_j)<\exit>
m_E *= 1.0/(N_i*N_j)<\exit>
m_E *= 2.0/(C*(C-1))<\exit>
S2_E = 0<\exit>
for i in np.unique(self.y):<\exit>
for j in np.unique(self.y[self.y!=i]):<\exit>
Hs_i = self.get_Hs(i, row, col)<\exit>
Hs_j = self.get_Hs(j, row, col)<\exit>
for h_i in Hs_i:<\exit>
for h_j in Hs_j:<\exit>
S2_E += (self.hist_intersect(h_i, h_j)-m_E)**2<\exit>
weight = (m_I-m_E)**2/(S2_I+S2_E)<\exit>
return weight<\exit>
def get_N(self, i):<\exit>
return len(self.X[self.y==i])<\exit>
def calculate_L(self, X):<\exit>
L = []<\exit>
for x in X:<\exit>
L.append(self.lbp_operator(x))<\exit>
return np.asarray(L)<\exit>
def get_Hs(self, label, row, col):<\exit>
args = (label, row, col)<\exit>
if args not in self.Hs:<\exit>
self.Hs[args] = self._get_Hs(label, row, col)<\exit>
return self.Hs[args]<\exit>
def _get_Hs(self, label, row, col):<\exit>
L = self.L[self.y==label]<\exit>
Hs = []<\exit>
for l in L:<\exit>
lbp_height, lbp_width = l.shape<\exit>
grid_rows, grid_cols = self.sz<\exit>
py = int(np.floor(lbp_height / grid_rows))<\exit>
px = int(np.floor(lbp_width / grid_cols))<\exit>
C = l[row * py:(row + 1) * py, col * px:(col + 1) * px]<\exit>
Hs.append(super(WeightedHS, self)._get_histogram(C, row, col))<\exit>
return Hs<\exit>
def _get_histogram(self, C, row, col, normed=True):<\exit>
return self.get_weight(row, col)* \<\exit>
super(WeightedHS, self)._get_histogram(C, row, col)<\exit>
class ConcatendatedWeightedHS(SpatialHistogram):<\exit>
def __init__(self, lbp_operator=ExtendedLBP(radius=3), sz=(8, 8)):<\exit>
super(ConcatendatedWeightedHS, self).__init__(lbp_operator, sz)<\exit>
self.weights = None<\exit>
def compute(self, X, y):<\exit>
self.weights = self.construct_wights(X, y)<\exit>
super(ConcatendatedWeightedHS, self).compute(X, y)<\exit>
def construct_wights(self, X, y):<\exit>
X = np.asarray(X)<\exit>
n_gabors = X.shape[1]<\exit>
weights = [WeightedHS(X=X[:, i, :, :], y=y) for i in xrange(n_gabors)]<\exit>
return weights<\exit>
def spatially_enhanced_histogram(self, X):<\exit>
hists = []<\exit>
for gabor_idx, x in enumerate(X):<\exit>
hist = self.weights[gabor_idx].spatially_enhanced_histogram(x)<\exit>
hists.extend(hist)<\exit>
return np.asarray(hists)<\exit>
class WeightedLGBPHS(ChainedFeature):<\exit>
def __init__(self, n_orient=4, n_scale=2, lbp_operator=ExtendedLBP(radius=3)):<\exit>
gabor = GaborFilterCv2(n_orient, n_scale)<\exit>
lbp_hist = ConcatendatedWeightedHS(lbp_operator=lbp_operator)<\exit>
super(WeightedLGBPHS, self).__init__(gabor, lbp_hist)<\exit>
import sys<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.point_to_point<\exit>
import ns.wifi<\exit>
def SetPosition(node, position):<\exit>
mobility = node.GetObject(ns.mobility.MobilityModel.GetTypeId())<\exit>
mobility.SetPosition(position)<\exit>
def GetPosition(node):<\exit>
mobility = node.GetObject(ns.mobility.MobilityModel.GetTypeId())<\exit>
return mobility.GetPosition()<\exit>
def AdvancePosition(node):<\exit>
pos = GetPosition(node);<\exit>
pos.x += 5.0<\exit>
if pos.x >= 210.0:<\exit>
return<\exit>
SetPosition(node, pos)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(1.0), AdvancePosition, node)<\exit>
def main(argv):<\exit>
ns.core.CommandLine().Parse(argv)<\exit>
ns.network.Packet.EnablePrinting();<\exit>
ns.core.Config.SetDefault("ns3::WifiRemoteStationManager::RtsCtsThreshold", ns.core.StringValue("0"))<\exit>
ns.core.Config.SetDefault("ns3::WifiRemoteStationManager::FragmentationThreshold", ns.core.StringValue("2200"))<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
mobility = ns.mobility.MobilityHelper()<\exit>
stas = ns.network.NodeContainer()<\exit>
ap = ns.network.NodeContainer()<\exit>
packetSocket = ns.network.PacketSocketHelper()<\exit>
stas.Create(2)<\exit>
ap.Create(1)<\exit>
packetSocket.Install(stas)<\exit>
packetSocket.Install(ap)<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
ssid = ns.wifi.Ssid("wifi-default")<\exit>
wifi.SetRemoteStationManager("ns3::ArfWifiManager")<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiMac.SetType("ns3::StaWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"ActiveProbing", ns.core.BooleanValue(False))<\exit>
staDevs = wifi.Install(wifiPhy, wifiMac, stas)<\exit>
wifiMac.SetType("ns3::ApWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid),<\exit>
"BeaconGeneration", ns.core.BooleanValue(True),<\exit>
"BeaconInterval", ns.core.TimeValue(ns.core.Seconds(2.5)))<\exit>
wifi.Install(wifiPhy, wifiMac, ap)<\exit>
mobility.Install(stas)<\exit>
mobility.Install(ap)<\exit>
ns.core.Simulator.Schedule(ns.core.Seconds(1.0), AdvancePosition, ap.Get(0))<\exit>
socket = ns.network.PacketSocketAddress()<\exit>
socket.SetSingleDevice(staDevs.Get(0).GetIfIndex())<\exit>
socket.SetPhysicalAddress(staDevs.Get(1).GetAddress())<\exit>
socket.SetProtocol(1)<\exit>
onoff = ns.applications.OnOffHelper("ns3::PacketSocketFactory", ns.network.Address(socket))<\exit>
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(42)))<\exit>
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
apps = onoff.Install(ns.network.NodeContainer(stas.Get(0)))<\exit>
apps.Start(ns.core.Seconds(0.5))<\exit>
apps.Stop(ns.core.Seconds(43.0))<\exit>
ns.core.Simulator.Stop(ns.core.Seconds(44.0))<\exit>
ns.core.Simulator.Run()<\exit>
ns.core.Simulator.Destroy()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import sys<\exit>
import ns.applications<\exit>
import ns.core<\exit>
import ns.flow_monitor<\exit>
import ns.internet<\exit>
import ns.mobility<\exit>
import ns.network<\exit>
import ns.olsr<\exit>
import ns.wifi<\exit>
DISTANCE = 100<\exit>
NUM_NODES_SIDE = 3<\exit>
def main(argv):<\exit>
cmd = ns.core.CommandLine()<\exit>
cmd.NumNodesSide = None<\exit>
cmd.AddValue("NumNodesSide", "Grid side number of nodes (total number of nodes will be this number squared)")<\exit>
cmd.Results = None<\exit>
cmd.AddValue("Results", "Write XML results to file")<\exit>
cmd.Plot = None<\exit>
cmd.AddValue("Plot", "Plot the results using the matplotlib python module")<\exit>
cmd.Parse(argv)<\exit>
wifi = ns.wifi.WifiHelper.Default()<\exit>
wifiMac = ns.wifi.NqosWifiMacHelper.Default()<\exit>
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()<\exit>
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()<\exit>
wifiPhy.SetChannel(wifiChannel.Create())<\exit>
ssid = ns.wifi.Ssid("wifi-default")<\exit>
wifi.SetRemoteStationManager("ns3::ArfWifiManager")<\exit>
wifiMac.SetType ("ns3::AdhocWifiMac",<\exit>
"Ssid", ns.wifi.SsidValue(ssid))<\exit>
internet = ns.internet.InternetStackHelper()<\exit>
list_routing = ns.internet.Ipv4ListRoutingHelper()<\exit>
olsr_routing = ns.olsr.OlsrHelper()<\exit>
static_routing = ns.internet.Ipv4StaticRoutingHelper()<\exit>
list_routing.Add(static_routing, 0)<\exit>
list_routing.Add(olsr_routing, 100)<\exit>
internet.SetRoutingHelper(list_routing)<\exit>
ipv4Addresses = ns.internet.Ipv4AddressHelper()<\exit>
ipv4Addresses.SetBase(ns.network.Ipv4Address("10.0.0.0"), ns.network.Ipv4Mask("255.255.255.0"))<\exit>
port = 9<\exit>
onOffHelper = ns.applications.OnOffHelper("ns3::UdpSocketFactory",<\exit>
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.0.0.1"), port)))<\exit>
onOffHelper.SetAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate("100kbps")))<\exit>
onOffHelper.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))<\exit>
onOffHelper.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))<\exit>
addresses = []<\exit>
nodes = []<\exit>
if cmd.NumNodesSide is None:<\exit>
num_nodes_side = NUM_NODES_SIDE<\exit>
else:<\exit>
num_nodes_side = int(cmd.NumNodesSide)<\exit>
for xi in range(num_nodes_side):<\exit>
for yi in range(num_nodes_side):<\exit>
node = ns.network.Node()<\exit>
nodes.append(node)<\exit>
internet.Install(ns.network.NodeContainer(node))<\exit>
mobility = ns.mobility.ConstantPositionMobilityModel()<\exit>
mobility.SetPosition(ns.core.Vector(xi*DISTANCE, yi*DISTANCE, 0))<\exit>
node.AggregateObject(mobility)<\exit>
devices = wifi.Install(wifiPhy, wifiMac, node)<\exit>
ipv4_interfaces = ipv4Addresses.Assign(devices)<\exit>
addresses.append(ipv4_interfaces.GetAddress(0))<\exit>
for i, node in enumerate(nodes):<\exit>
destaddr = addresses[(len(addresses) - 1 - i) % len(addresses)]<\exit>
onOffHelper.SetAttribute("Remote", ns.network.AddressValue(ns.network.InetSocketAddress(destaddr, port)))<\exit>
app = onOffHelper.Install(ns.network.NodeContainer(node))<\exit>
app.Start(ns.core.Seconds(ns.core.UniformVariable(20, 30).GetValue()))<\exit>
flowmon_helper = ns.flow_monitor.FlowMonitorHelper()<\exit>
monitor = flowmon_helper.InstallAll()<\exit>
monitor = flowmon_helper.GetMonitor()<\exit>
monitor.SetAttribute("DelayBinWidth", ns.core.DoubleValue(0.001))<\exit>
monitor.SetAttribute("JitterBinWidth", ns.core.DoubleValue(0.001))<\exit>
monitor.SetAttribute("PacketSizeBinWidth", ns.core.DoubleValue(20))<\exit>
ns.core.Simulator.Stop(ns.core.Seconds(44.0))<\exit>
ns.core.Simulator.Run()<\exit>
def print_stats(os, st):<\exit>
print >> os, "  Tx Bytes: ", st.txBytes<\exit>
print >> os, "  Rx Bytes: ", st.rxBytes<\exit>
print >> os, "  Tx Packets: ", st.txPackets<\exit>
print >> os, "  Rx Packets: ", st.rxPackets<\exit>
print >> os, "  Lost Packets: ", st.lostPackets<\exit>
if st.rxPackets > 0:<\exit>
print >> os, "  Mean{Delay}: ", (st.delaySum.GetSeconds() / st.rxPackets)<\exit>
print >> os, "  Mean{Jitter}: ", (st.jitterSum.GetSeconds() / (st.rxPackets-1))<\exit>
print >> os, "  Mean{Hop Count}: ", float(st.timesForwarded) / st.rxPackets + 1<\exit>
if 0:<\exit>
print >> os, "Delay Histogram"<\exit>
for i in range(st.delayHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.delayHistogram.GetBinStart (i), "-", \<\exit>
st.delayHistogram.GetBinEnd (i), "): ", st.delayHistogram.GetBinCount (i)<\exit>
print >> os, "Jitter Histogram"<\exit>
for i in range(st.jitterHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.jitterHistogram.GetBinStart (i), "-", \<\exit>
st.jitterHistogram.GetBinEnd (i), "): ", st.jitterHistogram.GetBinCount (i)<\exit>
print >> os, "PacketSize Histogram"<\exit>
for i in range(st.packetSizeHistogram.GetNBins () ):<\exit>
print >> os, " ",i,"(", st.packetSizeHistogram.GetBinStart (i), "-", \<\exit>
st.packetSizeHistogram.GetBinEnd (i), "): ", st.packetSizeHistogram.GetBinCount (i)<\exit>
for reason, drops in enumerate(st.packetsDropped):<\exit>
print "  Packets dropped by reason %i: %i" % (reason, drops)<\exit>
monitor.CheckForLostPackets()<\exit>
classifier = flowmon_helper.GetClassifier()<\exit>
if cmd.Results is None:<\exit>
for flow_id, flow_stats in monitor.GetFlowStats():<\exit>
t = classifier.FindFlow(flow_id)<\exit>
proto = {6: 'TCP', 17: 'UDP'} [t.protocol]<\exit>
print "FlowID: %i (%s %s/%s --> %s/%i)" % \<\exit>
(flow_id, proto, t.sourceAddress, t.sourcePort, t.destinationAddress, t.destinationPort)<\exit>
print_stats(sys.stdout, flow_stats)<\exit>
else:<\exit>
print monitor.SerializeToXmlFile(cmd.Results, True, True)<\exit>
if cmd.Plot is not None:<\exit>
import pylab<\exit>
delays = []<\exit>
for flow_id, flow_stats in monitor.GetFlowStats():<\exit>
tupl = classifier.FindFlow(flow_id)<\exit>
if tupl.protocol == 17 and tupl.sourcePort == 698:<\exit>
continue<\exit>
delays.append(flow_stats.delaySum.GetSeconds() / flow_stats.rxPackets)<\exit>
pylab.hist(delays, 20)<\exit>
pylab.xlabel("Delay (s)")<\exit>
pylab.ylabel("Number of Flows")<\exit>
pylab.show()<\exit>
return 0<\exit>
if __name__ == '__main__':<\exit>
sys.exit(main(sys.argv))<\exit>
import math<\exit>
import ns.wifi<\exit>
import ns.network<\exit>
import goocanvas<\exit>
from visualizer.base import Link, transform_distance_canvas_to_simulation<\exit>
class WifiLink(Link):<\exit>
def __init__(self, parent_canvas_item, sta, dev):<\exit>
self.node1 = sta<\exit>
self.dev = dev<\exit>
self.node2 = None<\exit>
self.canvas_item = goocanvas.Group(parent=parent_canvas_item)<\exit>
self.invisible_line = goocanvas.Polyline(parent=self.canvas_item,<\exit>
line_width=25.0,<\exit>
visibility=goocanvas.ITEM_HIDDEN)<\exit>
self.visible_line = goocanvas.Polyline(parent=self.canvas_item,<\exit>
line_width=1.0,<\exit>
stroke_color_rgba=0xC00000FF,<\exit>
line_dash=goocanvas.LineDash([2.0, 2.0 ]))<\exit>
self.invisible_line.props.pointer_events = (goocanvas.EVENTS_STROKE_MASK<\exit>
|goocanvas.EVENTS_FILL_MASK<\exit>
|goocanvas.EVENTS_PAINTED_MASK)<\exit>
self.canvas_item.set_data("pyviz-object", self)<\exit>
self.canvas_item.lower(None)<\exit>
self.set_ap(None)<\exit>
def set_ap(self, ap):<\exit>
if ap is self.node2:<\exit>
return<\exit>
if self.node2 is not None:<\exit>
self.node2.remove_link(self)<\exit>
self.node2 = ap<\exit>
if self.node2 is None:<\exit>
self.canvas_item.set_property("visibility", goocanvas.ITEM_HIDDEN)<\exit>
else:<\exit>
self.node2.add_link(self)<\exit>
self.canvas_item.set_property("visibility", goocanvas.ITEM_VISIBLE)<\exit>
self.update_points()<\exit>
def update_points(self):<\exit>
if self.node2 is None:<\exit>
return<\exit>
pos1_x, pos1_y = self.node1.get_position()<\exit>
pos2_x, pos2_y = self.node2.get_position()<\exit>
points = goocanvas.Points([(pos1_x, pos1_y), (pos2_x, pos2_y)])<\exit>
self.visible_line.set_property("points", points)<\exit>
self.invisible_line.set_property("points", points)<\exit>
def destroy(self):<\exit>
self.canvas_item.destroy()<\exit>
self.node1 = None<\exit>
self.node2 = None<\exit>
def tooltip_query(self, tooltip):<\exit>
pos1_x, pos1_y = self.node1.get_position()<\exit>
pos2_x, pos2_y = self.node2.get_position()<\exit>
dx = pos2_x - pos1_x<\exit>
dy = pos2_y - pos1_y<\exit>
d = transform_distance_canvas_to_simulation(math.sqrt(dx*dx + dy*dy))<\exit>
mac = self.dev.GetMac()<\exit>
tooltip.set_text(("WiFi link between STA Node %i and AP Node %i; distance=%.2f m.\n"<\exit>
"SSID: %s\n"<\exit>
"BSSID: %s")<\exit>
% (self.node1.node_index, self.node2.node_index, d,<\exit>
mac.GetSsid(), mac.GetBssid()))<\exit>
class WifiLinkMonitor(object):<\exit>
def __init__(self, dummy_viz):<\exit>
self.access_points = {}<\exit>
self.stations = []<\exit>
def scan_nodes(self, viz):<\exit>
for (sta_netdevice, viz_node, wifi_link) in self.stations:<\exit>
wifi_link.destroy()<\exit>
self.access_points = {}<\exit>
self.stations = []<\exit>
for node in viz.nodes.itervalues():<\exit>
ns3_node = ns.network.NodeList.GetNode(node.node_index)<\exit>
for devI in range(ns3_node.GetNDevices()):<\exit>
dev = ns3_node.GetDevice(devI)<\exit>
if not isinstance(dev, ns.wifi.WifiNetDevice):<\exit>
continue<\exit>
wifi_mac = dev.GetMac()<\exit>
if isinstance(wifi_mac, ns.wifi.StaWifiMac):<\exit>
wifi_link = WifiLink(viz.links_group, node, dev)<\exit>
self.stations.append((dev, node, wifi_link))<\exit>
elif isinstance(wifi_mac, ns.wifi.ApWifiMac):<\exit>
bssid = ns.network.Mac48Address.ConvertFrom(dev.GetAddress())<\exit>
self.access_points[str(bssid)] = node<\exit>
def simulation_periodic_update(self, viz):<\exit>
for (sta_netdevice, viz_node, wifi_link) in self.stations:<\exit>
if not sta_netdevice.IsLinkUp():<\exit>
wifi_link.set_ap(None)<\exit>
continue<\exit>
bssid = str(sta_netdevice.GetMac().GetBssid())<\exit>
if bssid == '00:00:00:00:00:00':<\exit>
wifi_link.set_ap(None)<\exit>
continue<\exit>
ap = self.access_points[bssid]<\exit>
wifi_link.set_ap(ap)<\exit>
def update_view(self, viz):<\exit>
for (dummy_sta_netdevice, dummy_viz_node, wifi_link) in self.stations:<\exit>
if wifi_link is not None:<\exit>
wifi_link.update_points()<\exit>
def register(viz):<\exit>
link_monitor = WifiLinkMonitor(viz)<\exit>
viz.connect("simulation-periodic-update", link_monitor.simulation_periodic_update)<\exit>
viz.connect("update-view", link_monitor.update_view)<\exit>
viz.connect("topology-scanned", link_monitor.scan_nodes)<\exit>
class Solution:<\exit>
def woodCut(self, L, k):<\exit>
if not L:<\exit>
return 0<\exit>
maxa = max(L)<\exit>
lo = 0<\exit>
hi = maxa+1<\exit>
while lo < hi:<\exit>
m = (lo+hi)/2<\exit>
if m == 0:<\exit>
return m<\exit>
cnt = 0<\exit>
for l in L:<\exit>
cnt += l/m<\exit>
if cnt >= k:<\exit>
lo = m+1<\exit>
else:<\exit>
hi = m<\exit>
return lo-1<\exit>
if __name__ == "__main__":<\exit>
assert Solution().woodCut([2147483644, 2147483645, 2147483646, 2147483647], 4) == 2147483644<\exit>
class TrieNode(object):<\exit>
def __init__(self, char):<\exit>
self.char = char<\exit>
self.word = None<\exit>
self.children = {}<\exit>
def __repr__(self):<\exit>
return repr(self.char)<\exit>
class Trie(object):<\exit>
def __init__(self):<\exit>
self.root = TrieNode(None)<\exit>
def add(self, word):<\exit>
word = word.lower()<\exit>
cur = self.root<\exit>
for c in word:<\exit>
if c not in cur.children:<\exit>
cur.children[c] = TrieNode(c)<\exit>
cur = cur.children[c]<\exit>
cur.word = word<\exit>
class Solution:<\exit>
directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]<\exit>
def wordSearchII_TLE(self, board, words):<\exit>
trie = Trie()<\exit>
for word in words:<\exit>
trie.add(word)<\exit>
ret = set()<\exit>
visited = set()<\exit>
for i in xrange(len(board)):<\exit>
for j in xrange(len(board[0])):<\exit>
self.dfs(board, i, j, trie.root, visited, ret)<\exit>
return list(ret)<\exit>
def dfs(self, board, i, j, parent, visited, ret):<\exit>
c = board[i][j]<\exit>
visited.add((i, j))<\exit>
if c in parent.children:<\exit>
cur = parent.children[c]<\exit>
if cur.word:<\exit>
ret.add(cur.word)<\exit>
for direction in Solution.directions:<\exit>
row = i+direction[0]<\exit>
col = j+direction[1]<\exit>
if 0 <= row < len(board) and 0 <= col < len(board[0]) and (row, col) not in visited:<\exit>
self.dfs(board, row, col, cur, visited, ret)<\exit>
visited.remove((i, j))<\exit>
def wordSearchII(self, board, words):<\exit>
ret = []<\exit>
for word in words:<\exit>
trie = Trie()<\exit>
trie.add(word)<\exit>
visited = set()<\exit>
r = set()<\exit>
found = False<\exit>
for i in xrange(len(board)):<\exit>
if not found:<\exit>
for j in xrange(len(board[0])):<\exit>
self.dfs2(board, i, j, trie.root, visited, r)<\exit>
if len(r) == 1:<\exit>
ret.append(r.pop())<\exit>
found = True<\exit>
break<\exit>
return ret<\exit>
def dfs2(self, board, i, j, parent, visited, ret):<\exit>
c = board[i][j]<\exit>
visited.add((i, j))<\exit>
if c in parent.children:<\exit>
cur = parent.children[c]<\exit>
if cur.word:<\exit>
ret.add(cur.word)<\exit>
for direction in Solution.directions:<\exit>
row = i+direction[0]<\exit>
col = j+direction[1]<\exit>
if 0 <= row < len(board) and 0 <= col < len(board[0]) and (row, col) not in visited and not ret:<\exit>
self.dfs2(board, row, col, cur, visited, ret)<\exit>
visited.remove((i, j))<\exit>
if __name__ == "__main__":<\exit>
board = ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<\exit>
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaab"]<\exit>
words = {"baaaaaaaaaaaaa", "a", "aa", "aaaa", "aaaax", "abaaabbaz"}<\exit>
assert Solution().wordSearchII(board, words) == ['a', 'aa', 'aaaa', 'baaaaaaaaaaaaa']<\exit>
import os<\exit>
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tagr.settings")<\exit>
from django.core.wsgi import get_wsgi_application<\exit>
from whitenoise.django import DjangoWhiteNoise<\exit>
application = get_wsgi_application()<\exit>
application = DjangoWhiteNoise(application)<\exit>
import os<\exit>
import os.path<\exit>
import sys<\exit>
import subprocess<\exit>
import shlex<\exit>
import Options<\exit>
import Utils<\exit>
import Logs<\exit>
import TaskGen<\exit>
import Build<\exit>
import re<\exit>
from waflib.Errors import WafError<\exit>
APPNAME=None<\exit>
VERSION=None<\exit>
bld=None<\exit>
def get_command_template(env, arguments=()):<\exit>
cmd = Options.options.command_template or '%s'<\exit>
for arg in arguments:<\exit>
cmd = cmd + " " + arg<\exit>
return cmd<\exit>
if hasattr(os.path, "relpath"):<\exit>
relpath = os.path.relpath<\exit>
else:<\exit>
def relpath(path, start=os.path.curdir):<\exit>
if not path:<\exit>
raise ValueError("no path specified")<\exit>
start_list = os.path.abspath(start).split(os.path.sep)<\exit>
path_list = os.path.abspath(path).split(os.path.sep)<\exit>
i = len(os.path.commonprefix([start_list, path_list]))<\exit>
rel_list = [os.path.pardir] * (len(start_list)-i) + path_list[i:]<\exit>
if not rel_list:<\exit>
return os.path.curdir<\exit>
return os.path.join(*rel_list)<\exit>
from waflib import Context<\exit>
def find_program(program_name, env):<\exit>
launch_dir = os.path.abspath(Context.launch_dir)<\exit>
found_programs = []<\exit>
for obj in bld.all_task_gen:<\exit>
if not getattr(obj, 'is_ns3_program', False):<\exit>
continue<\exit>
if not (obj.path.abspath().startswith(launch_dir)<\exit>
or obj.path.abspath(env).startswith(launch_dir)):<\exit>
continue<\exit>
name1 = obj.target<\exit>
name2 = os.path.join(relpath(obj.path.abspath(), launch_dir), obj.target)<\exit>
names = [name1, name2]<\exit>
found_programs.extend(names)<\exit>
if program_name in names:<\exit>
return obj<\exit>
raise ValueError("program '%s' not found; available programs are: %r"<\exit>
% (program_name, found_programs))<\exit>
def get_proc_env(os_env=None):<\exit>
env = bld.env<\exit>
if sys.platform == 'linux2':<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
elif sys.platform == 'darwin':<\exit>
pathvar = 'DYLD_LIBRARY_PATH'<\exit>
elif sys.platform == 'win32':<\exit>
pathvar = 'PATH'<\exit>
elif sys.platform == 'cygwin':<\exit>
pathvar = 'PATH'<\exit>
elif sys.platform.startswith('freebsd'):<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
else:<\exit>
Logs.warn(("Don't know how to configure "<\exit>
"dynamic library path for the platform %r;"<\exit>
" assuming it's LD_LIBRARY_PATH.") % (sys.platform,))<\exit>
pathvar = 'LD_LIBRARY_PATH'<\exit>
proc_env = dict(os.environ)<\exit>
if os_env is not None:<\exit>
proc_env.update(os_env)<\exit>
if pathvar is not None:<\exit>
if pathvar in proc_env:<\exit>
proc_env[pathvar] = os.pathsep.join(list(env['NS3_MODULE_PATH']) + [proc_env[pathvar]])<\exit>
else:<\exit>
proc_env[pathvar] = os.pathsep.join(list(env['NS3_MODULE_PATH']))<\exit>
pymoddir = bld.path.find_dir('bindings/python').get_bld().abspath()<\exit>
pyvizdir = bld.path.find_dir('src/visualizer').abspath()<\exit>
if 'PYTHONPATH' in proc_env:<\exit>
proc_env['PYTHONPATH'] = os.pathsep.join([pymoddir, pyvizdir] + [proc_env['PYTHONPATH']])<\exit>
else:<\exit>
proc_env['PYTHONPATH'] = os.pathsep.join([pymoddir, pyvizdir])<\exit>
if 'PATH' in proc_env:<\exit>
proc_env['PATH'] = os.pathsep.join(list(env['NS3_EXECUTABLE_PATH']) + [proc_env['PATH']])<\exit>
else:<\exit>
proc_env['PATH'] = os.pathsep.join(list(env['NS3_EXECUTABLE_PATH']))<\exit>
return proc_env<\exit>
def run_argv(argv, env, os_env=None, cwd=None, force_no_valgrind=False):<\exit>
proc_env = get_proc_env(os_env)<\exit>
if Options.options.valgrind and not force_no_valgrind:<\exit>
if Options.options.command_template:<\exit>
raise WafError("Options --command-template and --valgrind are conflicting")<\exit>
if not env['VALGRIND']:<\exit>
raise WafError("valgrind is not installed")<\exit>
argv = [env['VALGRIND'], "--leak-check=full", "--show-reachable=yes", "--error-exitcode=1"] + argv<\exit>
proc = subprocess.Popen(argv, env=proc_env, cwd=cwd, stderr=subprocess.PIPE)<\exit>
error = False<\exit>
for line in proc.stderr:<\exit>
sys.stderr.write(line)<\exit>
if "== LEAK SUMMARY" in line:<\exit>
error = True<\exit>
retval = proc.wait()<\exit>
if retval == 0 and error:<\exit>
retval = 1<\exit>
else:<\exit>
try:<\exit>
WindowsError<\exit>
except NameError:<\exit>
retval = subprocess.Popen(argv, env=proc_env, cwd=cwd).wait()<\exit>
else:<\exit>
try:<\exit>
retval = subprocess.Popen(argv, env=proc_env, cwd=cwd).wait()<\exit>
except WindowsError, ex:<\exit>
raise WafError("Command %s raised exception %s" % (argv, ex))<\exit>
if retval:<\exit>
signame = None<\exit>
if retval < 0:<\exit>
import signal<\exit>
for name, val in vars(signal).iteritems():<\exit>
if len(name) > 3 and name[:3] == 'SIG' and name[3] != '_':<\exit>
if val == -retval:<\exit>
signame = name<\exit>
break<\exit>
if signame:<\exit>
raise WafError("Command %s terminated with signal %s."<\exit>
" Run it under a debugger to get more information "<\exit>
"(./waf --run <program> --command-template=\"gdb --args %%s <args>\")." % (argv, signame))<\exit>
else:<\exit>
raise WafError("Command %s exited with code %i" % (argv, retval))<\exit>
return retval<\exit>
def get_run_program(program_string, command_template=None):<\exit>
env = bld.env<\exit>
if command_template in (None, '%s'):<\exit>
argv = shlex.split(program_string)<\exit>
program_name = argv[0]<\exit>
try:<\exit>
program_obj = find_program(program_name, env)<\exit>
except ValueError, ex:<\exit>
raise WafError(str(ex))<\exit>
program_node = program_obj.path.find_or_declare(program_obj.target)<\exit>
execvec = [program_node.abspath()] + argv[1:]<\exit>
else:<\exit>
program_name = program_string<\exit>
try:<\exit>
program_obj = find_program(program_name, env)<\exit>
except ValueError, ex:<\exit>
raise WafError(str(ex))<\exit>
program_node = program_obj.path.find_or_declare(program_obj.target)<\exit>
tmpl = command_template % (program_node.abspath(),)<\exit>
execvec = shlex.split(tmpl.replace('\\', '\\\\'))<\exit>
return program_name, execvec<\exit>
def run_program(program_string, env, command_template=None, cwd=None, visualize=False):<\exit>
dummy_program_name, execvec = get_run_program(program_string, command_template)<\exit>
if cwd is None:<\exit>
if (Options.options.cwd_launch):<\exit>
cwd = Options.options.cwd_launch<\exit>
else:<\exit>
cwd = Options.cwd_launch<\exit>
if visualize:<\exit>
execvec.append("--SimulatorImplementationType=ns3::VisualSimulatorImpl")<\exit>
return run_argv(execvec, env, cwd=cwd)<\exit>
def run_python_program(program_string, env, visualize=False):<\exit>
env = bld.env<\exit>
execvec = shlex.split(program_string)<\exit>
if (Options.options.cwd_launch):<\exit>
cwd = Options.options.cwd_launch<\exit>
else:<\exit>
cwd = Options.cwd_launch<\exit>
if visualize:<\exit>
execvec.append("--SimulatorImplementationType=ns3::VisualSimulatorImpl")<\exit>
return run_argv([env['PYTHON'][0]] + execvec, env, cwd=cwd)<\exit>
def monkey_patch_Runner_start():<\exit>
from waflib import Task<\exit>
def start(self):<\exit>
self.total = self.bld.total()<\exit>
while not self.stop:<\exit>
self.refill_task_list()<\exit>
tsk = self.get_next_task()<\exit>
if not tsk:<\exit>
if self.count:<\exit>
continue<\exit>
else:<\exit>
break<\exit>
if tsk.hasrun:<\exit>
self.processed += 1<\exit>
continue<\exit>
if self.stop:<\exit>
break<\exit>
try:<\exit>
st = tsk.runnable_status()<\exit>
except Exception:<\exit>
self.processed += 1<\exit>
if not self.stop and self.bld.keep:<\exit>
tsk.hasrun = Task.SKIPPED<\exit>
if self.bld.keep == 1:<\exit>
self.stop = True<\exit>
continue<\exit>
tsk.err_msg = Utils.ex_stack()<\exit>
tsk.hasrun = Task.EXCEPTION<\exit>
self.error_handler(tsk)<\exit>
continue<\exit>
if st == Task.ASK_LATER:<\exit>
self.postpone(tsk)<\exit>
elif st == Task.SKIP_ME:<\exit>
self.processed += 1<\exit>
tsk.hasrun = Task.SKIPPED<\exit>
self.add_more_tasks(tsk)<\exit>
else:<\exit>
tsk.position = (self.processed, self.total)<\exit>
self.count += 1<\exit>
tsk.master = self<\exit>
self.processed += 1<\exit>
if self.numjobs == 1:<\exit>
tsk.process()<\exit>
else:<\exit>
self.add_task(tsk)<\exit>
while self.error and self.count:<\exit>
self.get_out()<\exit>
assert (self.count == 0 or self.stop)<\exit>
self.free_task_pool()<\exit>
from waflib.Runner import Parallel<\exit>
Parallel.start = start<\exit>
import os<\exit>
import re<\exit>
entities = ['Ingredient','Amount','Unit','Recipe']<\exit>
auto_tag_set = []<\exit>
nonauto_tag_set = []<\exit>
def init_dict(dictOfdict):<\exit>
for e in entities:<\exit>
if not (e in dictOfdict):<\exit>
dictOfdict[e] = dict()<\exit>
def get_xml_content(file_path):<\exit>
f = open(file_path)<\exit>
content = f.read()<\exit>
content = pre_format(content)<\exit>
return get_xml_entity(content)<\exit>
def get_ann_content(file_path):<\exit>
f = open(file_path)<\exit>
content = f.read()<\exit>
return get_ann_entity(content)<\exit>
def process_files_in_dir(dir):<\exit>
dir = os.path.dirname(os.path.realpath(__file__)) + ('/'+dir)<\exit>
for root, dirs, files in os.walk(dir):<\exit>
for file in sorted(files):<\exit>
if(file.endswith('.xml')):<\exit>
auto_tag_set.append(get_xml_content(os.path.join(root,file)))<\exit>
if(file.endswith('.ann')):<\exit>
nonauto_tag_set.append(get_ann_content(os.path.join(root,file)))<\exit>
def get_ann_entity(content):<\exit>
entity_dict = dict()<\exit>
init_dict(entity_dict)<\exit>
content = content.split('\n')<\exit>
for line in content:<\exit>
token = line.split('\t')<\exit>
if("T" in token[0]):<\exit>
tag_name = token[1].split(' ')[0]<\exit>
if(token[2] in entity_dict[tag_name]):<\exit>
entity_dict[tag_name][token[2]] += 1<\exit>
else:<\exit>
entity_dict[tag_name][token[2]] = 1<\exit>
return entity_dict<\exit>
def get_xml_entity(content):<\exit>
entity_dict = dict()<\exit>
init_dict(entity_dict)<\exit>
for e in entities:<\exit>
e_reg = re.compile('<'+e + '>(?P<'+e+'>[^<]+)</'+e+'>');<\exit>
for i in e_reg.findall(content):<\exit>
if(i in entity_dict[e]):<\exit>
entity_dict[e][i] += 1<\exit>
else:<\exit>
entity_dict[e][i] = 1<\exit>
return entity_dict<\exit>
def pre_format(content):<\exit>
content = re.sub("<entity type=\"(\w+)\">([^<]+)</entity>", "<\g<1>>\g<2></\g<1>>", content)<\exit>
content = content.replace("<s>", "")<\exit>
content = content.replace("</B-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</I-Ingredient> <I-Ingredient>", " ")<\exit>
content = content.replace("</B-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</I-Recipe> <I-Recipe>", " ")<\exit>
content = content.replace("</B-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</I-Amount> <I-Amount>", " ")<\exit>
content = content.replace("</B-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-Unit> <I-Unit>", " ")<\exit>
content = content.replace("</I-", "</")<\exit>
content = content.replace("</B-", "</")<\exit>
content = content.replace("<B-", "<")<\exit>
content = content.replace("<I-", "<")<\exit>
return content<\exit>
def calc_diff_by_entity(nonauto_tag_set,auto_tag_set):<\exit>
diff_matrix = dict()<\exit>
init_dict(diff_matrix)<\exit>
for key, value in diff_matrix.iteritems():<\exit>
value['FP'] = 0<\exit>
value['TP'] = 0<\exit>
value['FN'] = 0<\exit>
for article in zip(nonauto_tag_set,auto_tag_set):<\exit>
for entity in entities:<\exit>
for key, value in article[0][entity].iteritems():<\exit>
if key in article[1][entity]:<\exit>
if article[1][entity][key] - value > 0:<\exit>
diff_matrix[entity]['FP'] += (article[1][entity][key] - value)<\exit>
else:<\exit>
diff_matrix[entity]['FN'] += (value - article[1][entity][key])<\exit>
diff_matrix[entity]['TP'] += min(article[1][entity][key],value)<\exit>
else:<\exit>
diff_matrix[entity]['FN'] += value<\exit>
for key, value in article[1][entity].iteritems():<\exit>
if not key in article[0][entity]:<\exit>
diff_matrix[entity]['FP'] += value<\exit>
return diff_matrix<\exit>
process_files_in_dir('tagged_data')<\exit>
confusion_matrix = calc_diff_by_entity(nonauto_tag_set,auto_tag_set)<\exit>
for key, value in confusion_matrix.iteritems():<\exit>
if value['TP'] == 0:<\exit>
precision = 0<\exit>
recall = 0<\exit>
f_measure = 0<\exit>
else:<\exit>
precision = 1.0 * value['TP'] / (value['TP'] + value['FP'])<\exit>
recall = 1.0 * value['TP'] / (value['TP'] + value['FN'])<\exit>
f_measure = 2.0 * (precision * recall)/(precision + recall)<\exit>
print key+':\tPrecision-'+str("{0:.4f}".format(precision))+'\tRecall-'+str("{0:.4f}".format(recall))+'\tF-measure-'+str("{0:.4f}".format(f_measure))<\exit>
MOD = 10 ** 9 + 7<\exit>
BIT_CNT = 10 ** 5<\exit>
SHIFT_CNT = 314159<\exit>
N = BIT_CNT + SHIFT_CNT<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
a, b = cipher<\exit>
len_a = len(a)<\exit>
len_b = len(b)<\exit>
a_array = [0 for _ in xrange(N)]<\exit>
b_array = [0 for _ in xrange(N)]<\exit>
for ind, val in enumerate(a):<\exit>
a_array[len_a - 1 - ind] = int(val)<\exit>
for ind, val in enumerate(b):<\exit>
b_array[len_b - 1 - ind] = int(val)<\exit>
dp = [[0, 0] for _ in xrange(N + 1)]<\exit>
for i in xrange(1, N + 1):<\exit>
dp[i][0] = dp[i - 1][0] + 1 if b_array[i - 1] == 0 else dp[i - 1][0]<\exit>
dp[i][1] = dp[i - 1][1] + 1 if b_array[i - 1] == 1 else dp[i - 1][1]<\exit>
result = 0<\exit>
sig = 1<\exit>
for i in xrange(N):<\exit>
if i < SHIFT_CNT:<\exit>
cnt_zero = dp[i + 1][0] + SHIFT_CNT - i<\exit>
cnt_one = dp[i + 1][1]<\exit>
else:<\exit>
cnt_zero = dp[len_b][0] - dp[i - SHIFT_CNT][0] + SHIFT_CNT<\exit>
cnt_one = dp[len_b][1] - dp[i - SHIFT_CNT][1]<\exit>
cur_bit_sum = (a_array[<\exit>
i] ^ 0) * cnt_zero<\exit>
cur_bit_sum += (a_array[i] ^ 1) * cnt_one<\exit>
result = (result + sig * cur_bit_sum) % MOD<\exit>
sig = (sig * 2) % MOD<\exit>
return result<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
a = f.readline().strip()<\exit>
b = f.readline().strip()<\exit>
cipher = (a, b)<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
class Solution(object):<\exit>
def solve(self, cipher):<\exit>
length, lst = cipher<\exit>
return reduce(lambda x, y: x | y, lst) * 2 ** (length - 1) % (10 ** 9 + 7)<\exit>
if __name__ == "__main__":<\exit>
import sys<\exit>
f = open("1.in", "r")<\exit>
testcases = int(f.readline().strip())<\exit>
for t in xrange(testcases):<\exit>
length = int(f.readline().strip())<\exit>
lst = map(lambda x: int(x), f.readline().strip().split(" "))<\exit>
cipher = [length, lst]<\exit>
s = "%s\n" % (Solution().solve(cipher))<\exit>
print s,<\exit>
